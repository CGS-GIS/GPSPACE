C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C     NAME:  GPSPACE
C
C     FUNCTION: PRECISE POINT POSITIONING USING PSEUDO-RANGES AND CARRIER-PHASES
C
C
C
C * License_en.txt
C
C GPSPACE software - Terms and Conditions of Use
C
C Unless otherwise noted, computer program source code of the GPSPACE
C software is covered under Crown Copyright, Government of Canada, and is
C distributed under the MIT License.
C
C The Canada wordmark and related graphics associated with this distribution
C are protected under trademark law and copyright law. No permission is
C granted to use them outside the parameters of the Government of Canada's
C corporate identity program. For more information, see
C http://www.tbs-sct.gc.ca/fip-pcim/index-eng.asp
C
C Copyright title to all 3rd party software distributed with the GPSPACE is
C held by the respective copyright holders as noted in those files. Users
C are asked to read the 3rd Party Licenses referenced with those assets.
C
C MIT License
C
C Copyright (c) 2018 Government of Canada
C
C Permission is hereby granted, free of charge, to any person obtaining a
C copy of this software and associated documentation files (the "Software"),
C to deal in the Software without restriction, including without limitation
C the rights to use, copy, modify, merge, publish, distribute, sublicense,
C and/or sell copies of the Software, and to permit persons to whom the
C Software is furnished to do so, subject to the following conditions:
C
C The above copyright notice and this permission notice shall be included in
C all copies or substantial portions of the Software.
C
C THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
C IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
C IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
C CLAIM, DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT, TORT
C OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
C THE USE OR OTHER DEALINGS IN THE SOFTWARE.
C
C * Licence_fr.txt
C
C Logiciel GPSPACE - Conditions regissant l'utilisation
C
C Sauf indication contraire, le code source du logiciel GPSPACE est protege
C par le droit d'auteur de la Couronne du gouvernement du Canada et
C distribue sous la licence MIT.
C
C Le mot-symbole "Canada" et les elements graphiques connexes lies a cette 
C distribution sont proteges en vertu des lois portant sur les marques de
C commerce et le droit d'auteur.
C
C Aucune autorisation n'est accordee pour leur utilisation a l'exterieur des
C parametres du programme de coordination de l'image de marque du
C gouvernement du Canada. Pour obtenir davantage de renseignements a ce
C sujet, veuillez consulter
C http://www.tbs-sct.gc.ca/fip-pcim/index-fra.asp
C
C La propriete du droit d'auteur de tout logiciel tiers distribue avec le
C Logiciel GPSPACE est conservee par les detenteurs du droit d'auteur
C mentionnes dans ces fichiers. Nous demandons aux utilisateurs de lire les
C licences des tiers indiques a titre de reference dans ces logiciels.
C
C Licence MIT
C
C (c) Droit d'auteur (c) Gouvernement du Canada, 2018
C
C La presente autorise toute personne d'obtenir gratuitement une copie du
C present logiciel et des documents connexes (le "logiciel"), de traiter
C le logiciel sans restriction, y compris, mais sans s'y limiter, les droits
C d'utiliser, de copier, de modifier, de fusionner, de publier, de
C distribuer, d'accorder une sous licence et de vendre des copies dudit
C logiciel, et de permettre aux personnes auxquelles le logiciel est fourni
C de le faire, selon les conditions suivantes :
C
C L'avis de droit d'auteur ci-dessus et le present avis de permission seront
C inclus dans toutes les copies et les sections importantes du logiciel.
C
C LE LOGICIEL EST FOURNI "TEL QUEL", SANS AUCUNE GARANTIE, EXPRESSE OU
C IMPLICITE, Y COMPRIS, MAIS SANS S'Y LIMITER, LA GARANTIE DE QUALITE
C MARCHANDE, L'ADAPTATION A UN USAGE PARTICULIER ET L'ABSENCE DE
C CONTREFACON. EN AUCUN CAS LES AUTEURS OU LES DETENTEURS DU DROIT D'AUTEUR
C NE SERONT TENUS RESPONSABLES DE TOUTE DEMANDE, DOMMAGE OU BRIS DE CONTRAT,
C DELIT CIVIL OU TOUT AUTRE MANQUEMENT LIE AU LOGICIEL, A SON UTILISATION OU
C A D'AUTRES ECHANGES LIES AU LOGICIEL.
C
C
      IMPLICIT NONE
C
C
      INCLUDE 'MAXDIM'
C
C MULTI-GNSS FEATURE
C  GPS       1<=PRN<= 32
C  GLONASS  33<=PRN<= 64  
C  GALILEO  65<=PRN<=100  
C  BEIDOU  101<=PRN<=136  
C
      REAL*8   IONCOR(MAXOBS) 
C
C     ARRAYS FOR BROADCAST EPHEMERIS
C
      INTEGER*4 IEPTIM(MAXSAT),NEPTIM(MAXSAT),IEPSV(MAXSAT),
     &          IBEFIT(MAXSAT)
      REAL*8    EPHSAT(MAXKEP,MAXSAT), EPHTIM(MAXSAT,MAXEPH),
     &          EPHTBL(MAXKEP,MAXSAT,MAXEPH),EPHCLK(7,MAXSAT)
C
      INTEGER*4 YAWMODEL
C ARRAYS FOR RTCM-SSR CORRECTIONS (ORBIT&CLOCKS&BIAS)
C
      LOGICAL*4  RTCMBFLG(32,MAXSAT),RTCMCLKAMB(MAXSAT)
     &          ,RTCMCLKBUF(MAXSAT)
     &          ,RTCMPFLG(32,MAXSAT)
      INTEGER*4  LTRTCM(MAXSAT), FRRTCM(MAXSAT)
      INTEGER*4  RTCMTBUF(MAXSAT), RTCMIBUF(2,MAXSAT)
      REAL*8     RTCMBUF(8,MAXSAT), RTCMBBUF(32,MAXSAT)
     &          ,RTCMPBUF(32,MAXSAT)
C
C ARRAYS FOR MRTCA CORRECTIONS (ORBIT&CLOCKS&IONO)
C
      INTEGER*4  IONDAY
      INTEGER*4  LTRTCA(MAXSAT), FRRTCA(MAXSAT)
      INTEGER*4  RTCATBUF(MAXSAT), RTCAIBUF(MAXSAT)
      REAL*8     RTCABUF(8,MAXSAT), DORBC(12,MAXSAT)
      REAL*8     RTCAVERT(1808), RTCAGIVE(1808)
      REAL*8     TIONINIT(MAXDAYS), TIONX
     &         , TION_END(MAXDAYS)
C
C     ARRAYS FOR PRECISE EPHEMERIS POLYNOMIAL COEFFICIENTS
C
      INTEGER*4 IPEPACC(MAXSAT),IPEPSV(MAXSAT),NPARC(MAXSAT),
     &          NPDEG(MAXSAT,MAXARC),IPEFIT(MAXSAT,MAXARC),
     &          NARCSTOR
      REAL*8    PTB(MAXSAT,MAXARC),PTE(MAXSAT,MAXARC),
     &          PCX(MAXSAT,MAXARC,MAXDEG),PCY(MAXSAT,MAXARC,MAXDEG),
     &          PCZ(MAXSAT,MAXARC,MAXDEG),PDT(MAXSAT,MAXARC,MAXPFIT)
C     ARRAYS FOR SATELLITE AMBIGUITIES
C
      REAL*8    PRIAMB
      REAL*8    CPAMB(MAXSAT),OCPAMB(MAXSAT),CPIAMB(MAXSAT),
     &          DCPAMB(MAXSAT),VCPAMB(MAXSAT),SCPAMB(MAXSAT)
      REAL*8    AMBRMS, AMBWRMS
      LOGICAL*4 CLKAMB(MAXSAT)
C
C     ARRAYS FOR SATELLITE DIFFERENTIAL CODE BIASES
C
      INTEGER*4 LSVDCB(MAXSAT)
      REAL*8    SVDCB(MAXSAT),SVDCBS(MAXSAT),TGD(MAXSAT),PRNDCB(MAXSAT)
C
C     ARRAYS FOR STATION DIFFERENTIAL CODE BIASES
C
      REAL*8    RXDCB(MAXADT),RXDCBS(MAXADT)
C
C     ARRAYS FOR OLD OBSERVATIONS
C
      REAL*8    FLTSUM(MAXFLT,MAXSAT),FLTPAR(MAXFLT)
     &         ,FLTSAV(MAXFLT)
      REAL*8    DMXNLSAV, DMXWLSAV
      LOGICAL*4 LFIXNL, LFIXWL
      REAL*8    HORDION(MAXHOION), sinel
      REAL*8 ION2COR(MAXOBS), AMBP12
C
C     ARRAY FOR OBSERVATION BUFFER FOR CLKJMP
C
      REAL*8    OBSBUF(6,MAXSAT)
C
C    ARRAY FOR VMF1 & IMF MAPPING FUNCTIONS (UP TO 5 6-hour epochs I)
C     vmf1  - COEFMF(I,MJD,   Ah,     Aw,     ZPDry,     ZPDw, KTemp)
C    vmf1grd- COEFMF(I,MJD,   Ah,     Aw,     ZPDry,     ZPDw,     0)
C     imf   - COEFMF(I,MJD, H200, Wratio, GradAlpfa, GradIncl, Ktemp)
      REAL*8  COEFMF(5,6)
C
C new yaw/eclipsing model
C
      real*8 beta, vsvc(3)
      REAL*8  SOLTTAG
C YRTIN IF NON ZERO OVERRIDES THE DATA DEFAULT VALUES IN THE ECLIPS
C YBSIN IF NON ZERO OVERRIDES THE DATA/DEFAULT VALUES IN THE ECLIPS
C INPRN - WHEN NON ZERO INVOKES GAL ECLIPSING
      REAL*8    YRTIN, YBSIN
      INTEGER*4 INPRN
C ACCORDING TO DILSSNER EMAIL OF June 03, 2017 THE  IGEO- 6 (PRN13)
C ECLIPSE LIKE GAILEOL
C WARNING! BEFORE OCT 11, 2016 IGEO-6 WAS PRN 15! CHANGE INPRN TO PRN 13!
C ALSO APPLICABLE TO IGES-1 (C06) (internally PRN 106) since Oct 2016
C AND             TO  MEO -1 (C14) (internally PRN 114) since March 2017!
C ALL BEIDOU 3 MAY EMPLOY YS, TOO, SO
C BEI MEO/IGEO BLKS 25, 26 IN SVB ALSO INVOKE GAL ECLIPSING WHEN INPRN=0
      DATA YRTIN/0.0D0/, YBSIN/ 0.0D0/, INPRN/0/
C
C GNNS Dependent RX ant OFFSET
      REAL*8 ANTXGNSS(3)
C-----------------------------------------------------------------------
C     INTEGER ARRAYS
C-----------------------------------------------------------------------
C
      INTEGER*4 MSJMP(MAXSAT),          MSOFF(MAXSAT)
      INTEGER*4 IBLK(MAXSAT),           ISVN(MAXSAT)
      INTEGER*4 IDX(MAXSAT) ,         IHREP(MAXSAT), IMNEP(MAXSAT)
      INTEGER*4 IARC(MAXSAT),           NRC(MAXSAT,MAXARC)
     &                      ,           NRCFX(MAXSAT,MAXARC)
      INTEGER*4 NRCDF(MAXSAT,MAXARC),   NCPDF(MAXSAT,MAXARC)
      INTEGER*4 NRCRJCT(MAXSAT,MAXARC,MAXREJ)
      INTEGER*4 CNTSLIP(MAXSAT,MAXARC,MAXREJ)
      INTEGER*4 CNTAMB(MAXSAT),CNTFIX(MAXSAT)
      INTEGER*4 ISVRJCT(MAXOBS),ISVRJSV(MAXOBS)
      INTEGER*4 LLUCLK(MAXSAT),     IDSVCLK(MAXSAT), LTSVCLK(MAXSAT+25)
      REAL*8   WSBCOR(MAXSAT),PSBCOR(MAXSAT)
      INTEGER*4 IEOFSA(MAXSAT),    NBPBUF(MAXSAT)
      INTEGER*4 IBPBUF(MAXSAT),    IEPBUF(MAXSAT)
      INTEGER*4 ITMBUF(MAXSAT,MAXOBS), IODBUF(MAXSAT,MAXOBS)
      INTEGER*4 IAOD15(MAXSAT),    ICSLIP15(MAXSAT)
      INTEGER*4 LCSLIP(MAXSAT)
      INTEGER*4 IAMB(MAXSAT)
      INTEGER*4 IUCMD(MAXCMD)
      INTEGER*4 IOBPOS(10)
      INTEGER*4 IECLIPS, NECLIPS(MAXSAT)
C MINFX - MINNIMUM TIME  (IN MIN) FOR WL INITIALIZATION 
     & , MINFX, NOBALL(4)
C
C-----------------------------------------------------------------------
C     DOUBLE ARRAYS
C-----------------------------------------------------------------------
C
      REAL*8     EPH(MAXKEP)
      REAL*8     RCAVG(MAXSAT,MAXARC),  RCSIG(MAXSAT,MAXARC)
      REAL*8     RCRMS(MAXSAT,MAXARC)
      REAL*8     CPAVG(MAXSAT,MAXARC),  CPSIG(MAXSAT,MAXARC)
      REAL*8     CPRMS(MAXSAT,MAXARC)
      REAL*8     STIME(MAXSAT,MAXARC),  ETIME(MAXSAT,MAXARC)
      REAL*8     DSABUF(MAXSAT,MAXOBS)
      LOGICAL*4 IAROFF
      LOGICAL*4 ISARDONE
      INTEGER*4 ISVFX
C     DSGBUF - CLK SIGMA BUF
      REAL*8     DSGBUF(MAXSAT,MAXOBS),DN1,DN2,DN3, AL4                      
     & , DN12REF,  PRDCREF
      REAL*8     DSPBUF(MAXSAT,MAXOBS)
C SAT WL DCB IN DSWBUF
      REAL*8     DSWBUF(MAXSAT,MAXOBS)
      LOGICAL*4  AMBBUF(MAXSAT,MAXOBS)
      REAL*8     YAWBUF(MAXSAT,MAXOBS)
      REAL*8     TROCOR(MAXOBS)
      REAL*8     DRYMAP(MAXOBS),        WETMAP(MAXOBS)
      REAL*8     SAGCOR(MAXOBS),        TIDCOR(MAXOBS)
      REAL*8     PCVCOR(MAXOBS)
      REAL*8     SRELCOR(MAXOBS),       WUPCOR(MAXOBS)
      REAL*8     TWUPCOR(MAXSAT),       PWUPCOR(MAXSAT)
      REAL*8     DPRCP(MAXSAT)
      REAL*8     DSVX(MAXSAT)
      REAL*8     DSVY(MAXSAT)
      REAL*8     DSVZ(MAXSAT)
      REAL*8     DP1P2(MAXSAT), DP1C1(MAXSAT), DP2C2(MAXSAT)
      REAL*8     AVCLK(MAXSAT)
      REAL*8     AZ(MAXOBS),            EL(MAXOBS)
      REAL*8     VELAZ(MAXOBS)
      REAL*8     XRVAPR(MAXPAR), XRVEPO(MAXPAR),XRVVEL(3),DZE,DAZ, RXVEL
      INTEGER*4  NBACCEVAL
      REAL*8     XRVVELP(3), XRVACC(3), XRVACC3D, PRDPOSQLT
     &           ,WETZPD,WETZPDNEW
      REAL*8     DIRC(MAXCOR)
      REAL*8     XSV(MAXCOR),           VSV(MAXCOR)
      REAL*8     ANTX(MAXCOR)
      REAL*8     XRVINP(MAXCOR),        XRVINI(MAXCOR)
      REAL*8     PLHEPO(MAXCOR)
      REAL*8     XRVMRK(MAXCOR),        PLHMRK(MAXCOR)
      REAL*8     XRVAPC(MAXCOR)
     &          ,XRVCOD(MAXCOR)
      REAL*8     XRVTRF(MAXCOR),        PLHTRF(MAXCOR)
      REAL*8     XRVOUT(MAXCOR),        PLHOUT(MAXCOR)
      REAL*8     REFXYZ(MAXCOR)
      REAL*8     XRVDIF(MAXCOR),        PLHDIF(MAXCOR)
      REAL*8     XRVAVG(MAXCOR),        PLHAVG(MAXCOR)
      REAL*8     PLHDIFM(MAXCOR),       PLHAVGM(MAXCOR)
      REAL*8     XRVRMS(MAXCOR),        PLHRMS(MAXCOR)
      REAL*8     XRVSIG(MAXCOR),        PLHSIG(MAXCOR)
      REAL*8     XRVSUM(MAXCOR),        PLHSUM(MAXCOR)
      REAL*8     ETIDE(MAXCOR),         ETIDEX(MAXCOR)
      REAL*8     ADION(MAXLAT,MAXLON),  RDION(MAXLAT,MAXLON)
      REAL*8     ECLSTM(MAXSAT,MAXARC), ECLETM(MAXSAT,MAXARC)
C
      REAL*8     DTM(7)
C
C ARRAYS FOR CLKFIT FOR GPS, GLONASS AND DIFFERENCES
C
      REAL*8     SUMLR(8,7)
C
      REAL*8     CLKBUF(10) , CLKTIM(10)
      REAL*8     SANTXYZ(3)
     &         , TEMPUVX(3), tempuval
      REAL*8     PCVNEU(6,4),   PCVELV(361,182,4), PCVSAT(MAXSAT,43)
      REAL*8     HDXYZH(4)
      REAL*8     AIONBRD(4), BIONBRD(4)
      REAL*8     TRFPAR(16)
      REAL*8     SSVX(1440,4,MAXSAT)
C
      CHARACTER*1  IGNSS(MAXSAT)
      CHARACTER*6  CDEGP, CDEGL, NEG_ZERO
      CHARACTER*4  LRXDCB(MAXADT)
      CHARACTER*80 MEAREC
      CHARACTER*80 NAMOBS, JNAM
      CHARACTER*80 NAMEPH(MAXDAYS)
      CHARACTER*80 NAMCLK(MAXDAYS)
      CHARACTER*80 NAMION(MAXDAYS)
      CHARACTER*80 NAMORG(10)
      CHARACTER*80 NAMMET
      CHARACTER*80 NAMIPX
      CHARACTER*80 NAMCMD
      CHARACTER*80 NAMDEF
      CHARACTER*80 NAMFLT
      CHARACTER*80 NAMSVB
      CHARACTER*80 NAMOLC
      CHARACTER*80 NAMPCV
      CHARACTER*80 NAMTRF
      CHARACTER*80 NAMSTC
      CHARACTER*80 NAMERP
      CHARACTER*40 STNA, REFNAM
      CHARACTER*20 ANTNAM
      CHARACTER*20 RECNAM
      CHARACTER*5  RFRAME(2), RFREAL(2)
      CHARACTER*11 RFNAME
      CHARACTER*80 CMDLST(25)
      CHARACTER*90 RESARC(2,MAXSAT)
      CHARACTER*80 RESREJ(MAXRES)
      CHARACTER*80 DATJMP(MAXRES)
      CHARACTER*3  DIR(2)
C
      LOGICAL FIRSTE, FIRSTM, IPFOUND, INIEPO, UPDEPO
C
C-----------------------------------------------------------------------
C     ADJUSTMENT MATRICES :
C-----------------------------------------------------------------------
C
      INTEGER*4 ISVO(MAXOBS), ISVFLT(MAXOBS)
      INTEGER*4 IGF(MAXSAT), IODC(MAXOBS)
      INTEGER*4 ICSLIP(MAXOBS)
      INTEGER*4 ISVOL(MAXOBS)
      REAL*8     TTAG(MAXOBS)
      REAL*8     PRDC(10,MAXSAT), RAVGALL(4)
      REAL*8     CR1(MAXOBS)
      REAL*8     CR2(MAXOBS)
      LoGICAL*4  ISPR1(MAXOBS), ISPR2(MAXOBS)
      REAL*8     PR1(MAXOBS), PR2(MAXOBS)
      REAL*8     P1(MAXOBS) , P2(MAXOBS)
      REAL*8     FPR(MAXOBS)
      REAL*8     FCP(MAXOBS)
      REAL*8     PSATCOR(MAXOBS)
C
C     ADJUSTMENT MATRICES
C
      REAL*8    PL(MAXOBS2,MAXOBS2)   , A(MAXOBS2,MAXPAR2)
      REAL*8    W(MAXOBS2,1)
      REAL*8    VX(MAXPAR2,MAXPAR2),   OVX(MAXPAR2,MAXPAR2)
      REAL*8    EA(MAXOBS,MAXPAR2),EVX(MAXPAR2,MAXPAR2),SUWFAC,GDOP
      REAL*8    VP(MAXPAR2,MAXPAR2),   OVP(MAXPAR2,MAXPAR2)
      REAL*8    T(MAXPAR2,MAXOBS2)   , U(MAXPAR2,1)      , X(MAXPAR2,1)
      REAL*8    AX(MAXOBS2,1)    , V(MAXOBS2,1)
      REAL*8    VPR(MAXOBS,1)      , VCP(MAXOBS,1)
      REAL*8    PX(MAXPAR2,MAXPAR2)
      REAL*8    OPX(MAXPAR2,MAXPAR2)
      REAL*8    SDXYZ(3),  SDPLH(3)
      REAL*8    OSDXYZ(3), OSDPLH(3)
C
C SCALAR DECLARATIONS
C
      INTEGER*4 I,J,K,ID,IOB,IA,IO,IL,ISV
      INTEGER*4 ISRCH
      INTEGER*4 NUCMD
      INTEGER*4 ICMD(13)
      INTEGER*4 NOCOF
      INTEGER*4 MAXIT,NPAR,NDAY
      INTEGER*4 LUI,LUO,LUDEF,LUMEA,LPR,LUCMD,LPOS,LRES,LUIPX,
     &          LUCOR,LUSES,LUEPH,LUCLK,LUMET,LUION,ILUCLK,LUPX
      INTEGER*4 NSVOL,IDIR,NDIR,IVERSION,IRLEASE,NFIXR,INTCLK,ITER,
     &          IEOF,ITIM,IELL,IVEL,MININC, IABRST, ISMEPO, NSVFLT
     &         ,MXINT,MNINT,GCD
C
      INTEGER*4 LNG,IOS,IFMTM,IEND,IYEARS,IMTHS,IDAYS,IOBTYP,NOBTYP,
     &          NFREQ,IDC,IFREQ,ICOROUT,IONBAND,INXMAP,MAPINT,
     &          MAXMAP,NLNORG,IFMTE,ISVEPH,ISVCLK,IPOSSOL,ICLKSOL,
     &          ICMDERR,IONSLM,IREFOUT,NBDAY,IMODE,ITRPSOL,
     &          IFITCLK,NTRPSOL,JULD,IGPSWK,IWKDAY,IDCFREQ,ISLMFMT,
     &          IERR,IULTRA,IREFIN,IFLT,IFLTON,IPC,ISVB,IOLC,IPCV,
     &          ITRF,IMET(6),NSVCLK,NEPSV,IS,IE,IHR,IMIN,IPDAY,IPHR,
     &          IPMIN,NPEPSV,IPX,NFIX,NCLKFIT,NCLKUP,
     &          NSVO,NSVRJCT,IYEAR,IMTH,IDAY,IREASON,IRJCT,IQLTY,
     &          NSVRJSV,
     &          IRJCTPR, IRJCTCP,
     &          IFLAG,IFLTOP,NCSLIP15,IYGRD,IMGRD,IDGRD,NRXDCB,
     &          NSVDCB,IRC,MJD,INSVO,IPRN,IELV,IEL2,IOBPR,IOBCP,
     &          NMSJMP,NMSOFF,IAMBSUM,
     &          NFPAR,NSVO2,NEWAMB,IDEGP,IMINP,IDEGL,IMINL,
     &          NSVARC,     IONREF,NOBREC,IC1USE,IC2USE,
     &          IDCBUSE,INTOBS,IXRVRNX,NOBS,IMIX, NRESREJ,
     &          ICORRTT , ICORRPR, ICORRCP, NMSCLJ, NMSCPJ, NDATJMP,
     &          ICORRTTP , ICORRPRP, ICORRCPP, MJDS, IPXR
     &          ,IEXP
     &          , IMINACC
C
C AMPL(4,J) PHAS(4,j) contains frequency/phase of tidal term
C
      REAL*8    AMPL(4,MAXOTLC), ANOON, ANIGHT, PHAS(4,MAXOTLC),
     &          C,F1,F2,F1S,F2S,F12S,F1ION,F2ION,AL1,AL2,AL3,CLKOFF,
     &          CLKOFF2,
     &          PCHIP,CACHIP,PI,HION,OBSINT,UPDINT,DLAY12,EPOCH,GPSUTC,
     &          FLTINT,
     &          SDPR,ANTH(4),CUTOFF,DOPMAX,SDCP,SDTROP,TEMP,PRES,RH,
     &          TROSCL,REFHGT,VSCALE,DRYEPO,WETEPO,DRYM,WETM,TROZEN,
     &                                              SMA,PERIOD,SEC,
     &          PSEC,ANTN(4),ANTE(4),SD,PTTAG,DTTAG,ENDTTAG,UTTAG,
     &          PN,FLTVAR,DTION,TION,FRLAT,TOLAT,DLAT,FRLON,TOLON,DLON,
     &          SLMHGT,REFLAT,FMJDDT,UT1UTC,DUT1,ALPHAE,SIDT,
     &          REFTM0,REFTM,SECEP,DMJDT,DMJDOL,DUP,DNS,DEW,TXTIM,
     &          DELTAT,RELDTR,TXPEP,SATCOR,RNG,RANGL1,RANGL2,ZEN,
     &          VIONCOR,PCVL1,PCVL2,DOY,DUMMY,TROHOP,RRATE,SUWCP,
     &          SIONCOR,
     &          SUWPR,OFMJDDT,SRELINI,RANGL,RANGP,DELTAR,DELTAP,
     &          DX,VTVPR,VTVCP,PDOP,XRVCOR,CORMAX,VPRTOL,VCPTOL,
     &          VPRMAX,VCPMAX,CLKPRD,UOFFSET,UDRIFT,UREFTM,
     &          DCLKEPO,CLKTOL,USDOFF,USDRIFT,OFFSET,DRIFT,
     &          DRIFTRATE,SDOFF,SDRIFT,SDRIFTRATE,SECP,SECL,
     &          CLKRMS,REFM,SVBCOS,SDX,VPV,DVPV,CHI299,SO,STRTTAG
      INTEGER*4 SCHA_NSET, SCHA_L(MAXSHCOEF,2), SCHA_M(MAXSHCOEF,2)
     &         ,SCHA_DEG, SHCOEFHEAD
      REAL*8    SCHA_DCB(MAXSAT), SCHA_T(2), SCHA_NMN(MAXSHCOEF,2),
     &          SCHA_ALM(MAXSHCOEF,2), SCHA_BLM(MAXSHCOEF,2)
     &         ,SCHA_DLM(MAXSHCOEF,2),SVIONCOR, TECX(3), TECZ(3) 
     &         , MAGLAT, MAGLON, MAGHRA
      INTEGER*4 SCHA_ORD, SCHA_CNT, SCHACOEFHEAD
     &          ,SCHA_REF
      REAL*8    SCHA_CAP, SCHA_CLAT, SCHA_CLON, SCHA_INT
      LOGICAL*4 SLMGPS, SLMGLN
      REAL*8    SDCLK, SDCLK0, PCLKSIG, PMTTAG
      INTEGER*4 IERP
      REAL*8    FMJDMP, XMPDIF, YMPDIF, XMPDRT, YMPDRT
C
C checking diverging solutions
C
      REAL*8     LOGDX,LOGDXO
      DATA       LOGDXO/0.D0/
C
C GLONASS CLK (RLK)
C
      INTEGER*4 RNCLKFIT,DNCLKFIT,ICONST
      INTEGER*4 ENCLKFIT,DENCLKFIT
      INTEGER*4 CNCLKFIT,DCNCLKFIT
      INTEGER*4 NGPS,NGLN, NGAL
      LOGICAL   GPS, GLN, GAL
      REAL*8    GPSCLK,GLNCLK,SGPSCLK,SGLNCLK, GALCLK, SGALCLK
      INTEGER*4 NBEI          
      LOGICAL   BEI             
      REAL*8    BEICLK, SBEICLK
      REAL*8 ROFFSET,RDRIFT, RSDOFF, RSDRIFT
      REAL*8 DOFFSET,DDRIFT, DSDOFF, DSDRIFT
      REAL*8 RDRIFTRATE, RSDRIFTRATE, RCLKRMS
      REAL*8 DDRIFTRATE, DSDRIFTRATE, DCLKRMS
      REAL*8 EOFFSET,EDRIFT, ESDOFF, ESDRIFT
      REAL*8 DEOFFSET,DEDRIFT, DESDOFF, DESDRIFT
      REAL*8 EDRIFTRATE, ESDRIFTRATE, ECLKRMS
      REAL*8 DEDRIFTRATE, DESDRIFTRATE, DECLKRMS
      REAL*8 COFFSET,CDRIFT, CSDOFF, CSDRIFT
      REAL*8 DCOFFSET,DCDRIFT, DCSDOFF, DCSDRIFT
      REAL*8 CDRIFTRATE, CSDRIFTRATE, CCLKRMS
      REAL*8 DCDRIFTRATE, DCSDRIFTRATE, DCCLKRMS
      INTEGER*4 NAMBFX
      INTEGER*4 MINSAT
C
      REAL*8 SOBWD
      DATA SOBWD/1.d0/
      REAL*8 LSTFWDVX(MAXPAR)
      DATA LSTFWDVX/MAXPAR * 0.D0/
C
C track average NL and WL
C
      REAL*8 AVGNL, AVGWL
      DATA AVGNL/0.d0/, AVGWL/0.d0/
      real*8  trpsig,grdsig
C
C new station clock input file
C
      INTEGER*4 ICLKAP, ICLKFIT
      REAL*8    CLKY0,CLKD0,UCLKY0,UCLKD0,CLKSD0
      INTEGER*4   IPXRELAX
C     GLNS INTER FREQ RATE/CHANNEL IN NS (FROM RDHDR)
      REAL*8 RIFRATE , DRIFRT, SUMIGF , SRIFRT
      INTEGER*4 IPRNREF
C      IPEPINT-  PREC EPH INTERVAL
      INTEGER*4 IPEPINT
      INTEGER*4 IK
      LOGICAL*4 RELAXAMB
      INTEGER*4 IPRNFX(MAXDAYS)
      REAL*8    SMDCLK,NLPERIOD,NLWL,NCLKNL
      INTEGER*4 NSVCOMN,IDXN(MAXOBS),IDXO(MAXOBS)
      LOGICAL*8 SVRELAX(MAXOBS)
      INTEGER*4 MNRELAX,NRELAX,NFIXGRP
      REAL*8    DMISCPNL
      LOGICAL*4 SMTHCLK
C Previous DELTAR, DELTAP
      REAL*8 DELTAPP_GLN, DELTARP_GLN
      LOGICAL    O_GPS, O_GLN, O_GAL
      INTEGER*4  IOBP_GPS, IOBP_GLN, IOBP_GAL, IOBP
      REAL*8 DELTAPP_GPS, DELTARP_GPS , DELTAPP_GAL, DELTARP_GAL
      REAL*8 DELTAPP_BEI, DELTARP_BEI
      LOGICAL O_BEI
      INTEGER*4 IOBP_BEI
      REAL*8 DELTAPP, DELTARP
      LOGICAL*4 TESTMISCPROB
      CHARACTER*160 MISFMT,RESFMT
      INTEGER*4 KR,KP
      INTEGER*4 CMISC, NMISC(4), IMISCR(MAXOBS,4), IMISCP(MAXOBS,4)
      REAL*8 MISCR(MAXOBS),MISCP(MAXOBS)
      INTEGER*4 NMISCRGRP, IMISCR_GRP(MAXOBS),MISCRCNT(MAXOBS)
      REAL*8 MISCRAVG(MAXOBS),MISCRSTD(MAXOBS)
      INTEGER*4 NMISCPGRP, IMISCP_GRP(MAXOBS),MISCPCNT(MAXOBS)
      REAL*8 MISCPAVG(MAXOBS),MISCPSTD(MAXOBS)
      REAL*8 MISCFACTR, MISCFACTP
      INTEGER*4 NEPFIX
      INTEGER*4 NEPOCHDEL,INIEPOCHDEL
      INTEGER*4 NSVDWGT, NSVDWSAV, ISVDWGT(MAXOBS), ISVDWSAV(MAXOBS)
C WHEN OUTLIERACTION=0 ALL MISCLOSURES/RESIDUAL REJECTION ARE DELETED
C ELSE (DEFAULT) THEY ARE DEWEIGHTED
      INTEGER*4 OUTLIERACTION
      DATA OUTLIERACTION/0/
      INTEGER*4 IMFSEL
      REAL*8    ION_MF1
      REAL*8 BEIPR
C BETAINI- INI BETA ANGLE OF ECLPS START(BEI EXCLUDED)
      REAL*8 BETAINI(136)
      DATA   BETAINI/136*0.D0/
      LOGICAL*4 TESTMISC
C
      DATA YAWMODEL/0/
C RTCM SPECIFIC INITIALIZATION
      DATA RTCMCLKAMB/MAXSAT*.FALSE./
      DATA RTCMCLKBUF/MAXSAT*.FALSE./
      DATA CLKAMB/MAXSAT*.FALSE./
C MRTCA SPECIFIC INITIALIZATION
      DATA IONDAY/1/
      DATA TION/-1/
      DATA TIONX/-1/
      DATA TIONINIT/MAXDAYS*-1/
      DATA TION_END/MAXDAYS*-1/
      DATA RTCAVERT/1808*63.875D0/
      DATA RTCAGIVE/1808*1.D6/
C!!
C!!   INITIALIZE BROADCAST EPHEMERIS SORT AND SEARCH OPTIONS
C!!   0) LARGEST TRANSMIT/RECEIVE TIME < CURRENT EPOCH
C!!   1) CLOSEST REFERENCE TIME TO CURRENT EPOCH
C!!
C!! Code Beg ==================================================================
      DATA ISRCH / 0 /
C!!   DATA ISRCH / 1 /
C!! Code End ==================================================================
      DATA INIEPO / .TRUE. /
      DATA INIEPOCHDEL / 0 /
C
C
C     INITIALIZE USER OPTIONS
C
      DATA  NUCMD      /21/
      DATA  (IUCMD(I),I=1,21) 
     &/1, 2, 3, 4, 5, 6, 7, 8, 9, 10,11,12,13,14,15,16,17,18,19,20,21/
C
C     OLOAD ARRAY & DATA
C
      DATA NOCOF /9/
C
C     INITIALIZE TRANSFORMATION PARAMETERS
C
      DATA   (RFRAME(ID),ID=1,2)    /  'NAD83','ITRF ' /
      DATA   (RFREAL(ID),ID=1,2)    /  'CSRS ','WGS84' /
C
      DATA   (DIR(ID),ID=1,2)      /  'FWD','BWD' /
C
      DATA FIRSTE,FIRSTM / .TRUE., .TRUE. /
      DATA MAXIT /7/
      DATA NPAR /5/
      DATA NDAY /1/
C
      DATA LUI /5/,     LUO /6/
      DATA LUDEF /7/
      DATA LUMEA /21/
      DATA lPR /13/,    LUCMD /14/
      DATA LPOS /15/,   LRES/16/
      DATA LUCOR/17/,   LUSES/18/
      DATA LUEPH/19/,   LUCLK/20/
      DATA LUMET/11/,   LUION/22/
      DATA LUIPX /23/
      DATA LUPX/25/
      DATA ILUCLK/25/
      DATA NOBREC/0/
C
C     ZERO SUMS USED IN LINEAR REGRESSION
C
      DATA (SUMLR(I,1),I=1,8)           /8*0.D0/
      DATA (SUMLR(I,2),I=1,8)           /8*0.D0/
      DATA (SUMLR(I,3),I=1,8)           /8*0.D0/
      DATA (SUMLR(I,4),I=1,8)           /8*0.D0/
      DATA (SUMLR(I,5),I=1,8)           /8*0.D0/
      DATA (SUMLR(I,6),I=1,8)           /8*0.D0/
      DATA (SUMLR(I,7),I=1,8)           /8*0.D0/
C
      DATA (IODC(I),I=1,MAXOBS)         /MAXOBS*0/
C
C SET IGF to USE GPS and REJECT GLONASS
C RDSVB will update this
C
      DATA  (IGF(I),I=1,32)  /32*0/
      DATA  (IGF(I),I=33,56) /24*99/
      DATA (FLTPAR(I),I=1,MAXFLT) /MAXFLT*0.D0/
      DATA (FLTSAV(I),I=1,MAXFLT) /MAXFLT*0.D0/
      DATA (HORDION(I),I=1,MAXHOION) /MAXHOION*0.D0/
C
C-----------------------------------------------------------------------
C  INITIALIZED VALUES:
C-----------------------------------------------------------------------
C
      DATA NSVOL, NSVO /0, 0/
      DATA (ISVOL(I),I=1,MAXOBS)/MAXOBS*0/
      DATA (ISVO(I),I=1,MAXOBS)/MAXOBS*0/
      DATA IDIR/1/
      DATA NDIR/-1/
C     VERSION NUMBER
      DATA IVERSION/110/
C     RELEASE NUMBER (day of year,last two-digits of year)
      DATA IRLEASE/25018/
      DATA NFIXR / 0/
      DATA INTCLK / 900/
      DATA ITER / 0/
      DATA IEOF / 0/
C
C!! ITIM = 0 : order broadcast by reference time
C!! ITIM = 1 : order broadcast by reception/transmission time
C!!
C!! Code Beg ==================================================================
C!!   DATA ITIM / 1/
      DATA ITIM / 0/
C!! Code End ==================================================================
      DATA IELL/0/
      DATA IVEL/1/
      DATA MININC/5/
      DATA IONBAND/30/
      DATA INXMAP/0/
      DATA MAPINT/0/
      DATA MAXMAP/0/
      DATA NMSJMP/0/
      DATA NMSOFF/0/
      DATA NMSCLJ, NMSCPJ/0, 0/
      DATA ICORRTT, ICORRTTP, ICORRPR, ICORRPRP, ICORRCP, ICORRCPP 
     &     / 0, 0, 0, 0, 0, 0 /
      DATA NDATJMP/0/
      DATA    CPAMB/MAXSAT*0.0/
      DATA    OCPAMB/MAXSAT*0.0/
      DATA    CPIAMB/MAXSAT*0.0/
      DATA    DCPAMB/MAXSAT*0.0/
      DATA    VCPAMB/MAXSAT*0.0/
      DATA    SCPAMB/MAXSAT*0.0/
      DATA NCSLIP15/0/
      DATA ISMEPO/1/
      DATA NRESREJ/0/
      DATA  NEG_ZERO /'    -0'/
      DATA ((COEFMF(I,J), I=1,5),j=1,6)/30*0.0/
C
C OVERLAPPING POLYNOMIALS
C
      DATA NARCSTOR/0/
      DATA NPARC/MAXSAT*0/
C
      DATA NECLIPS/MAXSAT*0/
C
      DATA PRNDCB/MAXSAT*-999.D0/
      DATA TGD/MAXSAT*-999.D0/
      DATA SCHA_DCB/MAXSAT*-999.D0/
      DATA DSVX / MAXSAT*0.D0 /
      DATA DSVY / MAXSAT*0.D0 /
      DATA DSVZ / MAXSAT*0.D0 /
      DATA ISLMFMT / 0 /
      DATA IAROFF/.FALSE./
C MISCFACT[PR]  > 0 SERVES AS A LOWER LIMIT
C MISCFACT[PR] <= 0 DISABLES MISCLOSURE TESTING UNLESS ACTIVATED IN CMD FILE
C                   LOWER LIMIT IS THEN 9.0
C DEFAULT: ENABLING CODE MISC TEST; ENABLING PHASE MISC TEST
C DEFAULT: ENABLING CODE MISC TEST; DISABLING PHASE MISC TEST
      DATA MISCFACTR, MISCFACTP/ 9.D0, 0.D0 /
      DATA RELAXAMB/.FALSE./
      DATA IPRNFX/MAXDAYS*0/
      DATA SVRELAX/MAXOBS*.FALSE./
      DATA SMDCLK/0.D0/
      DATA NCLKNL/0.D0/
      DATA SMTHCLK/.TRUE./
      DO I=1,MAXOBS2
        DO J=1,MAXPAR2
          A(I,J) = 0.D0
          IF(I.LE.MAXOBS .AND. J.LE.MAXOBS) EA(I,J)=0.D0
        END DO
      END DO
      HORDION(2)=1.D02
      HORDION(11)=1.D 0  
      HORDION(15)=1.D 0 
C  WL INT PHASE INIILIZATION AFTER MINFX MIN ONLY! 
      MINFX= 30     
      HORDION(19)=1.D-3
      HORDION(19)=1.D-8 
      IPRNREF=0
      DELTARP=0.D0
      DELTAPP=0.D0
      SOLTTAG=0.D0
      C  = 299792458.0D0
      F1   = 1575.42D+06
      F2   = 1227.60D+06
      F1S  = F1*F1
      F2S  = F2*F2
      F12S = F1S - F2S
      F1ION = F2S / F12S
      F2ION = F1S / F12S
      AL1  = C/F1
      AL2  = C/F2
      AL3  = F2ION*AL1-F1ION*AL2
C (AL4- WL WAVE LENGTH)
      AL4= C/(F1-F2)
      CLKOFF = 0.D0
      ENDTTAG = 0.D0
      PMTTAG   = 0.D0
      STRTTAG = -1.D0
      NPAR    = MAXPAR2
      PCHIP= C/10.23D6
      CACHIP= C/1.023D6
      PI = (DATAN(1.0D0))*4.0D0
      HION = 350.D3
C GPS clock
      XRVEPO(4)=0.D0
C Tropo gradients
      XRVEPO(6)=0.D0
      XRVEPO(7)=0.D0
C Glonass clock
      XRVEPO(8)=0.D0
C Galileo clock
      XRVEPO(9)=0.D0
C Beidou  clock
      XRVEPO(10)=0.D0
      WETZPD=0.2D0
C SKIN
      SDX=0.0d0
      VPV=0.0d0
      NOBS=0
      IABRST = 0
C
      SO =1.d0
C
      DO I=1,MAXSAT
        TWUPCOR(I)=-1.D0
        PRDC(9,I) = 0.D0
        CNTAMB(I)=0
        DO J=1,MAXARC
       IPEFIT(I,J)=1
      END DO
      END DO
      OPEN ( LUDEF, FILE=".DEWEIGHT", STATUS='OLD', ERR=22)
      OUTLIERACTION=1
      CLOSE(LUDEF)
 22   CONTINUE
C
C-----------------------------------------------------------------------
C      DEFINE DATUM
C----------------------------------------------------------------------
C
       CALL DATUM(LUI,LUO,DTM,IELL)
C
C------------------------------------------------------------------------
C     OPEN FILES
C------------------------------------------------------------------------
C
C     ASSIGN DEFAULT FILE NAME AND OPEN  
C
      NAMDEF='gpsppp.def'
      OPEN ( LUDEF, FILE=NAMDEF, STATUS='UNKNOWN')
C
C     READ LIST OF DEFAULT FILE NAMES
C
      CALL GETDEF(   LUI, LUO, LUDEF, NAMFLT, 
     &               NAMSVB, NAMOLC, NAMPCV, NAMTRF, NAMMET, NAMIPX,
     &               NAMORG, NAMERP, NAMSTC, NLNORG,  LNG )
C
C     READ INITIAL PARAMETERS AND WEIGHTS
C        
      IPXR=0
      OPEN ( LUIPX, FILE=NAMIPX, STATUS='OLD', FORM='UNFORMATTED',
     &       ERR=4)
c!    WRITE(*,*) 'CALLING RDIPX',NAMIPX
      CALL RDIPX( LUIPX, IPXR, UTTAG, NFPAR, XRVEPO, NSVO, ISVO,  
     &            CPAMB, PX, NSVFLT, ISVFLT, FLTSUM, TWUPCOR, PWUPCOR,
     &            NCSLIP15, ICSLIP15, PL, EL, HORDION, FLTSAV,
     &            LFIXNL, LFIXWL, DMXNLSAV, DMXWLSAV, IRLEASE )
      CLOSE(LUIPX)
C
C ensure compatibility of initial
C
      IF( NFPAR .NE. MAXPAR ) IPXR=0
C
c!    WRITE(*,*) ' MATRIX PX IN RDDEF AFTER RDIPX', IPX
c!    WRITE(*,'(15F5.3)') (PX(I,I),I=1,NFPAR+NSVO)  
c!    WRITE(*,*) 'IN GPSPPP, XRVEPO'
c!    WRITE(*,*) (XRVEPO(I),I=1,NFPAR)
C
4     CONTINUE
      IPX=IPXR
      NFPAR=MAXPAR
C
      CALL PGMLBL( LUO, IVERSION, IRLEASE, NAMORG, NLNORG, LNG)
C
    5 CONTINUE
      WRITE(NAMOBS,'(80A1)') ' '
      WRITE(LUO,710)
      READ(LUI,720) NAMOBS
      OPEN  ( LUMEA, FILE=NAMOBS, STATUS='OLD', IOSTAT=IOS, ERR=7 )
      GO TO 9
    7 CONTINUE
      WRITE(LUO,730) IOS, NAMOBS
      GO TO 5
    9 CONTINUE
C
      CALL RDFMT (LUMEA, IFMTM, IEND)
      IF (IEND .EQ. 1) GO TO 690
C
      CALL RDHDR ( IFMTM, LUMEA, IYEARS, IMTHS, IDAYS, STNA,
     &             OBSINT, NOBREC, IOBPOS, DLAY12, NFREQ, IFREQ, HDXYZH,
     &             ANTNAM, RECNAM, RIFRATE, IEOF )
C
      IF (IEOF .EQ. 1 .OR. OBSINT .EQ. 0.D0 ) THEN
        WRITE(*,*) '*END - OBSERVATION INTERVAL NOT VALID'
        GO TO 690
      END IF
      IF ( IFMTM .EQ. 1 .AND. NOBREC .EQ. 0 ) THEN
        WRITE(*,*) '*END - NON-STANDARD RINEX FILE FORMAT'
        GO TO 690
      END IF
C
C      APPROXIMATE EPOCH IN YEARS FOR TOREF TRANSFORMATIONS
C      COMPUTE APPROXIMATE  GPSUTC +- 1SEC
C
       EPOCH= IYEARS +((IMTHS-1)*30+IDAYS)/365.d0
       GPSUTC = -13.D0 - DBLE(INT((EPOCH-2001.D0)/4.D0))
C
c!    WRITE(*,*) 'ANTENNA NAME IS ',ANTNAM
c!    WRITE(*,'(A20,4F12.1)') 'HDXYZH-AFTER RDHDR',
c!   &            HDXYZH(1),HDXYZH(2),HDXYZH(3),HDXYZH(4)
C
C      READ COMMAND FILE
C      
      IDC=1
      CALL RDCMD( LUI, LUO, LUCMD, NAMCMD, NFREQ, IFMTM, IFMTE,  
     &            MISCFACTR, MISCFACTP,
     &            SDPR, XRVMRK, XRVVEL, IXRVRNX,ANTH(1),ICLKSOL,CUTOFF, 
     &            IDC, ICMDERR, NUCMD, IUCMD, DOPMAX, HDXYZH, DTM, 
     &            PI, SDCP, SDTROP, CMDLST, ICMD, SMTHCLK, LNG )
         SRIFRT=0.D0
         write(*,*) 'XYZ STA vel (m/y)', XRVVEL(1)*365.25*86400,
     & XRVVEL(2)*365.25*86400, XRVVEL(3)*365.25*86400 
       
C
C       NBDAY  = UT DAYS OBSERVED                       (1-7)
C       IMODE  = USER DYNAMICS         (1=STATIC,2=KINEMATIC)
C       IOBTYP = OBSERVATION TO PROCESS         (1=COD,2=C&P)
C       IFREQ  = FREQUENCY TO PROCESS        (1=L1,2=L2,3=L3)
C              = 3, 5 GAL(L1,L5), 7 GAL (L1, L7), 8 GAL(L1,L8)
C       ISVEPH = SATELLITE EPHEMERIS INPUT     (1=BRD ,2=SP3)
C       ISVCLK = PRECISE SATELLITE CLOCK INPUT   (1=NO,2=YES,3=MRTCA,4=RTCM)
C switching off AR when ISVCLK=ISVCLK +10
C       IFITCLK= SATELLITE CLOCK INTERPOLATION   (1=NO,2=YES)
C       IONSLM = IONOSPHERIC GRID INPUT          (1=NO,2=YES)
C       IPOSSOL= SOLVE STATION COORDINATES       (1=NO,2=YES)
C       ITRPSOL= SOLVE TROPOSPHERIC DELAY (1=NO,2-5=RW MM/HR)
C       NDIR   = BACWARD SUBSTITUTION            (1=NO,2=YES)
C       IREFOUT= REFERENCE SYSTEM            (1=NAD83,2=ITRF)
C       ICOROUT= COORDINATE SYSTEM(1=ELLIPSOIDAL,2=CARTESIAN)
C
      NBDAY   = ICMD(1)
      IMODE   = ICMD(2)
      IOBTYP  = ICMD(3)
      IFREQ   = ICMD(4)
      ISVEPH  = ICMD(5)
      IAROFF = ICMD(6)/10 .NE. 0
      ISVCLK =  MOD(ICMD(6),10)
      IFITCLK = ICMD(7)
      IMFSEL  = ICMD(8)/10
      IONSLM  = MOD(ICMD(8),10)
      IPXRELAX = ICMD(9)/10
      IPOSSOL =  MOD(ICMD(9),10)
      ITRPSOL = ICMD(10)
      NDIR    = ICMD(11)
      IREFOUT = ICMD(12)
      ICOROUT = ICMD(13)
      CALL FREQ12(1, F1, F2, F1S, F2S, F12S, F1ION, F2ION,
     &            AL1, AL2, AL3, AL4, IFREQ )
      NLWL=AL3
      NLPERIOD=NLWL/C*1.D9
C
C       SAVE SELECTED TROPO SOLUTION AND OBSERVATION TYPE
C       SET TROPO MODEL AND CODE OBSERVATION FOR INITIAL EPOCH
C
      NOBTYP=IOBTYP
      IF (IPXR .EQ. 0) THEN
        NTRPSOL=ITRPSOL
        IOBTYP=1
        ITRPSOL=1
      ELSE
        INIEPO=.FALSE.
        PTTAG=UTTAG
        DO I=1,NFPAR
          XRVAPR(I)=XRVEPO(I)
        END DO
        DO I=1,MAXSAT
          OCPAMB(I)=CPAMB(I)
        END DO
        IF( IPXRELAX .NE. 0 ) THEN
          DO I=1,3
            PX(I,I) = PX(I,I) + 1.D10
          ENDDO
        ENDIF
      END IF
C      
      DO I=1,3
        XRVINP(I)=XRVMRK(I)
        XRVINI(I)=XRVMRK(I)
      END DO
C
      IF ( ICMDERR .EQ. 1 ) THEN
        WRITE(*,*) '*END - COMMAND FILE ERROR'
        GO TO 690
      END IF
C
C     CONVERT MARKER COORDINATES (CARTESIAN->ELLIPSOIDAL)
C
      CALL XYZPL2 (DTM(3),DTM(4),DTM(5),DTM(1),DTM(2),XRVMRK(1),
     &             XRVMRK(2),XRVMRK(3),PLHMRK(1),PLHMRK(2),PLHMRK(3))
C
C     READ MET FILE, ADJUST PRESSURE USING STATION HEIGHT
C        
      OPEN ( LUMET, FILE=NAMMET, STATUS='UNKNOWN')
      CALL RDMET( LUI, LUO, LUMET, IYEARS, IMTHS, IDAYS, 
     &     IMET,
     &     TEMP, PRES, RH, TROSCL, PLHMRK   , COEFMF, STNA, LNG)
      CLOSE(LUMET)
C
C     READ ERP FILE
C        
      OPEN ( LUMET, FILE=NAMERP, STATUS='UNKNOWN')
      CALL RDERP( LUI, LUO, LUMET, IYEARS, IMTHS, IDAYS, 
     &            FMJDMP, XMPDIF, YMPDIF, XMPDRT, YMPDRT, IERP )
      CLOSE( LUMET )
C
C OPEN CNES WSB IN gpsppp.wsb FOR AR IF IT EXIST
C
        OPEN ( LUMET, FILE='gpsppp.wsb', STATUS='OLD',ERR=30)
10       READ(LUMET,*                           ,ERR=20,END=30)
     &              J, K, IA, IL, (PRDC(9,I),I=1,32)
         IF(J.EQ.IYEARS.AND.K.EQ.IMTHS.AND.IA.EQ.IDAYS) GO TO 30
20       GO TO 10
30      CONTINUE
        DO I=1,32
         PRDC(8,I)=0.D0
         PRDC(9,I)= PRDC(9,I)*C/(F1-F2)
         PRDC(10,I)=0.D0
        END DO
        CLOSE(LUMET)
C
C OPEN CNES NSB IN gpsppp.wsb FOR AR IF IT EXIST
C input NL Sat Biase (NSB) in gpsppp.nsb
C
        OPEN ( LUMET, FILE='gpsppp.nsb', STATUS='OLD',ERR=31)
11       READ(LUMET,*                           ,ERR=21,END=31)
     &              J, K, IA, IL, (PRDC(10,I),I=1,32)
         IF(J.EQ.IYEARS.AND.K.EQ.IMTHS.AND.IA.EQ.IDAYS) GO TO 31
21      GO TO 11
31      CONTINUE
        CLOSE(LUMET)
C
C ITRPSOL = i*100+j*10+k WHERE
C where     k=1 no tropo estimation whatsoever
C            =2-5 tropo process noise of k cm/sqrt(h)
C           j=0 non-VMF1 mapping
C             2 VMF1 mapping
C           i=0 no gradient estimation
C             2 gradient estimation
C
      IF(COEFMF(1,2).GT.0.D0.AND.COEFMF(1,2).LT.2.d-3
C EXCLUDE GPT2 IMET(1-3)=6
     &   .AND.COEFMF(1,4).GT.0.d 0.AND.IMET(2).NE.6) NTRPSOL=NTRPSOL+20
C
C OPEN PXFWD FILE ON LUPX. SAVING FWD AMB SOLUTION FOR BWD RUN
      IF(NDIR.LE.-1.AND.IDIR.EQ.1.AND.NOBTYP.EQ.2) THEN
        OPEN (LUPX,FILE='PXFWD',STATUS='UNKNOWN')
        CLOSE ( LUPX, STATUS='DELETE' )
        OPEN ( LUPX,FILE='PXFWD',STATUS='NEW', FORM='UNFORMATTED')
      END IF
C
      CALL GPSDC ( JULD,IYEARS,IMTHS,IDAYS,IGPSWK,IWKDAY, 2 )
      CALL JLIAN ( MJDS, IYEARS, IMTHS, IDAYS)
C
      CALL FNAME( NAMOBS, JNAM, LUI, LUO, LUMEA, ISVEPH,
     &            IFMTE, LUEPH,
     &            LPR, LPOS, LRES, LUIPX, LUCOR, LUSES, LUCLK, 
     &            LUION, ISVCLK,  NAMCLK, NAMEPH, NAMION, IDCFREQ, 
     &            IONSLM, REFNAM, REFXYZ, REFHGT, NBDAY, IYEARS,
     &            IMTHS, IDAYS, ISLMFMT, IERR, IULTRA, IMINACC, LNG )

C
C     WRITE PROGRAM LABEL AND HEADER RECORD TO OUTPUT FILES
C
      CALL PGMLBL( LPR, IVERSION, IRLEASE, NAMORG, NLNORG, LNG )
      CALL PGMLBL( LPOS, IVERSION, IRLEASE, NAMORG, NLNORG, LNG )
      IF ( ICOROUT .EQ. 1 ) THEN
      WRITE (LPOS,2400)
      ELSE
      WRITE (LPOS,2401)
      END IF
      CALL PGMLBL( LRES, IVERSION, IRLEASE, NAMORG, NLNORG, LNG )
      WRITE(LRES,2600) 
C
C     WRITE PPP VERSION AND RELEASE NUMBER TO SESSION FILE
C
      WRITE(LUSES,'(A3,1X,F5.2,1X,I5.5)') 'VER',IVERSION/100.0,IRLEASE  
      IREFIN=2
      IF ( ISVEPH .EQ. 2 ) 
     &  CALL SP3REF ( LUEPH, IREFIN, RFRAME, RFREAL, EPOCH, IEND )
C
C MRTCA: if orbit is BRD+MRTCA reference is NAD83
C
      IF( ISVEPH .EQ. 1 .AND. ISVCLK .EQ. 3 ) IREFIN=1
C
C RTCM-SSR: if orbit is BRD+RTCM-SSR reference is ITRF
C           should read 1057,1060 to be correct
C
      IF( ISVEPH .EQ. 1 .AND. ISVCLK .EQ. 4 ) THEN
       IREFIN=2
       RFREAL(IREFIN)='IGb08'
      ENDIF
      IF (IREFOUT .EQ. 1) 
     &         WRITE(RFNAME,'(A5,A1,A4,A1)') RFRAME(IREFOUT),'(',
     &                                       RFREAL(IREFOUT),')'
      IF (IREFOUT .EQ. 2) 
     &         WRITE(RFNAME,'(A4,A1,A5,A1)') RFRAME(IREFOUT),'(',
     &                                       RFREAL(IREFOUT),')'
C
C     WRITE SUMMARY OF I/O FILE NAMES
C
      CALL SUMIOF ( LPR, NAMOBS, NAMCMD, ISVEPH, NAMEPH, ISVCLK,  
     &              NAMCLK, IONSLM, NAMION, NBDAY, IFREQ, LNG )
C
C     READ DEFAULT FILES AND SET PROCESSING PARAMETERS 
C
      CALL SUMDEF ( LUI, LUO, LPR, LUDEF, IYEARS, IMTHS, IDAYS,
     &     IFREQ, IOBPOS,
     &     IFLT, NAMFLT, FLTPAR, IFLTON, IPC, VSCALE, 
     &     IC1USE, IC2USE, IDCBUSE, SDPR, SDCLK0, 
     &     ISVB, NAMSVB, IGNSS, ISVN, IBLK, 
     &     DSVX, DSVY, DSVZ, DP1P2, DP1C1, DP2C2, AVCLK,
     &     IOLC, NAMOLC, NOCOF, XRVMRK, DTM, DMJDOL, AMPL, PHAS, 
     &     IPCV, NAMPCV, ANTNAM, PCVNEU, PCVELV, PCVSAT,
     &     ITRF, NAMTRF, RFRAME(2), RFREAL(2), TRFPAR,
     &     IMET, NAMMET, PLHMRK(3), TEMP, PRES, RH, TROSCL,
     &     IERP, NAMERP, FMJDMP, XMPDIF, YMPDIF, XMPDRT, YMPDRT,
     &     IPXR, NAMIPX, ICLKAP,NAMSTC,CLKY0,CLKD0,UCLKY0,
     &     UCLKD0,CLKSD0, ICLKFIT, EPOCH, LNG, IGF )
C SAVE INPUT DMAXNL&DMAXWL IN DMXNLSAV & DMXWLSAV for CY SLIP SWITCH
      IF (IPXR .EQ. 0) THEN
           LFIXNL=FLTPAR(1) .LT. 0.D0
           LFIXWL=FLTPAR(2) .LT. 0.D0
           DMXNLSAV=FLTPAR(1)
           DMXWLSAV=FLTPAR(2)
C WHEN  DMXNLSAV & DMXWLSAV < 0, CONSTANT DMAXNL&DMAXWL
           FLTPAR(1)=ABS(FLTPAR(1))
           FLTPAR(2)=ABS(FLTPAR(2))
      ELSE
           FLTPAR(1)=FLTSAV(1)
           FLTPAR(2)=FLTSAV(2)
           FLTPAR(3)=FLTSAV(3)
      ENDIF
C
C     SORT SA CLOCK CORRECTIONS INTO SATELLITE FILES
C     AND FILL BUFFERS ( ISVCLK=2 )
C
      IF ( ISVCLK .EQ. 2 ) THEN
        NSVCLK=0
        WRITE(*,'(/,A40,/)') 'PRE-PROCESSING PRECISE SATELLITE CLOCKS '
c!      WRITE(*,*) (NAMCLK(ID),ID=1,NBDAY)
C
        CALL CLKSORT(LUCOR, NAMCLK, ILUCLK,
     &               LLUCLK, NSVCLK, WSBCOR, PSBCOR, IDSVCLK, LTSVCLK, 
     &               PRDC, IERR, IEND, INTCLK, YAWMODEL, NBDAY, IPC )
C USAGE OF EXTERNAL YAW INFO DISABLED UNTIL FIRM REFERENCE DEFINITION
        YAWMODEL=0
        CALL SABUF1 ( NSVCLK, LLUCLK, LTSVCLK, IEOFSA, 
     &               NBPBUF, IBPBUF, IEPBUF, DSABUF, DSGBUF,
     &               DSPBUF, DSWBUF,
     &               ITMBUF, AMBBUF, YAWBUF, IODBUF )
      END IF
C
C     SORT MRTCA CORRECTIONS INTO SATELLITE FILES
C     AND FILL BUFFERS ( ISVCLK=3 )
C
      IF( ISVCLK .EQ. 3 ) THEN
       NSVCLK=0
       WRITE(*,'(/,A40,/)') 'PRE-PROCESSING MRTCA RECORDS '
c!     WRITE(*,*) (NAMCLK(ID),ID=1,NBDAY)
C
       CALL RTCASORT( LUCOR, NAMCLK, ILUCLK, LLUCLK, NSVCLK,
     &                IDSVCLK, LTRTCA, FRRTCA,
     &                RTCATBUF, RTCABUF, RTCAIBUF,
     &                ENDTTAG,
     &                IERR, IEND, INTCLK, NBDAY, C, IPC )
      END IF
C
C     SORT RTCM-SSR CORRECTIONS INTO SATELLITE FILES
C     AND FILL BUFFERS ( ISVCLK=4 )
C
      IF( ISVCLK .EQ. 4 ) THEN
       NSVCLK=0
       WRITE(*,'(/,A40,/)') 'PRE-PROCESSING RTCM-SSR RECORDS '
c!     WRITE(*,*) (NAMCLK(ID),ID=1,NBDAY)
C
       CALL RTCMSORT( LUCOR, NAMCLK, ILUCLK, LLUCLK, NSVCLK,
     &                IDSVCLK, LTRTCM, FRRTCM, RTCMTBUF,IREFIN,
     &                ENDTTAG, YAWMODEL,
     &                IERR, IEND, INTCLK, NBDAY, C, IPC )
C USAGE OF EXTERNAL YAW INFO DISABLED UNTIL FIRM REFERENCE DEFINITION
       YAWMODEL=0
      END IF
C
C     WRITE SUMMARY OF PROCESSING COMMANDS
C
      CALL SUMCMD( LPR, LUSES, STNA, IYEARS, IMTHS, IDAYS,
     &             IMODE, NOBTYP, IFREQ, ISVEPH, ISVCLK, IFITCLK, 
     &             IONSLM, ISLMFMT, IMFSEL, IPOSSOL, NTRPSOL,
     &             NDIR, IREFOUT, ICOROUT, SDPR, SDCP, ANTH(1),
     &             PLHMRK,XRVVEL, MISCFACTR, MISCFACTP,
     &             INTCLK, CUTOFF, IPCV, SMTHCLK, LNG )
C
C     CONVERT INITIAL COORDINATES FROM THE USER OUTPUT REFERENCE
C     INTO THE REFERENCE OF THE PRECISE EPHEMERIS
C
      IF ( IREFIN .NE. IREFOUT ) THEN
        CALL TOREF (XRVMRK, XRVOUT, IREFOUT, IREFIN, TRFPAR, EPOCH )
        DO I=1,3
          XRVMRK(I)=XRVOUT(I)
          XRVINI(I)=XRVOUT(I)
        END DO
        CALL XYZPL2 (DTM(3),DTM(4),DTM(5),DTM(1),DTM(2),
     &                 XRVMRK(1),XRVMRK(2),XRVMRK(3),
     &                 PLHMRK(1),PLHMRK(2),PLHMRK(3))
      END IF
C
C----------------------------------------------------------------------
C     READ SINGLE LAYER MODEL AND STORE IN GRID
C----------------------------------------------------------------------
C
      IF ( IONSLM .GE. 2 ) THEN
        IF( IPC .GE. 1 ) WRITE(*,'(/,A60,/)') 
     &             '*** GPSPPP - READING IONOSPHERIC COEFFICIENTS '
        OPEN  ( LUION, FILE=NAMION(NDAY), STATUS='OLD',IOSTAT=IOS, 
     &            ERR=600 )       
        IF( ISLMFMT .EQ. 2 ) THEN
          CALL RDEPH  (LPR,LUION,1,NEPSV,IEPSV,NEPTIM,EPHTIM,
     &                 EPHTBL, AIONBRD, BIONBRD, ISRCH) 
          DO I=1,NEPSV
          TGD(IEPSV(I)) = EPHTBL(6,I,1)*C
c!        WRITE(*,*) I,IEPSV(I),TGD(IEPSV(I))
          END DO
        ELSE IF( ISLMFMT .EQ. 4 .OR. ISLMFMT .EQ. 5 ) THEN
          IF( ISLMFMT .EQ. 4 ) THEN
            IF( SCHACOEFHEAD( LUION, SCHA_ORD, SCHA_CLAT, SCHA_CLON, 
     &              SCHA_CAP, SLMHGT, SCHA_CNT, SCHA_INT, SCHA_DCB )
     &              .LT. 0 ) WRITE(*,'(/,A60,/)') 
     &           '*** ERROR - READING SPHERICAL CAP HARM.COEFFICIENTS '
          ELSE
            IF( SHCOEFHEAD( LUION, SCHA_DEG, SCHA_ORD, SCHA_CNT,
     &                      SCHA_INT, SLMHGT, SCHA_DCB, SCHA_REF )
     &                                                          .LT. 0 )
     &        WRITE(*,'(/,A60,/)') 
     &           '*** ERROR - READING GLOBAL SPH. HARM.COEFFICIENTS '
          ENDIF
          SLMGPS=.FALSE.
          SLMGLN=.FALSE.
          DO I=1,32
                SLMGPS=SLMGPS.OR.SCHA_DCB(I).NE.-999.D0
          END DO
          DO I=33,56
                SLMGLN=SLMGLN.OR.SCHA_DCB(I).NE.-999.D0
          END DO
          IF(.NOT.SLMGPS) THEN
            DO I=1,32
               IF(DABS(DP1P2(I)).LT.300.D0) SCHA_DCB(I)=DP1P2(I)
            END DO
          ELSE
            DO I=1,32
               IF(DABS(SCHA_DCB(I)).LT.300.D0) DP1P2(I)=SCHA_DCB(I)
            END DO
          ENDIF
          IF(.NOT.SLMGLN) THEN
             DO I=33,56
               IF(DABS(DP1P2(I)).LT.300.D0) SCHA_DCB(I)=DP1P2(I)
             END DO
          ELSE
            DO I=33,56
               IF(DABS(SCHA_DCB(I)).LT.300.D0) DP1P2(I)=SCHA_DCB(I)
            END DO
          ENDIF
        ELSE IF( ISLMFMT .EQ. 6 ) THEN
            DO I=1,56
               IF(DABS(DP1P2(I)).LT.300.D0) SCHA_DCB(I)=DP1P2(I)
            END DO
        ENDIF
      END IF
C
c!     write(*,*) 'TEMP, PRES, RH', TEMP, PRES, RH, DRYEPO,WETEPO
C       
C
C----------------------------------------------------------------------
C     READ EPHEMERIS AND STORE IN TABLE
C----------------------------------------------------------------------
C
      NEPSV = 0
      IF ( ISVEPH .NE. 2 ) THEN
c!      WRITE(*,*) 'READING EPHEMERIS  '
        CALL RDEPH  (LPR,LUEPH,IFMTE,NEPSV,IEPSV,NEPTIM,EPHTIM,EPHTBL,
     &               AIONBRD, BIONBRD, ISRCH)
c!      WRITE(*,*) 'AFTER READING EPHEMERIS  '
        REWIND (LUEPH)
C
C MRTCA: load ephemeris from MRTCA T28
C
        IF( ISVCLK .EQ. 3 ) THEN
         OPEN(LUCOR,FILE=NAMCLK(1),STATUS='OLD')
         CALL RTCAEPH( LPR, LUCOR, NEPSV, IEPSV,
     &                 NEPTIM, EPHTIM, EPHTBL, ISRCH)
         CLOSE(LUCOR)
        END IF
C
C MRTCA: load ephemeris from RTCM-SSR T1019
C
        IF( ISVCLK .EQ. 4 ) THEN
         OPEN(LUCOR,FILE=NAMCLK(1),STATUS='OLD')
         CALL RTCMEPH( LPR, LUCOR, NEPSV, IEPSV,
     &                 NEPTIM, EPHTIM, EPHTBL, ISRCH)
         CLOSE(LUCOR)
        END IF
      END IF
C
C     STORE BROADCAST SATELLITE HEALTH 
C     AND PRINT OUT EPHEMERIS SUMMARY
C
      IF ( IPC .GT. 2 .AND. ISVEPH .NE. 2 ) THEN
       WRITE(LPR,800)
       DO IS=1,NEPSV
        WRITE (LPR,*)
        DO IE=1,NEPTIM(IS)
          SMA    = EPHTBL(19,IS,IE)**2
          PERIOD = DSQRT (4.D0*(PI**2)*(SMA**3)/3.986D14)
          CALL TOWHMS( IWKDAY, EPHTIM(IS,IE), IHR, IMIN, SEC, 0 )
          CALL TOWHMS( IPDAY, PERIOD, IPHR, IPMIN, PSEC, 0 )
          WRITE (LPR,820) IEPSV(IS),IE,INT(EPHTBL(5,IS,IE)),
     &                      INT(EPHTBL(7,IS,IE)),
     &                      IHR,IMIN,SEC, EPHTBL(11,IS,IE)*1.D9,
     &                      EPHTBL(10,IS,IE)*3.6D12, IPHR, IPMIN,
     &                      PSEC
        END DO
       END DO
       WRITE (LPR,'(/)')
      END IF
C
      IF ( ISVEPH .NE. 2 )
     &   CALL CHKCLK (LPR,NEPSV,IEPSV,NEPTIM,EPHTIM,EPHTBL,EPHCLK)
C
C     FIT POLYNOMIALS TO BROADCAST/PRECISE SATELLITE COORDINATES
C
C      IF ( ISVEPH .EQ. 2 ) THEN
      WRITE(*,'(/,1X,A30,6I5,/)') 'SORTING EPHEMERIS FILE',
     &                IPC, MAXSAT, MAXARC, MAXDEG,MAXKEP, MAXEPH 
      CALL FITEPH (LUI, LUO, LPR, LUEPH, NAMEPH, NDAY,
     &             IPC, ISVEPH, C, DTM, XRVMRK, 
     &             NEPSV, IEPSV, NEPTIM, EPHTIM, EPHTBL, IBEFIT, 
     &             NPEPSV, IPEPSV, IPEPACC, NPARC, NPDEG, IPEFIT, 
     &             PTB,  PTE, PCX, PCY, PCZ, PDT, ENDTTAG, IULTRA,
     &             IMINACC, IPEPINT, SSVX)
C
      CALL INEPH (EPHSAT,NEPSV,IEPSV,IEPTIM,NEPTIM,EPHTBL)
C
C-----------------------------------------------------------------------
C     UPDATE EXCENTRICITY WITH PHASE CENTER OFFSETS AND COMPUTE IN XYZ
C-----------------------------------------------------------------------
C
      DO I=1,4
        ANTN(I) = 0.D0
        ANTE(I) = 0.D0
        IF(I.GT.1) ANTH(I) = ANTH(1)
      END DO
C
C     OVERRIDE ANT's WITH PCV VALUES IF THE PCV TABLE FOUND (IPCV>=1)
C
      IF(IPCV.GE.1) THEN
C USE PRN=1 - IE GPS/GLN FQCY FOR ANT OFFSET 
        DO I=1,4
          CALL ANTPCV (IFREQ, 1, PCVNEU(1,I), ANTN(I), ANTE(I), ANTH(I))
        END DO
      END IF
C
      CALL ANTEX ( DTM, PLHMRK(1), PLHMRK(2), PLHMRK(3),
     &             ANTN(1), ANTE(1), ANTH(1), ANTX )
C
C-----------------------------------------------------------------------
C     ASSIGN P MATRIX VALUES ( OBSERVATION WEIGHTS ) AND
C     PX MATRIX (APRIORI STATION POSITION COV MATRIX)
C-----------------------------------------------------------------------
C
      IF (IPXR .EQ. 0) THEN
        DO I=1,MAXPAR2
          DO J=1,MAXPAR2
            PX(I,J)=0.0D0
          END DO
        END DO
C
C check if vmf par available to constrain the ini tropo to 1 cm
C
        CALL INIPX ( LPR, NPAR, IPOSSOL, ICLKSOL,  
     &               ITRPSOL, IOBTYP, SDPR, SDCP,
     &               NFPAR, PL, PX, OPX, C, IPX, IMODE )
c!      WRITE(*,*) ' SQRT OF DIAGONAL OF MATRIX PX, AFTER INIPX '
c!      WRITE(*,'(15F5.3)') (DSQRT(1.D0/PX(I,I)),I=1,MAXPAR2)
C
        IF (IPC .GE. 3) THEN
          WRITE(*,*) ' MATRIX PX IN GPSPPP AFTER INIPX', IPX
          WRITE(*,'(15E15.3)') (PX(I,I),I=1,NPAR)
        END IF
C
C-----------------------------------------------------------------------
C         APPLY ANTENNA OFFSET TO GET PHASE CENTER COORDINATES
C-----------------------------------------------------------------------
C
C
        DO I=1,3
          XRVAPC(I) = XRVMRK(I) + ANTX(I)
          XRVEPO(I) = XRVAPC(I)
          XRVAPR(I) = XRVAPC(I)
        END DO
      END IF
C
C     CONVERT ANTENNA COORDINATES (CARTESIAN->ELLIPSOIDAL)
C
      CALL XYZPL2 (DTM(3),DTM(4),DTM(5),DTM(1),DTM(2),XRVEPO(1),
     &             XRVEPO(2),XRVEPO(3),PLHEPO(1),PLHEPO(2),PLHEPO(3))
C
      XRVAPR(4)    = XRVEPO(4)
      XRVAPR(8)    = XRVEPO(8)
      XRVAPR(9)    = XRVEPO(9)
      XRVAPR(10)    = XRVEPO(10)
      DRYEPO=0.d0
      IF( PLHEPO(3).GT.-30.0.AND. PLHEPO(3).LT.100000.0)
     &CALL TROPO ( 2, TEMP, PRES, RH, PI/2.D0, DRYEPO, WETEPO,
     &             DRYM, WETM, TROZEN, PLHEPO, XRVEPO )
      IF( IPXR .EQ. 1 ) THEN
       XRVAPR(5)= XRVAPR(5)-DRYEPO
       XRVEPO(5)= XRVEPO(5)-DRYEPO
      ENDIF
C
C---------------------------------------------------------------------
C      DETERMINE PARAMETER UPDATE INTERVAL AND SAVE
C      LIST OF SATELLITES UPDATED AT LAST EPOCH
C---------------------------------------------------------------------
C
      INTOBS=0
      UPDINT= OBSINT
      FLTINT= OBSINT
C  FOR NO CLKS SET UPDINT TO SP3 PEP INT
      IF(ISVCLK.EQ.1) INTCLK = IPEPINT
C
C USE LEAST COMMON MULTIPLE OF CLK AND OBS INTERVALS
C PERFORM COMPUTATION IN MS
C
      IF ( ISVCLK .GE. 1 .AND. IFITCLK .EQ. 1 ) THEN
       INTOBS=OBSINT*1000
        MXINT=MAX(1000*INTCLK,INTOBS)
        MNINT=MIN(1000*INTCLK,INTOBS)
 88     CONTINUE
        GCD=MOD(MXINT,MNINT)
        IF(GCD.NE.0) THEN
          MXINT=MNINT
          MNINT=GCD
          GOTO 88
        ENDIF
        GCD=MNINT
        UPDINT=(MIN(1000*INTCLK,INTOBS)/1000.)*
     &         (MAX(1000*INTCLK,INTOBS)/GCD)
      write(*,*) 
     & (MIN(1000*INTCLK,INTOBS)/1000.),(MAX(1000*INTCLK,INTOBS)/GCD),
     & (MIN(1000*INTCLK,INTOBS)/1000.)*(MAX(1000*INTCLK,INTOBS)/GCD),
     & UPDINT
        IF( ISVCLK .EQ. 4 ) FLTINT=UPDINT
      ENDIF
C
 89   CONTINUE
C
C     FIX STATION POSITION IN STATIC BACKwARD RUN
C
      IF ( IDIR .LT. 0 ) THEN
        SD=1.D-6
        DO I=1,MAXPAR2-1
C RELAX FIXED AMBS FOR BWD
          IF(PX(I,I).LE. SD**2*1.D8) PX(I,I)=SD**2*1.D8
          DO J=I+1,MAXPAR2
            PX(I,J)=0.D0
            PX(J,I)=0.D0
          END DO
        END DO
        DO I=1,3
          PX(I,I)=SD**2
        END DO
        IF( ITRPSOL .LT. 100 ) THEN
         PX(6,6)=SD**2*1.D-10
         PX(7,7)=SD**2*1.D-10
        ELSE
         PX(6,6)=SD**2*1.D 4 
         PX(7,7)=SD**2*1.D 4 
        END IF
      END IF
      NFIX = 0
      NEPFIX = 0
C
      DO I=1,3
        XRVSUM(I) = 0.D0
        PLHSUM(I) = 0.D0
        XRVAVG(I) = 0.D0
        PLHAVG(I) = 0.D0
      END DO
      DO I=1,MAXSAT
        IAMB(I) = 1
        LCSLIP(I)=0
        IAOD15(I) = 0
        IARC(I) = 0
        DO J=1,MAXARC
          NRC(I,J) = 0
          NRCFX(I,J) = 0
          NRCDF(I,J) = 0
          RCAVG(I,J) = 0.D0
          RCSIG(I,J) = 0.D0
          RCRMS(I,J) = 0.D0
C zero sum of carrier phase
          NCPDF(I,J) = 0
          CPAVG(I,J) = 0.D0
          CPSIG(I,J) = 0.D0
          CPRMS(I,J) = 0.D0
          STIME(I,J) = 0.D0
          ETIME(I,J) = 0.D0
          DO K=1,MAXREJ
            NRCRJCT(I,J,K)=0
            CNTSLIP(I,J,K)=0
          END DO
        END DO
        CNTFIX(I)=0
C
C       INITIALIZE FILTER AND OBSERVATION BUFFERS ONLY
C       IF IPXR=0 (NO INITIAL PX READ) OR IDIR<0 (BACKWARD PASS)
C
        IF ( IPXR .EQ. 0 .OR. IDIR .LT. 0 ) THEN
       FLTSUM(10,I)=0.D0
       FLTSUM(9, I)=0.D0
       FLTSUM(13,I )= 0.D0
       DO J=1,NSVO 
        IF(I.EQ.ISVO(J))THEN
          FLTSUM(13,I)=FCP(J)*C
          FLTSUM( 8,I)=FCP(J)*C
        END IF
       END DO
       IF(FLTSUM(13,I).EQ.0.D0) THEN
        IF(FLTSUM(1,I).GT.0.D0)
     &  FLTSUM(MAXFLT,I)= FLTSUM(MAXFLT,I)/FLTSUM(1,I)
        DO J=1,MAXFLT-1
        FLTSUM(J,I)=0.D0
        END DO
       END IF
          DO J=1,6
           OBSBUF(J,I)=0.D0
          END DO
        END IF
      END DO
C     CLOCK UPDATE
      NCLKFIT=0
      RNCLKFIT=0
      ENCLKFIT=0
      DENCLKFIT=0
      CNCLKFIT=0
      DCNCLKFIT=0
      DNCLKFIT=0
      NCLKUP=0
      DO I=1,8
       SUMLR(I,1)=0.D0
       SUMLR(I,2)=0.D0
       SUMLR(I,3)=0.D0
       SUMLR(I,4)=0.D0
       SUMLR(I,5)=0.D0
       SUMLR(I,6)=0.D0
       SUMLR(I,7)=0.D0
      END DO
      NEPOCHDEL=0
C
C---------------------------------------------------------------------
C     UPDATE EPOCH ELLIPSOIDAL COORDINATES AND SATELLITE LIST
C---------------------------------------------------------------------
C
   90 CONTINUE
C DO NOT RESET FOR NO SOLUTION, KEEP PREVIOUS EPOCH!
      IF((ITER.LE.MAXIT.OR.NSVOL.EQ.0).AND.UPDEPO) THEN
        CALL XYZPL2 (DTM(3),DTM(4),DTM(5),DTM(1),DTM(2),XRVEPO(1),
     &               XRVEPO(2),XRVEPO(3),PLHEPO(1),PLHEPO(2),PLHEPO(3))
C
        CALL LASTSV ( NSVO, ISVO, NSVOL, ISVOL ) 
      ENDIF
      ITER=0
C
C---------------------------------------------------------------------
C     READ NEXT OBSERVATION EPOCH
C---------------------------------------------------------------------
C
   91 CONTINUE
C DO NOT REDO AR ATTEMPTS WHEN REPROCESSING CURRENT EPOCH
      ISARDONE= .FALSE.
      ISVFX=0
      CALL RDEPO ( LUMEA, LPR, FIRSTM, MEAREC, NOBREC, IOBPOS,
     &             OBSINT, IGPSWK,PMTTAG-ICORRTT*.001D0, TTAG, 
     &             NSVO, ISVO, IGF, DP1C1, DP2C2,
     &    PR1, PR2, P1, P2, CR1, CR2, RIFRATE, C, AL1, AL2, IDIR,
     &        ISVRJCT, NSVRJCT, IERR, IEOF, ISPR1, ISPR2,
     &        IC1USE, IC2USE, IDCBUSE, IFREQ)
c!     WRITE(*,*) 'after rdepo',IEOF,NSVO,IDIR,TTAG(1),ENDTTAG
c!     write(*,*) (i,isvo(i), pr1(i)*c,cr1(i)*c,DP1C1(ISVO(I)),i=1,nsvo)
      IF ( IEOF .EQ. 1 ) GO TO 500
      IF ( NSVO .EQ. 0 ) GO TO 91
C
C     FORM UNAMBIGUOUS TIME TAG
C
      CALL TOWHMS( IWKDAY, TTAG(1), IHR, IMIN, SEC, 0 )
      CALL GPSDC ( JULD,IYEAR,IMTH,IDAY,IGPSWK,IWKDAY, 4 )
      UTTAG=IGPSWK*604800.D0+TTAG(1)
      IF(UTTAG.LT.STRTTAG-0.003D0) GO TO 500
      IF(DABS(UTTAG-PMTTAG).GT.(OBSINT+1.1D0).AND.PMTTAG.NE.0.D0) 
     &  WRITE(*,*) 'TIME GAP'
      IF( IMODE .EQ. 1 .OR. XRVACC3D .NE. 0.D0 ) THEN
        PRDPOSQLT=XRVACC3D*(UTTAG-PTTAG)**2
      ELSE
        PRDPOSQLT=9*SDPR
      END IF
C ACCOUNT FOR VELOCITY
      IF(PMTTAG.GT.0.D0) THEN
         DO I=1,3
          XRVEPO(I)=XRVEPO(I)+XRVVEL(I)*(UTTAG-PMTTAG)
         END DO
      END IF
      PMTTAG=UTTAG
C
C RESET AMBIGUITY FOR ANY SATELLITE DEWEIGHTED FOR PREVIOUS SOLUTION
C
      IF( IOBTYP.EQ.2 ) THEN
        DO I=1,NSVOL
          IF( PL(IOBTYP*I,IOBTYP*I)*SDCP**2 .LT. 1.D-20 )
     &      ICSLIP15(ISVOL(I))=1
        END DO
      ENDIF
C
      WRITE(*,900) IYEAR,IMTH,IDAY,IHR,IMIN,SEC,
     &               (ISVO(I),I=1,NSVO)
C
C     SAVE SATELLITE ARC START AND END TIMES
C
      DO I=1,NSVO
        CALL SVTIME(IDIR,ISVO(I),IARC(ISVO(I)),UTTAG,STIME,ETIME)
C
C RESTORE OBSERVATION WEIGHTS
C
        PL(IOBTYP*(I-1)+1,IOBTYP*(I-1)+1) = 1.D0/SDPR/SDPR
        IF( IOBTYP .EQ.2 )
     &    PL(IOBTYP*I,IOBTYP*I) = 1.D0/SDCP/SDCP
      END DO
C
C     IF PRECISE SATELLITE CLOCKS AND NO INTERPOLATION
C     UPDATE EPOCH PARAMETERS IF SATELLITE CLOCKS AVAILABLE
C
      UPDEPO=.TRUE.
C
c!    WRITE(*,900) IYEAR,IMTH,IDAY,IHR,IMIN,SEC,
c!   &              (IGF(ISVO(I)),I=1,NSVO)
C
C     REJECT NON-GPS SATELLITES
C
C      
C     FORCE THE SAME SV's FOR BWD RUN
C
      IF(IDIR.EQ.-1.AND.UTTAG.EQ.ENDTTAG.AND.NSVOL.GT.0) THEN
        NSVRJCT=0
        DO I=1,NSVO
          DO J =1,NSVOL
            IF (ISVO(I).EQ.ISVOL( J) ) GO TO 92
          END DO
          NSVRJCT=NSVRJCT+1
          ISVRJCT(NSVRJCT)=ISVO(I)
92        CONTINUE
        END DO
        IF ( NSVRJCT .NE. 0 ) THEN
          IREASON=1
          CALL VPCREJ ( LPR, NSVRJCT, ISVRJCT, NSVO, ISVO, TTAG,
     &                PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                FCP, ICSLIP,
     &                ISPR1, ISPR2,
     &                MSOFF, MSJMP, NRCRJCT, IARC, IPC, IREASON, 
     &                MAXSAT, MAXARC )
          NSVRJCT=0
        END IF
        IF( NSVO .EQ. 0 ) THEN
          NEPOCHDEL=NEPOCHDEL+1
          GO TO 91
        END IF
      END IF
C
C     DETECT 1 MS CLOCK JUMPS IN TIME TAG OR OBSERVATIONS
C     AND UPDATE RECEIVER CLOCK OFFSET
C
c!    WRITE(*,*) 'CALLING CLKJMP - IOBTYP', IOBTYP
      IF( NSVO .GT. 0 ) THEN
       CALL CLKJMP (LPR, NSVO, ISVO, IFREQ, IOBTYP, IDIR, OBSINT,   
     &              C, TTAG   , PR1, PR2, P1, P2, OBSBUF, 
     &              IGPSWK,
     &              NMSOFF, NMSJMP, NMSCPJ, NMSCLJ, CLKOFF,
     &              ICORRTT, ICORRPR, ICORRCP )
C
C Apply time ms correction and clock jumps
C
       IF( ICORRTT .NE. ICORRTTP .OR. ICORRPR .NE. ICORRPRP .OR.
     &    ICORRCP .NE. ICORRCPP ) THEN
        ICORRTTP=ICORRTT
        ICORRPRP=ICORRPR
        ICORRCPP=ICORRCP
        IF (NDATJMP .LT. MAXRES) THEN 
          NDATJMP=NDATJMP+1
              WRITE(DATJMP(NDATJMP),1211)  DIR((1-IDIR)/2+1),
     &      IYEAR,IMTH,IDAY,IHR,IMIN,INT(SEC),INT((SEC-INT(SEC))*1.D3),
     &      ICORRTT, ICORRPR, ICORRCP
        END IF
       END IF
      END IF
      UTTAG=UTTAG+ICORRTT*.001D0
      PMTTAG=PMTTAG+ICORRTT*.001D0
      IF ( ISVCLK .GE. 1 .AND. IFITCLK .EQ. 1 ) THEN        
        DTTAG=(UTTAG/UPDINT - IDNINT(UTTAG/UPDINT))*UPDINT
        IF ( DABS(DTTAG) .GT. 0.1D0 ) UPDEPO=.FALSE.
      END IF
      IF(IDIR.EQ.-1.AND.UPDEPO.AND.
     &   INIEPOCHDEL.GT.0.AND.UTTAG.LT.STRTTAG-0.003D0) THEN
        NSVRJCT=0
        DO I=1,NSVO
          NSVRJCT=NSVRJCT+1
          ISVRJCT(NSVRJCT)=ISVO(I)
        END DO
        IF ( NSVRJCT .NE. 0 ) THEN
          IREASON=1
          CALL VPCREJ ( LPR, NSVRJCT, ISVRJCT, NSVO, ISVO, TTAG,
     &                PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                FCP, ICSLIP,
     &                ISPR1, ISPR2,
     &                MSOFF, MSJMP, NRCRJCT, IARC, IPC, IREASON, 
     &                MAXSAT, MAXARC )
        END IF
        NEPOCHDEL=NEPOCHDEL+1
        GO TO 91
      END IF
C
C
C---------------------------------------------------------------------
C     APPLY CORRECTIONS SECTION
C---------------------------------------------------------------------
C
C     READ IONOSPHERIC GRID IF REQUIRED
C
c!     WRITE(*,*) 'IONSLM,ISLMFMT,INIEPO',IONSLM,ISLMFMT,INIEPO
      IF (IONSLM .EQ. 2 .AND. .NOT. INIEPO .AND. UPDEPO ) THEN
       IF( ISLMFMT .EQ. 1 ) THEN
c!        WRITE(*,*) 'DTION,UTTAG,YION',DTION,UTTAG,TION
         DTION=(UTTAG-TION)*IDIR
   94    CONTINUE
         IF (DTION .GE. MAPINT ) THEN
           INXMAP=INXMAP+IDIR
           IF ( INXMAP .EQ. 1 ) THEN
            IF( IPC .GE. 1 ) WRITE(*,'(/,A50,I5,/)') 
     &             '*** GPSPPP - OPENING IONOSPHERIC GRID ',INXMAP
            OPEN  ( LUION,FILE=NAMION(NDAY),STATUS='OLD',IOSTAT=IOS, 
     &                ERR=600 )
           END IF
           CALL RDSSLM ( LUION, LUO, PLHMRK(1), IYGRD, IMGRD, IDGRD,
     &                STNA,
     &                FRLAT, TOLAT, DLAT, FRLON, TOLON, DLON, 
     &                TION, ADION, RDION, 
     &                NRXDCB, LRXDCB, RXDCB, RXDCBS,
     &                NSVDCB, LSVDCB, SVDCB, SVDCBS, 
     &                MININC, SLMHGT, IONREF, ISLMFMT,
     &                PI, INXMAP, MAXMAP, MAPINT, IONBAND, REFLAT, 
     &                IEXP,
     &                       IRC, IDIR )
           IF( SLMHGT .LT. 200.D0 .OR. SLMHGT .GT. 800.D0 )
     &        SLMHGT=HION
           IF ( INXMAP .EQ. 1 ) THEN
             SLMGPS=.FALSE.
             SLMGLN=.FALSE.
             DO I=1,NSVDCB
              IF(DABS(SVDCB(I)).LT.100.D0) THEN
               PRNDCB(LSVDCB(I))=SVDCB(I)
               IF(LSVDCB(I).LE.32) THEN
                 SLMGPS=.TRUE.
               ELSE IF(LSVDCB(I).LE.56) THEN
                 SLMGLN=.TRUE.
               ENDIF
              ENDIF
             END DO
C THE INPUT DCB IS ONLY VALID FOR L3 PROCESSING
             IF( IFREQ .GE. 3 ) THEN
             DO I=1,NRXDCB
               IF( LRXDCB(I) .EQ. STNA(1:4) ) THEN
                 HORDION(1) = RXDCB(I)
                 HORDION(11) = 1.D20
               END IF
             END DO
             END IF
             IF(.NOT.SLMGPS) THEN
              DO I=1,32
               IF(DABS(DP1P2(I)).LT.300.D0) PRNDCB(I)=DP1P2(I)*1.D-9*C 
              END DO
             ELSE
              DO I=1,32
               IF(DABS(PRNDCB(I)).LT.300.D0) DP1P2(I)=PRNDCB(I)*1.D9/C
              END DO
             ENDIF
             IF(.NOT.SLMGLN) THEN
              DO I=33,56
               IF(DABS(DP1P2(I)).LT.300.D0) PRNDCB(I)=DP1P2(I)*1.D-9*C
              END DO
             ELSE
              DO I=33,56
               IF(DABS(PRNDCB(I)).LT.300.D0) DP1P2(I)=PRNDCB(I)*1.D9/C
              END DO
             ENDIF
           END IF
           IF( IPC .GE. 1 ) WRITE(*,'(/,A50,I5,F12.1,/)') 
     &             '*** GPSPPP - READ IONOSPHERIC MAP ',INXMAP,DTION
           DTION=(UTTAG-TION)*IDIR
           IF (INXMAP .LT. MAXMAP ) GO TO 94
         END IF
       ELSE IF (ISLMFMT .EQ. 2 ) THEN
          CALL IONBRD (AIONBRD, BIONBRD, PI/2.0D0,
     &                 0.D0, PLHEPO(1), PLHEPO(2),
     &                 TTAG(1), PI, C, SIONCOR,VIONCOR)
          SLMHGT=350.D0
       ELSE IF( ISLMFMT .EQ. 3 ) THEN
        IF( IPC .GE. 1 ) WRITE(*,'(/,A60,/)') 
     &             '*** GPSPPP - READING MRTCA IONOSPHERIC MESSAGES '
        CALL RTCAIONRD( LUION, IDIR, UTTAG, TION, TIONX,
     &                  TIONINIT(IONDAY), RTCAVERT, RTCAGIVE, IRC )
        IF( ( IDIR .EQ. 1 .AND.
     &        TIONX .EQ. TION .AND. IONDAY .LT. NBDAY ) .OR.
     &      ( IDIR .EQ. -1 .AND.
     &        TIONX .EQ. -1 .AND. IONDAY .GT. 1 ) ) THEN
         CLOSE(LUION)
         IONDAY=IONDAY+IDIR
         OPEN(LUION,FILE=NAMION(IONDAY),STATUS='OLD',ERR=600)
         CALL RTCAIONRD( LUION, IDIR, UTTAG, TION, TIONX,
     &                   TIONINIT(IONDAY), RTCAVERT, RTCAGIVE, IRC )
            SLMHGT=350.D0
        END IF
       ELSE IF( ISLMFMT .EQ. 6 ) THEN
        IF( IPC .GE. 1 ) WRITE(*,'(/,A60,/)')
     &             '*** GPSPPP - READING RTCM-SSR IONOSPHERIC MESSAGES '
        CALL RTCMIONRD( LUION,IDIR,UTTAG,TION,TIONX,TIONINIT(IONDAY),
     &                  TION_END(IONDAY), SLMHGT, SCHA_INT, SCHA_NSET,
     &                  SCHA_DEG, SCHA_ORD, SCHA_REF, SCHA_T, SCHA_L,
     &                  SCHA_M, SCHA_NMN, SCHA_ALM, SCHA_BLM, SCHA_DLM )

        IF( ( IDIR .EQ. 1 .AND.  TION_END(IONDAY) .GT. 0 .AND.
     &        UTTAG .GT. TION_END(IONDAY) .AND. IONDAY .LT. NBDAY ) .OR.
     &      ( IDIR .EQ. -1 .AND.
     &        TIONX .EQ. -1 .AND. IONDAY .GT. 1 ) ) THEN
         CLOSE(LUION)
         IONDAY=IONDAY+IDIR
         OPEN(LUION,FILE=NAMION(IONDAY),STATUS='OLD',ERR=600)
         CALL RTCMIONRD( LUION,IDIR,UTTAG,TION,TIONX,TIONINIT(IONDAY),
     &                  TION_END(IONDAY), SLMHGT, SCHA_INT, SCHA_NSET,
     &                  SCHA_DEG, SCHA_ORD, SCHA_REF, SCHA_T, SCHA_L,
     &                  SCHA_M, SCHA_NMN, SCHA_ALM, SCHA_BLM, SCHA_DLM )
        END IF
       ELSE IF( ISLMFMT .EQ. 4 .OR. ISLMFMT .EQ. 5 ) THEN
         IF( (IDIR .EQ.  1 .AND. UTTAG .GT.
     &                           SCHA_T(2)+SCHA_INT/2.D0) .OR.
     &       (IDIR .EQ. -1 .AND. UTTAG .LT.
     &                           SCHA_T(1)-SCHA_INT/2.D0) ) THEN
           IF( IPC .GE. 1 ) WRITE(*,'(/,A60,/)') 
     &           '*** GPSPPP - READING SPHERICAL HARM.COEFFICIENTS '
           SCHA_NSET=2
           IF( ISLMFMT .EQ. 4 ) THEN
           CALL SCHACOEFBUF( LUION, IDIR, UTTAG, SCHA_CNT, SCHA_INT,
     &                       SCHA_T, SCHA_L, SCHA_M, SCHA_NMN,
     &                       SCHA_ALM, SCHA_BLM, SCHA_NSET )
           ELSE
           CALL SHCOEFBUF( LUION, IDIR, UTTAG, SCHA_CNT, SCHA_INT,
     &                     SCHA_REF, SCHA_DEG, SCHA_ORD, SCHA_T,
     &                     SCHA_L, SCHA_M, SCHA_NMN, SCHA_ALM,
     &                     SCHA_BLM, SCHA_DLM, SCHA_NSET )
           ENDIF
           IF( SCHA_NSET .LT. 2 .AND.
     &        ( ( IDIR .EQ. 1 .AND. IONDAY .LT. NBDAY ) .OR.
     &          ( IDIR .EQ. -1 .AND. IONDAY .GT. 1 ) ) ) THEN
            IONDAY=IONDAY+IDIR
            CLOSE(LUION)
            OPEN(LUION,FILE=NAMION(IONDAY),STATUS='OLD',ERR=600)
            IF( ISLMFMT .EQ. 4 ) THEN
            IF( SCHACOEFHEAD( LUION, SCHA_ORD, SCHA_CLAT, SCHA_CLON, 
     &              SCHA_CAP, SLMHGT, SCHA_CNT, SCHA_INT, SCHA_DCB )
     &              .LT. 0 ) WRITE(*,'(/,A60,/)') 
     &           '*** ERROR - READING SPHERICAL CAP HARM.COEFFICIENTS '
            ELSE
            IF( SHCOEFHEAD( LUION, SCHA_DEG, SCHA_ORD, SCHA_CNT,
     &                      SCHA_INT, SLMHGT, SCHA_DCB, SCHA_REF ).LT.
     &                                                               0 )
     &        WRITE(*,'(/,A60,/)') 
     &           '*** ERROR - READING GLOBAL SPH. HARM.COEFFICIENTS '
            ENDIF
            SLMGPS=.FALSE.
            SLMGLN=.FALSE.
            DO I=1,32
                SLMGPS=SLMGPS.OR.SCHA_DCB(I).NE.-999.D0
            END DO
            DO I=33,56
                SLMGLN=SLMGLN.OR.SCHA_DCB(I).NE.-999.D0
            END DO
            IF(.NOT.SLMGPS) THEN
             DO I=1,32
               IF(DABS(DP1P2(I)).LT.300.D0) SCHA_DCB(I)=DP1P2(I)
             END DO
            ELSE
             DO I=1,32
               IF(DABS(SCHA_DCB(I)).LT.300.D0) DP1P2(I)=SCHA_DCB(I)
             END DO
            ENDIF
            IF(.NOT.SLMGLN) THEN
             DO I=33,56
               IF(DABS(DP1P2(I)).LT.300.D0) SCHA_DCB(I)=DP1P2(I)
             END DO
            ELSE
             DO I=33,56
               IF(DABS(SCHA_DCB(I)).LT.300.D0) DP1P2(I)=SCHA_DCB(I)
             END DO
            ENDIF
            IF( ISLMFMT .EQ. 4 ) THEN
            CALL SCHACOEFBUF( LUION, IDIR, UTTAG, SCHA_CNT, SCHA_INT,
     &                        SCHA_T, SCHA_L, SCHA_M, SCHA_NMN,
     &                        SCHA_ALM, SCHA_BLM, SCHA_NSET )
           ELSE
            CALL SHCOEFBUF( LUION, IDIR, UTTAG, SCHA_CNT, SCHA_INT,
     &                      SCHA_REF, SCHA_DEG, SCHA_ORD, SCHA_T,
     &                      SCHA_L, SCHA_M, SCHA_NMN, SCHA_ALM,
     &                      SCHA_BLM, SCHA_DLM, SCHA_NSET )
           ENDIF
           ENDIF
         END IF
       END IF
      END IF
C
C     READ DIFFERENTIAL CORRECTIONS ( ISVCLK=2 )
C
      IF ( ISVCLK .GE. 2 .AND. ISVCLK .LE. 4 ) THEN
        IF( ISVCLK .EQ. 2 )
     &   CALL SAFIT2 ( LPR, NSVCLK, IDSVCLK, LLUCLK, LTSVCLK, IEOFSA, 
     & NBPBUF, IBPBUF, IEPBUF, DSABUF, DSGBUF, DSPBUF,DSWBUF, ITMBUF,
     &               AMBBUF, YAWBUF, CLKAMB,
     &               IODBUF, NSVO, ISVO, IGPSWK, TTAG, PRDC, AVCLK,
     &               IODC, NSVRJSV, ISVRJSV, C, IDIR, INTCLK, IFITCLK ,
     &               IBLK)
C
C     READ MRTCA DIFFERENTIAL CORRECTIONS ( ISVCLK=3 )
C
        IF( ISVCLK .EQ. 3 )
     &   CALL RTCASLCT ( LPR, NSVCLK, IDSVCLK, LLUCLK, IEOFSA,
     &               FRRTCA, LTRTCA, RTCATBUF, RTCABUF, RTCAIBUF, 
     &               NSVO, ISVO, IGPSWK, TTAG, PRDC, DORBC,
     &               IODC, NSVRJSV, ISVRJSV, C, IDIR, INTCLK,
     &               IFITCLK )
C
C     READ RTCM-SSR DIFFERENTIAL CORRECTIONS ( ISVCLK=4 )
C
        IF( ISVCLK .EQ. 4 ) THEN
         CALL RTCMSLCT ( LPR, NSVCLK, IDSVCLK, LLUCLK, IEOFSA,
     &               FRRTCM, LTRTCM, RTCMTBUF, RTCMBUF, RTCMIBUF, 
     &               RTCMBFLG, RTCMBBUF,
     &               RTCMPFLG, RTCMPBUF,
     &               RTCMCLKAMB, RTCMCLKBUF,
     &               NSVO, ISVO, IGPSWK, TTAG, PRDC, DORBC,
     &               IODC, CLKAMB, NSVRJSV, ISVRJSV, C,
     &               IDIR, INTCLK )
         DO I=1,NSVO
C SEPARATING RTCM DCB's FROM DCM CORRECTIONS
C USING RTCM C[12]P[12] DCB'S, IF REQUESTED
C THIS ASSUMES RTCM IS P1&P2 BASED
          IF( IDCBUSE.GT.1 .AND. .NOT. ISPR1(I) )
     &      PR1(I) = PR1(I)+(PRDC(3,I)-PRDC(4,I))/C-DP1C1(ISVO(I))/1.D9
          IF( IDCBUSE.GT.1 .AND. .NOT. ISPR2(I) )
     &      PR2(I) = PR2(I)+(PRDC(5,I)-PRDC(6,I))/C-DP2C2(ISVO(I))/1.D9
          PRDC(3,I)=PRDC(4,I)
          PRDC(5,I)=PRDC(6,I)
         END DO
        END IF
      END IF
C
C RE-INITIALIZE THE EPOCH VTEC&STADCB NORMALS ELEMENTS
C
C
C     FILTER OBSERVATIONS (SINGLE OR DUAL FREQUENCY)
C
      PN=0.D0
      NSVRJCT=0
      IFLTOP=3
      IF(IPC.GE.1) THEN
       write(*,'(15i8)')(isvol(ia), ia=1,nsvol)
       write(*,'(15f8.2)')(sqrt(px(ia,ia)),ia= nfpar+1,npar)
      IF(IPC.GT.1) THEN
       do ia= nfpar+1,npar
        if(ia.eq.nfpar+1)
     &write(*,'(15f8.2)')sqrt(px(ia,ia)),(PX(ia,il)/sqrt(px(ia,ia)*px(il       
     &  ,il) ), il= ia   +1,npar)
        if(ia.gt.nfpar+1)
     &write(*,'(15f8.2)')(PX(ia,il)/sqrt(px(ia,ia)*px(il,il)),il=nfpar+1        
     &   ,ia-1),      sqrt(px(ia,ia)),(PX(ia,il)/sqrt(px(ia,ia)*px(il       
     &   ,il) ),il=ia +1,npar)
        end do
       ENDIF
       ENDIF
      DO I=1,NSVO
        CALL FREQ12(ISVO(I), F1, F2, F1S, F2S, F12S, F1ION, F2ION,
     &                   AL1, AL2, AL3, AL4, IFREQ )
        IRJCT=0
         K=MAXOBS
         EL(K)=0.D0
         ia=0
         do j=1,nsvol
          if(isvo(i).eq.isvol(j) ) then
           k =j
           ia =j
          endif
         end do
        IF(IMODE.EQ.1) THEN
         AVGNL=0.0D0
         AVGWL=0.0D0
        ENDIF
        CALL FLTOBS ( IPC, IOBTYP, IFREQ, IDIR, ISVO(I),
     &                UTTAG, PR1(I)*C, PR2(I)*C, CR1(I)*C, 
     &                P1(I), P2(I), SDPR, PN, FLTSUM(1,ISVO(I)), 
     &                FLTPAR(1), FLTPAR(2), FLTPAR(5), FLTPAR(3), 
     &                LFIXNL, LFIXWL, DMXNLSAV, DMXWLSAV,
     &                IFLTOP, IQLTY, IFLAG, FPR(I), FCP(I), FLTVAR,
     &                IRJCT, ICSLIP(I), FLTINT, IFLTON, eL(k ),
     &                I, AVGNL, AVGWL,
     &                DP1P2(ISVO(I)),
     &                HORDION(1) )
C
C when reprocessing already filtered remember Cslip  
C
C start PR COOR (Wanninger & Beer 2014)                  
       IF(ISVO(I).GT.100.AND.ISVO(I).LE.136.AND.EL(K).NE.0.D0
C GEO (BLK 23 & BLK 27) Excluded below
     &   ) THEN
         PR1(I)= PR1(I) + BEIPR(1, EL(K), IBLK(ISVO(I)))/C
         PR2(I)= PR2(I) + BEIPR(2, EL(K), IBLK(ISVO(I)))/C
         CR1(I)= CR1(I) + BEIPR(1, EL(K), IBLK(ISVO(I)))/C
       ENDIF
        IF (LCSLIP(I) .EQ. 1) THEN
          ICSLIP(I)=1
          IF ( UPDEPO ) LCSLIP(I)=0
        END IF
        IF(DABS(UTTAG-PTTAG).GT. FLTPAR(5).AND.
     &     UTTAG .LE. ENDTTAG .AND.
     &     PTTAG.NE.0.D0.AND.IMODE.GT.1) THEN
C
C  FORCE NEW AMBS FOR KIN SOLUTION GAP!
C
         IF(IFITCLK.EQ.2) THEN
          ICSLIP(I)=1
         ENDIF
        ENDIF
        IF(I.EQ.1.AND.HORDION(10).GT.0.D0) THEN
C APPLY RW OF 0.05 TECU/SQRT(sec)
           CALL SPIN ( HORDION(11),  3,  3, sinel     , J)
           HORDION(19)= HORDION(19)+0.25D0*IDIR*(UTTAG-HORDION(10))
           CALL SPIN ( HORDION(11),  3,  3, sinel     , J)
        ENDIF
C ACCUMULATE THE DCB/VTEC NORMALS  FOR GPS/GLONASS   
C allow only G & R in VTEC comp (For now)
        IF( IFLAG .EQ. 0 .AND.ISVO(I).LE.64.AND.
     &      FLTSUM(1,ISVO(I)) .GT. 1 .AND.
     &     icslip15(ISVO(I)).eq.0.and. EL(K).GT.0.D0 ) THEN
           sinel=1.D0
           suwpr=1.d0
           if( EL(K) .LE. 90.D0 ) then
            sinel= sqrt(DABS(sin(el(K)/57.296d0)))
C GLONASS PR DOWN WEIGHTING BY (1/2)**2
           SUWCP= 1.D0
            IF (ISVO(I).GT.32.AND.ISVO(I).LE.64 )  SUWCP= 0.25D0
            IF(IFREQ.LT.3.AND.UTTAG.GE.ENDTTAG) SUWCP=0.0D0
            suwpr= acos(sqrt(0.87253D0*(1.-sinel**4)))-el(K)/57.296d0
            if(suwpr.le.0.d0) suwpr= 0.01d0
            suwpr= exp(-suwpr**2*1.00d0)
            suwpr=1.
           endif
C
C VTEC MSCL REJECTIONS
      IL= 1
      if(ISVO(I).GT.32.AND.ISVO(I).LE.64 ) IL= 3
      IF(IFREQ.GE.3)
     &HORDION(4) =    FLTSUM(6,ISVO(I))*AL2 - FLTSUM(5,ISVO(I))*AL1 -
     &                FLTSUM(MAXFLT,ISVO(I))/FLTSUM(1,ISVO(I)) -
     &                DP1P2(ISVO(I))*C*1.D-9-HORDION(IL)
     & + HORDION(2)/SQRT(1.-(1.-sinel**4)*0.87253D0)*0.10507D-1*suwpr
      IF(IFREQ.LT.3) THEN
           IF(IFREQ.EQ.1) suwpr=-suwpr*1.5457d0
           IF(IFREQ.EQ.2) suwpr=-suwpr*2.5457d0
         HORDION(4)=             PR1(I)*C-FCP(I)-CPAMB(ISVO(I))+
     &                DP1P2(ISVO(I))*C*1.546D-9-HORDION(IL)
     & + HORDION(2)/SQRT(1.-(1.-sinel**4)*0.87253D0)*0.10507D-1*suwpr
      ENDIF
       IF(ABS(HORDION(4))*sqrt(SUWCP)*SINEL.GT.(4.4D0*sqrt(1.D0+
     &        HORDION(9)/(HORDION(11)+ HORDION(15)))).AND.
     &       (HORDION(11)+HORDION(15)).GT.2.D0) THEN
      write(*,*)'SAT EL dVTEC',isvo(i),el(k), hordion(4),sqrt(hordion(9)
     & /(hordion(11)+ hordion(15))), hordion(11),hordion(15)
        GO TO 50
       END IF
C
           J = 11
C GLONASS DCB NORMALS AT HORDION(15), GPS DCB (11), VTEC (19)
           IF(ISVO(I).GT.32.AND.ISVO(I).LE.64 ) J= 15
           HORDION(J)= HORDION(J)+1.D0*sinel*sinel*SUWCP
           IL= 1
           J= 6
C GLONASS DCB  AT(HORDION( 9) and THE NORMALS TERM AT HORDION(10)
           IF(ISVO(I).GT.32.AND.ISVO(I).LE.64 ) THEN
            IL = 3
            J= 8 
           ENDIF
           IF(IFREQ.GE.3) THEN
            HORDION(7)= HORDION(7)-
     &                ( FLTSUM(6,ISVO(I))*AL2 - FLTSUM(5,ISVO(I))*AL1 -
     &                  FLTSUM(MAXFLT,ISVO(I))/FLTSUM(1,ISVO(I)) -
     &                DP1P2(ISVO(I))*C*1.D-9-HORDION(IL)
     & + HORDION(2)/SQRT(1.-(1.-sinel**4)*0.87253D0)*0.10507D-1*suwpr)/
     &SQRT(1.-(1.-sinel**4)*0.87253D0)*0.10507D-1*suwpr*sinel*sinel
     &   *SUWCP
            HORDION(J)= HORDION(J)+
     &               (FLTSUM(6,ISVO(I))*AL2 - FLTSUM(5,ISVO(I))*AL1 -
     &                FLTSUM(MAXFLT,ISVO(I))/FLTSUM(1,ISVO(I)) -
     &                DP1P2(ISVO(I))*C*1.D-9-HORDION(IL)
     & + HORDION(2)/SQRT(1.-(1.-sinel**4)*0.87253D0)*0.10507D-1*suwpr)
     &   *sinel*sinel*SUWCP
            HORDION(9)= HORDION(9)+
     &               (FLTSUM(6,ISVO(I))*AL2 - FLTSUM(5,ISVO(I))*AL1 -
     &                FLTSUM(MAXFLT,ISVO(I))/FLTSUM(1,ISVO(I)) -
     &                DP1P2(ISVO(I))*C*1.D-9-HORDION(IL)
     & + HORDION(2)/SQRT(1.-(1.-sinel**4)*0.87253D0)*0.10507D-1*suwpr)
     &   **2*sinel*sinel*SUWCP
           ENDIF
C L1/L2 PHASE (IOBS=2)
           IF(IFREQ.LT.3) THEN
            HORDION(J)= HORDION(J)+(PR1(I)*C-FCP(I)-CPAMB(ISVO(I))+
     &                DP1P2(ISVO(I))*C*1.546D-9-HORDION(IL)
     & + HORDION(2)/SQRT(1.-(1.-sinel**4)*0.87253D0)*0.10507D-1*suwpr)
     &   *sinel*sinel*SUWCP
            HORDION(9)= HORDION(9)+(PR1(I)*C-FCP(I)-CPAMB(ISVO(I))+
     &                DP1P2(ISVO(I))*C*1.546D-9-HORDION(IL)
     & + HORDION(2)/SQRT(1.-(1.-sinel**4)*0.87253D0)*0.10507D-1*suwpr)
     &   **2*sinel*sinel*SUWCP
            HORDION(7)= HORDION(7)-(PR1(I)*C-FCP(I)-CPAMB(ISVO(I))+
     &                DP1P2(ISVO(I))*C*1.546D-9-HORDION(IL)
     & + HORDION(2)/SQRT(1.-(1.-sinel**4)*0.87253D0)*0.10507D-1*suwpr)/
     &SQRT(1.-(1.-sinel**4)*0.87253D0)*0.10507D-1*suwpr*sinel*sinel
     & * SUWCP
           ENDIF
C
C USING IONO HGT OF 450 KM FOR SLANT MAPPING (R/(R+H))**2 = 0.87253   
C &  0.1 TECU CONVERSION FACTOR: 40.309D15/(1/F1^2-1/F2^2) =-0.10507D-1
           HORDION(19)= HORDION(19)+1./(1.-(1.-sinel**4)*0.87253D0)*
     &                (0.10507D-1)**2*suwpr*suwpr*sinel*sinel*SUWCP
                      J= 17
           IF(ISVO(I).GT.32.AND.ISVO(I).LE.64 ) J= 18
           HORDION(J)= HORDION(J)-1./SQRT(1.-(1.-sinel**4)*0.87253D0)*
     &                0.10507D-1*suwpr*sinel*sinel*SUWCP
50       CONTINUE
        ENDIF
C Check the mean resid & reset amb if fails
        IF(NCPDF(ISVO(I),MAXARC).GE.4.AND.IA.NE.0.AND.
     &     ABS(CPAVG(ISVO(I),MAXARC)).GT.VCPTOL/2.2D0) THEN
         IF(EL(IA).GT.12.5D0.AND.PX(NFPAR+IA,NFPAR+IA).LE.1.D-6)THEN
          ICSLIP(I)=1
          write(*,*)  DIR((1-IDIR)/2+1),ISVO(i),' AMB RESET MEAN RES=',
     &      CPAVG(ISVO(I),MAXARC),' NO ',NCPDF(ISVO(I),MAXARC),EL(IA)
     &    , PX(NFPAR+IA,NFPAR+IA)
          CPAVG(ISVO(I),MAXARC)= 0.
          NCPDF(ISVO(I),MAXARC)= 0
         ENDIF
        ENDIF
C
C flag cycle clip for next update
C
        IF (ICSLIP(I) .NE. 0 .AND. IOBTYP .EQ. 2) THEN
          NCSLIP15 = 1
          ICSLIP15(ISVO(I)) = 1
          IF( IFLAG .EQ. 5 ) ICSLIP15(ISVO(I)) = 1
          IF( IFLAG .EQ. 6 ) ICSLIP15(ISVO(I)) = 2
          IF( IFLAG .EQ. 7 ) ICSLIP15(ISVO(I)) = 3
          CNTSLIP(ISVO(I),IARC(ISVO(I)),ICSLIP15(ISVO(I)))=
     &        CNTSLIP(ISVO(I),IARC(ISVO(I)),ICSLIP15(ISVO(I)))+1
        END IF
        IF( IRJCT .EQ. 1 ) THEN
          NSVRJCT=NSVRJCT+1
          ISVRJCT(NSVRJCT)=ISVO(I)
          FPR(I)=FPR(I)/C
          FCP(I)=FCP(I)/C
        ELSE
          FPR(I)=FPR(I)/C
          FCP(I)=FCP(I)/C
        END IF
      END DO
C
C SOLVE VTEC & STADCB NORMALS ACCUMULATED AT PREVIOUS EPOCH 
C
C VTEC & DCB SOLUTION ONLY FOR PHASE PROCESSING!
      IF( HORDION(19).GT.1.D-10.AND.IOBTYP.EQ.2 ) THEN
         IF(HORDION(11).GT.1.D0.OR.HORDION(15).GT.1.D0) THEN
C GPS OR GLONASS OR GLONASS+GPS
C    HORDION MAPPING FOR X(DCBg,VTEC,DCBr, ..)
C HORDION(1)  (2)  (3)  (4)  (5)  (6)   (7)   (8)   (9)   (10)
C     DCBg  VTEC  DCBr Resd VtRt UdcbG Uvtec UdcbR free  UTTG 
C HORDION(11)  (12)  (13)  (14)  (15)  (16)  (17)  (18)   (19)  
C        N11    N21   N31   N12   N22   N32   N13   N23    N33
C BUT THE ORDER IN THE ABOVE NORNALS N (HORDION(11-19):(DCBg, DCBr, VTEC) !!!
C ( UdcbG Uvtec UdcbR - the RH side of Normals)
C ONLY UPPER TRIANGLE NEEDED FOR INVERSION
          CALL SPIN ( HORDION(11),  3,  3, sinel     , J)
C SOLVE FOR DCBg, DCBr & VTEC, RESP (HORDION(1), (3) & (2))
          HORDION(1)= HORDION(1)+ HORDION(11)*HORDION(6)+
     &    HORDION(14)*HORDION( 8)+ HORDION(17)*HORDION( 7)
          HORDION(3)= HORDION(3)+ HORDION(14)*HORDION(6)+
     &    HORDION(15)*HORDION( 8)+ HORDION(18)*HORDION( 7)
          HORDION(2)= HORDION(2)+ HORDION(17)*HORDION(6)+
     &    HORDION(18)*HORDION( 8)+ HORDION(19)*HORDION( 7)
C VTEC RATE(SMOOTHED OVER 10 INTERVALS) BUT ONLY WHEN VTEC CONVERGED
      IF(UTTAG.NE.HORDION(10).AND.HORDION(19).LT.400.D0)
     &    HORDION(5)=(HORDION(5)*9 + (HORDION(17)*HORDION(6)+
     &    HORDION(18)*HORDION( 8)+ HORDION(19)*HORDION( 7))/
     &    (UTTAG-HORDION(10)))/10
C LIMIT VTEC RT to .01 TEU/S
      IF(ABS(HORDION(5)).GT. 1.D-1) HORDION(5)= 1.D-1*HORDION(5)/
     &  ABS(HORDION(5))
C FORM REDUCED NORMALS (2.2)
C INITILIZE GPS
          CALL SPIN ( HORDION(11),  3,  3, sinel     , J)
         ENDIF
C FORCE ONLY REASONABLE VTEC (0, 120) TECU (VTEC 1200 .1TECU)
C AND CORRECT DCB's ACCORDINGLY FOR A DCB DATUM, BUT ONLY IF REASONABLE
        IF(HORDION(2).LT.20.D0.AND.HORDION(2).GT.-1200.D0) THEN
          IF(IFREQ.GE.3.AND.HORDION(1).NE.0.D0) HORDION(1)=HORDION(1)+
C NOTE : 40.309D15/(1/F12-1/F22)=-0.0105/0.67 (Vtec/dcb corr)=-.016 
     &      (20.D0-HORDION(2)  )*0.016D0
          IF(IFREQ.GE.3.AND.HORDION(3).NE.0.D0) HORDION(3)=HORDION(3)+
     &      (20.D0-HORDION(2)  )*0.016D0
          HORDION(2)=2.D01
        ENDIF
        IF(HORDION(2).GT.1200.D0.AND.HORDION(2).LT. 2400.D0) THEN
          IF(IFREQ.GE.3.AND.HORDION(1).NE.0.D0)HORDION(1)=HORDION(1)+
     &      (1200.D0-HORDION(2) )* 0.016D0
          IF(IFREQ.GE.3.AND.HORDION(3).NE.0.D0)HORDION(3)=HORDION(3)+
     &      (1200.D0-HORDION(2) )* 0.016D0
          HORDION(2)=12.D02
        ENDIF
C CORRECT INITIAL VTEC & STA DCB IF G ABS(sta DCB) > 15 NS(4.5m) 
        IF(ABS(HORDION(1)).GT. 4.5D0) THEN
         HORDION(2)= HORDION(2) -HORDION(1)/0.016D0
         IF(HORDION(3).NE.0.D0) HORDION(3)= HORDION(3)-HORDION(1)        
         HORDION(1)= 0.D0                         
        ENDIF
C IN CASE OF GARBAGE VTECs < -1200 or > 2400(.1tecu)
        IF(HORDION(2).GE. 2400.D0) HORDION(2)=12.D02
        IF(HORDION(2).LE.-1200.D0) HORDION(2)= 2.D01
C FORCE ZERO VTEC FOR LEO > 450 KM
        IF(PLHEPO(3).GE.450.D03)  HORDION(2)=0.D0
C RE-INITIALIZE THE EPOCH VTEC NORMALS ELEMENTS
C IMITILIZE U's & TIME
        HORDION(6)=0.D0
        HORDION(7)=0.D0
        HORDION(8)=0.D0
        HORDION(10)=UTTAG
      ENDIF
C
C     CYCLE SLIP DETECTED OVER OBSERVATION INTERVAL, REJECT
C
      IF ( UPDEPO .AND. NSVRJCT .NE. 0 ) THEN
        IREASON=1
        CALL VPCREJ ( LPR, NSVRJCT, ISVRJCT, NSVO, ISVO, TTAG,
     &                   PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                   FCP, ICSLIP,
     &                   ISPR1, ISPR2,
     &                   MSOFF, MSJMP, NRCRJCT, IARC, IPC, IREASON, 
     &                   MAXSAT, MAXARC )
        NSVRJCT=0
      END IF
C
C read next if no obs left
C
      IF( NSVO .EQ. 0 ) THEN
        IF( UPDEPO ) NEPOCHDEL=NEPOCHDEL+1
        GO TO 91
      END IF
C
      IF ( IEOF .EQ. 1 ) GO TO 997
C
C     IF PRECISE EPHEMERIS AND CLOCK
C     --> PROCESS ONLY 15/5 MINUTE SAMPLES
C
      IF (ISVEPH .EQ. 2 .OR. ISVCLK .GE. 2 ) THEN
         IF ( .NOT. UPDEPO  ) GO TO 91
      END IF
      IF( NDAY .EQ. NBDAY .AND. UTTAG .GT. ENDTTAG) GO TO 91
C     
C
C Apply internal clock linear when available
C Set the clock process noise parameters
C
      IF( NCLKUP .GE. 1 .AND. ICLKAP .GE. 1 ) THEN
        XRVEPO(4)=XRVEPO(4)-
     &            (CLKY0+CLKD0*(PTTAG-REFTM))*(UTTAG-PTTAG) 
        XRVAPR(4)=XRVAPR(4)-
     &            (CLKY0+CLKD0*(PTTAG-REFTM))*(UTTAG-PTTAG) 
        SDCLK=0.D0
        IF(DABS(UTTAG-PTTAG) .LE. 3*INTCLK ) SDCLK=CLKSD0
        IF( ICLKAP .GE. 2 )
     &   SDCLK=DSQRT(SDCLK*SDCLK+UCLKY0**2+(UCLKD0*(UTTAG-REFTM)/2)**2)
      ELSE
        IF( NCLKUP .GE. 1 .AND. DABS(UTTAG-PTTAG) .LE. 3*INTCLK ) THEN
          SDCLK=SDCLK0
        ELSE
          SDCLK=0.0D0
        END IF
      END IF
      IF ( NSVRJSV .GE. 1 ) THEN
         IREASON=3
         CALL VPCREJ ( LPR, NSVRJSV, ISVRJSV, NSVO, ISVO, TTAG,
     &                 PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                 FCP, ICSLIP,
     &                 ISPR1, ISPR2,
     &                 MSOFF, MSJMP, NRCRJCT, IARC, IPC, IREASON, 
     &                 MAXSAT, MAXARC )
         NSVRJSV=0
C
C        END OF CLK FILE, GO TO END & SKIP ANY REMAINING OBS !
C
c!       WRITE(*,*) 'NO CLOCKS, READ NEXT EPOCH'
         IF ( NSVO .EQ. 0 ) THEN
           NEPOCHDEL=NEPOCHDEL+1
           GO TO 91
         END IF
      END IF
        J=0
       IF(.NOT.IAROFF) THEN
        IAROFF= .TRUE.
        DO I= 1, NSVO
         IF(PRDC(9,ISVO(I)).NE.0.D0) IAROFF= .FALSE.
        END DO
       ENDIF
        DO I=1,NSVO
         CALL FREQ12(ISVO(I), F1, F2, F1S, F2S, F12S, F1ION, F2ION,
     &                   AL1, AL2, AL3, AL4, IFREQ )
         IF(IAROFF.OR.IFREQ.LT.3) THEN
C        AR SWITCHING OFF 
          PRDC(8,ISVO(I))= 0.D0
          PRDC(9,ISVO(I))= 0.D0
         ENDIF    
         IF(ISVO(I).EQ.IPRNREF) J= IPRNREF
         IF(FLTSUM(1,ISVO(I)).EQ.1.D0) THEN
      if(ipc.ge.4)write(*,*)
     &    'ARDEBUG: INIT1',uttag,isvo(i),fltsum(20,isvo(i)),
     &    fltsum(21,isvo(i)),fltsum(22,isvo(i)),fltsum(23,isvo(i))
C ACCOUNT FOR THE INITIAL INTEGER DCM (PSB)
          DN1= -INT((PRDC(8,ISVO(I)))/AL1)
          DN2= -INT((PRDC(8,ISVO(I)))/AL2)
          DN3 = DN1*F2ION*AL1-DN2*F1ION*AL2
          FLTSUM(20,ISVO(I))= FLTSUM(20,ISVO(I)) + DN1*AL1  
          FLTSUM(21,ISVO(I))= FLTSUM(21,ISVO(I)) + DN2*AL2
          FLTSUM(13,ISVO(I))= FLTSUM(13,ISVO(I))- DN3
          FCP(I)= FCP(I)- DN3/C
           FLTSUM(22,ISVO(I))= FLTSUM(22,ISVO(I))-DN1+DN2
      if(ipc.ge.4)write(*,*) 
     &    'ARDEBUG: INIT2',uttag,isvo(i),fltsum(20,isvo(i)),
     &    fltsum(21,isvo(i)),fltsum(22,isvo(i)),fltsum(23,isvo(i)),
     &    prdc(8,isvo(i))
         END IF
C
C APPLYING DCM RESETS
C
         IF( CLKAMB(ISVO(I)) ) THEN
          ICSLIP(I) = 1
          NCSLIP15 = 1
          ICSLIP15(ISVO(I)) = 1
          ICSLIP15(ISVO(I)) = 4
          CNTSLIP(ISVO(I),IARC(ISVO(I)),ICSLIP15(ISVO(I)))=
     &        CNTSLIP(ISVO(I),IARC(ISVO(I)),ICSLIP15(ISVO(I)))+1
         END IF
        ENDDO
        IPRNREF = J
C
      CALL TOWHMS( IWKDAY, TTAG(1)               , IHR, IMIN, SEC, 0 )
      CALL GPSDC ( JULD,IYEAR,IMTH,IDAY,IGPSWK,IWKDAY, 4 )
c!    WRITE(*,900) IYEAR,IMTH,IDAY,IHR,IMIN,SEC,
c!   &              (ISVO(IOB),IOB=1,NSVO)
C      
      CALL JLIAN ( MJD, IYEAR, IMTH, IDAY)
c!    WRITE(*,*) IYEAR,IMTH,IDAY,MJD
      FMJDDT = ((SEC/60.D0+DBLE(IMIN))/60.D0+DBLE(IHR))/24.D0
      CALL SIDTM ( MJD, FMJDDT, GPSUTC, UT1UTC, DUT1,
     &                   ALPHAE, SIDT )
C
      IF ( FIRSTE .AND. NSVO .NE. 0 ) THEN
       REFTM = UTTAG
       IYEARS = IYEAR
       IMTHS = IMTH
       IDAYS = IDAY
       FIRSTE = .FALSE.
      END IF
C
C
C     DAY HAS CHANGED,
C     UPDATE EPHEMERIS, CLOCK AND IONO FILES
C
      IF ( MJD .NE. MJDS+NDAY-1 .AND. MJD-MJDS+1 .LE. NBDAY ) THEN
C
C       AND FILL BUFFERS
C
        RELAXAMB=.TRUE.
        NDAY=MJD-MJDS+1
C
C----------------------------------------------------------------------
C       READ EPHEMERIS AND STORE IN TABLE
C----------------------------------------------------------------------
C
        IF ( ISVEPH .EQ. 2 ) THEN
         CLOSE(LUEPH)          
         IF( NDIR .LT. 0 ) THEN
          IF( IDIR .EQ. 1 ) THEN
C
C STORE LAST POLYNOMIAL, POTENTIALLY THE ONE SPANNING MIDNIGHT
C IN PREPARATION OF BWD RUN
C
           NARCSTOR=NARCSTOR+1
           DO IS=1,MAXSAT
            IF( NPARC(IS) .EQ. NARCSTOR-1 ) THEN
             IPEFIT(IS,NARCSTOR)=1
            ELSE
             DO ID=1,NPDEG(IS,NPARC(IS))
              PCX(IS,NARCSTOR,ID)=PCX(IS,NPARC(IS),ID)
              PCY(IS,NARCSTOR,ID)=PCY(IS,NPARC(IS),ID)
              PCZ(IS,NARCSTOR,ID)=PCZ(IS,NPARC(IS),ID)
             END DO
           DO ID=1,MAXPFIT
              PDT(IS,NARCSTOR,ID)=PDT(IS,NPARC(IS),ID)
             END DO
             IPEFIT(IS,NARCSTOR)=IPEFIT(IS,NPARC(IS))
             NPDEG(IS,NARCSTOR)=NPDEG(IS,NPARC(IS))
             PTB(IS,NARCSTOR)=PTB(IS,NPARC(IS))
             PTE(IS,NARCSTOR)=PTE(IS,NPARC(IS))
            END IF
           END DO
          ELSE
C RESTORE LAST POLYNOMIAL, POTENTIALLY THE ONE SPANNING MIDNIGHT
           NARCSTOR=NARCSTOR-1
          END IF
C CLEAR OTHERS
          DO IS=1,MAXSAT
           DO IA=NARCSTOR+1,NPARC(IS)
            DO ID=1,NPDEG(IS,IA)
             PCX(IS,IA,ID)=0.D0
             PCY(IS,IA,ID)=0.D0
             PCZ(IS,IA,ID)=0.D0
            END DO
          DO ID=1,MAXPFIT
             PDT(IS,IA,ID)=0.D0
            END DO
            IPEFIT(IS,IA)=1
            NPDEG(IS,IA)=0
            PTB(IS,IA)=0.D0
            PTE(IS,IA)=0.D0
           END DO
           NPARC(IS)=NARCSTOR
          END DO
         END IF
c!       WRITE(*,*) NAMEPH(NDAY)
c!       WRITE(*,'(/,1X,A30,/)') 'SORTING PRECISE EPHEMERIS FILE'
          OPEN ( LUEPH, FILE=NAMEPH(NDAY), STATUS='OLD',IOSTAT=IOS, 
     &            ERR=610 )
          CALL FITEPH (LUI, LUO, LPR, LUEPH, NAMEPH, NDAY, 
     &                 IPC, ISVEPH, C, DTM,
     &                 XRVEPO, NEPSV, IEPSV, NEPTIM, EPHTIM, EPHTBL,
     &                 IBEFIT, NPEPSV, IPEPSV, IPEPACC, NPARC, NPDEG, 
     &         IPEFIT, PTB, PTE, PCX, PCY, PCZ, PDT, ENDTTAG, IULTRA,
     &             IMINACC, IPEPINT, SSVX)
        END IF
C
        IF ( ISVEPH .EQ. 1 ) THEN
          CLOSE(LUEPH)          
          WRITE(*,'(/,1X,A30,/)') 'SORTING BROADCAST EPHEMERIS FILE'
          OPEN  ( LUEPH, FILE=NAMEPH(NDAY), STATUS='OLD',IOSTAT=IOS,
     &            ERR=600 )
          CALL RDEPH  (LPR,LUEPH,IFMTE,NEPSV,IEPSV,NEPTIM,EPHTIM,EPHTBL,
     &               AIONBRD, BIONBRD, ISRCH)
          REWIND (LUEPH)
C
C load ephemeris from MRTCA T28
C
          IF( ISVCLK .EQ. 3 ) THEN
           OPEN(LUCOR,FILE=NAMCLK(NDAY),STATUS='OLD')
           CALL RTCAEPH( LPR, LUCOR, NEPSV, IEPSV,
     &                 NEPTIM, EPHTIM, EPHTBL, ISRCH)
           CLOSE(LUCOR)
          END IF
C
C load ephemeris from RTCM-SSR T1019
C
          IF( ISVCLK .EQ. 4 ) THEN
           OPEN(LUCOR,FILE=NAMCLK(NDAY),STATUS='OLD')
           CALL RTCMEPH( LPR, LUCOR, NEPSV, IEPSV,
     &                 NEPTIM, EPHTIM, EPHTBL, ISRCH)
           CLOSE(LUCOR)
          END IF
        END IF
C
C----------------------------------------------------------------------
C       READ SINGLE LAYER MODEL AND STORE IN GRID
C----------------------------------------------------------------------
C
        IF ( IONSLM .EQ. 2 ) THEN
          IF ( ISLMFMT .LE. 1 ) THEN
            INXMAP=1
            IF( IPC .GE. 1 ) WRITE(*,'(/,A50,I5,/)') 
     &             '*** GPSPPP - OPENING IONOSPHERIC GRID ',INXMAP
            OPEN  ( LUION, FILE=NAMION(NDAY), STATUS='OLD',IOSTAT=IOS, 
     &            ERR=600 )
            CALL RDSSLM ( LUION, LUO, PLHMRK(1), IYGRD, IMGRD, IDGRD,
     &                STNA,
     &                FRLAT, TOLAT, DLAT, FRLON, TOLON, DLON, 
     &                TION, ADION, RDION, 
     &                NRXDCB, LRXDCB, RXDCB, RXDCBS,
     &                NSVDCB, LSVDCB, SVDCB, SVDCBS, 
     &                MININC, SLMHGT, IONREF, ISLMFMT,
     &                PI, INXMAP, MAXMAP, MAPINT, IONBAND, REFLAT, 
     &                IEXP,
     &                       IRC, IDIR )
            IF( SLMHGT .LT. 200.D0 .OR. SLMHGT .GT. 800.D0 )
     &        SLMHGT=HION
            IF ( INXMAP .EQ. 1 ) THEN
             SLMGPS=.FALSE.
             SLMGLN=.FALSE.
             DO I=1,NSVDCB
              IF(DABS(SVDCB(I)).LT.100.D0) THEN
               PRNDCB(LSVDCB(I))=SVDCB(I)
               IF(LSVDCB(I).LE.32) THEN
                 SLMGPS=.TRUE.
               ELSE IF(LSVDCB(I).LE.56) THEN
                 SLMGLN=.TRUE.
               ENDIF
              ENDIF
             END DO
C THE INPUT DCB IS ONLY VALID FOR L3 PROCESSING
             IF( IFREQ .EQ. 3 ) THEN
              DO I=1,NRXDCB
               IF( LRXDCB(I) .EQ. STNA(1:4) ) THEN
                 HORDION(1) = RXDCB(I)
                 HORDION(11) = 1.D20
               END IF
              END DO
             END IF
             IF(.NOT.SLMGPS) THEN
              DO I=1,32
               IF(DABS(DP1P2(I)).LT.300.D0) PRNDCB(I)=DP1P2(I)*1.D-9*C 
              END DO
             ELSE
              DO I=1,32
               IF(DABS(PRNDCB(I)).LT.300.D0) DP1P2(I)=PRNDCB(I)*1.D9/C
              END DO
             ENDIF
             IF(.NOT.SLMGLN) THEN
              DO I=33,56
               IF(DABS(DP1P2(I)).LT.300.D0) PRNDCB(I)=DP1P2(I)*1.D-9*C
              END DO
             ELSE
              DO I=33,56
               IF(DABS(PRNDCB(I)).LT.300.D0) DP1P2(I)=PRNDCB(I)*1.D9/C
              END DO
             ENDIF
            END IF
            IF( IPC .GE. 1 ) WRITE(*,'(/,A50,I5,/)') 
     &             '*** GPSPPP - READ IONOSPHERIC MAP ',INXMAP
C
C update MRTCA iono
C
          ELSE IF( ISLMFMT .EQ. 3 ) THEN
           IF( IONDAY .NE. NDAY ) THEN
            IONDAY=NDAY
            IF( IPC .GE. 1 ) WRITE(*,'(/,A60,/)') 
     &             '*** GPSPPP - READING MRTCA IONOSPHERIC MESSAGES '
            OPEN  ( LUION, FILE=NAMION(NDAY), STATUS='OLD',IOSTAT=IOS, 
     &            ERR=600 )       
            SLMHGT=350.D0
            CALL RTCAIONRD( LUION, IDIR, UTTAG, TION, TIONX,
     &                      TIONINIT(IONDAY), RTCAVERT, RTCAGIVE, IRC )
           END IF
          ELSE IF( ISLMFMT .EQ. 6 ) THEN
           IF( IPC .GE. 1 ) WRITE(*,'(/,A60,/)') 
     &             '*** GPSPPP - READING RTCM-SSR IONOSPHERIC MESSAGES '
           CALL RTCMIONRD( LUION,IDIR,UTTAG,TION,TIONX,TIONINIT(IONDAY),
     &                  TION_END(IONDAY), SLMHGT, SCHA_INT, SCHA_NSET,
     &                  SCHA_DEG, SCHA_ORD, SCHA_REF, SCHA_T, SCHA_L,
     &                  SCHA_M, SCHA_NMN, SCHA_ALM, SCHA_BLM, SCHA_DLM )
           IF( ( IDIR .EQ. 1 .AND.
     &           TION_END(IONDAY) .GT. 0 .AND.
     &           UTTAG .GT. TION_END(IONDAY) .AND.
     &                           IONDAY .LT. NBDAY ) .OR.
     &         ( IDIR .EQ. -1 .AND.
     &           TIONX .EQ. -1 .AND. IONDAY .GT. 1 ) ) THEN
            CLOSE(LUION)
            IONDAY=IONDAY+IDIR
            OPEN(LUION,FILE=NAMION(IONDAY),STATUS='OLD',ERR=600)
            CALL RTCMIONRD( LUION,IDIR,UTTAG,TION,TIONX,
     &                      TIONINIT(IONDAY),
     &                  TION_END(IONDAY), SLMHGT, SCHA_INT, SCHA_NSET,
     &                  SCHA_DEG, SCHA_ORD, SCHA_REF, SCHA_T, SCHA_L,
     &                  SCHA_M, SCHA_NMN, SCHA_ALM, SCHA_BLM, SCHA_DLM )
           END IF
          ELSE IF( ISLMFMT .EQ. 4 .OR. ISLMFMT .EQ. 5 ) THEN
            IF( IPC .GE. 1 ) WRITE(*,'(/,A60,/)') 
     &           '*** GPSPPP - READING SPHERICAL HARM.COEFFICIENTS '
            OPEN( LUION, FILE=NAMION(NDAY), STATUS='OLD',IOSTAT=IOS, 
     &            ERR=600 )       
            SCHA_NSET=2
            IF( ISLMFMT .EQ. 4 ) THEN
            CALL SCHACOEFBUF( LUION, IDIR, UTTAG, SCHA_CNT, SCHA_INT,
     &                    SCHA_T, SCHA_L, SCHA_M, SCHA_NMN,
     &                    SCHA_ALM, SCHA_BLM, SCHA_NSET )
            ELSE
            CALL SHCOEFBUF( LUION, IDIR, UTTAG, SCHA_CNT, SCHA_INT, 
     &                      SCHA_REF, SCHA_DEG, SCHA_ORD, SCHA_T,
     &                      SCHA_L, SCHA_M, SCHA_NMN, SCHA_ALM,
     &                      SCHA_BLM, SCHA_DLM, SCHA_NSET )
            ENDIF
          ELSE
            IF( IPC .GE. 1 ) WRITE(*,'(/,A60,/)') 
     &             '*** GPSPPP - READING IONOSPHERIC COEFFICIENTS '
            OPEN  ( LUION, FILE=NAMION(NDAY), STATUS='OLD',IOSTAT=IOS, 
     &            ERR=600 )       
            CALL RDEPH  (LPR,LUION,1,NEPSV,IEPSV,NEPTIM,EPHTIM,
     &                 EPHTBL, AIONBRD, BIONBRD, ISRCH) 
            DO I=1,NEPSV
             TGD(IEPSV(I)) = EPHTBL(6,I,1)*C
c!           WRITE(*,*) I,IEPSV(I),TGD(IEPSV(I))
            END DO
          END IF
        END IF
C
C     UPDATE VMF1/IMF FOR CURRENT DAY
C        
        IF((COEFMF(5,2).GT.0.D0.and.COEFMF(5,2).LT.2.D-3).OR. 
     &     (COEFMF(5,2).LT.2.D4.and.COEFMF(5,2).GT.9.D3)) THEN
          OPEN ( LUMET, FILE=NAMMET, STATUS='UNKNOWN')
          CALL RDMET( LUI, LUO, LUMET, IYEAR, IMTH, IDAY, 
     &     IMET,
     &     TEMP, PRES, RH, TROSCL, PLHMRK   , COEFMF, STNA, 0)
          CLOSE(LUMET)
        END IF
C
C       UPDATE ERP FOR CURRENT DAY
C        
        OPEN ( LUMET, FILE=NAMERP, STATUS='UNKNOWN')
        CALL RDERP( LUI, LUO, LUMET, IYEAR , IMTH , IDAY , 
     &            FMJDMP, XMPDIF, YMPDIF, XMPDRT, YMPDRT, IERP )
        CLOSE( LUMET )
      END IF
C
      IF( ISVCLK .LT. 3 .AND. ISVEPH .EQ. 1 )
     & CALL UPEPH ( IGPSWK,TTAG,NSVO,ISVO,EPHSAT,NEPSV,IEPSV,
     &             IEPTIM,NEPTIM,EPHTIM,EPHTBL,ISRCH )     
      IF( ISVCLK .GE. 3 ) THEN
       NSVRJCT=0
       DO IO=1,NSVO
        K=0
        DO I=1,NEPSV
         IF( ISVO(IO) .EQ. IEPSV(I) ) THEN
          IPRN=I
          DO J=1,NEPTIM(I)
           IF( DBLE(IODC(IO)) .EQ. EPHTBL(12,I,J) .AND.
     &         DABS(TTAG(IO)-EPHTBL(20,I,J)+
     &         604800.D0*(IGPSWK - EPHTBL(2,I,J))) .LE. 21600.D0 ) K=J
          END DO
         END IF
        END DO
        IF( K .EQ. 0 ) THEN
         NSVRJCT=NSVRJCT+1
         ISVRJCT(NSVRJCT)=ISVO(IO)
        ELSE
         DO J=1,MAXKEP
          EPHSAT(J,ISVO(IO))=EPHTBL(J,IPRN,K)
         END DO
        END IF
       END DO
C REMOVE THOSE OBS WITHOUT EPHEMERIS CORESPONDING TO MRTCA/RTCM
       IF( NSVRJCT .GT. 0 ) THEN
        IREASON=3
        CALL VPCREJ ( LPR, NSVRJCT, ISVRJCT, NSVO, ISVO, TTAG,
     &                PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                FCP, ICSLIP,
     &                ISPR1, ISPR2,
     &                MSOFF, MSJMP, NRCRJCT, IARC, IPC, IREASON, 
     &                MAXSAT, MAXARC )
        NSVRJCT=0
       END IF
       IF ( NSVO .EQ. 0  .AND. NBDAY .EQ. 1 ) THEN
         NEPOCHDEL=NEPOCHDEL+1
         GO TO 91
       END IF
      END IF
      IF ( IPC .GT. 1 ) THEN
c!      WRITE(LPR,900) IYEAR,IMTH,IDAY,IHR,IMIN,SEC,
c!    &                (ISVO(IOB),IOB=1,NSVO)
       DO 95 I=1,NSVO
       J = ISVO(I)
       CALL TOWHMS(IWKDAY,EPHSAT(20,J),IHREP(I),IMNEP(I),SECEP,0)
  95   CONTINUE
       IF ( ISVEPH .EQ. 1 ) 
     &    WRITE(LPR,1000) (IHREP(IOB),IMNEP(IOB), IOB=1,NSVO)
      END IF
C
C-----------------------------------------------------------------------
C    PROCESS MEASUREMENT SECTION  (LOOP)
C-----------------------------------------------------------------------
C
      INSVO = 1
      TESTMISC = MISCFACTR .GT. 0.D0 .OR. MISCFACTP .GT. 0.D0
      TESTMISCPROB = .FALSE.
      NSVDWSAV=0
100   CONTINUE
      IF ( NSVO .EQ. 0 ) THEN
       ITER=MAXIT
        DO I=1,MAXOBS
         ISVO(I)=0
         ISVOL(I)=0
        END DO
      NSVOL=0
      END IF
C
C     IF STATIC SOLUTION, 2 SATELLITES IS MINIMUM
C     UNLESS FIRST FIX THEN 5 SATELLITES IS MINIMUM
C
C     IF KIN SOLUTION, 5 SATELLITES IS MINIMUM
C     UNLESS NO AMBIGUITIES ARE RESET THEN 4 SATELLITES IS MINIMUM
C     (DISALLOW 4SV KIN PPP FOR A GPS/GLONASS MIX)
C
C COUNT INTERV CY SLIP/NEW AMBS
C
      IAMBSUM=0
      NSVDWGT=0
      GPS=.FALSE.
      GLN=.FALSE.
      GAL=.FALSE.
      NGAL=0
      BEI=.FALSE.
      NBEI=0
      NGPS=0
      NGLN=0
      DO I=1,NSVO
       GPS=GPS.OR.(ISVO(I).GE. 1.AND.ISVO(I).LE.32)
       GLN=GLN.OR.(ISVO(I).GE.33.AND.ISVO(I).LE.64)
       GAL=GAL.OR.(ISVO(I).GE.65.AND.ISVO(I).LE.100)
       IF(ISVO(I).GE.65.AND.ISVO(I).LE.100) NGAL=NGAL+1
       BEI=BEI.OR.(ISVO(I).GE.101.AND.ISVO(I).LE.136)
       IF(ISVO(I).GE.101.AND.ISVO(I).LE.136) NBEI=NBEI+1
       IF(ISVO(I).GE. 1.AND.ISVO(I).LE.32) NGPS=NGPS+1
       IF(ISVO(I).GE.33.AND.ISVO(I).LE.64) NGLN=NGLN+1
       IF( ICSLIP15(ISVO(I)) .NE. 0 )
     &    IAMBSUM= IAMBSUM + 1
       IF( PL(IOBTYP*(I-1)+1,IOBTYP*(I-1)+1)*SDPR**2 .LT. 1.D-20 .OR.
     &    ( IOBTYP .EQ. 2 .AND.
     &      PL(IOBTYP*I,IOBTYP*I)*SDCP**2 .LT. 1.D-20 ) ) THEN
         NSVDWGT=NSVDWGT+1
         ISVDWGT(NSVDWGT)=ISVO(I)
       ENDIF
      END DO
C
C STATIC AND KIN REDUNDANCY CHECK
C
      MINSAT=0
      IF( NREDUND.GE.0 ) MINSAT=MINSAT+NREDUND
C KINEMATIC OR INITIAL STATIC
      IF( IPOSSOL.EQ.2 .AND.
     &    ( IMODE.GE.2 .OR. NFIX.EQ.0 .OR. INIEPO ) ) MINSAT=MINSAT+3
C CONSTELLATION-SPECIFIC CLOCKS
      IF( ICLKSOL .EQ. 1 .AND. GPS ) MINSAT=MINSAT+1
      IF( ICLKSOL .EQ. 1 .AND. GLN ) MINSAT=MINSAT+1
      IF( ICLKSOL .EQ. 1 .AND. GAL ) MINSAT=MINSAT+1
      IF( ICLKSOL .EQ. 1 .AND. BEI ) MINSAT=MINSAT+1
C SPECIAL KINEMATIC CASE: WHEN NREDUND=0 WE REQUIRE NO AMBIGUITY RESETS
      IF( IMODE.GE.2 .AND. NREDUND.EQ.0 .AND. IAMBSUM.GT.0 )
     &                                       MINSAT=MINSAT+1
C TEST RESULTING REDUNDANCY
      IF( NSVO-NSVDWGT .LT. MINSAT ) THEN
       ITER=MAXIT
       NSVRJCT=0
       DO I=1,NSVO
        K=0
        DO J=1,NSVDWGT
          IF( ISVO(I) .EQ. ISVDWGT(J) ) K=J
        END DO
        IF( K .EQ. 0 ) THEN
          NSVRJCT=NSVRJCT+1
          ISVRJCT(NSVRJCT)=ISVO(I)
        ENDIF
       END DO
       IF ( NSVRJCT .NE. 0 ) THEN
        IREASON=1
        CALL VPCREJ ( LPR, NSVRJCT, ISVRJCT, NSVO, ISVO, TTAG,
     &                PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                FCP, ICSLIP,
     &                ISPR1, ISPR2,
     &                MSOFF, MSJMP, NRCRJCT, IARC, IPC, IREASON, 
     &                MAXSAT, MAXARC )
        NSVRJCT=0
      END IF
      END IF
      ITER = ITER +1
C
C     RESTORE PARAMETERS TO LATEST ESTIMATES
C     IF NUMBER OF ITERATIONS (ITER) .GT. MAXIMUM ITERATIONS (MAXIT)
C
      IF(ITER.GT.MAXIT .OR. NSVO-NSVDWGT .EQ. 0) THEN
          IF(IPC.GT.1) WRITE(LPR ,*) ' STOP ITERATIONS AT',ttag(1),NSVO
     &                ,NSVDWGT
     &  ,'REDUNDANCY'
        WRITE(* ,*) ' STOP ITERATIONS AT',ttag(1),NSVO,NSVDWGT
     &  ,'REDUNDANCY'
        GO TO 997
      END IF
C
C------------------------------------------------------------------------
C     COMPUTE EFFECT OF EARTH TIDES
C------------------------------------------------------------------------
C
      IF ( ITER .EQ. 1 ) THEN
        DMJDT = MJD + FMJDDT
        CALL BODYT ( PLHEPO(1), PLHEPO(2), XRVEPO, IYEAR, IMTH, IDAY,
     &               DMJDT,  SIDT, ETIDE(1), ETIDE(2), ETIDE(3) )
        DMJDT = DMJDT + GPSUTC/86400.D0
c!      WRITE(*,'(A5,4F15.3)') 'ETIDE',UTTAG,ETIDE(1),
c!   &                      ETIDE(2),ETIDE(3)
C
C       COMPUTE OCEAN LOADING IF COEFFICIENTS ARE AVAILABLE (IOLC=1)
C
        IF (IOLC.EQ.1) THEN
          CALL OLOADN(IYEAR, JULD, IHR, IMIN, SEC, NOCOF,
     &               AMPL, PHAS, DUP, DNS, DEW)
        ETIDE(1) = ETIDE(1)+ DUP
        ETIDE(2) = ETIDE(2)+ DEW
        ETIDE(3) = ETIDE(3)+ DNS
c!      WRITE(*,'(A5,4F15.3)') 'OTIDE',UTTAG,DUP,DEW,DNS
        END IF
C
C       COMPUTE POLAR TIDES IF CURRENT DAY ERP WAS READ
C       NOTE XMPDIF&YMPDIF ARE ZERO OTHERWISE WHICH DISABLES THE CORRECTION
C
        ETIDE(1) = ETIDE(1)- 33D-3*DSIN(2*PLHEPO(1))*
     &             ((XMPDIF+(DMJDT-FMJDMP)*XMPDRT)*DCOS(PLHEPO(2))-
     &              (YMPDIF+(DMJDT-FMJDMP)*YMPDRT)*DSIN(PLHEPO(2)))
        ETIDE(2) = ETIDE(2)+ 9.D-3*DSIN(PLHEPO(1))*
     &             ((XMPDIF+(DMJDT-FMJDMP)*XMPDRT)*DSIN(PLHEPO(2))+
     &              (YMPDIF+(DMJDT-FMJDMP)*YMPDRT)*DCOS(PLHEPO(2)))
        ETIDE(3) = ETIDE(3)- 9.D-3*DCOS(2*PLHEPO(1))*
     &             ((XMPDIF+(DMJDT-FMJDMP)*XMPDRT)*DCOS(PLHEPO(2))-
     &              (YMPDIF+(DMJDT-FMJDMP)*YMPDRT)*DSIN(PLHEPO(2)))
C
        CALL ANTEX ( DTM, PLHEPO(1), PLHEPO(2), PLHEPO(3), ETIDE(3), 
     &               ETIDE(2), ETIDE(1), ETIDEX )
        IF( IMET(1) .LT. 5 .AND. IMET(2) .LT. 5
     &                     .AND. IMET(3) .LT. 5 ) THEN
         IF( PLHEPO(3).GT.-30.0.AND. PLHEPO(3).LT.100000.0) THEN
           CALL GPT(DMJDT, PLHEPO(1), PLHEPO(2), PLHEPO(3) ,
     &              PRES, TEMP, DUMMY)  
         ENDIF
        ENDIF
        WETEPO=0.d0
        DRYEPO=0.d0
        IF(                         PLHEPO(3).LT.100000.0)
     &  CALL TROPO ( 2, TEMP, PRES, RH, PI/2.D0, DRYEPO, WETEPO,
     &               DRYM, WETM, TROZEN, PLHEPO, XRVEPO )
C WETEPO should be initialized on the first phase sol
        IF( .NOT. INIEPO ) THEN
C WETEPO estimate should be initialized on the first phase sol
         IF( PTTAG .EQ. 0 ) THEN
        COEFMF(1,5)=WETEPO
        XRVAPR(5)=WETEPO
        XRVEPO(5)=WETEPO
         ENDIF
        END IF
      END IF
C
C-----------------------------------------------------------------------
C     LOOP FOR NUMBER OF OBSERVATIONS
C-----------------------------------------------------------------------
C
      DO 110, J = INSVO,NSVO
       IDX(ISVO(J)) = J
110   CONTINUE
C
C INITIALIZE INDECES FOR EPOCH AND CONSTELLATION-SPECIFIC MISCLOSURES TEST
      IOBP_GPS=0
      DELTAPP_GPS=0.D0
      DELTARP_GPS=0.D0
      IOBP_GLN=0
      DELTAPP_GLN=0.D0
      DELTARP_GLN=0.D0
      IOBP_GAL=0
      DELTAPP_GAL=0.D0
      DELTARP_GAL=0.D0
      IOBP_BEI=0
      DELTAPP_BEI=0.D0
      DELTARP_BEI=0.D0
      DELTAPP=0.D0
      DELTARP=0.D0
C
C INITIALIZE MISCLOSURE CONSTELLATION COUNTS
C
      NMISC(1)=0
      NMISC(2)=0
      NMISC(3)=0
      NMISC(4)=0
      DO 200 IOB = INSVO,NSVO
        IPRN = ISVO(IOB)
        CALL FREQ12( IPRN, F1, F2, F1S, F2S, F12S, F1ION, F2ION,
     &                   AL1, AL2, AL3, AL4, IFREQ )
c!      WRITE(*,*) 'PROCESSING PRN# ',IPRN
        O_GPS=(IPRN.GE. 1.AND.IPRN.LE.32)
        O_GLN=(IPRN.GE.33.AND.IPRN.LE.64)
        O_GAL=(IPRN.GE.65.AND.IPRN.LE.100)
        O_BEI=(IPRN.GE.101.AND.IPRN.LE.136)
C
        IF (IPC .GT. 2)
     &   WRITE(*,'(A12,I3.3,5F16.4)') 'PR1&FPR&FCP',ISVO(IOB),
     &               TTAG(IOB), PR1(IOB)*C, FPR(IOB)*C, FCP(IOB)*C
C
C REMOVE LAST CONSTELLATION-SPECIFIC SATELLITE
C
        IF( (IPRN.GE. 1.AND.IPRN.LE.32.AND.NGPS.EQ.1).OR.
     &      (IPRN.GE.33.AND.IPRN.LE.64.AND.NGLN.EQ.1).OR.
     &      (IPRN.GE.65.AND.IPRN.LE.100.AND.NGAL.EQ.1).OR. 
     &      (IPRN.GE.101.AND.IPRN.LE.136.AND.NBEI.EQ.1)) THEN
           IREASON=1
           CALL OPCREJ ( LPR, IOB, NSVO, ISVO, TTAG, 
     &                   PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                   FCP, ICSLIP,
     &                   ISPR1, ISPR2,
     &                   MSOFF, MSJMP, 
     &                   NRCRJCT, IARC(ISVO(IOB)), IPC, IREASON )
           ITER = 0
           INSVO = 1
           GO TO 100
        END IF
C
C     FILL EPHEMERIS ARRAY FROM TABLE
C
        DO 115 J = 1 , 30
       EPH(J) = EPHSAT( J , IPRN)
115     CONTINUE
C
C     COMPUTE SATELLITE POSITION AT TRANSMIT TIME (ITIM=0)
C
C     APPLY PSEUDORANGE TO GET TRANSMIT TIME
C
        TXTIM = TTAG(IOB) - FPR(IOB)
C
C     COMPUTE DELTA TIME FROM EPHEMERIS REFERENCE TIME
C
C
        IF ( ISVEPH .EQ. 1 ) THEN
         IF ( EPH(1) .NE. 0.D0 .AND. EPH(5) .EQ. 0.D0 
     &           .AND. IBEFIT(IPRN) .EQ. 0 .AND.
     &        ( ISVCLK .LT. 3 .OR. EPH(12) .EQ. DBLE(IODC(IOB)) ) ) THEN
           TXTIM = TXTIM - EPH(20) + (IGPSWK - EPH(2))*604800.D0
           CALL KLCLK (EPH,DTM,TXTIM,DELTAT,RELDTR)
           TXTIM = TXTIM - DELTAT
           CALL KLORB( LUO, EPH, XSV, VSV, C, XRVEPO, DTM, TXTIM, ITIM,
     &                 LPR, IVEL )
C!!
C!!    MRTCA/RTCM ORBIT CORRECTIONS APPLIED TO BROADCAST ORBITS
C!!
C!!        This code is Ok! You can choose to apply the RTCA/RTCM correction
C!!        on the BRD computed satellite positions or on the observation
C!!        as done later. If the following is uncommented, the observation
C!!        correction should be commented, and vice-versa
C!!
C!! Code Beg ==================================================================
           IF( ISVCLK .GE. 3 ) THEN
           IF( ISVCLK .EQ. 4 )
     &      CALL RTCM_RACTOXYZ( DELTAT+FPR(IOB), XSV, VSV,
     &                          DORBC(7,IOB), DORBC(1,IOB) )
            XSV(1) = XSV(1) + DORBC(1,IOB)
            XSV(2) = XSV(2) + DORBC(2,IOB)
            XSV(3) = XSV(3) + DORBC(3,IOB)
           END IF
C!! Code End ==================================================================
         ELSE
           IREASON=4
           CALL OPCREJ ( LPR, IOB, NSVO, ISVO, TTAG, 
     &                   PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                   FCP, ICSLIP,
     &                   ISPR1, ISPR2,
     &                   MSOFF, MSJMP, 
     &                   NRCRJCT, IARC(ISVO(IOB)), IPC, IREASON )
           ITER = 0
           INSVO = 1
           GO TO 100
         END IF
        END IF
C
C
C------------------------------------------------------------------------
C     USE PRECISE EPHEMERIS IF SPECIFIED
C------------------------------------------------------------------------
C
        IF ( ISVEPH .GE. 2 ) THEN
          IPFOUND = .FALSE.
        DO 130 IA=NARCSTOR,NPARC(IPRN)
          IF( IA.GE.1 ) THEN
              TXPEP=IGPSWK*604800.D0+TXTIM
              IF ( IPEFIT(IPRN,IA) .EQ. 0 .AND. 
     &             TXPEP .GE. PTB(IPRN,IA) .AND.
     &             TXPEP .LE. PTE(IPRN,IA) ) GOTO 140 
            END IF
130       CONTINUE
140       CONTINUE
          IF( IA .GT. 0 .AND. IA .LE. NPARC(IPRN) ) THEN
          IPFOUND=.TRUE.
          IF( TXPEP .GT. (PTB(IPRN,IA)+3*PTE(IPRN,IA))/4 .AND.
     &          IA .LT. NPARC(IPRN) ) THEN
              IF( IPEFIT(IPRN,IA+1) .EQ. 0 .AND.
     &            TXPEP .LE. (PTB(IPRN,IA+1)+3*PTE(IPRN,IA+1))/4 .AND.
     &            TXPEP .GE. (3*PTB(IPRN,IA+1)+PTE(IPRN,IA+1))/4 )
     &          IA=IA+1
          END IF
c!          write(*,'("SELECT",1X,4F5.2,3I3.2)') 
c!   &             (TXPEP-PTB(IPRN,IA))/3600,
c!   &             (TXPEP-(3*PTB(IPRN,IA)+PTE(IPRN,IA))/4)/3600,
c!   &             (TXPEP-(PTB(IPRN,IA)+3*PTE(IPRN,IA))/4)/3600,
c!   &             (TXPEP-PTE(IPRN,IA))/3600,IA,NPARC(IPRN),IPRN
        END IF
        IF( IPFOUND ) THEN
            IF ( ISVCLK .EQ. 2 ) THEN
              SATCOR = PRDC(1,IDX(IPRN))/C
            ELSE
            SATCOR =
     &             PDT(IPRN,IA,IDINT((TXPEP-PTB(IPRN,IA))/IPEPINT)+1)
            IF( DABS(SATCOR*1.D6-999999D0) .LT. 1.D0 .OR.
     &                DABS(SATCOR*1.D6-99999D0) .LT. 1.D0 ) THEN
                IREASON=3
                CALL OPCREJ ( LPR, IOB, NSVO, ISVO, TTAG, 
     &               PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &               FCP, ICSLIP,
     &               ISPR1, ISPR2,
     &               MSOFF, MSJMP, 
     &               NRCRJCT, IARC(ISVO(IOB)), IPC, IREASON )
                ITER = 0
                INSVO = 1
                GO TO 100
            END IF
            END IF
          TXPEP = TXPEP - SATCOR
          CALL FITXYZ ( LPR, TXPEP, IPRN, IA, NPDEG, PTB,
     &                        PTE, PCX, PCY, PCZ,
     &                        XSV, VSV, IPRN, DSVZ )
          END IF
C
C       NO PRECISE EPHEMERIS FOUND FOR THIS SATELLITE
C
          IF ( .NOT. IPFOUND ) THEN
            IREASON=4
            CALL OPCREJ ( LPR, IOB, NSVO, ISVO, TTAG, 
     &                   PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                   FCP, ICSLIP,
     &                   ISPR1, ISPR2,
     &                   MSOFF, MSJMP, 
     &                   NRCRJCT, IARC(ISVO(IOB)), IPC, IREASON )
            ITER = 0
            INSVO = 1
            GO TO 100
          END IF
        END IF
C
C------------------------------------------------------------------------
C       COMPUTE SATELLITE ANTENNA (X-DIRECTION) EXCENTRICITY 
C------------------------------------------------------------------------
C
C correct for ITRF rotations
        vsvc(1)= vsv(1) - xsv(2)*dtm(7)
        vsvc(2)= vsv(2) + xsv(1)*dtm(7) 
        vsvc(3)= vsv(3)
        CALL SANTX( XSV, MJD , FMJDDT, SIDT, SANTXYZ(1), SANTXYZ(2),
     &            SANTXYZ(3), SVBCOS, vsvc, beta )     
C
C     SV IN SHADOW: ANGLE BETWEEN SUN AND SV RADIUS VECTORS +/- 14.5 DEG 
C     COS(180+-14.5 DEG)= -.968 
C     SV AT NOON: ANGLE BETWEEN SUN AND SV RADIUS VECTORS +/- 5.7 DEG 
C     COS(+-5.7 DEG)= .995 
C     NOTE: NOON TURN DISABLED USING .9999 INSTEAD OF .995 
C
        ANOON=5.9
        ANIGHT=180.D0+13.25D0
        IF(IPRN.GT.32.AND.IPRN.LE.64) ANIGHT=180.D0+14.20D0
        IF(IPRN.GT.64.AND.IPRN.LE.100) ANIGHT=180.D0+15.00D0
C SAVING NOMINAL ANTENNA ORIENTATION
        DO I=1,3
          TEMPUVX(I)=SANTXYZ(I)
        ENDDO
        CALL ECLIPS ( IDIR, IPRN, TTAG(IOB), SVBCOS, 
     &                ANOON, ANIGHT, NECLIPS, ECLSTM, ECLETM, 
     &                IECLIPS, PI, xsv, santxyz, vsvc, beta,
     &                iblk,BETAINI, YRTIN, YBSIN, INPRN)
        IF( YAWMODEL .NE. 0 .AND. PRDC(7,IDX(IPRN)) .GT. -998.D0 ) THEN
          DO I=1,3
            SANTXYZ(I)=TEMPUVX(I)
          ENDDO
C
          CALL APPLY_EXTYAW( IBLK(IPRN), TTAG(IOB), MJD, FMJDDT, SIDT,
     &                       XSV, VSV, DTM(7), YAWMODEL,
     &                       PRDC(7,IDX(IPRN)), SANTXYZ, PI )
        ENDIF
C
        IF( ISVEPH .EQ. 2 ) THEN
          XSV(1) = XSV(1) + SANTXYZ(1)*DSVX(IPRN)
          XSV(2) = XSV(2) + SANTXYZ(2)*DSVX(IPRN)
          XSV(3) = XSV(3) + SANTXYZ(3)*DSVX(IPRN)
        END IF
C
        if(IPC .GT. 0 .AND. ieclips.ne.0) then
          write(*,*) 'ECL', iprn, ieclips,
     &     acos(svbcos)*180./pi,
     &     acos((santxyz(1)*vsvc(1)+santxyz(2)*vsvc(2)+
     &                              santxyz(3)*vsvc(3))/
     &           sqrt(vsvc(1)**2+vsvc(2)**2+vsvc(3)**2))*180./PI,
     &     (beta*180/pi-90.d0)
        endif
C
c!     WRITE(*,'(A8,I2.2,F15.2,3F10.4)') 'SANT_XYZ',IPRN,
c!   &               DMOD(TTAG(1),86400.D0)/3600.D0, SANTXYZ
C
C------------------------------------------------------------------------
C     COMPUTE AZIMUTH , ELEVATION AND DISTANCE TO SATELLITE
C------------------------------------------------------------------------
C
c!    WRITE(*,'(3(A3,3F12.1,/))') 'STA',XRVEPO(1),XRVEPO(2),XRVEPO(3),
c!   &                            'PLH',PLHEPO(1),PLHEPO(2),PLHEPO(3),    
c!   &                            'SAT',XSV(1),XSV(2),XSV(3)
C ACCOUNT FOR GNSS FRQCY RX ANT OFFSET
          J=1
          IF(IPRN.GT.32. AND.IPRN.LE.64)   J=2
          IF(IPRN.GT.64. AND.IPRN.LE.100)  J=3
          IF(IPRN.GT.100.AND.IPRN.LE.136)  J=4
C
      CALL ANTEX ( DTM, PLHEPO(1), PLHEPO(2), PLHEPO(3),
     &             ANTN(J), ANTE(J), ANTH(J), ANTXGNSS )
        CALL AZELD ( XRVEPO(1)-ANTX(1)+ANTXGNSS(1)
     &    , XRVEPO(2)-ANTX(2)+ANTXGNSS(2),XRVEPO(3)-ANTX(3)+ANTXGNSS(3)
     &    , PLHEPO(1),PLHEPO(2),
     &               XSV(1), XSV(2), XSV(3), AZ(IDX(IPRN)),
     &               EL(IDX(IPRN)), RNG )
C
        VELAZ(IDX(IPRN))=AZ(IDX(IPRN))
        IF (IPC .GT. 3)
     &   WRITE(*,'(A3,I3.3,1X,A10,16X,A10,F16.4)') 'PRN',IPRN,
     &    'INIT','RNG',RNG
C
C CORRECT AZIMUTH FOR PCV FOR A MOVING RX
C
       RXVEL=sqrt(xrvvel(1)**2+xrvvel(2)**2+xrvvel(3)**2)
      IF(RXVEL.GT.1.d0) THEN  
       IF((-sin(plhepo(2))*xrvvel(1)+
     &     xrvvel(2)*cos(plhepo(2))).LT.0.D0) THEN
         VELAZ(IDX(IPRN)) = VELAZ(IDX(IPRN))
     &    + acos((-sin(plhepo(1))*cos(plhepo(2))*xrvvel(1)-
     &            xrvvel(2)*sin(plhepo(1))*sin(plhepo(2))+
     &            cos(plhepo(1))*xrvvel(3))/RXVEL)
       ELSE
         VELAZ(IDX(IPRN)) = VELAZ(IDX(IPRN))
     &    - acos((-sin(plhepo(1))*cos(plhepo(2))*xrvvel(1)-
     &            xrvvel(2)*sin(plhepo(1))*sin(plhepo(2))+
     &            cos(plhepo(1))*xrvvel(3))/RXVEL)
        ENDIF
      ENDIF
        AZ(IDX(IPRN)) = AZ(IDX(IPRN))*180.0D0/PI
        EL(IDX(IPRN)) = EL(IDX(IPRN))*180.0D0/PI
c!      WRITE(*,*) 'AZ,EL',AZ(IDX(IPRN)),EL(IDX(IPRN))
C
        IF(AZ(IDX(IPRN)).LT.0.D0)
     &        AZ(IDX(IPRN)) = AZ(IDX(IPRN)) +360.0D0
        IF(AZ(IDX(IPRN)).GT.360.D0)
     &        AZ(IDX(IPRN)) = AZ(IDX(IPRN)) -360.0D0
        VELAZ(IDX(IPRN)) = VELAZ(IDX(IPRN))*180.0D0/PI
        IF(VELAZ(IDX(IPRN)).LT.0.D0)
     &        VELAZ(IDX(IPRN)) = VELAZ(IDX(IPRN)) +360.0D0
        IF(VELAZ(IDX(IPRN)).GT.360.D0)
     &        VELAZ(IDX(IPRN)) = VELAZ(IDX(IPRN)) -360.0D0
C
C-----------------------------------------------------------------------
C      REJECT LOW ELEVATION OBSERVATIONS/ECLIPSING & .5H after eclipse
C------------------------------------------------------------------------
C
        IF (.NOT. INIEPO) THEN
          IF ( EL(IDX(IPRN)) .LT. CUTOFF  ) THEN
           IREASON = 7
           CALL OPCREJ ( LPR, IOB, NSVO, ISVO, TTAG, 
     &                   PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                   FCP, ICSLIP,
     &                   ISPR1, ISPR2,
     &                   MSOFF, MSJMP, 
     &                   NRCRJCT, IARC(ISVO(IOB)), IPC, IREASON )
           ITER = 0
           INSVO = 1
           GO TO 100
          END IF
C
C  REJECT ONLY BLK II/IIA A HALF HOUR AFTER A SHADOW EXIT
C
          IF (IECLIPS.EQ.1 .AND.IBLK(IPRN).LE.3) THEN
            I=0
            DO J=1, NECLIPS(IPRN)
             IF(  TTAG(IOB).GE.ECLSTM(IPRN,J).AND.
     &            TTAG(IOB).LE.ECLETM(IPRN,J)+1800.D0) I= J
            END DO
            IF( (TTAG(IOB)-ECLETM(IPRN,I)).GT.0.d0.AND.
     &          (TTAG(IOB)-ECLETM(IPRN,I)).LT.1800.d0 ) THEN
              IREASON = 7
              CALL OPCREJ ( LPR, IOB, NSVO, ISVO, TTAG,
     &                   PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                   FCP, ICSLIP,
     &                   ISPR1, ISPR2,
     &                   MSOFF, MSJMP,
     &                   NRCRJCT, IARC(ISVO(IOB)), IPC, IREASON )
               ITER = 0
               INSVO = 1
               GO TO 100
            END IF
          END IF
C
C EXCLUDE DATA WITHOUT EXTERNAL YAW WHEN IT IS PROVIDED
C
          IF( YAWMODEL .NE. 0 .AND.
     &        PRDC(7,IDX(IPRN)) .LT. -998.D0 ) THEN
           IREASON = 7
           CALL OPCREJ ( LPR, IOB, NSVO, ISVO, TTAG, 
     &                   PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                   FCP, ICSLIP,
     &                   ISPR1, ISPR2,
     &                   MSOFF, MSJMP, 
     &                   NRCRJCT, IARC(ISVO(IOB)), IPC, IREASON )
           ITER = 0
           INSVO = 1
           GO TO 100
          END IF
        END IF
C
C------------------------------------------------------------------------
C     COMPUTE DUAL FREQUENCY IONOSPHERIC DELAY
C------------------------------------------------------------------------
C
        RANGL1 = PR1(IOB)*C
        RANGL2 = PR2(IOB)*C
        IONCOR(IDX(IPRN)) = 0.D0
C
        IF ( NFREQ .EQ. 2 .AND. IFREQ .GE. 3 ) THEN
          CALL IONO ( 1, 0, RANGL1, RANGL2, IONCOR(IDX(IPRN)) )
          ZEN =  PI/2.D0 - EL(IDX(IPRN))*PI/180.0D0
          VIONCOR=IONCOR(IDX(IPRN))*
     &                          DCOS(DASIN(6371.D0*DSIN(0.9782D0*ZEN)/
     &                                               (6371.D0+506.7D0)))
          RANGL1 = PR1(IOB)*C - F1ION*IONCOR(IDX(IPRN))
          RANGL2 = PR2(IOB)*C - F2ION*IONCOR(IDX(IPRN))
          IF (IPC .GT. 2)
     &     WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,F16.4)') 'PRN',IPRN,
     &     'IONCOR',IONCOR(IDX(IPRN)),'OBS',RANGL1
C COMPUTE AND APPLY 2nd IONO CORRECTION (IERS 2010 CONVENTIONS)
          AMBP12 = 0.D0
C AMBP12 - THE P2-P1 PHASE INITIAL AMBIGUITY FROM FLTDF SUBROUTINE
          IF(FLTSUM(1,IPRN).GT.1.D0)
     &      AMBP12=FLTSUM(MAXFLT,IPRN)/FLTSUM(1,IPRN)
          ION2COR(IDX(IPRN)) =  0.D0
C HORDION(1) and HORDION(2) ARE AVG STATION P12 DCB (M) AND VTEC(0.1 TECU)
C FROM PREVIOUS TRACKED EPOCH
C  STADCB GPS HORDION(1), GLN HIORD(3)!
          J=1
          IF(IPRN.GT.32.AND.IPRN.LE.64) J= 3
          IF(.NOT.INIEPO.AND.IOBTYP.EQ.2.AND.PLHEPO(3).LT.450.D03)
     &    CALL IONO2ND(IYEARS, JULD, PLHEPO, XRVEPO, XSV, EL(IDX(IPRN)),
     &                 450.D0, DTM(1), P1(IOB), P2(IOB), DP1P2(IPRN),
     &                 HORDION(J), AMBP12, HORDION(2),
     &                 ION2COR(IDX(IPRN)))
        END IF
C
        IF ( IFREQ .LT. 3 .AND. IONSLM .EQ. 2 ) THEN 
         ZEN =  PI/2.D0 - EL(IDX(IPRN))*PI/180.0D0
         IF (ISLMFMT .EQ. 1 .AND. .NOT. INIEPO)  THEN
           CALL GRDLAY( LPR, IYEAR, IMTH, IDAY, TTAG(1), XRVEPO, XSV, 
     &               ZEN, DTM(1), SLMHGT, MININC, REFLAT, FRLON, 
     &               DLAT, DLON, ADION, RDION, PRNDCB(IPRN), VIONCOR,
     &               IONCOR(IDX(IPRN)), IONREF, TION, PI )
           DTION=UTTAG-TION
c!         WRITE(*,*) 'PPP GRDLAY', IPRN,DTION,IONCOR(IDX(IPRN)),
c!   &                              TION,VIONCOR,PRNDCB(IPRN)
           IF (DABS(DTION) .GT. 1.44D4 .OR.
     &             VIONCOR .EQ. 999.D0 .OR.
     &         DABS(PRNDCB(IPRN)) .GT. 100.D0 ) THEN
             IREASON = 5
c!           WRITE(*,*) 'IONOSPHERIC GRID POINT MISSING',ttag(1),tion
             CALL OPCREJ ( LPR, IOB, NSVO, ISVO, TTAG, 
     &                     PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                     FCP, ICSLIP,
     &                     ISPR1, ISPR2,
     &                     MSOFF, MSJMP, 
     &                     NRCRJCT, IARC(ISVO(IOB)), IPC, IREASON )
             ITER = 0
             INSVO = 1
             GO TO 100
           ELSE
             IF( IMFSEL .GT. 0 )
     &         IONCOR(IDX(IPRN))= (VIONCOR             )*
     &            ION_MF1(IMFSEL,SLMHGT,ZEN,PLHEPO(3)/1.D3)-PRNDCB(IPRN)
             RANGL1 = PR1(IOB)*C - F1ION*IONCOR(IDX(IPRN))
             RANGL2 = PR2(IOB)*C - F2ION*IONCOR(IDX(IPRN))
             IF (IPC .GT. 2)
     &        WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,5F16.4)') 'PRN',IPRN,
     &         'IONCOR',IONCOR(IDX(IPRN))+PRNDCB(IPRN),'OBS',RANGL1,
     &         VIONCOR,(IONCOR(IDX(IPRN))+PRNDCB(IPRN))/VIONCOR,
     &         -PRNDCB(IPRN),-DP1P2(IPRN)*1.D-9*C
           END IF
         END IF
C     
         IF (ISLMFMT .EQ. 2 ) THEN
          CALL IONBRD (AIONBRD, BIONBRD, EL(IDX(IPRN))*PI/180.0D0,
     &                 AZ(IDX(IPRN))*PI/180.D0, PLHEPO(1), PLHEPO(2),
     &                 TTAG(1), PI, C, IONCOR(IDX(IPRN)),VIONCOR)
          IF( IMFSEL .GT. 0 )
     &         IONCOR(IDX(IPRN))= VIONCOR*
     &            ION_MF1(IMFSEL,SLMHGT,ZEN,PLHEPO(3)/1.D3)
c!        WRITE(*,*) F1ION,IONCOR(IDX(IPRN)),TGD(IPRN)
          RANGL1 = PR1(IOB)*C-F1ION*IONCOR(IDX(IPRN))-TGD(IPRN)
          RANGL2 = PR2(IOB)*C-F2ION*IONCOR(IDX(IPRN))-
     &                                F2ION*TGD(IPRN)/F1ION
          IF (IPC .GT. 2)
     &        WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,5F16.4)') 'PRN',IPRN,
     &         'IONCOR',IONCOR(IDX(IPRN)),'OBS',RANGL1,VIONCOR,
     &         IONCOR(IDX(IPRN))/VIONCOR,TGD(IPRN)/F1ION,
     &         -DP1P2(IPRN)*1.D-9*C
         END IF
C compute MRTCA iono correction
         IF (ISLMFMT .EQ. 3 .AND. .NOT. INIEPO ) THEN
          IF( TION .GE. 0 .AND. UTTAG-TION .GE. 0 .AND.
     &        UTTAG-TION .LT. 7200 ) 
     &     CALL RTCADLAY( LPR, PLHEPO(1), PLHEPO(2), AZ(IDX(IPRN)),
     &                    EL(IDX(IPRN)), RTCAVERT, RTCAGIVE,
     &                    VIONCOR, IONCOR(IDX(IPRN)), PI )
          IF( TION .LT. 0 .OR. UTTAG-TION .LT. 0 .OR.
     &        UTTAG-TION .GT. 7200 .OR.  VIONCOR .EQ. 999.D0 .OR.
     &                             SVDCB(IPRN) .GT. 100.D0 ) THEN
            IREASON = 5
c!          WRITE(*,*) 'IONOSPHERIC GRID POINT MISSING',ttag(1),tion
            CALL OPCREJ ( LPR, IOB, NSVO, ISVO, TTAG, 
     &                     PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                     FCP, ICSLIP,
     &                     ISPR1, ISPR2,
     &                     MSOFF, MSJMP, 
     &                     NRCRJCT, IARC(ISVO(IOB)), IPC, IREASON )
            ITER = 0
            INSVO = 1
            GO TO 100
          ELSE
            IF( IMFSEL .GT. 0 )
     &         IONCOR(IDX(IPRN))= VIONCOR*
     &            ION_MF1(IMFSEL,SLMHGT,ZEN,PLHEPO(3)/1.D3)
            RANGL1 = PR1(IOB)*C-IONCOR(IDX(IPRN))-EPH(6)*C
            RANGL2 = PR2(IOB)*C-F2ION*IONCOR(IDX(IPRN))/F1ION
     &               -F2ION*EPH(6)*C/F1ION
            IF (IPC .GT. 2)
     &        WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,5F16.4)') 'PRN',IPRN,
     &         'IONCOR',IONCOR(IDX(IPRN))/F1ION,'OBS',RANGL1,
     &         VIONCOR/F1ION,IONCOR(IDX(IPRN))/VIONCOR,EPH(6)*C/F1ION,
     &         -DP1P2(IPRN)*1.D-9*C
          END IF
         END IF
         IF( (ISLMFMT .GE. 4 .AND. ISLMFMT .LE. 6) .AND.
     &                            .NOT. INIEPO ) THEN
           CALL IONPT( XRVEPO, XSV, ZEN, DTM(1), 1.D3*SLMHGT,
     &                 TECX, TECZ, PI )
           IF( ISLMFMT .EQ. 4 ) THEN
           CALL IPP2TEC( TECZ(1)*180D0/PI, TECZ(2)*180D0/PI, UTTAG,
     &                   SCHA_CLAT, SCHA_CLON, SCHA_CAP, SCHA_INT,
     &                   SCHA_T, SCHA_L, SCHA_M, SCHA_NMN,
     &                   SCHA_ALM, SCHA_BLM, SCHA_NSET, VIONCOR )
           ELSE
           CALL IPPSH2TEC( TECZ(1)*180D0/PI, TECZ(2)*180D0/PI, UTTAG,
     &                   SCHA_INT, SCHA_REF, SCHA_T, SCHA_L, SCHA_M,
     &                   SCHA_NMN, SCHA_ALM, SCHA_BLM, SCHA_DLM,
     &                   SCHA_NSET, VIONCOR, SVIONCOR )
           ENDIF
           IF( VIONCOR .LT. 0.D0 .OR.
     &         SCHA_DCB(IPRN) .EQ. -999.D0 ) THEN
            IREASON = 5
C           WRITE(*,*) 'IONOSPHERIC GRID POINT MISSING',ttag(1),tion
            CALL OPCREJ ( LPR, IOB, NSVO, ISVO, TTAG, 
     &                    PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                    FCP, ICSLIP,
     &                    ISPR1, ISPR2,
     &                    MSOFF, MSJMP, 
     &                    NRCRJCT, IARC(ISVO(IOB)), IPC, IREASON )
            ITER = 0
            INSVO = 1
            GO TO 100
           ELSE
            VIONCOR=VIONCOR/9.52D0
            IONCOR(IDX(IPRN))=VIONCOR/
     &                          DCOS(DASIN(6371.D0*DSIN(0.9782D0*ZEN)/
     &                                               (6371.D0+506.7D0)))
            IF( IMFSEL .GT. 0 )
     &         IONCOR(IDX(IPRN))= VIONCOR*
     &            ION_MF1(IMFSEL,SLMHGT,ZEN,PLHEPO(3)/1.D3)
             RANGL1 = PR1(IOB)*C-
     &               F1ION*(IONCOR(IDX(IPRN))-SCHA_DCB(IPRN)*1.D-9*C)
             RANGL2 = PR2(IOB)*C-
     &               F2ION*(IONCOR(IDX(IPRN))-SCHA_DCB(IPRN)*1.D-9*C)
             IF (IPC .GT. 2)
     &        WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,5F16.4)') 'PRN',IPRN,
     &         'IONCOR',IONCOR(IDX(IPRN)),'OBS',RANGL1,VIONCOR,
     &         IONCOR(IDX(IPRN))/VIONCOR,-SCHA_DCB(IPRN)*1.D-9*C,
     &         -DP1P2(IPRN)*1.D-9*C
           END IF
         END IF
        END IF
C
C------------------------------------------------------------------------
C       COMPUTE EFFECT OF ANTENNA PHASE CENTER VARIATION
C------------------------------------------------------------------------
C
        PCVCOR(IDX(IPRN))  = 0.D0
C
        IF(IPCV.GT.10) THEN
        DZE =( IPCV-(IPCV/100)*100)/10
          ZEN=90.D0-EL(IDX(IPRN))+DZE/2.d0
          IELV=IDINT(ZEN/DZE )+1
          IEL2=IELV + 91       
C INTERPOLATE PCV L1, L2 & L3
C ABSOLUTE SV/RX PCV
          I=1
C AZIM PCV AVAILABLE (DAZIM=5 deg), INTERPOLATE
          IF(IPCV.GT.100) THEN
           DAZ= INT(IPCV/100)
           I= IDINT((VELAZ(IDX(IPRN))+DAZ/2.d0)/DAZ )+1
          END IF
C NADIR ANGLE (DEG)
          ZEN= ACOS(((XSV(1)-XRVEPO(1))*XSV(1)+
     &               (XSV(2)-XRVEPO(2))*XSV(2)+
     &               (XSV(3)-XRVEPO(3))*XSV(3))/RNG/
     &              SQRT(XSV(1)**2+XSV(2)**2+
     &                   XSV(3)**2))*180.0D0/PI
C ALLOW LEOS ( with ZEN > max DEG encoded in PCVSAT(IPRN,43))
          IF(ZEN.GT.PCVSAT(IPRN,43)) ZEN=PCVSAT(IPRN,43)
          IF(IELV.GT.91) THEN
             IELV=91
             IEL2=182
          ELSE IF( IELV.LT.1 ) THEN
             IELV=1
             IEL2=92
          ENDIF
          PCVL1=
     &     (PCVELV(I,IELV,1)+PCVSAT(IPRN,IDINT(ZEN+.5d0)+ 1))/1.d3
          PCVL2=
     &     (PCVELV(I,IEL2,1)+PCVSAT(IPRN,IDINT(ZEN+.5d0)+21+1))/1.d3
C
          IF ( IFREQ .EQ. 1 ) THEN
           PCVCOR(IDX(IPRN))  = PCVL1
          END IF
          IF ( IFREQ .EQ. 2 ) THEN
           PCVCOR(IDX(IPRN))  = PCVL2
          END IF
          IF ( IFREQ .GE. 3 ) THEN
        CALL FREQ12(  IPRN , F1, F2, F1S, F2S, F12S, F1ION, F2ION,
     &                   AL1, AL2, AL3, AL4, IFREQ )
           PCVCOR(IDX(IPRN))  =  PCVL1*F1S/F12S - PCVL2*F2S/F12S
C  GLONASS ION L3 correction (FRQ chanell independent)
           IF(IPRN.GT.32.AND.IPRN.LE.64)
     &      PCVCOR(IDX(IPRN)) = PCVCOR(IDX(IPRN))-
     &                          0.014478d0*(PCVL1-PCVL2)
          END IF
        END IF
C
c!      WRITE(*,'(A20,7F5.3)') ' PCVCOR', 
c!   &                        PCVCOR(IDX(IPRN))
C
C------------------------------------------------------------------------
C       COMPUTE EFFECT OF EARTH TIDES
C------------------------------------------------------------------------
C
        TIDCOR(IDX(IPRN))= 0.d0
        IF(PLHEPO(3).LT.15000.d0) THEN
         TIDCOR(IDX(IPRN))= (ETIDEX(1)*(XSV(1)-XRVEPO(1))+ETIDEX(2)*
     &       (XSV(2)-XRVEPO(2)) + ETIDEX(3)*(XSV(3)-XRVEPO(3)))/RNG
        ENDIF
c!      WRITE(*,'(A5,I5,6F10.3)') 'ETIDE',IPRN,TTAG(IOB),ETIDE(1),
c!   &                      ETIDE(2),ETIDE(3),TIDCOR(IDX(IPRN)),
c!   &                       EL(IDX(IPRN))
C
C------------------------------------------------------------------------
C     COMPUTE TROPOSPHERIC DELAY
C------------------------------------------------------------------------
C
        DOY= JULD+FMJDDT
c!      WRITE(*,*) EL(IDX(IPRN)),DRYEPO,(XRVMRK(I),PLHEPO(I),I=1,3)
C   valid vmf1 mapping function coefficients available, use vmf1!
        IF(coefmf(5,2).gt.0.d0.and.coefmf(5,2).lt.2.d-3) THEN
          CALL VMFINTRP( DMJDT, PLHEPO(1), PLHEPO(3),  EL(IDX(IPRN)),
     &               COEFMF, DRYMAP(IDX(IPRN)), WETMAP(IDX(IPRN)),
     &               DRYEPO , TROHOP)
        ELSE
C use gmf, no valid mapping function coefficients available
          ZEN =  PI/2.D0 - EL(IDX(IPRN))*PI/180.0D0
          CALL GMF( DMJDT, PLHEPO(1),PLHEPO(2), PLHEPO(3),
     &               ZEN           ,DRYMAP(IDX(IPRN)),
     &               WETMAP(IDX(IPRN))                               )
c!        WRITE(*,'(I3, F5.2,"=",F5.2,"*",F5.2,"+",F5.2,"*",F5.2)') 
c!   &    IPRN, TROCOR(IDX(IPRN)), DRYEPO, DRYMAP(IDX(IPRN)),
c!   &                              XRVEPO(5), WETMAP(IDX(IPRN))
        END IF
        TROHOP= DRYEPO*DRYMAP(IDX(IPRN))+ WETEPO*WETMAP(IDX(IPRN))
C
C ON FIRST CODE ONLY FIX, USE FIXED 2.1M CORRECTION MAPPED TO AVERAGE ELEVATION
C OF 37DEG (3.5 = 2.1/SIN(37))
C
        IF (INIEPO .AND. IPXR .EQ. 0) TROHOP=3.5D0
        TROCOR(IDX(IPRN))=TROHOP
c!      write(*,*) DRYEPO, DRYMAP(IDX(IPRN)),
c!   &            XRVEPO(5), WETMAP(IDX(IPRN)),PRES, TROHOP
C
C     TROPOSPHERIC SCALE IS BEING SOLVED
C
        IF ( .NOT. INIEPO .AND. MOD(ITRPSOL,10) .GE. 2) THEN
         IF( ITRPSOL .LT. 100 ) THEN
           TROCOR(IDX(IPRN)) =  DRYEPO*DRYMAP(IDX(IPRN))
         ELSE
           TROCOR(IDX(IPRN))=DRYMAP(IDX(IPRN))* (DRYEPO+ 
     &          (XRVEPO(6)*DCOS(AZ(IDX(IPRN))*PI/180.d0) + 
     &           XRVEPO(7)*DSIN(AZ(IDX(IPRN))*PI/180.d0))
     &          /DTAN(EL(IDX(IPRN))*PI/180.d0))
         END IF
         TROCOR(IDX(IPRN)) =  TROCOR(IDX(IPRN))
     &                         + XRVEPO(5)*WETMAP(IDX(IPRN))
         IF ( IPC .GE. 3 ) 
     &   WRITE(*,7778) IPRN, TROCOR(IDX(IPRN)), DRYEPO,
     &   (XRVEPO(6)*DCOS(AZ(IDX(IPRN))*PI/180.d0) +
     &    XRVEPO(7)*DSIN(AZ(IDX(IPRN))*PI/180.d0))
     &   /DTAN(EL(IDX(IPRN))*PI/180.d0),
     &   DRYMAP(IDX(IPRN)),
     &                              XRVEPO(5), WETMAP(IDX(IPRN))
7778  FORMAT(I3, F5.2,"=(",F5.2,"+",D8.2,")*",F5.2,"+",F5.2,"*",F5.2)
        END IF
C
C------------------------------------------------------------------------
C      COMPUTE SAGNAC CORRECTION 
C------------------------------------------------------------------------
C
        CALL SAGNAC( XRVEPO , XSV , DTM(7) , C , SAGCOR(IDX(IPRN)) )
C
C------------------------------------------------------------------------
C      COMPUTE PHASE WIND-UP CORRECTION 
C------------------------------------------------------------------------
C
c!     WRITE(*,*) 'WUPCOR',IPRN,TWUPCOR(IPRN),PWUPCOR(IPRN),XRVEPO(1)
        CALL WNDUP( IPRN, UTTAG, DTM, XRVEPO, XSV, SANTXYZ, PI,
     &            XRVVEL,
     &            TWUPCOR(IPRN), PWUPCOR(IPRN), WUPCOR(IDX(IPRN)) )
        IF ( IFREQ .EQ. 1 )
     &   WUPCOR(IDX(IPRN)) = WUPCOR(IDX(IPRN))*AL1
        IF ( IFREQ .EQ. 2 )
     &   WUPCOR(IDX(IPRN)) = WUPCOR(IDX(IPRN))*AL2
        IF ( IFREQ .GE. 3 ) THEN
          WUPCOR(IDX(IPRN)) = WUPCOR(IDX(IPRN))*AL3
        ENDIF
C
C------------------------------------------------------------------------
C      COMPUTE RANGE RATE, DIRECTION COSINES AND FORM DESIGN
C------------------------------------------------------------------------
C
        CALL RNGRT ( XRVEPO, XSV, VSV, C, RNG, RRATE, DIRC )
C
        IF ( IOBTYP .EQ. 1 ) THEN
         IOBPR = IOB
        ELSE
         IOBPR = IOB*2-1
         IOBCP = IOB*2
        END IF
        IF(SSVX(1,1,IPRN).NE.0.D0.AND.IPEPINT.GE.60) THEN
C USE EPOCH XYZ & CLK SP3 precision
          I= INT((IHR*3600+IMIN*60+SEC)/IPEPINT) +1
         IF(SSVX(I,1,IPRN).NE.0.D0) THEN
C ADD  8MM TO SP3 EPOCH SIGMAS
          IPEPACC(IPRN)= SQRT( 64 + DIRC(1)**2*SSVX(I,1,IPRN)**2+
     &    DIRC(2)**2*SSVX(I,2,IPRN)**2+ DIRC(3)**2*SSVX(I,3,IPRN)**2)
         ENDIF
C ADD 30PSEC TO SP3 SIGMAS
         IF(ISVCLK.EQ.1) PRDC(2,IDX(IPRN))=SQRT(900+SSVX(I,4,IPRN)**2)
     &    *1.D-12
        END IF
C
C     UPDATE SIGMA OF UNIT WEIGHT (SUW)  USING
C     SATELLITE ELEVATION, ORBIT AND CLOCK INFORMATION
C
        CALL UPDSUW ( IPRN, IOBPR, IOBCP, IDX, EL, IPEPACC, PRDC, 
     &       SDCP, SUWCP, SUWPR, C, PI) 
C
        SUWFAC=1.D0
        IF(IPRN.GT.32.AND.IPRN.LE.64) SUWFAC=2.D0
        SUWFAC=SUWFAC*SDPR*DSQRT(PL(IOBPR,IOBPR))
        EA(IOB,1) = DIRC(1)*(-1.0D0) * SUWPR * SUWFAC
        EA(IOB,2) = DIRC(2)*(-1.0D0) * SUWPR * SUWFAC
        EA(IOB,3) = DIRC(3)*(-1.0D0) * SUWPR * SUWFAC
        EA(IOB,4) = 0.d0 
        IF( IPRN.GE. 1 .AND. IPRN .LE. 32 )
     &    EA(IOB,4) = (-1.0D0)*(C-RRATE)*1.0D-9* SUWPR * SUWFAC
        EA(IOB,5) = 0.d0 
        IF(IPRN.GT.32.AND.IPRN.LE.64)
     &    EA(IOB,5) = (-1.0D0)*(C-RRATE)*1.0D-9* SUWPR * SUWFAC
        A(IOBPR,1) = DIRC(1)*(-1.0D0) * SUWPR
        A(IOBPR,2) = DIRC(2)*(-1.0D0) * SUWPR
        A(IOBPR,3) = DIRC(3)*(-1.0D0) * SUWPR
        A(IOBPR,4) = 0.D0
        IF( IPRN.GE. 1 .AND. IPRN .LE. 32 )
     &    A(IOBPR,4) = (-1.0D0)*(C-RRATE)*1.0D-9* SUWPR
C  GLONASS (PRN.GT.32)
        A(IOBPR,8) = 0.d0 
        IF(IPRN.GT.32.AND.IPRN.LE.64)
     &    A(IOBPR,8) = (-1.0D0)*(C-RRATE)*1.0D-9*SUWPR
C  GALILEO (PRN.GT.64.AND.LE.100)
        A(IOBPR,9) = 0.d0
        IF(IPRN.GT.64.AND.IPRN.LE.100)
     &    A(IOBPR,9) = (-1.0D0)*(C-RRATE)*1.0D-9*SUWPR
C  BEIDOU  (PRN.GT.100.AND.LE.136)
        A(IOBPR,10) = 0.d0
        IF(IPRN.GT.100.AND.IPRN.LE.136)
     &    A(IOBPR,10) = (-1.0D0)*(C-RRATE)*1.0D-9*SUWPR
        A(IOBPR,5) = 0.D0
        A(IOBPR,6) = 0.D0
        A(IOBPR,7) = 0.D0
        IF( MOD(ITRPSOL,10) .GT. 1 ) THEN
        A(IOBPR,5) = WETMAP(IDX(IPRN)) * SUWPR
C DATA ABOVE ANTENNA HORIZON
        IF( ITRPSOL .GT. 100 ) THEN
        IF(EL(IDX(IPRN)).GT.0.D0) THEN
        A(IOBPR,6) =
     &    DRYMAP(IDX(IPRN))*DCOS(AZ(IDX(IPRN))*PI/180.d0)*SUWPR
     &             /DTAN(EL(IDX(IPRN))*PI/180.d0)
        A(IOBPR,7) =
     &    DRYMAP(IDX(IPRN))*DSIN(AZ(IDX(IPRN))*PI/180.d0)*SUWPR
     &             /DTAN(EL(IDX(IPRN))*PI/180.d0)
        ELSE
C DATA BELOW ANTENNA HORIZON
C FOR EL(IPRN).LE.0 USE 3 DEG FOR TROPO GRADIENT MF
        A(IOBPR,6) =
     &    DRYMAP(IDX(IPRN))*DCOS(AZ(IDX(IPRN))*PI/180.d0)*SUWPR
     &             /DTAN(3.D0         *PI/180.d0)
        A(IOBPR,7) =
     &    DRYMAP(IDX(IPRN))*DSIN(AZ(IDX(IPRN))*PI/180.d0)*SUWPR
     &             /DTAN(3.D0         *PI/180.d0)
        ENDIF
        ENDIF
        ENDIF
C
        IF ( IOBTYP .EQ. 2 ) THEN
          A(IOBCP,1) = DIRC(1)*(-1.0D0)*SUWCP 
          A(IOBCP,2) = DIRC(2)*(-1.0D0)*SUWCP 
          A(IOBCP,3) = DIRC(3)*(-1.0D0)*SUWCP 
          A(IOBCP,4) = 0.D0
          IF( IPRN .GE. 1 .AND. IPRN .LE. 32 )
     &      A(IOBCP,4) = (-1.0D0)*(C      )*1.0D-9*SUWCP
C  GLONASS (PRN.GT.32)
          A(IOBCP,8) = 0.d0 
          IF(IPRN.GT.32.AND.IPRN.LE.64)
     &      A(IOBCP,8) = (-1.0D0)*(C      )*1.0D-9*SUWCP
C  GALILEO (PRN.GT.64)
          A(IOBCP,9) = 0.d0
          IF(IPRN.GT.64.AND.IPRN.LE.100)
     &      A(IOBCP,9) = (-1.0D0)*(C      )*1.0D-9*SUWCP
C  BEIDOU  (PRN.GT.101.AND. PRN.LE132)
          A(IOBCP,10) = 0.d0
          IF(IPRN.GT.101.AND.IPRN.LE.136)
     &      A(IOBCP,10) = (-1.0D0)*(C      )*1.0D-9*SUWCP
          A(IOBCP,5) = 0.D0
          A(IOBCP,6) = 0.D0
          A(IOBCP,7) = 0.D0
          IF( MOD(ITRPSOL,10) .GT. 1 ) THEN
          A(IOBCP,5) = WETMAP(IDX(IPRN))*SUWCP
          IF( ITRPSOL .GT. 100 ) THEN
          A(IOBCP,6) =
     &      DRYMAP(IDX(IPRN))*DCOS(AZ(IDX(IPRN))*PI/180.d0)*SUWCP
     &             /DTAN(EL(IDX(IPRN))*PI/180.d0)
          A(IOBCP,7) =
     &      DRYMAP(IDX(IPRN))*DSIN(AZ(IDX(IPRN))*PI/180.d0)*SUWCP
     &             /DTAN(EL(IDX(IPRN))*PI/180.d0)
          ENDIF
          ENDIF
          A(IOBCP,NFPAR+IOB) = (-1.0D0)*(C      )*1.0D-9*SUWCP
        END IF
C
C------------------------------------------------------------------------
C APPLY SATELLITE CLOCK CORRECTIONS TO GPS TIME
C------------------------------------------------------------------------
C
        PSATCOR(IOB) = SATCOR
C
C      IF STATION CLOCK AND TROP ARE INPUT .AND. STATION POSITION FIXED
C       ==> SATELLITE CLOCKS ARE SOLVED, SET SATCOR=0
C
        IF ( ISVEPH .EQ. 1 .AND. (ISVCLK .EQ. 1 .OR. ISVCLK .GE. 3) )
     &     SATCOR = EPH(11) + EPH(10)*TXTIM + EPH(9)*TXTIM*TXTIM
C
C!!    MRTCA/RTCM CLOCK CORRECTIONS APPLIED TO BROADCAST CLOCKS
C!!
C!!        This code is Ok! You can choose to apply the MRTCA/RTCM-SSR correction
C!!        on the BRD computed satellite clocks or on the observation,
C!!        as done later. If the following is uncommented, the observation
C!!        correction should be commented, and vice-versa
C!!
C!! Code Beg ==================================================================
        IF ( ISVCLK .GE. 3 ) 
     &     SATCOR = SATCOR - PRDC(1,IDX(IPRN))/C
C!! Code End ==================================================================
        IF ( ISVCLK .EQ. 2 ) 
     &                 SATCOR = PRDC(1,IDX(IPRN))/C
C AR when gpsppp.nsb NL bias in prdc(10, iprn)
        RNG = RNG - C * SATCOR-PRDC(10,iprn)
C
        IF (IPC .GE. 3)
     &  WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,F16.4)') 'PRN',IPRN,
     &    'SATCOR',-(C*SATCOR),'RNG',RNG
C
C------------------------------------------------------------------------
C      APPLY RECEIVER CLOCK CORR FROM LAST ITERATION
C------------------------------------------------------------------------
C
C GPS
        IF( IPRN .GE. 1 .AND. IPRN .LE. 32 )
     &    RNG = RNG - C * XRVEPO(4)
C GLONASS
        IF(IPRN.GT.32.AND.IPRN.LE.64)
     &    RNG = RNG - C * XRVEPO(8)
C GALILEO
        IF(IPRN.GT.64.AND.IPRN.LE.100)
     &    RNG = RNG - C * XRVEPO(9)
C BEIDOU 
        IF(IPRN.GT.100.AND.IPRN.LE.136)
     &    RNG = RNG - C * XRVEPO(10)
        IF (IPC .GT. 2) THEN
          IF(IPRN.GE.1.AND.IPRN.LE.32)
     &    WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,F16.4)') 'PRN',IPRN,
     &    'XRVEPO(4)',-(C*XRVEPO(4)),'RNG',RNG
          IF(IPRN.GT.32.AND.IPRN.LE.64)
     &    WRITE(*,'(A3,I2.2,1X,A10,F16.4,A10,F16.4)') 'PRN',IPRN,
     &    'XRVEPO(8)',-(C*XRVEPO(8)),'RNG',RNG
          IF(IPRN.GT.64.AND.IPRN.LE.100)
     &    WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,F16.4)') 'PRN',IPRN,
     &    'XRVEPO(9)',-(C*XRVEPO(9)),'RNG',RNG
          IF(IPRN.GT.100.AND.IPRN.LE.136)
     &    WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,F16.4)') 'PRN',IPRN,
     &    'XRVEPO(10)',-(C*XRVEPO(10)),'RNG',RNG
        ENDIF
C
        OFMJDDT=FMJDDT
        CALL RELATE ( IPRN, XRVEPO, XSV, VSV, MJD, OFMJDDT, DTM(7), C,
     &                SRELCOR(IDX(IPRN)), SRELINI )
C
        RNG = RNG + TROCOR(IDX(IPRN))
        IF (IPC .GE. 3)
     &    WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,F16.4)') 'PRN',IPRN,
     &    'TROCOR',TROCOR(IDX(IPRN)),'RNG',RNG
C
        RNG = RNG + SRELCOR(IDX(IPRN))
        IF (IPC .GE. 3)
     &    WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,F16.4)') 'PRN',IPRN,
     &    'SRELCOR',SRELCOR(IDX(IPRN)),'RNG',RNG
C
        RNG = RNG + SAGCOR(IDX(IPRN))
        IF (IPC .GE. 3)
     &    WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,F16.4)') 'PRN',IPRN,
     &    'SAGCOR',SAGCOR(IDX(IPRN)),'RNG',RNG
C
        RNG = RNG - TIDCOR(IDX(IPRN))
        IF (IPC .GE. 3)
     &    WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,F16.4)') 'PRN',IPRN,
     &    'TIDCOR',-TIDCOR(IDX(IPRN)),'RNG',RNG
C
C      PHASE WIND UP CORRECTION
C
        RNG= RNG + WUPCOR(IDX(IPRN))
        IF (IPC .GE. 3)
     &    WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,F16.4)') 'PRN',IPRN,
     &    'WUPCOR',WUPCOR(IDX(IPRN)),'RNG',RNG
C
C      2ND ORDER IONO CORRECTION
C
        RNG= RNG + ION2COR(IDX(IPRN))
        IF (IPC .GE. 3)
     &    WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,F16.4)') 'PRN',IPRN,
     &    'ION2COR',ION2COR(IDX(IPRN)),'RNG',RNG
C
C      ANTENNA PHASE CENTER VARIATION CORRECTION
C
        RNG= RNG + PCVCOR(IDX(IPRN))
        IF (IPC .GE. 3)
     &    WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,F16.4)') 'PRN',IPRN,
     &    'PCVCOR',PCVCOR(IDX(IPRN)),'RNG',RNG
C
C!!
C!!    MRTCA/RTCM CLOCK CORRECTIONS APPLIED TO OBSERVATIONS
C!!
C!!        This code is Ok! You can choose to apply the MRTCA/RTCM correction
C!!        on the observations or directly on BRD computed satellite clocks,
C!!        as done earlier. If the following is uncommented, the computed clock
C!!        correction should be commented, and vice-versa.
C!!
C!! Code Beg ==================================================================
C!!     IF( ISVCLK .GE. 3 ) THEN
C!!       RNG= RNG + PRDC(1,IDX(IPRN))               
C!!       IF (IPC .GE. 3)
C!!  &    WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,F16.4)') 'PRN',IPRN,
C!!  &    'RTCLKCOR',+PRDC(1,IDX(IPRN)),'RNG',RNG
C!! Code End ==================================================================
C
C!!
C!!    MRTCA/RTCM ORBIT CORRECTIONS APPLIED TO OBSERVATIONS
C!!
C!!        This code is Ok! You can choose to apply the MRTCA/RTCM correction
C!!        on the observations or directly on BRD computed satellite positions,
C!!        as done earlier. If the following is uncommented, the sat. position
C!!        correction should be commented, and vice-versa.
C!!
C!! Code Beg ==================================================================
C!!       IF( ISVCLK .EQ. 4 )
C!!  &      CALL RTCM_RACTOXYZ( XSV, VSV, DORBC(7,IOB), DORBC(1,IOB) )
C!!       RNG= RNG
C!!  &      +DORBC(1,IDX(IPRN))*((XSV(1)-XRVEPO(1))
C!!  &      /DSQRT((XSV(1)-XRVEPO(1))**2+(XSV(2)-XRVEPO(2))**2
C!!  &             +(XSV(3)-XRVEPO(3))**2))
C!!  &      +DORBC(2,IDX(IPRN))*((XSV(2)-XRVEPO(2))
C!!  &      /DSQRT((XSV(1)-XRVEPO(1))**2+(XSV(2)-XRVEPO(2))**2
C!!  &             +(XSV(3)-XRVEPO(3))**2))
C!!  &      +DORBC(3,IDX(IPRN))*((XSV(3)-XRVEPO(3))
C!!  &      /DSQRT((XSV(1)-XRVEPO(1))**2+(XSV(2)-XRVEPO(2))**2
C!!  &             +(XSV(3)-XRVEPO(3))**2))
C!!       IF (IPC .GE. 3)
C!!  &    WRITE(*,'(A3,I2.2,1X,A10,F16.4,A10,F16.4)') 'PRN',IPRN,
C!!  &    'RTORBCOR',
C!!  &      +DORBC(1,IDX(IPRN))*((XSV(1)-XRVEPO(1))
C!!  &      /DSQRT((XSV(1)-XRVEPO(1))**2+(XSV(2)-XRVEPO(2))**2
C!!  &             +(XSV(3)-XRVEPO(3))**2))
C!!  &      +DORBC(2,IDX(IPRN))*((XSV(2)-XRVEPO(2))
C!!  &      /DSQRT((XSV(1)-XRVEPO(1))**2+(XSV(2)-XRVEPO(2))**2
C!!  &             +(XSV(3)-XRVEPO(3))**2))
C!!  &      +DORBC(3,IDX(IPRN))*((XSV(3)-XRVEPO(3))
C!!  &      /DSQRT((XSV(1)-XRVEPO(1))**2+(XSV(2)-XRVEPO(2))**2
C!!  &             +(XSV(3)-XRVEPO(3))**2)),'RNG',RNG
C!!     END IF
C!! Code End ==================================================================
C
C------------------------------------------------------------------------
C APPLY RANGE CORRECTIONS IF REQUIRED
C------------------------------------------------------------------------
C
        IF ( NFREQ .GE. 1 .AND. IFREQ .EQ. 1 .AND. IOBTYP .EQ. 1 )
     &    RANGL = RANGL1
C
        IF ( NFREQ .GE. 1 .AND. IFREQ .EQ. 2 .AND. IOBTYP .EQ. 1 )
     &    RANGL = RANGL2
C
        IF ( NFREQ .EQ. 2 .AND. IFREQ .GE. 3 .AND. IOBTYP .EQ. 1 )
     &    RANGL = RANGL1
C
        IF ( IOBTYP .EQ. 2 ) THEN
          RANGP = FCP(IOB)*C
         IF (IFREQ .EQ. 2)
     &    RANGP = RANGP + DP1P2(IPRN)*C*0.5D-9 
         RANGL = RANGL1 + PRDC(8,IPRN)
         IF ( IFREQ .EQ. 1 .AND. IONSLM .NE. 2 ) THEN
          VIONCOR = HORDION(2)*40.309D15/F1S
          IONCOR(IDX(IPRN)) = VIONCOR
     &    /SQRT(1.d0-(1.d0-SIN(EL(IDX(IPRN))/57.296d0)**2)*0.87253D0)
          IF( IMFSEL .GT. 0 ) THEN
            ZEN =  PI/2.D0 - EL(IDX(IPRN))*PI/180.0D0
            IONCOR(IDX(IPRN))= VIONCOR*
     &            ION_MF1(IMFSEL,450.D0,ZEN,PLHEPO(3)/1.D3)
          ENDIF
          RANGL = RANGL - IONCOR(IDX(IPRN))
C MAKES COMPATBLE WITH P3/L3 SAT CLOCKS
     &    + DP1P2(IPRN)*C*1.546D-9
          IF (IPC .GT. 2)
     &      WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,4F16.4)') 'PRN',IPRN,
     &        'IONCOR',IONCOR(IDX(IPRN)),'OBS',RANGL,
     &        VIONCOR,IONCOR(IDX(IPRN))/VIONCOR,
     &        -DP1P2(IPRN)*C*1.D-9
         ENDIF
         IF (IFREQ .EQ. 2 .AND. IONSLM .NE. 2 ) THEN 
          RANGL=RANGL2
          VIONCOR = HORDION(2)*40.309D15/F2S
          IONCOR(IDX(IPRN)) = VIONCOR
     &    /SQRT(1.d0-(1.d0-SIN(EL(IDX(IPRN))/57.296d0)**2)*0.87253D0)
          IF( IMFSEL .GT. 0 ) THEN
            ZEN =  PI/2.D0 - EL(IDX(IPRN))*PI/180.0D0
            IONCOR(IDX(IPRN))= VIONCOR*
     &            ION_MF1(IMFSEL,450.D0,ZEN,PLHEPO(3)/1.D3)
          ENDIF
          RANGL = RANGL - IONCOR(IDX(IPRN))
C MAKES COMPATBLE WITH P3/L3 SAT CLOCKS
     &    + DP1P2(IPRN)*C*2.546D-9
          IF (IPC .GT. 2)
     &      WRITE(*,'(A3,I3.3,1X,A10,F16.4,A10,4F16.4)') 'PRN',IPRN,
     &        'IONCOR',IONCOR(IDX(IPRN)),'OBS',RANGL,
     &        VIONCOR,IONCOR(IDX(IPRN))/VIONCOR,
     &        -DP1P2(IPRN)*C*1.D-9
         ENDIF
        END IF
C
        IF ( IDIR .EQ.-1 .AND. UTTAG .EQ. ENDTTAG .AND.
     &       IABRST.EQ.0 ) THEN
        IF(IOB.GE.NSVO) IABRST= 1
        END IF
        IF ( IOBTYP .EQ. 2 ) THEN 
          RANGP = RANGP + CPAMB(IPRN)
        ELSE IF  ( .NOT. UPDEPO ) THEN
          RANGP = RANGP + CPAMB(IPRN)
        END IF      
c!      WRITE(*,*) 'IPRN,RANGP,CPAMB(IPRN)',IPRN,RANGP,CPAMB(IPRN),IOBTYP
C
C------------------------------------------------------------------------
C COMPUTE RANGE DIFFERENCE ( COMPUTED - OBSERVED ) (W MATRIX)
C------------------------------------------------------------------------
C
        DPRCP(IPRN)=RANGL-RANGP
C CHECK PR/CLKOFF MS CONSISTENCY IN BWD RUN
        IF(IDIR.LT.0.AND.ABS(DPRCP(IPRN)).GT.290.d3) THEN
          RANGP=RANGP+DPRCP(IPRN)*
     &     INT((DABS(DPRCP(IPRN))+1.d3)/DPRCP(IPRN))*
     &     299792.458D0/DPRCP(IPRN)
        CPAMB(IPRN)=CPAMB(IPRN)+DPRCP(IPRN)*
     &     INT((DABS(DPRCP(IPRN))+1.d3)/DPRCP(IPRN))*
     &     299792.458D0/DPRCP(IPRN)
        END IF 
        DELTAR = RNG - WUPCOR(IDX(IPRN)) - RANGL
        DELTAP = RNG - RANGP
C - L1, L2 affected by 1/2 wupcor only
        IF(IFREQ.LT.3)  DELTAP = DELTAP- WUPCOR(IDX(IPRN))/2.d0 
c!      WRITE(*,*) 'Before DELTAR',ihr,imin,sec,DELTAR,DELTAP,CLKOFF
C
        DELTAR = (DELTAR - CLKOFF)
        DELTAP = (DELTAP - CLKOFF)
C CHECK FOR MS PSEUDORANGE JUMP
        IF( O_GPS ) THEN
         IOBP=IOBP_GPS
         DELTAPP=DELTAPP_GPS
         DELTARP=DELTARP_GPS
        ELSE IF ( O_GLN ) THEN
         IOBP=IOBP_GLN
         DELTAPP=DELTAPP_GLN
         DELTARP=DELTARP_GLN
      ELSE IF ( O_GAL ) THEN
        IOBP=IOBP_GAL
        DELTAPP=DELTAPP_GAL
        DELTARP=DELTARP_GAL
      ELSE IF ( O_BEI ) THEN
        IOBP=IOBP_BEI
        DELTAPP=DELTAPP_BEI
        DELTARP=DELTARP_BEI
        ELSE
         IOBP=0
         DELTAPP=0.D0
         DELTARP=0.D0
        END IF
      IF(.NOT.INIEPO                 ) THEN 
       IF( IOBP .NE. 0 ) THEN
C CHECK THE SAME GNSS ONLY (DUE TO DIFF CLOCKS!)
        IF(DABS(DELTAR-DELTARP).GT.298792.D0
     &   .AND.MOD(ABS(DELTAR-DELTARP)+1.d2,299792.458D0).LT.2.D2) THEN  
C SKIP 1st OBS
        IF(DELTARP.NE.0.D0.AND.(DELTAR-DELTARP).NE.0.D0)
     &   DELTAR= DELTAR-(DELTAR-DELTARP)*INT((DABS(DELTAR-DELTARP)+1.D3)
     &   /299792.458D0)*299792.458D0/DABS(DELTAR-DELTARP)
        IF(DELTAPP.NE.0.D0.AND.DABS(DELTAP-DELTAPP).GT.298792.D0)
     &   DELTAP= DELTAP-(DELTAP-DELTAPP)*INT((DABS(DELTAP-DELTAPP)+1.D3)
     &   /299792.458D0)*299792.458D0/DABS(DELTAP-DELTAPP)
        ENDIF
       ENDIF
      ENDIF
C
C STORE MISCLOSURE FOR LATER GROUP SCREENING
C
       MISCR(IOB) = DELTAR
       MISCP(IOB) = DELTAP
       KR=0
       KP=0
       IF( O_GPS ) THEN
        IOBP_GPS=IOB
        DELTARP_GPS = DELTAR
        DELTAPP_GPS = DELTAP
C SELECT CONSTELLATION INDEX
        CMISC=1
       ENDIF
       IF( O_GLN ) THEN
        IOBP_GLN=IOB
        DELTARP_GLN = DELTAR
        DELTAPP_GLN = DELTAP
C SELECT CONSTELLATION INDEX
        CMISC=2
       ENDIF
       IF( O_GAL ) THEN
        IOBP_GAL=IOB
        DELTARP_GAL = DELTAR
        DELTAPP_GAL = DELTAP
        CMISC=3
       ENDIF
       IF( O_BEI ) THEN
        IOBP_BEI=IOB
        DELTARP_BEI = DELTAR
        DELTAPP_BEI = DELTAP
        CMISC=4
       ENDIF
C
C BUILD CONSTELLATION-SPECIFIC INDEX LISTS FOR GROUPED MISCLOSURE TESTING
C NEGATIVE INDECES MEAN EXCLUDE MISCLOSURE FROM TESTING
C CURRENTLY DONE PHASE ONLY FOR RESET/UNCONVERGED AMBGUITIES
C
       DO I=1,NMISC(CMISC)
         IF( DELTAR .GT. MISCR(IMISCR(I,CMISC)) ) KR=I
         IF( DELTAP .GT. MISCP(ABS(IMISCP(I,CMISC))) ) KP=I
       END DO
       KR=KR+1
       DO I=NMISC(CMISC),KR,-1
        IMISCR(I+1,CMISC)=IMISCR(I,CMISC)
       END DO
       IMISCR(KR,CMISC)=IOB
       KP=KP+1
       DO I=NMISC(CMISC),KP,-1
        IMISCP(I+1,CMISC)=IMISCP(I,CMISC)
       END DO
       J=0
       DO I=1,NSVOL
         IF( ISVOL(I) .EQ. ISVO(IOB) ) J=I
       END DO
       IF( J .NE. 0 .AND. ICSLIP15(ISVO(IOB)).EQ.0 .AND.
     &     SCPAMB(ISVO(IOB)) .LT. 0.06D0 .AND.
     &     SCPAMB(ISVO(IOB)) .GT. 0.D0 ) THEN
        IMISCP(KP,CMISC)=IOB
       ELSE
        IMISCP(KP,CMISC)=-IOB
       END IF
       NMISC(CMISC)=NMISC(CMISC)+1
c!      WRITE(*,*) 'After DELTAR',ihr,imin,sec,DELTAR,DELTAP,CLKOFF
C
        W(IOBPR,1) = DELTAR*SUWPR
        IF ( IOBTYP .EQ. 2 ) W(IOBCP,1) = DELTAP*SUWCP
C
        IF ( IPC .GT. 1) THEN
          WRITE(*,'(A4,2X,A14,4F14.3)') STNA,
     &          'X,Y,Z        ',XRVEPO(1),XRVEPO(2),XRVEPO(3)
     &         ,CLKOFF
          WRITE(*,'(A3,I3.3,1X,A14,7F14.3)') 'PRN',IPRN,
     &                   'X,Y,Z,CLK(m)',XSV(1),XSV(2),XSV(3),
     &                    SATCOR*C,DELTAT,TXTIM,EPH(7)
          WRITE(*,'(A3,I3.3,1X,A14,8F12.2)') 'PRN',IPRN,
     &            'OC,OP,C,DC,O-C',RANGL,RANGP,RNG,PRDC(1,IDX(IPRN)),
     &             DELTAR, DELTAP,CPAMB(IPRN),PRDC(2,IDX(IPRN))*C
          WRITE(LPR,'(A4,2X,A18,3F14.2)') STNA,
     &            'X, Y, Z         ',XRVEPO(1),XRVEPO(2),XRVEPO(3)
          WRITE(LPR,'(A3,I3.3,1X,A18,4F14.2)') 'PRN',IPRN,
     &                   'X, Y, Z, CLK (m)',XSV(1),XSV(2),XSV(3),
     &                    SATCOR*C
          WRITE(LPR,'(A3,I3.3,1X,A14,8F12.2)') 'PRN',IPRN,
     &            'OC,OP,C,DC,O-C',RANGL,RANGP,RNG,PRDC(1,IDX(IPRN)),
     &             DELTAR, DELTAP,CPAMB(IPRN),PRDC(2,IDX(IPRN))*C
        END IF
c!      IF ( IOBTYP .EQ. 2 ) 
c!   &  WRITE(*,'(A3,I2.2,1X,A18,4F14.2)') 'PRN',IPRN,
c!   &            'OBS,CMP,DC,OBS-CMP(m)',RANGP,RNG,PRDC(1,IDX(IPRN)),
c!   &                                    DELTAP
200   CONTINUE
C
C  *********************  END OF OBSERVATION LOOP **********************
C
C
C NEW MISCLOSURE TESTING PERFORMED OVER ORDERED LISTS ON 1ST ITERATION
C ALWAYS PERFORMED UNDER STATIC AND WHEN IN KINEMATIC MODE
C ONLY WITH VALID STATION VELOCITY AND WITHIN 3*SOLUTION INTERVAL
C AND POS PREDICTION QUALITY WITHIN 3*SDPR (3*SDCP resp)
C
      IF( .NOT.INIEPO .AND. TESTMISC .AND.
     &    (IMODE.EQ.1.OR.IDIR.LT.0.OR.(NFIX.GT.1.AND.
     &        DABS(UTTAG-SOLTTAG).LE.3.D0*UPDINT) ) ) THEN
       NSVRJCT=0
       IF( IPC .GE. 3 ) 
     & WRITE(*,'(A,1X,3F16.3)') 'XRVACC3D :',UTTAG,XRVACC3D,PRDPOSQLT
C
C THROUGH GROUPING OF MISCLOSURE BY SIZES COMPUTING AVERAGE WITHIN GROUPS
C 1MS JUMPS HAVE ALREADY BEEN CHECKED AND POSSIBLY CORRECTED
C
C LOOP OVER CONSTELLATIONS: 1: GPS 2: GLN
C
       DO CMISC=1,2
        IF( NMISC(CMISC) .GT. 0 ) THEN
         NMISCRGRP=1
         NMISCPGRP=1
         MISCRAVG(1)=0.D0
         MISCRSTD(1)=0.D0
         MISCRCNT(1)=0
         MISCPAVG(1)=0.D0
         MISCPSTD(1)=0.D0
         MISCPCNT(1)=0
C
C INITIALIZE INDEX OF FIRST VALID MISCLOSURE
C
         KR=0
         KP=0
         DO I=NMISC(CMISC),1,-1
C CODE GROUP
           IF(IMISCR(I,CMISC) .GT. 0 ) 
     &       KR=I
C PHASE GROUP
           IF(IMISCP(I,CMISC) .GT. 0 )
     &       KP=I
         END DO
C
C FORM MISCLOSURE GROUPS AND COMPUTE MISC AVERAGE, STDEV & COUNTS
C GROUPS ARE DEFINED AS : 
C LOWEST_MISC_OF_HIGHER_GROUP-HIGHEST_MISC_OF_LOWEST_GROUP > 9*OBS_STD
C
C CODE GROUPS
         DO I= 1,NMISC(CMISC)
          IF(MISCFACTR.GT.0.D0 .AND.
     &       IMISCR(I,CMISC) .GT. 0 .AND. PRDPOSQLT .LT. 6*SDPR ) THEN
C IS NEW GROUP? FINALIZE STATS AND ADD GROUP
           IF( ABS(MISCR(IMISCR(I,CMISC))-MISCR(IMISCR(KR,CMISC))).GT.
     &                                           MISCFACTR*SDPR ) THEN
            MISCRAVG(NMISCRGRP)=MISCRAVG(NMISCRGRP)/MISCRCNT(NMISCRGRP)
            MISCRSTD(NMISCRGRP)=MISCRSTD(NMISCRGRP)/MISCRCNT(NMISCRGRP)
            MISCRSTD(NMISCRGRP)=
     &        SQRT(DABS(MISCRSTD(NMISCRGRP)-MISCRAVG(NMISCRGRP)**2))
            IF( IPC .GE. 3 )
     &      WRITE(*,'(A,I2,I4,2(F15.4,F10.4))')
     &      'CODE MISCLOSURE GROUP:',NMISCRGRP,MISCRCNT(NMISCRGRP),
     &      MISCRAVG(NMISCRGRP),MISCRSTD(NMISCRGRP),
     &      MISCR(IMISCR(I,CMISC))-MISCR(IMISCR(KR,CMISC)),
     &      MISCFACTR*SDPR
            NMISCRGRP=NMISCRGRP+1
            MISCRAVG(NMISCRGRP)=0.D0
            MISCRSTD(NMISCRGRP)=0.D0
            MISCRCNT(NMISCRGRP)=0
           END IF
C ASSIGN GROUP INDEX AND GATHER STATS
           IMISCR_GRP(I)=NMISCRGRP
           MISCRAVG(NMISCRGRP)= MISCRAVG(NMISCRGRP)+
     &          MISCR(IMISCR(I,CMISC))
           MISCRSTD(NMISCRGRP)= MISCRSTD(NMISCRGRP)+
     &          MISCR(IMISCR(I,CMISC))**2
           MISCRCNT(NMISCRGRP)=MISCRCNT(NMISCRGRP)+1
           KR=I
          ELSE
           IMISCR_GRP(I)=0
          END IF
          IF( IPC .GE. 3 )
     &    WRITE(*,'(A,I2," PRN",I3.3,F15.4)')
     &    'CODE MISCLOSURE :',
     &    IMISCR_GRP(I),ISVO(ABS(IMISCR(I,CMISC))),
     &    MISCR(ABS(IMISCR(I,CMISC)))
         END DO
C FINALIZE LAST CODE GROUP STATS
         IF( MISCRCNT(NMISCRGRP) .NE. 0 ) THEN
          MISCRAVG(NMISCRGRP)=MISCRAVG(NMISCRGRP)/MISCRCNT(NMISCRGRP)
          MISCRSTD(NMISCRGRP)=MISCRSTD(NMISCRGRP)/MISCRCNT(NMISCRGRP)
          MISCRSTD(NMISCRGRP)=
     &      SQRT(DABS(MISCRSTD(NMISCRGRP)-MISCRAVG(NMISCRGRP)**2))
          IF( IPC .GE. 3 )
     &    WRITE(*,'(A,I2,I4,2(F15.4,F10.4),F10.4)')
     &    'CODE MISCLOSURE GROUP:',NMISCRGRP,MISCRCNT(NMISCRGRP),
     &    MISCRAVG(NMISCRGRP),MISCRSTD(NMISCRGRP),XRVACC3D,
     &    PRDPOSQLT,MISCFACTR*SDPR
         ELSE IF( IPC .EQ. 3 ) THEN
          WRITE(*,'(A,I2,F15.4,2F10.4)')
     &    'NO CODE MISCLOSURE GROUP:',
     &       MISCRCNT(NMISCRGRP), XRVACC3D, PRDPOSQLT, 6*SDPR
         ENDIF
C IDENTIFY CODE GROUP WITH LARGEST COUNT
C CURRENTLY GROUP AVERAGE&STDEV ARE NOT USED, JUST REPORTED
         KR=NMISCRGRP
         DO I= 1,NMISCRGRP
          IF( MISCRCNT(I) .GT. MISCRCNT(KR) ) KR=I
         END DO
C MAKE UP EXCLUDE LIST WITH ALL SATS FROM ALL OTHER GROUPS, IF ANY
         DO I= 1,NMISC(CMISC)
          IF( KR .GT. 0 .AND. IMISCR_GRP(I) .GT. 0 .AND.
     &                        IMISCR_GRP(I) .NE. KR ) THEN
           NSVRJCT = NSVRJCT + 1
           ISVRJCT(NSVRJCT) = ISVO(IMISCR(I,CMISC))
          END IF
         END DO
C
C PHASE GROUPS
C
         DO I= 1,NMISC(CMISC)
          IF(MISCFACTP.GT. 0.D0 .AND. 
     &       IMISCP(I,CMISC) .GT. 0 .AND. PRDPOSQLT .LT. 6*SDCP ) THEN
C IS NEW GROUP? FINALIZE STATS AND ADD GROUP
           IF( ABS(MISCP(IMISCP(I,CMISC))-MISCP(IMISCP(KP,CMISC))).GT.
     &                                           MISCFACTP*SDCP ) THEN
            MISCPAVG(NMISCPGRP)=MISCPAVG(NMISCPGRP)/MISCPCNT(NMISCPGRP)
            MISCPSTD(NMISCPGRP)=MISCPSTD(NMISCPGRP)/MISCPCNT(NMISCPGRP)
            MISCPSTD(NMISCPGRP)=
     &        SQRT(DABS(MISCPSTD(NMISCRGRP)-MISCPAVG(NMISCPGRP)**2))
            IF( IPC .GE. 3 )
     &      WRITE(*,'(A,I2,I4,2(F15.4,F10.4))')
     &      'PHASE MISCLOSURE GROUP:',NMISCPGRP,MISCPCNT(NMISCPGRP),
     &      MISCPAVG(NMISCPGRP),MISCPSTD(NMISCPGRP),
     &      MISCP(IMISCP(I,CMISC))-MISCP(IMISCP(KP,CMISC)),
     &      MISCFACTP*SDCP
            NMISCPGRP=NMISCPGRP+1
            MISCPAVG(NMISCPGRP)=0.D0
            MISCPSTD(NMISCPGRP)=0.D0
            MISCPCNT(NMISCPGRP)=0
           END IF
C ASSIGN GROUP INDEX AND GATHER STATS
           IMISCP_GRP(I)=NMISCPGRP
           MISCPAVG(NMISCPGRP)=MISCPAVG(NMISCPGRP)+
     &          MISCP(IMISCP(I,CMISC))
           MISCPSTD(NMISCPGRP)=MISCPSTD(NMISCPGRP)+
     &          MISCP(IMISCP(I,CMISC))**2
           MISCPCNT(NMISCPGRP)=MISCPCNT(NMISCPGRP)+1
           KP=I
          ELSE
           IMISCP_GRP(I)=0
          END IF
          IF( IPC .GE. 3 )
     &    WRITE(*,'(A,I2," PRN",I3.3,F15.4,2F10.4)')
     &    'PHASE MISCLOSURE :',
     &    IMISCP_GRP(I),ISVO(ABS(IMISCP(I,CMISC))),
     &    MISCP(ABS(IMISCP(I,CMISC))),
     &    DCPAMB(ISVO(ABS(IMISCP(I,CMISC)))),
     &    SCPAMB(ISVO(ABS(IMISCP(I,CMISC))))
         END DO
C FINALIZE LAST PHASE GROUP STATS
         IF( MISCPCNT(NMISCPGRP) .NE. 0 ) THEN
          MISCPAVG(NMISCPGRP)=MISCPAVG(NMISCPGRP)/MISCPCNT(NMISCPGRP)
          MISCPSTD(NMISCPGRP)=MISCPSTD(NMISCPGRP)/MISCPCNT(NMISCPGRP)
          MISCPSTD(NMISCPGRP)=
     &      SQRT(DABS(MISCPSTD(NMISCPGRP)-MISCPAVG(NMISCPGRP)**2))
          IF( IPC .GE. 3 )
     &    WRITE(*,'(A,I2,I4,2(F15.4,F10.4),F10.4)')
     &    'PHASE MISCLOSURE GROUP:',NMISCPGRP,MISCPCNT(NMISCPGRP),
     &    MISCPAVG(NMISCPGRP),MISCPSTD(NMISCPGRP),XRVACC3D,
     &    PRDPOSQLT,MISCFACTP*SDCP
         ELSE IF( IPC .EQ. 3 ) THEN
          WRITE(*,'(A,I2,F15.4,2F10.4)')
     &    'NO PHASE MISCLOSURE GROUP:',
     &       MISCPCNT(NMISCPGRP), XRVACC3D, PRDPOSQLT, 6*SDCP
         ENDIF

C IDENTIFY PHASE GROUP WITH LARGEST COUNT
C CURRENTLY GROUP AVERAGE&STDEV ARE NOT USED, JUST REPORTED
         KP=NMISCPGRP
         DO I= 1,NMISCPGRP
          IF( MISCPCNT(I) .GT. MISCPCNT(KP) ) KP=I
         END DO
C MAKE UP EXCLUDE LIST WITH ALL SATS FROM ALL OTHER GROUPS, IF ANY
         DO I= 1,NMISC(CMISC)
          IF( KP .GT. 0 .AND. IMISCP_GRP(I) .GT. 0  .AND.
     &                        IMISCP_GRP(I) .NE. KP ) THEN
C CHECK IF NOT ALREADY REJECTED FOR CODE OUTLIER
          K=0
          IF( NSVRJCT .GT. 0 ) THEN
           DO J=1,NSVRJCT
            IF( ISVRJCT(J).EQ. ISVO(IMISCP(I,CMISC))) K=J
           END DO
          ENDIF
          IF( K.EQ.0 ) THEN
           NSVRJCT = NSVRJCT + 1
           ISVRJCT(NSVRJCT) = ISVO(IMISCP(I,CMISC))
          END IF
          END IF
         END DO
        END IF
       END DO
       TESTMISCPROB=( NSVRJCT .GT. 0 .AND.
     &                ( NSVO-NSVRJCT .LT.  MINSAT .OR.
     &                  ((1.D0*NSVRJCT)/NSVO) .GT. 33.D0 ) )
       IF( TESTMISCPROB ) THEN
         IF( IPC .GE. 3 )
     &     WRITE (*,*) 'DISABLING MISCLOSURE DEWEIGHTING'
         DO I=1,NSVRJCT
           ISVDWSAV(I)=ISVRJCT(I)
         END DO
         NSVDWSAV=NSVRJCT
       END IF
       TESTMISC = .FALSE.
C
C EXCLUDE ALL FLAGGED SATS, IF ANY
C
       IF( .NOT. TESTMISCPROB .AND. NSVRJCT .GT. 0 ) THEN
        DO I=1,NSVRJCT
         IF(OUTLIERACTION.NE.0) THEN
          NSVDWGT=NSVDWGT+1
          ISVDWGT(NSVDWGT)=ISVRJCT(I)
         ENDIF
         K=0
         DO J=1,NSVO
           IF( ISVRJCT(I).EQ.ISVO(J)) K=J
         END DO
         IF( K.NE.0 ) THEN
           IF( OUTLIERACTION .NE. 0 ) THEN
           PL(IOBTYP*(K-1)+1,IOBTYP*(K-1)+1) =
     &          1.D-40 * PL(IOBTYP*(K-1)+1,IOBTYP*(K-1)+1)
           PL(IOBTYP*K,IOBTYP*K) = 
     &          1.D-40 * PL(IOBTYP*K,IOBTYP*K)
           ENDIF
           NRESREJ=NRESREJ+1
           IF (NRESREJ .LE. MAXRES) THEN
            IF( (MISCR(K) .GE. 1.D5 .OR. MISCR(K) .LE. -1.D4) .AND.
     &          (MISCP(K) .GE. 1.D3 .OR. MISCP(K) .LE. -1.D2) ) THEN
             WRITE(MISFMT,1210) 'E','E'
            ELSE IF( MISCP(K) .GE. 1.D3 .OR. MISCP(K) .LE. -1.D2 ) THEN
             WRITE(MISFMT,1210) 'F','E'
            ELSE IF( MISCR(K) .GE. 1.D5 .OR. MISCR(K) .LE. -1.D4 ) THEN
             WRITE(MISFMT,1210) 'E','F'
            ELSE
             WRITE(MISFMT,1210) 'F','F'
            ENDIF
            WRITE(RESREJ(NRESREJ),MISFMT)  
     &      ISVO(K),IHR,IMIN,INT(SEC),INT((SEC-INT(SEC))*1.D3),
     &      MISCR(K), MISCFACTR*SDPR, MISCP(K)*1.D2,MISCFACTP*1.D2*SDCP
     &      ,IDIR
           ENDIF
         ENDIF
        END DO
        IREASON=6+OUTLIERACTION*10
        CALL VPCREJ ( LPR, NSVRJCT, ISVRJCT, NSVO, ISVO, TTAG,
     &                PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                FCP, ICSLIP,
     &                ISPR1, ISPR2,
     &                MSOFF, MSJMP, NRCRJCT, IARC, IPC, IREASON,
     &                MAXSAT, MAXARC )
        IF(OUTLIERACTION.EQ.0) THEN
        ITER = 0
        GO TO 100
        ENDIF
        NSVRJCT=0
       END IF
      END IF
C ----------------------------------------------------------------------
C    ADJUSTMENT SECTION
C-----------------------------------------------------------------------
C
      NFPAR=MAXPAR
C
      IF ( IOBTYP .EQ. 1 ) THEN
        NPAR  = NFPAR
        NSVO2 = NSVO
      END IF
      IF ( IOBTYP .EQ. 2 ) THEN
        NPAR = NSVO + NFPAR
        NSVO2=NSVO*2
      END IF
C
C     PRINT OUT OBSERVATION SUMMARY
C     ON FIRST ITERATION
C
      IF ( ITER .EQ. 1 .AND. IPC .GT. 1 )
     &  CALL WRTCOR( LUO, IYEAR, IMTH, IDAY, IHR, IMIN, SEC,
     &               NSVO, ISVO, IDX, AZ, EL, TROCOR, IONCOR,
     &               PCVCOR,TIDCOR,WUPCOR,ION2COR,
     &               SRELCOR, SAGCOR )
c!    IF ( ITER .EQ. 1 ) WRITE(*,*) 'W(IO)',( W(IO,1), IO=1,NSVO2 )
C
C     ADD PROCESS NOISE TO PX 
C
      IF ( ITER .EQ. 1 ) THEN                                                        IF 0 if first iter
         IF ( IPC .GT. 2 ) THEN
           WRITE(*,*) 'OLD PRN', (ISVOL(I),I=1,NSVOL)
           WRITE(*,*) 'NEW PRN', (ISVO(I),I=1,NSVO)
           WRITE(*,*) 'TTAG,PTTAG',TTAG(1),PTTAG,IOBTYP
           WRITE(*,*) ' SIGMAS OF PARAMETERS, BEFORE ADDPX '
           WRITE(*,'(15D9.3)') (DSQRT(PX(I,I)),I=1,NPAR)
         END IF
C  SKIN           
         IF(IMODE.EQ.3) THEN
           IF(SDX.GT.0.d0.AND. SDX.LT.1.2d0 ) THEN
            IF( IMIX .NE. 1 ) THEN
             IF( IPC .GE. 1 )
     &            WRITE(*,*) 'SKIN: SWITCH TO STATIC',SDX,RXVEL
             IMIX=1
            ENDIF
           ELSE IF( IMIX .NE. 2 ) THEN
             IF( IPC .GE. 1 )
     &            WRITE(*,*) 'SKIN: SET TO KINEMATIC'
             IMIX=2
           END IF
         ELSE
           IMIX=IMODE
         END IF
C check if vmf par available to constrain the ini tropo to 1 cm
C ADAPT SDTROP TO SPEED AND WET ZPD MAGNITUDES (36km/h & 0.2m)
         SDTROP= SDTROP*SQRT(1.d0+RXVEL/10.d0)*
     &           MIN(MAX(ABS(XRVEPO(5)),0.1D-3),0.5D0)/0.2D0
C SAVE PX MATRIX IN CASE OF EPOCH OR OUTLIER REJECTIONS
         DO I=1,NFPAR+NSVOL
          DO J=1,NFPAR+NSVOL
            OPX(I,J) = PX(I,J)
          END DO
         END DO
         IF( RELAXAMB .AND. SO.GT.0.D0 ) THEN
C BUILD COMMON OLD AND NEW FIXABLE SAT LIST
          NSVCOMN=0
          DO I=1,NSVOL
           K=0
           DO J=1,NSVO
            IF(ISVOL(I).EQ.ISVO(J)) THEN
             K=J
             NSVCOMN=NSVCOMN+1
             IDXN(NSVCOMN)=J
             IDXO(NSVCOMN)=I
            ENDIF
           END DO
           IF(K.EQ.0) THEN
            SVRELAX(I)=.TRUE.
            if(ipc.ge.1)write(*,*) "SKIP UNCOMMON",ISVOL(I)
           ELSE IF( PRDC(9,ISVO(K)).EQ.0.D0 ) THEN
            SVRELAX(I)=.TRUE.
            NSVCOMN=NSVCOMN-1
            if(ipc.ge.1)write(*,*) "SKIP   NON-AR",ISVOL(I)
           ELSE IF(PL(IOBTYP*(K-1)+1,IOBTYP*(K-1)+1)*SDPR**2
     &      .LT. 1.D-20.OR.PL(IOBTYP*K,IOBTYP*K)*SDCP**2.LT.
     &      1.D-20.OR.PX(NFPAR+I,NFPAR+I).GT.1.1D-6) THEN
            SVRELAX(I)=.TRUE.
            NSVCOMN=NSVCOMN-1
            if(ipc.ge.1)write(*,*) "SKIP DWT/UNFX",ISVOL(I)
           ELSE
            if(ipc.ge.1)write(*,*) "COMMON FIX SV",ISVOL(I)
            SVRELAX(I)=.FALSE.
           ENDIF
          END DO
C FIND HIGHEST ELEVATION SATELLITE IN COMMON LIST
          IL=0
          DO I=1,NSVCOMN
           IF( I.EQ.1 ) THEN
            IL=I
            if(ipc.ge.1)write(*,*)
     &      "SELECT",ISVO(IDXN(I)),EL(IDXN(I))
           ENDIF
           IF(EL(IDXN(I)).GT.EL(IDXN(IL)))THEN
            IL=I
            if(ipc.ge.1)write(*,*)
     &      "SELECT",ISVO(IDXN(I)),EL(IDXN(I)),">",EL(IDXN(IL))
           ELSE
            if(ipc.ge.1)write(*,*)
     &      "SKIP  ",ISVO(IDXN(I)),EL(IDXN(I)),"<=",EL(IDXN(IL))
           ENDIF
          END DO
C TEST PHASE MISCLOSURES ARE IN INTEGER NL WAVELENGTH GROUPS WITH
C RESPECT TO HIGHEST FIXED SAT
C ONLY IF ANTENNA ACCELERATION ALLOWS <3cm QUALITY EXTRAPOLATION
          NFIXGRP=0
          MNRELAX=NSVOL-NSVCOMN
          IF( PRDPOSQLT .LT. 0.03D0 ) THEN
           DO I=1,NSVCOMN
            DMISCPNL=DINT((MISCP(IDXN(I))-MISCP(IDXN(IL)))/NLWL+
     &                    SIGN(0.5D0,MISCP(IDXN(I))-MISCP(IDXN(IL))))
            IF( ABS((MISCP(IDXN(I))-MISCP(IDXN(IL)))/NLWL-DMISCPNL)
     &          .LT.0.1D0 ) NFIXGRP=NFIXGRP+1
            IF( DMISCPNL.NE.0 .OR.
     &          ABS((MISCP(IDXN(I))-MISCP(IDXN(IL)))/NLWL-DMISCPNL)
     &          .GE.0.1D0 ) MNRELAX=MNRELAX+1
           END DO
           if(ipc.ge.1.and.il.gt.0)
     &     write(*,*) 'GROUP NL TEST:',ISVO(IDXN(IL)),
     &                NSVCOMN,NFIXGRP,MNRELAX
          ENDIF
C TRY GROUP RELAXING WHEN ENOUGH GROUPED SATS
          IF(NFIXGRP.GE.3) THEN
C LOOK FOR LARGEST GROUP
           DO I=1,NSVCOMN
            NRELAX=NSVOL-NSVCOMN
            DO J=1,NSVCOMN
             DMISCPNL=DINT((MISCP(IDXN(I))-MISCP(IDXN(J)))/NLWL+
     &                     SIGN(0.5D0,MISCP(IDXN(I))-MISCP(IDXN(J))))
             IF( ABS(DMISCPNL).GT.0.D0.OR.
     &           ABS((MISCP(IDXN(I))-MISCP(IDXN(J)))/NLWL-DMISCPNL)
     &           .GE.0.1D0 ) NRELAX=NRELAX+1
            END DO
            IF( NRELAX.LT.MNRELAX) THEN
             IL=I
             MNRELAX=NRELAX
            ENDIF
           END DO
C WHEN LARGEST GROUP IS LARGE ENOUGH SET RELAX FLAGS
           IF(NSVOL-MNRELAX.GT.1) THEN
            DO I=1,NSVCOMN
             DMISCPNL=DINT((MISCP(IDXN(I))-MISCP(IDXN(IL)))/NLWL+
     &                     SIGN(0.5D0,MISCP(IDXN(I))-MISCP(IDXN(IL))))
             IF( ABS(DMISCPNL).GT.0.D0.OR.
     &           ABS((MISCP(IDXN(I))-MISCP(IDXN(IL)))/NLWL-DMISCPNL)
     &           .GE.0.1D0 ) THEN
              SVRELAX(IDXO(I))=.TRUE.
              if(ipc.ge.1)write(*,*) 'SKIPMS:', ISVOL(IDXO(I)),
     &        MISCP(IDXN(I))/NLWL,MISCP(IDXN(IL))/NLWL,
     &        (MISCP(IDXN(I))-MISCP(IDXN(IL)))/NLWL
             ELSE
              if(ipc.ge.1)write(*,*) 'KEEPMS:', ISVOL(IDXO(I)),
     &        MISCP(IDXN(I))/NLWL,MISCP(IDXN(IL))/NLWL,
     &        (MISCP(IDXN(I))-MISCP(IDXN(IL)))/NLWL
C SELECT ONE OF THE GROUP MEMBER AS REF
             ENDIF
            END DO
            if(ipc.ge.1)write(*,*) 'SELECT GROUP:',
     &      ISVOL(IDXO(IL)),NSVOL-MNRELAX
           ENDIF
C IF PHASE MISCLOSURE GROUP FAILED TRY SINGLY FIXED SATELLITE
          ELSE
C TRY PREVIOUSLY FIXED SATELLITE AS FOLLOWS:
C ON BWD TRY FWD FIXED SAT
           IK=0
           IF( IDIR.LT.0 .AND. IPRNFX(NDAY) .NE. 0 ) THEN
             DO I=1,NSVCOMN
              IF(IPRNFX(NDAY).EQ.ISVO(IDXN(I))) IK=I
             END DO
           ENDIF
C  ON FWD, TRY NDAY-1 SELECTION
C  ON BWD, IF FWD SELECTION FAILED, TRY NDAY+1 SELECTION
          IF( IK .EQ. 0 .AND. IPRNFX(NDAY-IDIR) .NE. 0 ) THEN
           DO I=1,NSVCOMN
            IF(IPRNFX(NDAY-IDIR).EQ.ISVO(IDXN(I))) IK=I
           END DO
          ENDIF
C USE WHATEVER WAS SELECTED
           IF(IK.NE.0) THEN
            NFIXGRP=1
            IL=IK
            if(ipc.ge.1)write(*,*) "PRVREF",ISVO(IDXN(IK))
           ENDIF
C FLAG ALL BUT SELECTED SATELLITE, IF ANY
           DO I=1,NSVCOMN
            IF(I.NE.IL) SVRELAX(IDXO(I))=.TRUE.
           END DO
          ENDIF
C RELAX LIST OF FLAGGED SATELLITES
          DO I=1,NSVOL
           IF(SVRELAX(I)) THEN
            PX(NFPAR+I,NFPAR+I)= PX(NFPAR+I,NFPAR+I) + 25.D-4/SO
            if(ipc.ge.1)write(*,*) "AMBS RELAXED BY 5CM",ISVOL(I),
     &                 SQRT(PX(NFPAR+I,NFPAR+I))
           ELSE
            if(ipc.ge.1)write(*,*) "KEEPING AMB FIXED  ",ISVOL(I),
     &                 SQRT(PX(NFPAR+I,NFPAR+I))
           ENDIF
          END DO
C STORE ONE OF THE SELECTED REF SAT FOR FUTURE CONTINUITY MAINTENANCE
          IF(IL.EQ.0) THEN
           IPRNFX(NDAY)=0
          ELSE IF( IDIR.GT.0 .OR.
     &             IPRNFX(NDAY-IDIR).NE.ISVOL(IDXO(IL)) ) THEN
           IPRNFX(NDAY)=ISVOL(IDXO(IL))
          ENDIF
C SHOULD WE RESET DN12REF? COMMENT OR UNCOMMENT FOLLOWING IPRNREF SETTING
C         IF(IL.NE.0) IPRNREF=ISVOL(IDXO(IL))
         ENDIF
         CALL ADDPX ( NSVO, ISVO, NSVOL, ISVOL, NPAR, NFPAR,
     &               IPOSSOL, ICLKSOL, ITRPSOL, IOBTYP, XRVRMS, 
     &               PX, OPX, IPX, IMIX , SDPR, CPAMB, PL, 
     &               PTTAG, UTTAG, SDTROP, C, ICSLIP15,
     &               CNTAMB,
     &               SDCLK, PCLKSIG )
C UNDO:ADAPT SDTROP TO SPEED AND WET ZPD MAGNITUDES (36km/h & 0.2m)
C
         NAMBFX =0
         ID = 0
         IF(IFREQ.GE.3.AND..NOT.INIEPO.AND.IOBTYP.EQ.2.AND.
     &      (NFIX.GT.0.OR.IDIR.LT.0).AND.
     &          (UPDINT*NFIX/60.).LT.DBLE(MINFX)) THEN                               IF 1 ref search condition
          IF(IPC.GE.1.AND..NOT.IAROFF)
     &                WRITE(*,*) "AR REF SEARCH: LOOK FOR REF SAT"
          DO I= INSVO, NSVO                                                          DO 2 loop AR sat
           IPRN= ISVO(I)
         CALL FREQ12( IPRN, F1, F2, F1S, F2S, F12S, F1ION, F2ION,
     &                   AL1, AL2, AL3, AL4, IFREQ )
           IF(PRDC(9,IPRN).NE.0.D0.AND..NOT.(
     &         PL(IOBTYP*(I-1)+1,IOBTYP*(I-1)+1)*SDPR**2 .LT. 1.D-20
     &         .OR. PL(IOBTYP*I,IOBTYP*I)*SDCP**2 .LT. 1.D-20 ) ) THEN               IF 3 if AR and ! deweight
            IF(IDIR.LT.0.AND.IPRN.EQ.IPRNREF.AND.NFIX.EQ.0) THEN                     IF 4 BWD selected at end FWD
              ID=I
              IF(IPC.GE.1)
     &          WRITE(*,*) "AR REF SELECT: ",IPRN,EL(IDX(IPRN)),
     &          CPAMB(IPRN)
            ELSE IF(IDIR.GT.0.AND.EL(IDX(IPRN)).GT.22.D0) THEN                  ELSE IF 4 if high enough sat
             IF(IPC.GE.2)
     &        WRITE(*,*) "AR REF SEARCH: ",IPRN,EL(IDX(IPRN)),
     &        (EL(IDX(IPRN))-FLTSUM(14,IPRN))/FLTINT,CPAMB(IPRN)
             IF(IDIR.GT.0.AND.(IPRNREF.EQ.0.OR.NFIX.LE.1)) THEN                      IF 5 FWD selection
              IF(             ID.EQ.0) THEN                                          IF 6 1st sat
               ID=I
               IF(IPC.GE.1)
     &          WRITE(*,*) "AR REF SELECT: ",IPRN,EL(IDX(IPRN)),
     &          (EL(IDX(IPRN))-FLTSUM(14,IPRN))/FLTINT
              ELSE IF(FLTSUM(1,ISVO(I)).GT.NFIX.AND.
     &                (EL(IDX(IPRN))-FLTSUM(14,IPRN))/FLTINT .GT.
     &                  (EL(IDX(ISVO(ID)))-FLTSUM(14,ISVO(ID)))/
     &                                                  FLTINT) THEN            ELSE IF 6 larger elevation rate
               ID=I                                                                       on n'th FWD epoch
               IF(IPC.GE.1)
     &          WRITE(*,*) "AR REF SELECT: ",IPRN,EL(IDX(IPRN)),
     &          (EL(IDX(IPRN))-FLTSUM(14,IPRN))/OBSINT,CPAMB(IPRN)
              END IF                                                             END IF 6 FWD selection criteria
             ENDIF                                                               END IF 5 BWD selection 
            ENDIF                                                                END IF 4 if high enough sat
           ENDIF                                                                 END IF 3 if AR and ! deweight
          END DO                                                                 END DO 2 loop AR sat
          IF( ID .NE. 0 ) THEN                                                       IF 2 if ref selected
           IPRN=ISVO(ID)
           IF( NFIX .EQ. 0 ) THEN                                                    IF 3 initial FWD/BWD fix
            PX(NFPAR+ID,NFPAR+ID)=   1.0D 6
            CPAMB(IPRN)= 0.0D0
            IPRNREF = IPRN
           ELSE IF( IPRN.NE.IPRNREF ) THEN                                      ELSE IF 3 ref changes
            DO J= INSVO, NSVO                                                        DO 4 sdiff amb
C ACCOUNT FOR NEW AMB REFERENCE
             IF(ISVO(J).NE.IPRN)CPAMB(ISVO(J))=CPAMB(ISVO(J))
     &        -CPAMB(IPRN)
            END DO                                                               END DO 4 sdiff amb
            CPAMB(IPRN)= 0.0D0                                    
            CALL SPIN ( PX, NPAR, MAXPAR2, SINEL, J   )                                   COVARIANCES
            DO IL=1,NPAR                                                             DO 4 loop all parameters
             DO J= NFPAR+1, NPAR                                                     DO 5 loop amb parameters
              IF(ABS(PX(IL, J)).GT.1.D-14.AND.IL.NE.(NFPAR+ID).AND.
     &           J.NE.(NFPAR+ID)) THEN                                               IF 6
               PX(IL, J)= PX(IL, J)-PX( NFPAR+ID,IL)
               IF(IL.GT.NFPAR) PX(IL, J)= PX(IL,J)-PX(NFPAR+ID,J)+
     &                          PX(NFPAR+ID,NFPAR+ID)
               IF(IL.LE.NFPAR) PX(J, IL)= PX(IL, J)
              ENDIF                                                              END IF 6
             END DO                                                              END DO 5 loop amb parameters
            END DO                                                               END DO 4 loop all parameters
            DO J=1, NPAR                                                             DO 4 loop all parameters
             PX(NFPAR+ID, J)= 0.D0
             PX(J, NFPAR+ID)= 0.D0
            ENDDO                                                                END DO 4 loop all parameters
            PX(NFPAR+ID,NFPAR+ID)=   1.0D-6
            CALL SPIN ( PX, NPAR, MAXPAR2, SINEL, J   )                                   WEIGHTS
            IPRNREF = IPRN
           ENDIF                                                               END ELSE 3 ref changes
           ID = IPRN
           write(*,*)'PRN EL', IPRNREF,EL(IDX(IPRNREF)),CPAMB(IPRNREF),
     &               ' INI AMB FIXED ' , DIR((1-IDIR)/2+1)
           GO TO 210
          ENDIF                                                                  END IF 2 if ref selected
         END IF                                                                  END IF 1 ref search condifion
         DO I= INSVO, NSVO                                                           DO 1 loop AR sat
         IPRN= ISVO(I)
         IF(PRDC(9,IPRN).NE.0.D0.AND. IFREQ.GE.3.AND..NOT.INIEPO.AND.
     &      .NOT.( PL(IOBTYP*(I-1)+1,IOBTYP*(I-1)+1)*SDPR**2 .LT. 1.D-20
     &      .OR.( IOBTYP .EQ. 2 .AND.
     &      PL(IOBTYP*I,IOBTYP*I)*SDCP**2 .LT. 1.D-20 ) )) THEN                      IF 2 if AR and ! deweight
C
C DO NOT REDO AR ATTEMPTS WHEN REPROCESSING CURRENT EPOCH
          IF(       ISARDONE ) THEN                                                  IF   added
            IF(ISVFX.EQ.IPRN) THEN
                   PX(NFPAR+I,NFPAR+I)= PX(NFPAR+I,NFPAR+I)+ 1.0D 6
            ENDIF
          ELSE
C
C WL INITILIZATION
          dn3=(P1(I)-P2(I)-fltsum(20,iprn)/al1+fltsum(21,iprn)/al2)
     &      *c/(f1-f2)-(f1*pr1(i)+f2*pr2(i))*c/(f1+f2)
          dn3=dn3+prdc(9,iprn)
          dn3=dn3*(f1-f2)/c
          FLTSUM(23,IPRN)=SQRT((FLTSUM(23,IPRN)**2*15+
     &      (dn3-FLTSUM(22,iprn) -PRDC(9,IPRN)/AL4)**2)/16)
          END IF                                                                 END IF   added
C SAVE INIT REF PRN WL FOR WL DATUM REFERENCE
          IF(IPRN.EQ.IPRNREF) THEN                                                   IF 3 if ref
           IF(FLTSUM(1,IPRN).GE.2) THEN                                              IF 4 if filtered
            ID = IPRN
            DN12REF= FLTSUM(22,iprn) + PRDC(9,IPRN)/AL4            
            PRDCREF= PRDC(9,IPRN)
      if(ipc.ge.1)write(*,*) "AR WL REF INIT:",IPRN,DN12REF
C SAVE FIRST FWD REFERENCE SELECTION
            IF(IDIR.GT.0.AND.NDAY.EQ.1)IPRNFX(NDAY)=IPRN
           ELSE                                                                    ELSE 4 if filtered
      if(ipc.ge.1)write(*,*) "AR REF SAT LOST, SET TO 0",IPRN
            IPRNREF =0
           ENDIF                                                                 END IF 4 if filtered
          ENDIF                                                                  END IF 3 if ref
C DO NOT REDO AR ATTEMPTS WHEN REPROCESSING CURRENT EPOCH
          IF( .NOT. ISARDONE ) THEN                                                  IF   added
          dN3 = FLTSUM(22,iprn)+PRDC(9,IPRN)/AL4 -DN12REF
          if(dn3.ne.0.d0.and.
     &       abs(dn3-int(dn3+sign(0.5d0,dn3))).LT.0.24)
     &       dn3=int(dn3+sign(0.5d0,dn3))
          dn1 =(-CPAMB(IPRN)         - dN3*F1ION*AL2)/al3
          dn2 = dn1 -dn3
          dn3= 0.d0
          if(dn1.ne.0.d0)
     &      dn3=  f1s*INT(DN1+SIGN(.5D0,DN1))*AL1/f12s
          if(dn2.ne.0.d0)
     &      dn3=dn3 -f2s*INT(DN2+SIGN(.5D0,DN2))*AL2/f12s
          IF(((FLTSUM(1,IPRN)-1)*FLTINT-MINFX*60.D0).LT.UPDINT.AND.
     &       ((FLTSUM(1,IPRN)-1)*FLTINT-MINFX*60.D0).GE.0.D0) THEN                   IF 3 enough time passed
           IF(IPRN  .NE.IPRNREF) THEN                                                IF 4 ! ref
            write(*,'(a3,(a),2i3,2f6.1,6F7.3)') DIR((1-IDIR)/2+1),
     &       ' INIT PRN EL dN1 dN2 dN3 AMB dAMB SIG WL' 
     &       ,IPRN,int(el(i)),dn1,dn2,dn3,cpamb(iprn),vcpamb(iprn),SQRT 
     &       (1.D0/PX(NFPAR+I,NFPAR+I)),FLTSUM(22,iprn)+PRDC(9,iprn)/AL4        
     &       -dn12ref, FLTSUM(23,IPRN)/4
            IF((DN2-DN1).NE.0.D0)DN2= DN1+
     &                                INT(DN2-DN1+SIGN(.5D0,DN2-DN1))
            IF(DN1.NE.0.D0)DN1= INT(DN1+SIGN(.5D0,DN1))
            IF(DN2.NE.0.D0)DN2= INT(DN2+SIGN(.5D0,DN2))
           ENDIF                                                                 END IF 4 ! ref
           DN3=0.D0
           IF(IPRN.NE.IPRNREF) THEN                                                  IF 4 ! ref
            IF(DN1.NE.0.D0)
     &        DN3=    f1s*INT(DN1+SIGN(.5D0,DN1))*AL1/f12s
            IF(DN2.NE.0.D0)
     &        DN3=DN3-f2s*INT(DN2+SIGN(.5D0,DN2))*AL2/f12s
           ENDIF                                                                 END IF 4 ! ref
           FLTSUM(13,IPRN)= FLTSUM(13,IPRN)-DN3
           FCP(I)= FCP(I) - (DN3)/C
           CPAMB(IPRN)= CPAMB(IPRN) + DN3 
           OCPAMB(IPRN)= CPAMB(IPRN)
           FLTSUM(22,IPRN)=FLTSUM(22,IPRN)-(DN1-DN2)                
           FLTSUM(20,IPRN)=FLTSUM(20,IPRN)+DN1*AL1
           FLTSUM(21,IPRN)=FLTSUM(21,IPRN)+DN2*AL2 
      if(ipc.ge.4) write(*,*)
     &    'ARDEBUG: INIWL',uttag,isvo(i),fltsum(20,isvo(i)),
     &    fltsum(21,isvo(i)),fltsum(22,isvo(i)),fltsum(23,isvo(i)),
     &    prdc(9,iprn)
      if(ipc.ge.1)write(*,*) "AR WL INITIALISATION",IPRN,DN1,DN2,DN3
          ENDIF                                                                  END IF 3 enough time passed
C
C END OF L1/L2 PHASE  WL INITILIZATION
C
C DO NOT REDO AR ATTEMPTS WHEN REPROCESSING CURRENT EPOCH
C NOW ATTEMPT TO FIX AMBIGUITIES
          IF(PX(NFPAR+I,NFPAR+I).LT. 0.9D 6.AND.OSDPLH(2).LE.8.0D-3)THEN             IF 3 ! fixed & converged
           CALL SPIN ( PX, NPAR, MAXPAR2, SINEL, J   )                                  COVARIANCES
           IF(ABS(VCPAMB(IPRN)).LE.5.D-4.AND.
     &        PX(NFPAR+I,NFPAR+I)*SO.LT.0.4D-04
     &       .AND.EL(IDX(IPRN)).GT.10.D0.AND.
C BUT ONLY AFTER MINFX+5 MIN!
     &        INT(FLTSUM(1,IPRN)*FLTINT/60.D0).GT.(MINFX+ 5 ))THEN                   IF 4 fixing condition
C CHECK THE AMBIGUITIES ONLY WHEN REAL AMB CHANGE < 1mm AND 1/SIG > 100 
            DN1= CPAMB(IPRN)/AL3      
            DN2= INT(DN1+SIGN(.5D0,DN1))
            IF(ABS(fltsum(22,iprn)+PRDC(9,iprn)/AL4-dn12ref).LT.0.20d0
C   use WLavg sig of ,25 cy, NOTE: WLavg sigmas=fltsum(23,iprn)/4
     &       .AND.FLTSUM(23,IPRN).LE.1..AND.ABS(DN1-DN2).LT.0.15D0) THEN             IF 5 NL fixing success
C IT IS A  NAROW LANE! FIX IT!
             write(*,'(a3,(a),2i3,f5.2,5F7.4)') DIR((1-IDIR)/2+1),
     &        ' NL AR PRN EL dN AMB dAMB SIG WL ',
     &        IPRN,int(el(i)),dn1,cpamb(iprn), vcpamb(iprn), SQRT(     
     &        PX(NFPAR+I,NFPAR+I)),FLTSUM(22,iprn)
     &                                       +PRDC(9,iprn)/AL4-dn12ref
     &        , FLTSUM(23,IPRN)/4
             FLTSUM(13, IPRN)= FLTSUM(13, IPRN)+DN2*AL3
             FLTSUM(20,IPRN)=FLTSUM(20,IPRN)-DN2*AL1
             FLTSUM(21,IPRN)=FLTSUM(21,IPRN)-DN2*AL2
             CPAMB(IPRN)= 0.0D0
             OCPAMB(IPRN)= 0.0D0
             CALL SPIN ( PX, NPAR, MAXPAR2, SINEL, J   )                                  WEIGHTS
             PX(NFPAR+I,NFPAR+I)= PX(NFPAR+I,NFPAR+I)+ 1.0D 6
C RESET MEAN RES & COUNT
             NCPDF(IPRN, MAXARC)= 0                     
             CPAVG(IPRN,MAXARC)= 0.D0                           
             CNTFIX(IPRN)=CNTFIX(IPRN)+1
      if(ipc.ge.4)write(*,*)
     &    'ARDEBUG: FIXNL',uttag,isvo(i),fltsum(20,isvo(i)),
     &    fltsum(21,isvo(i)),fltsum(22,isvo(i)),fltsum(23,isvo(i))
             GO TO 210
            ELSE                                                                   ELSE 5 NL fixing failure
      if(ipc.ge.1)write(*,*) "AR CANNOT NL FIX:",IPRN,
     &" DN12 res",ABS(fltsum(22,iprn)+PRDC(9,iprn)/AL4-dn12ref)
     &.LT.0.2d0,
     &" WL var",FLTSUM(23,IPRN).LE.1.," DN12 siz",ABS(DN1-DN2).LT.0.15D0
C DO L3 AR BUT ONLY WHEN WL INTEGER PHASE INITIL. QUESTIONABLE (GE 0.2 WL CY)!
              IF(ABS(FLTSUM(22,iprn)+PRDC(9,iprn)/AL4-dn12ref)
     &                                                   .GE..20)THEN                IF 6 L3 fixing conditions
               DN3 =  (CPAMB(IPRN)/F2ION/AL1-INT(CPAMB(IPRN)/F2ION/AL1))
               DO J=0,1                                                              DO 7 loop trials
                DN2 = (SIGN(1.D0,DN3)*J-DN3)/(F1ION*AL2/F2ION/AL1-1.0D0)
                DN1 =(CPAMB(IPRN)          +DN2*F1ION*AL2)/F2ION/AL1
                IF(ABS(DN2-INT(DN2+SIGN(.5D0,DN2))).LE.0.04d0.AND.
     &             ABS(INT(DN2+SIGN(.5D0,DN2))).LE.4.AND.
     &             ABS(DN2-DN1).LE.1.5D0.AND. 
     &             ABS(FLTSUM(22,iprn)+PRDC(9,iprn)/AL4-
     &                                     dn12ref+DN1-DN2).LE..5D0)THEN             IF 8 L3 success!
C FIX INT AMB, WITHIN 0.04 CY LIMIT & REOLUTION LIMIT |N2|<=4          
                 write(*,'(a3,(a),2i3,2f5.2,5F7.4)') DIR((1-IDIR)/2+1),
     &            ' L3 AR PRN EL dN1 dN2 AMB dAMB SIG WL',
     &            IPRN,int(el(i)),dn1,dn2,cpamb(iprn),vcpamb(iprn),
     &            SQRT(PX(NFPAR+I,NFPAR+I)),FLTSUM(22,iprn)+PRDC(9,iprn)
     &            /AL4-dn12ref
     &            , fltsum(23,iprn)/4
                 DN1= INT(DN1+SIGN(0.5D0,DN1))
                 DN2= INT(DN2+SIGN(0.5D0,DN2))
                 FLTSUM(13, IPRN)=FLTSUM(13,IPRN)+
     &                             DN1*F2ION*AL1- DN2 *F1ION*AL2 
                 FLTSUM(20,IPRN)=FLTSUM(20,IPRN)-DN1*AL1
                 FLTSUM(21,IPRN)=FLTSUM(21,IPRN)-DN2*AL2
                 FLTSUM(22,IPRN)=FLTSUM(22,IPRN)+
     &                          (DN1-DN2)                
                 CPAMB(IPRN)= 0.0D0                                    
                 OCPAMB(IPRN)= 0.0D0
                 CALL SPIN ( PX, NPAR, MAXPAR2, SINEL, J   )                              WEIGHTS
                 PX(NFPAR+I,NFPAR+I)= PX(NFPAR+I,NFPAR+I)+ 1.0D 6
                 NCPDF(IPRN, MAXARC)= 0                     
                 CPAVG(IPRN,MAXARC)= 0.D0                           
                 CNTFIX(IPRN)=CNTFIX(IPRN)+1
      if(ipc.ge.4)write(*,*) 'ARDEBUG: FIXL3',uttag,isvo(i),
     &fltsum(20,isvo(i)),fltsum(21,isvo(i)),fltsum(22,isvo(i)),
     &fltsum(23,isvo(i))
                 GO TO 210
      else
      if(ipc.ge.1)write(*,*) "AR CANNOT L3 FIX:",IPRN,J,
     &" FRAC DN2",ABS(DN2-INT(DN2+SIGN(0.5D0,DN2))).LE.0.04d0,
     &" INT DN2",ABS(INT(DN2+SIGN(0.5D0,DN2))).LE.4,
     &" DN12 siz",ABS(DN2-DN1).LE.1.5D0,
     &" DN12 res",ABS(FLTSUM(22,iprn)+PRDC(4,iprn)/AL4-dn12ref+DN1-DN2)
     &.LE..5D0
                ENDIF                                                            END IF 8 L3 success!
               ENDDO                                                             END DO 7 loop trials
              ENDIF                                                              END IF 6 L3 fixing conditions
             ENDIF                                                               END IF 5 ! NL fixing conditions
      else
      if(ipc.ge.1)write(*,*) "AR NO FIX TRIALS:",IPRN,
     &" VCPAMB:",ABS(VCPAMB(IPRN)).LE.5.D-4,
     &" AMBconv:",PX(NFPAR+I,NFPAR+I)*SO.LT.0.4D-04,
     &" ELV:",EL(IDX(IPRN)).GT.10.D0,
     &" TIME:",INT(FLTSUM(1,IPRN)*FLTINT/60.D0).GT.(MINFX+ 5 )
            ENDIF                                                                END IF 4 fixing condition
            CALL SPIN ( PX, NPAR, MAXPAR2, SINEL, J   )                                   WEIGHTS
      else
      if(ipc.ge.1)write(*,*) "AR NO FIX TRIALS:",IPRN,
     &" UNFIXED:",PX(NFPAR+I,NFPAR+I).LT. 0.9D 6,
     &" LONCONV:",OSDPLH(2).LE.8.0D-3,OSDPLH(2)
           ENDIF                                                                 END IF 3 ! fixed & converged
          END IF                                                                 END IF   added
          ENDIF                                                                  END IF 2 if AR and ! deweight
          ENDDO                                                                  END DO 1 loog AR sat
210       CONTINUE
C STORE FIXED SATELLITE IN CASE WE RETURN HERE
          IF( I.LE.NSVO .AND. .NOT. ISARDONE ) THEN
           ISVFX=ISVO(I)
          ENDIF
C DO NOT REDO AR ATTEMPTS WHEN REPROCESSING CURRENT EPOCH
          ISARDONE=.TRUE.
          IF(.NOT.
     &    IAROFF.AND.IFREQ.GE.3) THEN
           NAMBFX = 0
           ID = 0
           DO I=1, NSVO                                                              DO 2 Count fix & ref
            IF(PX(NFPAR+I,NFPAR+I).GE..9 D 6)  NAMBFX= NAMBFX+1
            IF(ISVO(I).EQ.IPRNREF) ID=IPRNREF
           ENDDO                                                                 END DO 2 count fix & ref
C IF ID.NE.0 REF SAT IS UP
           IPRNREF = ID
           write(*,*)' IPRNREF',IPRNREF,' NO OBS SAT:',NSVO,
     &    ' AMB FIXED:',NAMBFX, ' = ',100* NAMBFX/NSVO, ' %'
          ENDIF                                                                  END IF 1 when ar
C
        SDTROP= SDTROP/SQRT(1.d0+RXVEL/10.d0)*
     &          0.2D0/MIN(MAX(ABS(XRVEPO(5)),0.1D-3),0.5D0)
         IF ( IPC .GT. 2 ) THEN                                                      IF 1
           WRITE(*,*) ' SIGMAS OF PARAMETERS, AFTER ADDPX '
           WRITE(*,'(15D9.3)') (DSQRT(PX(I,I)),I=1,NPAR)
           WRITE(*,'(15D9.3)') (DSQRT(PL(I,I)),I=1,NSVO2)          
         END IF                                                                  END IF 1
         trpsig=1.d0/px(5,5)**.5
         grdsig=1.d0/px(7,7)**.5
      END IF                                                                     END IF 0 if first iter
C
C     ADJUST EPOCH OBSERVATIONS
C
      CALL ADJPX ( LPR, IPC, NPAR, NSVO, ISVO, NSVO2, 
     &             PX, A, PL, W, VX, X, EA, EVX )
      IF ( IPC .GT. 3 ) THEN
        WRITE(*,"(A5,I2,1X,2(I2,':'),F4.1,3F6.3,F10.3,(15F10.3))")
     &           'DX ',ITER,IHR,IMIN,SEC,(X(I,1),I=1,NPAR)
        WRITE(*,"(A5,I2,1X,2(I2,':'),F4.1,(15F10.2))")
     &           'SX ',ITER,IHR,IMIN,SEC,(DSQRT(VX(I,I)),I=1,NPAR)
      END IF
C
C  SKIN
C
      IF(ITER.EQ.1.AND.IMODE.EQ.3) THEN
        SDX = DSQRT(((XRVVEL(1)*(UTTAG-PTTAG)-X(1,1))**2/VX(1,1)+
     &               (XRVVEL(2)*(UTTAG-PTTAG)-X(2,1))**2/VX(2,2)+
     &               (XRVVEL(3)*(UTTAG-PTTAG)-X(3,1))**2/VX(3,3))/SO)
        IF(SQRT(VX(1,1)+VX(2,2)).GT.2.d-1) SDX=3.d0
        IF(UTTAG.EQ.PTTAG) SDX= 0.d0
        IF(.NOT.INIEPO.AND.SDX.GE.1.2d0.AND.IMIX.EQ.1) THEN
          IF( IPC .GE. 1 ) WRITE(*,*) 'SKIN: DELTA SWITCH TO KINEMATIC'
          IF( IPC .GE. 3 )
     &  WRITE(*,*) "SKINdx ",ihr,imin,sec,imix,sdx,x(1,1),x(2,1),x(3,1)

          IMIX=2
          IF( TESTMISCPROB ) THEN
            TESTMISCPROB=.FALSE.
            TESTMISC = .TRUE.
            NSVDWSAV = 0
          ENDIF
C
C         RESTORE PARAMETERS AND VARIANCES FROM LAST UPDATED EPOCH
C         AND REDO THE EPOCH AS KIEMATIC
C
          CALL RSETPX ( NFPAR, NSVO, NSVOL, ISVO,
     &                  XRVEPO, XRVAPR, CPAMB, OCPAMB, PX, OPX )
          ITER=0
          INSVO=1
          GO TO 100
      ENDIF
      END IF
C
C     APPLY CORRECTIONS TO A-PRIORI RECEIVER COORDINATES AND CLOCK
C
      XRVEPO(1) = XRVEPO(1) - X(1,1)
      XRVEPO(2) = XRVEPO(2) - X(2,1)
      XRVEPO(3) = XRVEPO(3) - X(3,1)
      IF(GPS) XRVEPO(4) = XRVEPO(4) - X(4,1)*1.D-9
      IF(GLN) XRVEPO(8) = XRVEPO(8) - X(8,1)*1.D-9
      IF(GAL) XRVEPO(9) = XRVEPO(9) - X(9,1)*1.D-9
      IF(BEI) XRVEPO(10) = XRVEPO(10) - X(10,1)*1.D-9
C
      IF(IMODE.EQ.1) THEN
        IF (MOD(ITRPSOL,10) .NE. 1) THEN
          XRVEPO(5) = XRVEPO(5) - X(5,1)
          IF( ITRPSOL .GT. 100 ) THEN
            XRVEPO(6) = XRVEPO(6) - X(6,1)
            XRVEPO(7) = XRVEPO(7) - X(7,1)
          END IF
        END IF
        DO I=1,NSVO
          VCPAMB(ISVO(I)) = X(I+NFPAR,1)*C/1.D9
          CPAMB(ISVO(I))  = CPAMB(ISVO(I)) - VCPAMB(ISVO(I))
          SCPAMB(ISVO(I)) = DSQRT(VX(I+NFPAR,I+NFPAR))*C/1.D9
        END DO
      END IF
C
      IF ( IPC .GT. 1 )
     &  CALL WRTPAR( LUO, ITER, ISVO, IHR, IMIN, SEC, NPAR, X, VX,
     &             XRVEPO, CPAMB, SCPAMB, NFPAR)
C
C------------------------------------------------------------------------
C     CHECK DIVERGENCE ( CORRECTIONS > 1000M. ==> DIVERGENCE )
C------------------------------------------------------------------------
C
      DX = DSQRT( X(1,1)**2 + X(2,1)**2 + X(3,1)**2 )
      LOGDX=DLOG10( DX )
      IF( LOGDX .LE. -20D0 ) LOGDX=-20D0
      IF( .NOT. TESTMISCPROB .AND.
     &    ITER .GT. 2 .AND. LOGDX .GT. LOGDXO ) THEN
       ITER=MAXIT
C      WRITE(LPR ,*) ' STOP ITERATIONS AT',ttag(1),' DIVERGING SOLUTION'
       WRITE(* ,*) ' STOP ITERATIONS AT',ttag(1),' DIVERGING SOLUTION'
      ENDIF
      LOGDXO=LOGDX
C
C------------------------------------------------------------------------
C     CHECK CONVERGENCE ( CORRECTIONS < 100CM. ==> CONVERGENCE )
C------------------------------------------------------------------------
C
      DX = DSQRT( X(1,1)**2 + X(2,1)**2+X(3,1)**2 )
C STOP ITERATING AT LESS THAN 1m POSITION CORRECTION ON INITIAL EPOCH AND
C FIRST TWO ITERATIONS (FOR MISCLOSURE/RESIDUAL TEST VERIFICATION) OR LESS THAN 10cm
C CORRECTION OTHERWISE.
C FOR FIRST TWO ITERATIONS POSITION CORRECTION TEST DONE AGAIN AFTER RESIDUAL CHECK
C
      IF( DX .GT. 1.D0 ) GO TO 100
C
C-----------------------------------------------------------------------
C     COMPUTE RESIDUALS
C-----------------------------------------------------------------------
C
      CALL MATMPY (A, X, AX, NSVO2, NPAR, 1,MAXOBS2,MAXPAR2,MAXOBS2,1)
      VPRTOL = 4.47D0*SDPR
      VCPTOL = 4.47D0*SDCP
      IF ( DABS(VCPTOL) .LT. .03D0 ) VCPTOL=0.03D0
C ceiling of 10m on pseudorange limit
C FORCE 10m PR LIMIT FOR L3 PROCESSING ONLY
      IF (IFREQ.GE.3.AND.DABS(VPRTOL) .GT.1.0D01 .AND.SDPR.LE.5.D0)
     &   VPRTOL=1.0D01
      IF ( ISVCLK .EQ. 1 .AND. ISVEPH .EQ. 1 ) VPRTOL = 1.D1 + VPRTOL
      IF ( IPOSSOL .EQ. 1 .AND. ICLKSOL .EQ. 2 .AND. ISVCLK .EQ. 1 ) 
     &                  VPRTOL = 1.D4
C     WRITE(*,*) 'CODSOL TOLERANCES',VPRTOL,VCPTOL
      CALL ADJV ( IOBTYP, NSVO, W, AX, VPRTOL, VCPTOL, VPR, VCP,
     &            VPRMAX, VCPMAX, VTVPR, VTVCP, SDCP, DVPV,
     &            SDPR, PL,
     &            IRJCTPR, IRJCTCP )
      IF( IPC .GT. 1 ) THEN
      DO I=1,NSVO
        write(*,*) "RESIDUALS ",ihr,":",imin,":",sec," PRN",
     &               ISVO(i),VPR(i,1),VCP(i,1)*100
      END DO
      END IF
C
C SKIN
C
C     CHI SQUARE APPROXIMATION (99%)
C
      IF(IMODE.EQ.3.AND.IMIX.EQ.1) THEN
        CHI299= 1.2*((NSVO-NSVDWGT) + SQRT(2.d0*(NSVO-NSVDWGT))*2.58)*SO
        IF(DVPV.GT.CHI299) THEN
          IF( IPC .GE. 1 ) WRITE(*,*) 'SKIN: CHISQ SWITCH TO KINEMATIC'
          IF( IPC .GE. 3 )
     &WRITE(*,*)  "SKINdv",ihr, imin, sec, nSVO, nobs, dvpv, chi299, so
          IMIX=2
          IF( TESTMISCPROB ) THEN
           TESTMISCPROB=.FALSE.
           TESTMISC = .TRUE.
           NSVDWSAV = 0
          END IF
          SDX=3.d0
C
C         RESTORE PARAMETERS AND VARIANCES FROM LAST UPDATED EPOCH
C
          CALL RSETPX ( NFPAR, NSVO, NSVOL, ISVO,
     &                  XRVEPO, XRVAPR, CPAMB, OCPAMB, PX, OPX )
C
          ITER=0
          INSVO=1
          GO TO 100
        END IF
      END IF
C
C ADDITIONAL CHECK LARGE MISCLOSURE REJECTIONS
C
      IF( TESTMISCPROB ) THEN
       IF( VTVPR .GT. 6*SDPR .OR. VTVCP .GT. 6*SDCP ) THEN
         IF( IPC .GE. 3 )
     &     WRITE (*,*) 'RE-ENABLING MISCLOSURE DEWEIGHTING'
     &    ,VTVPR,6*SDPR,VTVCP,6*SDCP,DVPV
     &    ,1.2*((NSVO-NSVDWGT) + SQRT(2.d0*(NSVO-NSVDWGT))*2.58)*SO 
         K=0
         DO I=1,NSVDWSAV
          DO J=1,NSVO
            IF( ISVDWSAV(I).EQ.ISVO(J)) K=J
          END DO
          IF( K.NE.0 ) THEN
           IF( OUTLIERACTION .NE. 0 ) THEN
           PL(IOBTYP*(K-1)+1,IOBTYP*(K-1)+1) =
     &          1.D-40 * PL(IOBTYP*(K-1)+1,IOBTYP*(K-1)+1)
           PL(IOBTYP*K,IOBTYP*K) = 
     &          1.D-40 * PL(IOBTYP*K,IOBTYP*K)
           ENDIF
           NRESREJ=NRESREJ+1
           IF (NRESREJ .LE. MAXRES) THEN
            IF( (VPR(K,1).GE.1.D5 .OR. VPR(K,1).LE.-1.D4) .AND.
     &          (VCP(K,1).GE.1.D3 .OR. VCP(K,1).LE.-1.D2) ) THEN
             WRITE(MISFMT,1210) 'E','E'
            ELSE IF( VCP(K,1).GE.1.D3 .OR.VCP(K,1).LE.-1.D2 ) THEN
             WRITE(MISFMT,1210) 'F','E'
            ELSE IF( VPR(K,1).GE.1.D5 .OR.VPR(K,1).LE.-1.D4 ) THEN
             WRITE(MISFMT,1210) 'E','F'
            ELSE
             WRITE(MISFMT,1210) 'F','F'
            ENDIF
            WRITE(RESREJ(NRESREJ),MISFMT)  
     &      ISVO(K),IHR,IMIN,INT(SEC),INT((SEC-INT(SEC))*1.D3),
     &      VPR(K,1), VPRTOL, VCP(K,1)*1.D2, VCPTOL*1.D2,IDIR
           ENDIF
          ENDIF
         END DO
         IREASON=6+OUTLIERACTION*10
         CALL VPCREJ ( LPR, NSVDWSAV, ISVDWSAV, NSVO, ISVO, TTAG,
     &                PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                FCP, ICSLIP,
     &                ISPR1, ISPR2,
     &                MSOFF, MSJMP, NRCRJCT, IARC, IPC, IREASON,
     &                MAXSAT, MAXARC )
         CALL RSETPX ( NFPAR, NSVO, NSVOL, ISVO,
     &                  XRVEPO, XRVAPR, CPAMB, OCPAMB, PX, OPX )
C ACCOUNT FOR VELOCITY AFTER RESET
         IF(PTTAG.GT.0.D0) THEN
          DO I=1,3
           XRVEPO(I)=XRVEPO(I)+XRVVEL(I)*(UTTAG-PTTAG)
          END DO
         END IF
         ITER = 0
         INSVO=1
         GO TO 100
       ELSE
         IF( IPC .GE. 3 )
     &     WRITE (*,*) 'UNFLAGGING MISCLOSURES FOR DEWEIGHTING'
     &    ,VTVPR,6*SDPR,VTVCP,6*SDCP,DVPV
     &    ,1.2*((NSVO-NSVDWGT) + SQRT(2.d0*(NSVO-NSVDWGT))*2.58)*SO 
       ENDIF
       NSVDWSAV = 0
       TESTMISCPROB = .FALSE.
      ENDIF
C
C-----------------------------------------------------------------------
C     REJECT SATELLITE WITH RESIDUAL GREATER THAN TOLERANCE > 3*SDPR
C-----------------------------------------------------------------------
C
      IF ( ICLKSOL .EQ. 1 ) THEN
        IF(ISVO(IRJCTPR).GE.33.AND.ISVO(IRJCTPR).LE.64)
     &                                              VPRMAX=VPRMAX/2.D0
        IF ( DABS(VCPMAX) .GT. DABS(VCPTOL) 
     &         .OR. DABS(VPRMAX) .GT. DABS(VPRTOL) ) THEN
          IF (IPC .GT.1.AND.ABS(VPRMAX).GT.ABS(VPRTOL)) THEN
           IF( ISVO(IRJCTPR).GT.32.AND.ISVO(IRJCTPR).LE.64 ) THEN
            WRITE(*,1212) 'MAX VPR',  
     &      ISVO(IRJCTPR),IHR,IMIN,INT(SEC),INT((SEC-INT(SEC))*1.D3),
     &      VPRMAX, VPRTOL, VPR(IRJCTPR,1)/SDPR/2.D0
           ELSE
            WRITE(*,1212) 'MAX VPR',
     &      ISVO(IRJCTPR),IHR,IMIN,INT(SEC),INT((SEC-INT(SEC))*1.D3),
     &      VPRMAX, VPRTOL, VPR(IRJCTPR,1)/SDPR
           ENDIF
          ENDIF
          IF (IPC .GT.1.AND.ABS(VCPMAX).GT.ABS(VCPTOL)) THEN
           WRITE(*,1212)  'MAX VCP',
     &      ISVO(IRJCTCP),IHR,IMIN,INT(SEC),INT((SEC-INT(SEC))*1.D3),
     &      VCPMAX, VCPTOL, VCP(IRJCTCP,1)/SDCP
          END IF
          IF( DABS(VCPMAX) .LE. DABS(VCPTOL ) ) THEN
           IRJCT=IRJCTPR
          ELSE IF( DABS(VPRMAX) .LE. DABS(VPRTOL ) ) THEN
           IRJCT=IRJCTCP
          ELSE IF((ISVO(IRJCTPR).GT.32.AND.ISVO(IRJCTPR).LE.64.AND.
     &             DABS(VPRMAX)/SDPR/2.D0 .GT. DABS(VCPMAX)/SDCP) .OR.
     &            ((ISVO(IRJCTPR).LE.32.OR.ISVO(IRJCTPR).GT.64).AND.
     &             DABS(VPRMAX)/SDPR .GT. DABS(VCPMAX)/SDCP) ) THEN
           IRJCT=IRJCTPR
          ELSE
           IRJCT=IRJCTCP
          ENDIF
          NRESREJ=NRESREJ+1
          NSVRJCT = NSVRJCT + 1
          ISVRJCT(NSVRJCT) = ISVO(IRJCT)
          IF (NRESREJ .LE. MAXRES)  THEN
           IF( (VPR(IRJCT,1).GE.1.D5 .OR. VPR(IRJCT,1).LE.-1.D4) .AND.
     &         (VCP(IRJCT,1).GE.1.D3 .OR. VCP(IRJCT,1).LE.-1.D2) ) THEN
            WRITE(MISFMT,1210) 'E','E'
           ELSE IF( VCP(IRJCT,1).GE.1.D3 .OR.
     &                                     VCP(IRJCT,1).LE.-1.D2 ) THEN
            WRITE(MISFMT,1210) 'F','E'
           ELSE IF( VPR(IRJCT,1).GE.1.D5 .OR.
     &                                     VPR(IRJCT,1).LE.-1.D4 ) THEN
            WRITE(MISFMT,1210) 'E','F'
           ELSE
            WRITE(MISFMT,1210) 'F','F'
           ENDIF
           WRITE(RESREJ(NRESREJ),MISFMT)  
     &      ISVO(IRJCT),IHR,IMIN,INT(SEC),INT((SEC-INT(SEC))*1.D3),
     &      VPR(IRJCT,1), VPRTOL, VCP(IRJCT,1)*1.D2, VCPTOL*1.D2
     &      ,IDIR
          END IF
           IF( OUTLIERACTION .NE. 0 ) THEN
          PL(IOBTYP*(IRJCT-1)+1,IOBTYP*(IRJCT-1)+1) =
     &          1.D-40 * PL(IOBTYP*(IRJCT-1)+1,IOBTYP*(IRJCT-1)+1)
          PL(IOBTYP*IRJCT,IOBTYP*IRJCT) = 
     &          1.D-40 * PL(IOBTYP*IRJCT,IOBTYP*IRJCT)
           ENDIF
          IREASON=6+OUTLIERACTION*10
c!      WRITE(*,*) 'RESIDUALS REJECTED'
          CALL OPCREJ ( LPR, IRJCT, NSVO, ISVO, TTAG, 
     &                   PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                   FCP, ICSLIP,
     &                   ISPR1, ISPR2,
     &                   MSOFF, MSJMP, 
     &                   NRCRJCT, IARC(ISVO(IRJCT)), IPC, IREASON )
C
C         RESTORE PARAMETERS AND VARIANCES FROM LAST UPDATED EPOCH
C
          CALL RSETPX ( NFPAR, NSVO, NSVOL, ISVO, 
     &                  XRVEPO, XRVAPR, CPAMB, OCPAMB, PX, OPX )
C
C ACCOUNT FOR VELOCITY AFTER RESET
          IF(PTTAG.GT.0.D0) THEN
           DO I=1,3
            XRVEPO(I)=XRVEPO(I)+XRVVEL(I)*(UTTAG-PTTAG)
           END DO
          END IF
          ITER=0
          INSVO=1
          GO TO 100
        END IF
      END IF
C
C-----------------------------------------------------------------------
C     COMPUTE PDOP and GDOP
C-----------------------------------------------------------------------
C
      GDOP= DSQRT((EVX(1,1)+EVX(2,2)+EVX(3,3)))
      GDOP= DSQRT(GDOP**2+.299792458**2*(EVX(4,4)+EVX(5,5)))
      IF( GDOP .GT. 99.D0 ) GDOP=99.D0
      PDOP= DSQRT((VX(1,1)+VX(2,2)+VX(3,3))/SDPR/SDPR)
C
C------------------------------------------------------------------------
C     INITIAL EPOCH - UPDATE A-PRIORI COORDINATES IF REQUIRED
C------------------------------------------------------------------------
C 
      IF (INIEPO) THEN
        WRITE(*,*) 'INITIAL EPOCH PROCESSING'
        WRITE(*,*) 'GDOP,DOPMAX,NSVO,VTVPR',PDOP,DOPMAX,NSVO,VTVPR
        IF ( PDOP .LT. DOPMAX .AND. VTVPR .LT. 5*SDPR ) THEN
          WRITE(*,*) 'SOLUTION VALID' 
          INIEPO=.FALSE.
          IF(GPS) XRVAPR(4)= XRVEPO(4)
          IF(GLN) XRVAPR(8)= XRVEPO(8)
          IF(GAL) XRVAPR(9)= XRVEPO(9)
          IF(BEI) XRVAPR(10)= XRVEPO(10)
C   reset observed satellites for initial code fix
          NSVOL = 0
          DO I=1,MAXOBS
           ISVOL(I)=0
          END DO
C
C         COMPUTE CORRECTION VECTOR TO COORDINATES
C
          XRVCOR=0.D0
          DO I=1,3
          XRVCOR=XRVCOR+(XRVEPO(I)-XRVMRK(I)) * (XRVEPO(I)-XRVMRK(I))
          XRVCOD(I)=XRVEPO(I)-ANTX(I)
          END DO
          XRVCOR=DSQRT(XRVCOR)
          CORMAX=100.D0
          WRITE(*,*) 'XRVCOR,CORMAX',XRVCOR,CORMAX
C
C UPDATE THE INITIAL COORDINATES ONLY IF NOT FROM CMD FILE
C
          IF ( XRVCOR .GT. CORMAX .AND. IXRVRNX .NE. 0 ) THEN 
            WRITE(*,*) 'UPDATING INITIAL COORDINATES' 
            CALL INIXRV ( DTM, XRVEPO, PLHEPO, XRVAPR,
     &                    XRVMRK, PLHMRK, XRVAPC, XRVINI,
     &                    ANTX )
          END IF
        END IF
C
C       RESTORE EPOCH A-PRIORI PARAMETERS AND VARIANCES 
C
        CALL RSETPX ( NFPAR, NSVO, NSVOL, ISVO, 
     &                XRVEPO, XRVAPR, CPAMB, OCPAMB, PX, OPX )    
        ITER=0
        INSVO=1
C
C INITIAL CODE SOLUTION HAS NOT SUCCEEDED: LOOK FOR NEXT
C
        IF (INIEPO) THEN
          INIEPOCHDEL=INIEPOCHDEL+1
          NEPOCHDEL=NEPOCHDEL+1
          GO TO 90
C
C INITIAL CODE SOLUTION HAS SUCCEEDED: RESET FOR REPROCESSING
C
        ELSE
          IOBTYP=NOBTYP
          ITRPSOL=NTRPSOL
          IF (IOBTYP .EQ. 2) THEN
          WRITE(*,*) 'RESETING INIPX' 
C check if vmf par available to constrain the ini tropo to 1 cm
            CALL INIPX ( LPR, NPAR, IPOSSOL, ICLKSOL,  
     &                   ITRPSOL, IOBTYP, SDPR, SDCP,
     &                   NFPAR, PL, PX, OPX, C, IPX, IMODE )
          END IF
          IF ( IONSLM .GE. 2 ) THEN
           IF ( ISLMFMT .EQ. 1 ) THEN
             DTION=UTTAG-TION
  300        CONTINUE
             IF (DTION .GE. MAPINT ) THEN
              INXMAP=INXMAP+1
              IF ( INXMAP .EQ. 1 ) THEN
               IF( IPC .GE. 1 )
     &         WRITE(*,'(/,A50,I5,/)') 
     &             '*** GPSPPP - OPENING IONOSPHERIC GRID ',INXMAP
               OPEN  ( LUION,FILE=NAMION(NDAY),STATUS='OLD',
     &                   IOSTAT=IOS, ERR=600 )
              END IF
              CALL RDSSLM ( LUION, LUO, PLHMRK(1), IYGRD, IMGRD, IDGRD,
     &                STNA,
     &                FRLAT, TOLAT, DLAT, FRLON, TOLON, DLON, 
     &                TION, ADION, RDION, 
     &                NRXDCB, LRXDCB, RXDCB, RXDCBS,
     &                NSVDCB, LSVDCB, SVDCB, SVDCBS, 
     &                MININC, SLMHGT, IONREF, ISLMFMT,
     &                PI, INXMAP, MAXMAP, MAPINT, IONBAND, REFLAT, 
     &                IEXP,
     &                       IRC, IDIR )
              IF( SLMHGT .LT. 200.D0 .OR.
     &             SLMHGT .GT. 800.D0 ) SLMHGT=HION
              IF ( INXMAP .EQ. 1 ) THEN
                SLMGPS=.FALSE.
                SLMGLN=.FALSE.
                DO I=1,NSVDCB
                 IF(DABS(SVDCB(I)).LT.100.D0) THEN
                  PRNDCB(LSVDCB(I))=SVDCB(I)
                  IF(LSVDCB(I).LE.32) THEN
                    SLMGPS=.TRUE.
                  ELSE IF(LSVDCB(I).LE.56) THEN
                    SLMGLN=.TRUE.
                  ENDIF
                 ENDIF
                END DO
C THE INPUT DCB IS ONLY VALID FOR L3 PROCESSING
                IF( IFREQ .EQ. 3 ) THEN
                DO I=1,NRXDCB
                 IF( LRXDCB(I) .EQ. STNA(1:4) ) THEN
                  HORDION(1) = RXDCB(I)
                  HORDION(11) = 1.D20
                 END IF
                END DO
                END IF
                IF(.NOT.SLMGPS) THEN
                 DO I=1,32
                 IF(DABS(DP1P2(I)).LT.300.D0) PRNDCB(I)=DP1P2(I)*1.D-9*C
                 END DO
                ELSE
                 DO I=1,32
                 IF(DABS(PRNDCB(I)).LT.300.D0) DP1P2(I)=PRNDCB(I)*1.D9/C
                END DO
                ENDIF
                IF(.NOT.SLMGLN) THEN
                 DO I=33,56
                 IF(DABS(DP1P2(I)).LT.300.D0) PRNDCB(I)=DP1P2(I)*1.D-9*C
                 END DO
                ELSE
                 DO I=33,56
                 IF(DABS(PRNDCB(I)).LT.300.D0) DP1P2(I)=PRNDCB(I)*1.D9/C
                END DO
                ENDIF
              END IF
              IF( IPC .GE. 1 )
     &        WRITE(*,'(/,A50,I5,F12.1,/)') 
     &             '*** GPSPPP - READ IONOSPHERIC MAP ',INXMAP,DTION
              DTION=UTTAG-TION
C
              IF (INXMAP .LT. MAXMAP ) GO TO 300
             END IF
             RNG=SQRT(XRVEPO(1)**2+XRVEPO(2)**2+XRVEPO(3)**2)
             XSV(1) = XRVEPO(1) + 2.D5 * XRVEPO(1)/RNG
             XSV(2) = XRVEPO(2) + 2.D5 * XRVEPO(2)/RNG
             XSV(3) = XRVEPO(3) + 2.D5 * XRVEPO(3)/RNG
             CALL GRDLAY( LPR, IYEAR, IMTH, IDAY, TTAG(1), XRVEPO, XSV,
     &               0.D0, DTM(1), SLMHGT, MININC, REFLAT, FRLON, 
     &               DLAT, DLON, ADION, RDION, 0.D0, VIONCOR,
     &               SIONCOR, IONREF, TION, PI )
             IF (DABS(DTION) .LE. 1.44D4 .AND.
     &                            VIONCOR .NE. 999.D0 ) THEN
              HORDION(2) = VIONCOR*100.D0
              IF(IPC .GT. 1)
     &        WRITE(*,*) 'INITIALIZED VTEC FROM GRID TO: '
     &         ,HORDION(2)
             ELSE IF(IPC .GT. 1) THEN
              WRITE(*,*) 'UNABLE TO INITIALIZE VTEC: USING '
     &         ,HORDION(2)
               ENDIF
           ELSE IF (ISLMFMT .EQ. 2 ) THEN
             CALL IONBRD (AIONBRD, BIONBRD, PI/2.0D0,
     &                 0.D0, PLHEPO(1), PLHEPO(2),
     &                 TTAG(1), PI, C, SIONCOR,VIONCOR)
             SLMHGT=350.D0
             HORDION(2)=VIONCOR*100.D0
             IF(IPC .GT. 1)
     &       WRITE(*,*) 'INITIALIZED VTEC FROM BRD TO: '
     &         ,HORDION(2)
           ELSE IF ( ISLMFMT .EQ. 3 ) THEN
             IF( IPC .GE. 1 )
     &       WRITE(*,'(/,A60,/)') 
     &             '*** GPSPPP - READING MRTCA IONOSPHERIC MESSAGES '
             CALL RTCAIONRD( LUION, IDIR, UTTAG, TION, TIONX,
     &                    TIONINIT(IONDAY), RTCAVERT, RTCAGIVE, IRC )
             SLMHGT=350.D0
             IF( ( IDIR .EQ. 1 .AND.
     &           TIONX .EQ. TION .AND. IONDAY .LT. NBDAY ) .OR.
     &           ( IDIR .EQ. -1 .AND.
     &           TIONX .EQ. -1 .AND. IONDAY .GT. 1 ) ) THEN
                CLOSE(LUION)
                IONDAY=IONDAY+IDIR
                OPEN(LUION,FILE=NAMION(IONDAY),STATUS='OLD',ERR=600)
                CALL RTCAIONRD( LUION, IDIR, UTTAG, TION, TIONX,
     &                     TIONINIT(IONDAY), RTCAVERT, RTCAGIVE, IRC )
             END IF
             IF( TION .GE. 0 .AND. UTTAG-TION .GE. 0 .AND.
     &         UTTAG-TION .LT. 7200 ) THEN
               CALL RTCADLAY( LPR, PLHEPO(1), PLHEPO(2), AZ(IDX(IPRN)),
     &                    EL(IDX(IPRN)), RTCAVERT, RTCAGIVE,
     &                    VIONCOR, SIONCOR, PI )
               IF( TION .GE. 0 .AND. UTTAG-TION .GE. 0 .AND.
     &             UTTAG-TION .LE. 7200 .AND.
     &             VIONCOR .NE. 999.D0 ) THEN
                 HORDION(2) = VIONCOR
                 IF(IPC .GT. 1)
     &           WRITE(*,*) 'INITIALIZED VTEC FROM RTCA TO: '
     &           ,HORDION(2)
               ELSE IF(IPC .GT. 1) THEN
                 WRITE(*,*) 'UNABLE TO INITIALIZE VTEC: USING '
     &         ,HORDION(2)
               ENDIF
             ENDIF
           ELSE IF( ISLMFMT .EQ. 6 ) THEN
            IF( IPC .GE. 1 ) WRITE(*,'(/,A60,/)') 
     &             '*** GPSPPP - READING RTCM-SSR IONOSPHERIC MESSAGES '
            CALL RTCMIONRD( LUION,IDIR,UTTAG,TION,TIONX,
     &                      TIONINIT(IONDAY),
     &                  TION_END(IONDAY), SLMHGT, SCHA_INT, SCHA_NSET,
     &                  SCHA_DEG, SCHA_ORD, SCHA_REF, SCHA_T, SCHA_L,
     &                  SCHA_M, SCHA_NMN, SCHA_ALM, SCHA_BLM, SCHA_DLM )
            IF( ( IDIR .EQ. 1 .AND.
     &            TION_END(IONDAY) .GT. 0 .AND.
     &            UTTAG .GT. TION_END(IONDAY) .AND.
     &                            IONDAY .LT. NBDAY ) .OR.
     &          ( IDIR .EQ. -1 .AND.
     &            TIONX .EQ. -1 .AND. IONDAY .GT. 1 ) ) THEN
             CLOSE(LUION)
             IONDAY=IONDAY+IDIR
             OPEN(LUION,FILE=NAMION(IONDAY),STATUS='OLD',ERR=600)
             CALL RTCMIONRD( LUION,IDIR,UTTAG,TION,TIONX,
     &                       TIONINIT(IONDAY),
     &                  TION_END(IONDAY), SLMHGT, SCHA_INT, SCHA_NSET,
     &                  SCHA_DEG, SCHA_ORD, SCHA_REF, SCHA_T, SCHA_L,
     &                  SCHA_M, SCHA_NMN, SCHA_ALM, SCHA_BLM, SCHA_DLM )
            END IF
            IF( TION .GE. 0 .AND. UTTAG-TION .GE. 0 .AND.
     &          UTTAG-TION .LT. 7200 ) THEN
             RNG=SQRT(XRVEPO(1)**2+XRVEPO(2)**2+XRVEPO(3)**2)
             XSV(1) = XRVEPO(1) + 2.D5 * XRVEPO(1)/RNG
             XSV(2) = XRVEPO(2) + 2.D5 * XRVEPO(2)/RNG
             XSV(3) = XRVEPO(3) + 2.D5 * XRVEPO(3)/RNG
             CALL IONPT( XRVEPO, XSV, 0.D0, DTM(1), 1.D3*SLMHGT,
     &                 TECX, TECZ, PI )
             CALL IPPSH2TEC( TECZ(1)*180D0/PI, TECZ(2)*180D0/PI, UTTAG,
     &                   SCHA_INT, SCHA_REF, SCHA_T, SCHA_L, SCHA_M,
     &                   SCHA_NMN, SCHA_ALM, SCHA_BLM, SCHA_DLM,
     &                   SCHA_NSET, VIONCOR, SVIONCOR )
             IF( VIONCOR .GE. 0.D0 ) THEN
               HORDION(2)=VIONCOR*100.D0/9.52D0
               IF(IPC .GT. 1)
     &         WRITE(*,*) 'INITIALIZED VTEC FROM RTCM1264 TO: '
     &           ,HORDION(2)
             ELSE IF(IPC .GT. 1) THEN
               WRITE(*,*) 'UNABLE TO INITIALIZE VTEC: USING '
     &         ,HORDION(2)
             ENDIF
            ENDIF
           ELSE IF( ISLMFMT .EQ. 4 .OR. ISLMFMT .EQ. 5 ) THEN
             IF( IPC .GE. 1 )
     &       WRITE(*,'(/,A60,/)') 
     &           '*** GPSPPP - READING SPHERICAL HARM.COEFFICIENTS '
             SCHA_NSET=2
             IF( ISLMFMT .EQ. 4 ) THEN
             CALL SCHACOEFBUF( LUION, IDIR, UTTAG, SCHA_CNT, SCHA_INT,
     &                    SCHA_T, SCHA_L, SCHA_M, SCHA_NMN,
     &                    SCHA_ALM, SCHA_BLM, SCHA_NSET )
             ELSE
             CALL SHCOEFBUF( LUION, IDIR, UTTAG, SCHA_CNT, SCHA_INT, 
     &                      SCHA_REF, SCHA_DEG, SCHA_ORD, SCHA_T,
     &                      SCHA_L, SCHA_M, SCHA_NMN, SCHA_ALM,
     &                      SCHA_BLM, SCHA_DLM, SCHA_NSET )
             ENDIF
             IF( SCHA_NSET .LT. 2 .AND.
     &          (( IDIR .EQ. 1 .AND. IONDAY .LT. NBDAY ) .OR.
     &           ( IDIR .EQ. -1 .AND. IONDAY .GT. 1 )) ) THEN
                IONDAY=IONDAY+IDIR
                CLOSE(LUION)
                OPEN(LUION,FILE=NAMION(IONDAY),STATUS='OLD',ERR=600)
                IF( ISLMFMT .EQ. 4 ) THEN
                IF( SCHACOEFHEAD( LUION, SCHA_ORD, SCHA_CLAT, SCHA_CLON,
     &                  SCHA_CAP, SLMHGT, SCHA_CNT, SCHA_INT, SCHA_DCB )
     &              .LT. 0 ) WRITE(*,'(/,A60,/)') 
     &           '*** ERROR - READING SPHERICAL CAP HARM.COEFFICIENTS '
                ELSE
                IF( SHCOEFHEAD( LUION,SCHA_DEG,SCHA_ORD,SCHA_CNT,
     &                          SCHA_INT, SLMHGT, SCHA_DCB, SCHA_REF )
     &                                                          .LT. 0 )
     &            WRITE(*,'(/,A60,/)')
     &           '*** ERROR - READING GLOBAL SPH. HARM.COEFFICIENTS '
                ENDIF
                IF( ISLMFMT .EQ. 4 ) THEN
                CALL SCHACOEFBUF( LUION, IDIR, UTTAG, SCHA_CNT,SCHA_INT,
     &                        SCHA_T, SCHA_L, SCHA_M, SCHA_NMN,
     &                        SCHA_ALM, SCHA_BLM, SCHA_NSET )
                ELSE
                CALL SHCOEFBUF( LUION, IDIR, UTTAG, SCHA_CNT, SCHA_INT, 
     &                          SCHA_REF, SCHA_DEG, SCHA_ORD, SCHA_T,
     &                          SCHA_L, SCHA_M, SCHA_NMN, SCHA_ALM,
     &                          SCHA_BLM, SCHA_DLM, SCHA_NSET )
                ENDIF
             ENDIF
             RNG=SQRT(XRVEPO(1)**2+XRVEPO(2)**2+XRVEPO(3)**2)
             XSV(1) = XRVEPO(1) + 2.D5 * XRVEPO(1)/RNG
             XSV(2) = XRVEPO(2) + 2.D5 * XRVEPO(2)/RNG
             XSV(3) = XRVEPO(3) + 2.D5 * XRVEPO(3)/RNG
             CALL IONPT( XRVEPO, XSV, 0.D0, DTM(1), 1.D3*SLMHGT,
     &                 TECX, TECZ, PI )
             IF( ISLMFMT .EQ. 4 ) THEN
             CALL IPP2TEC( TECZ(1)*180D0/PI, TECZ(2)*180D0/PI, UTTAG,
     &                   SCHA_CLAT, SCHA_CLON, SCHA_CAP, SCHA_INT,
     &                   SCHA_T, SCHA_L, SCHA_M, SCHA_NMN,
     &                   SCHA_ALM, SCHA_BLM, SCHA_NSET, VIONCOR )
             ELSE
             CALL IPPSH2TEC( TECZ(1)*180D0/PI, TECZ(2)*180D0/PI, UTTAG,
     &                   SCHA_INT, SCHA_REF, SCHA_T, SCHA_L, SCHA_M,
     &                   SCHA_NMN, SCHA_ALM, SCHA_BLM, SCHA_DLM,
     &                   SCHA_NSET, VIONCOR, SVIONCOR )
             ENDIF
             IF( VIONCOR .GE. 0.D0 ) THEN
               HORDION(2)=VIONCOR*100.D0/9.52D0
               IF(IPC .GT. 1)
     &         WRITE(*,*) 'INITIALIZED VTEC FROM SPH.HARM. TO: '
     &           ,HORDION(2)
             ELSE IF(IPC .GT. 1) THEN
               WRITE(*,*) 'UNABLE TO INITIALIZE VTEC: USING '
     &         ,HORDION(2)
             ENDIF
           END IF
C
C DISABLING IONO FILE READING WHEN OPERATION ON CODE*PHASE
C
           IF( IONSLM .EQ. 3 ) IONSLM = 1
          END IF
          GO TO 100
        END IF
      END IF
C
      IF ( IPC .GT. 2 ) 
     &  CALL WRTDIF( LUO, IHR, IMIN, SEC, GDOP, DRYEPO, XRVEPO,
     &               XRVMRK, VX, C )
      IF(IMODE .EQ. 2 .AND. PDOP.GT.100) GO TO 997
C
      IF( DX .GT. 0.1D0 .AND.
     &    DX .GT. DSQRT(VX(1,1)+VX(2,2)+VX(3,3)) ) GO TO 100
      IF(IMODE.GE.2) THEN
        IF (MOD(ITRPSOL,10) .NE. 1) THEN
          XRVEPO(5) = XRVEPO(5) - X(5,1)
          IF( ITRPSOL .GT. 100 ) THEN
            XRVEPO(6) = XRVEPO(6) - X(6,1)
            XRVEPO(7) = XRVEPO(7) - X(7,1)
          END IF
        END IF
        DO I=1,NSVO
          VCPAMB(ISVO(I)) = X(I+NFPAR,1)*C/1.D9
          CPAMB(ISVO(I))  = CPAMB(ISVO(I)) - VCPAMB(ISVO(I))
          SCPAMB(ISVO(I)) = DSQRT(VX(I+NFPAR,I+NFPAR))*C/1.D9
        END DO
      END IF
C
C ***************** END  OF  ADJUSTMENT  SECTION  ***********************'
C 
      IF((IDIR+ISMEPO).GE.0) THEN
C DRIFRT - GLN IF RATE DIFF (SUM); SUMIGF - SUM of ABS GLN FCY NO.
        DRIFRT= 0.d0
        SUMIGF= 0.d0
        DO IO=1,NSVO
          NRC(ISVO(IO),IARC(ISVO(IO)))=NRC(ISVO(IO),IARC(ISVO(IO)))+1
          IF( PX(NFPAR+IO,NFPAR+IO).GT..9D6 )
     &     NRCFX(ISVO(IO),IARC(ISVO(IO)))=
     &                               NRCFX(ISVO(IO),IARC(ISVO(IO)))+1
C RELY ON THE NEW FLTOBS CY SLIP CORRECTIONS/DETECTIONS ONLY
C BUT ONLY WHEN CY SLIP RECOV IS ON
          IF(FLTSUM(16,ISVO(IO)).LT.DMXNLSAV.AND.
     &       FLTSUM(17,ISVO(IO)).LT.DMXWLSAV.AND.
     &       FLTPAR(5).GT.31.D0) THEN
          NEWAMB = 0
          ELSE
C FORCE THE SAME SATELLITE SLIP RECOV IS OFF!
          NEWAMB = 1
          DO IL=1,NSVOL
          IF ( ISVO(IO) .EQ. ISVOL(IL) ) NEWAMB=0
          END DO
          ENDIF
          IF( ICSLIP15(ISVO(IO)) .NE. 0 ) THEN
          NEWAMB=ICSLIP15(ISVO(IO))
          ICSLIP15(ISVO(IO))=0
C
C CLEARING DCM RESET
C
          CLKAMB(ISVO(IO)) = .FALSE.
          END IF
          IAMB(ISVO(IO)) = NEWAMB
        IF (NEWAMB .NE. 0) CPIAMB(ISVO(IO)) = CPAMB(ISVO(IO))
          DCPAMB(ISVO(IO)) = CPAMB(ISVO(IO))-CPIAMB(ISVO(IO))
C
C       UPDATE THE SIGMAS OF UNIT WEIGHT
C
          IPRN= ISVO(IO)
          IF ( IOBTYP .EQ. 1 ) THEN
            IOBPR = IOB
          ELSE
            IOBPR = IOB*2-1
            IOBCP = IOB*2
          END IF
          CALL UPDSUW ( IPRN, IOBPR, IOBCP, IDX, EL, IPEPACC, PRDC, 
     &          SDCP, SUWCP, SUWPR, C, PI) 
           VPR(IO,1)=VPR(IO,1)/SUWPR
C
          PRIAMB=FLTSUM(8,IPRN)-FLTSUM(13,IPRN)-WUPCOR(IDX(IPRN))
          IF (IFREQ .LT. 3) PRIAMB=FLTSUM(5,IPRN)
          IF( (VPR(IO,1) .GE. 1.D5 .OR. VPR(IO,1) .LE. -1.D4) .AND.
     &        (VCP(IO,1)/SUWCP .GE. 1.D5 .OR.
     &                            VCP(IO,1)/SUWCP .LE. -1.D4) ) THEN
           WRITE(RESFMT,2610) 'E', 'E'
          ELSE IF( VPR(IO,1) .GE. 1.D5 .OR. VPR(IO,1) .LE. -1.D4 ) THEN
           WRITE(RESFMT,2610) 'E', 'F'
          ELSE IF( VCP(IO,1)/SUWCP .GE. 1.D5 .OR.
     &                             VCP(IO,1)/SUWCP .LE. -1.D4 ) THEN
           WRITE(RESFMT,2610) 'F', 'E'
          ELSE
           WRITE(RESFMT,2610) 'F', 'F'
          ENDIF
          WRITE(LRES,RESFMT) DIR((1-IDIR)/2+1), IYEAR, IMTH, IDAY,
     &            JULD+FMJDDT,IHR,IMIN,INT(DINT(SEC*1000+.5)/1000.),
     &            MOD(INT(SEC*1000+0.5),1000),
     &            INT(ISVO(IO)),AZ(IDX(IPRN)),EL(IDX(IPRN)),
     &            VPR(IO,1)      , VCP(IO,1)/SUWCP,CPAMB(IPRN), 
     &            DCPAMB(IPRN),CPIAMB(IPRN),
     &            CPAMB(IPRN)+PRIAMB,NEWAMB
     &            ,ION2COR(IDX(IPRN))
     &           ,FLTSUM(16,IPRN),FLTSUM(17,IPRN)
     & ,fltsum(22,iprn)+PRDC(9,iprn)/AL4 -dn12ref                        
     &          ,DLOG10(SDPR*DSQRT(PL((IO-1)*IOBTYP+1,(IO-1)*IOBTYP+1)))
C Compute the running res average
          NCPDF(IPRN, MAXARC)= NCPDF(IPRN, MAXARC)+1
          CPAVG(IPRN,MAXARC)=  CPAVG(IPRN, MAXARC)  +(VCP(IO,1)-
     &    CPAVG(IPRN,MAXARC))/10.                
          IF ( IPC .GT. 1 )
     &      WRITE(*,11111)
     &            NEWAMB,IHR,IMIN,SEC,INT(IPRN),
     &            AZ(IDX(IPRN)), EL(IDX(IPRN)),
     &            VPR(IO,1),VCP(IO,1),CPAMB(IPRN),
     &            DCPAMB(IPRN),CPIAMB(IPRN)
11111 FORMAT(I1,3X,2(I2.2,':'),F4.1,3X,'PRN',I3.3,
     &                       2(3X,F7.1),5(3X,F10.3))
         IF(IPRN.GT.32.AND.IPRN.LE.64.AND.IGF(IPRN).NE.0) THEN
          DRIFRT= DRIFRT +SIGN(1   ,IGF(IPRN))*(VPR(IO,1))
     &            *ABS(SIN(EL(IDX(iprn))/57.296d0))
          SUMIGF= SUMIGF+ABS(IGF(IPRN))*ABS(SIN(EL(IDX(iprn))/57.296d0))
         ENDIF
        END DO
        IF(SUMIGF.GT.0.D0.AND.IDIR.EQ.1) THEN
          RIFRATE=RIFRATE + DRIFRT/0.2998D0/SUMIGF/(NFIX+1)
          SRIFRT = SRIFRT  + (DRIFRT/0.2998D0/SUMIGF)**2
        ENDIF
        SOLTTAG = UTTAG
      END IF
C
C       IF CODE/CARRIER SOLUTION,
C       COMPUTE STATISTIC ON AMBIGUITY RESIDUALS
C
      IF ( IOBTYP .EQ. 2 ) THEN
         CALL AMSTAT (NSVO, ISVO, IAMB, VCPAMB, SCPAMB, 
     &                AMBRMS, AMBWRMS)
c!    WRITE(*,'(20I6)') (ISVO(I),I=1,NSVO)
c!    WRITE(*,'(20I6)') (IAMB(ISVO(I)),I=1,NSVO)
c!    WRITE(*,'(20F6.2)') (VCPAMB(ISVO(I)),I=1,NSVO)
c!    WRITE(*,'(20F6.2)') (SCPAMB(ISVO(I)),I=1,NSVO)
         IAMBSUM=0
         DO I=1,NSVO
          IF( IAMB(ISVO(I)) .NE. 0 )
     &     IAMBSUM=IAMBSUM+1
       END DO
c!        WRITE(*,"(A3,3X,2(I2.2,':'),I2.2,'.',I3.3,3X,3F10.4)") 'AMB',
c!   &           IHR,IMIN,INT(SEC),INT((SEC-INT(SEC))*1.D3),
c!   &           IAMBSUM*1.D-1, AMBRMS,AMBWRMS
      END IF
      IF(IMODE.GT.1) THEN
      DO I=1,3
       IF( UTTAG.NE.PTTAG.AND.PTTAG.GT.0.D0)
     &   XRVVELP(I)=XRVVEL(I)
       IF( UTTAG.NE.ENDTTAG ) XRVVEL(I)=0.D0
       IF(UTTAG.NE.PTTAG.AND.PTTAG.GT.0.D0)     
     &   XRVVEL(I)=  (XRVEPO(I)-XRVAPR(I))/(UTTAG-PTTAG)
       IF( NFIX .GT. 1 .AND. UTTAG.NE.PTTAG.AND.PTTAG.GT.0.D0)
     &    XRVACC(I)=(XRVVEL(I)-XRVVELP(I))/(UTTAG-PTTAG)
      ENDDO
      IF( NFIX .GE. 2 ) THEN
        NBACCEVAL=MIN(NBACCEVAL+1,10)
        XRVACC3D=((NBACCEVAL-1)*XRVACC3D+
     &          DSQRT(XRVACC(1)**2+XRVACC(2)**2+XRVACC(3)**2))/NBACCEVAL
      ENDIF
      ENDIF
C ACCOUNT FOR WET ZPD WITH CHANGING HEIGHT (kouba 07 JoG grid VMF1)
C SAVE STATIC WET ZPD
C ACCOUNT FOR WET ZPD WITH CHANGING HEIGHT (exponentially e(h/2km)) 
       IF(RXVEL.LE.1.D0) THEN
        WETZPD=MIN(MAX(ABS(XRVEPO(5)),0.1D03),0.5D0)
       ELSE
        WETZPDNEW=XRVEPO(5)-WETZPD*(XRVVEL(1)*XRVEPO(1)+XRVVEL(2)*
     & XRVEPO(2)+ XRVVEL(3)*XRVEPO(3))*(UTTAG-PTTAG)/SQRT(XRVEPO(1)**2+
     & XRVEPO(2)**2+XRVEPO(3)**2)/2.D03/EXP(PLHEPO(3)/2.D3)
        IF( WETZPDNEW.GE.-0.1D0 .AND. WETZPDNEW.LE.0.5D0)
     &   XRVEPO(5)=WETZPDNEW
       ENDIF
c!     write(*,*) IDIR,(XRVVEL(I),I=1,3),(UTTAG-PTTAG), XRVEPO(5),sdtrop 
c!   &, wetzpd
C
C-----------------------------------------------------------------------
C     WRITE OUT EPOCH PARAMETER ESTIMATES
C-----------------------------------------------------------------------
C
C READ SAVED FWD AMBS & VARIANCES & DO BWD SMOOTHING
      IF(IDIR.EQ.-1.AND.IOBTYP.EQ.2) THEN
        ISMEPO = 0
        IF(UTTAG.GE.STRTTAG-0.003D0)
     &    CALL SMBWD(LUPX, NFPAR, NSVO, C, UTTAG, UPDINT,
     &               XRVEPO, XRVAPR, X, VX, OPX, LSTFWDVX,
     &               SMTHCLK,
     &               SOBWD,SO, STRTTAG, MINFX, NFIX, ISMEPO, IMODE)
      ENDIF
C
C-----------------------------------------------------------------------
C     COMPARE PREDICTED AND OBSERVED RECEIVER CLOCK
C-----------------------------------------------------------------------
C 
      IF ((IDIR+ISMEPO).GE.0) THEN
        IF ( ICLKSOL .EQ. 1 .AND. (GPS .OR. GLN .OR. GAL .OR. BEI)) THEN
          IF( BEI ) ICONST=10
          IF( GAL ) ICONST=9
          IF( GLN ) ICONST=8
          IF( GPS ) ICONST=4
          IF ( NCLKUP .GE. 3 ) THEN
            CLKPRD  = UOFFSET + UDRIFT*(UTTAG-UREFTM)
            DCLKEPO = XRVEPO(ICONST) - CLKPRD
            CLKTOL  = 5.D0*DSQRT(USDOFF**2 
     &              + (USDRIFT*(UTTAG-UREFTM))**2
     &              + VX(ICONST,ICONST)/1.D18       +1.D-20)
c!          WRITE(*,'(A6,5F10.2)') 'XRVEPO(4)',TTAG(NSVO),XRVEPO(4)*1.D9,
c!   &                           CLKPRD*1.D9,DCLKEPO*1.D9,CLKTOL*1.D9
          END IF
C
C-----------------------------------------------------------------------
C     IF PREDICTED AND CURRENT RECEIVER CLOCKS AGREE,
C     COMPUTE UP-TO-DATE AND SESSION STATISTICS
C-----------------------------------------------------------------------
C
C
c!        WRITE(*,*) 'BEFORE CLKTOL',NCLKUP,DABS(DCLKEPO),CLKTOL
          IF ( NCLKUP .GE. 3 .AND. DABS(DCLKEPO) .LT. CLKTOL ) THEN
C
c!         WRITE(*,*) 'BEFORE CLKFIT',TTAG(NSVO),XRVEPO(4),OFFSET
C
C PERFORM CLOCK FITTING FOR GPS, GLONASS AND DIFFERENCES
C
            IF( GPS )
     &        CALL CLKFIT ( UTTAG, -XRVEPO(4), SUMLR(1,1), REFTM0,
     &              OFFSET, DRIFT,DRIFTRATE, SDOFF, 
     &              SDRIFT,SDRIFTRATE, NCLKFIT, ICLKFIT )
            IF( GLN )
     &        CALL CLKFIT ( UTTAG, -XRVEPO(8), SUMLR(1,2), REFTM0,
     &                 ROFFSET,RDRIFT,RDRIFTRATE,RSDOFF,
     &                 RSDRIFT,RSDRIFTRATE,RNCLKFIT,ICLKFIT )
            IF( GLN .AND. GPS )
     &        CALL CLKFIT ( UTTAG, -XRVEPO(8)+XRVEPO(4), SUMLR(1,3),
     &                 REFTM0,DOFFSET,DDRIFT,DDRIFTRATE,DSDOFF,
     &                 DSDRIFT,DSDRIFTRATE,DNCLKFIT,ICLKFIT )
            IF( GAL )
     &        CALL CLKFIT ( UTTAG, -XRVEPO(9), SUMLR(1,4), REFTM0,
     &                 EOFFSET,EDRIFT,EDRIFTRATE,ESDOFF,
     &                 ESDRIFT,ESDRIFTRATE,ENCLKFIT,ICLKFIT )
            IF( GAL .AND. GPS )
     &        CALL CLKFIT ( UTTAG, -XRVEPO(9)+XRVEPO(4), SUMLR(1,5),
     &                 REFTM0,DEOFFSET,DEDRIFT,DEDRIFTRATE,DESDOFF,
     &                 DESDRIFT,DESDRIFTRATE,DENCLKFIT,ICLKFIT )
            IF( BEI )
     &        CALL CLKFIT ( UTTAG, -XRVEPO(10), SUMLR(1,6), REFTM0,
     &                 COFFSET,CDRIFT,CDRIFTRATE,CSDOFF,
     &                 CSDRIFT,CSDRIFTRATE,CNCLKFIT,ICLKFIT )
            IF( BEI .AND. GPS )
     &        CALL CLKFIT ( UTTAG, -XRVEPO(10)+XRVEPO(4), SUMLR(1,7),
     &                 REFTM0,DCOFFSET,DCDRIFT,DCDRIFTRATE,DCSDOFF,
     &                 DCSDRIFT,DCSDRIFTRATE,DCNCLKFIT,ICLKFIT )
            CALL CLKUP ( UTTAG, XRVEPO(ICONST), CLKBUF, CLKTIM, UREFTM,
     &                     UOFFSET, UDRIFT, USDOFF, USDRIFT, NCLKUP )
C
C-----------------------------------------------------------------------
C     IF PREDICTED AND CURRENT RECEIVER CLOCKS DISAGREE,
C     NOTIFY USER. IF ONLY 4 SATELLITES, GO TO NEXT FIX     
C-----------------------------------------------------------------------
C
          ELSE 
            IF ( NCLKUP .GE. 3 ) THEN
c!           WRITE(*,2290) IYEAR,IMTH,IDAY,IHR,IMIN,SEC,DCLKEPO,
c!    &                    CLKTOL,USDOFF,USDRIFT*(UTTAG-UREFTM),
c!    &                    DSQRT(VX(4,4)*VSCALE)
            END IF
            CALL CLKUP ( UTTAG, XRVEPO(ICONST), CLKBUF, CLKTIM, UREFTM, 
     &                     UOFFSET, UDRIFT, USDOFF, USDRIFT, NCLKUP )
          END IF
        END IF
C
        IF ( IPOSSOL .EQ. 2 .OR. ICLKSOL .EQ. 1 ) THEN
         CALL RNGCOR ( ISVO, NSVO, IARC, VPR, NRCDF, RCAVG, RCSIG,
     &                 RCRMS, SDPR, PL, IOBTYP, 1 )
         CALL RNGCOR ( ISVO, NSVO, IARC, VCP, NCPDF, CPAVG, 
     &                 CPSIG, CPRMS, SDCP, PL, IOBTYP, 2 )
        END IF
      END IF
C
C-----------------------------------------------------------------------
C         REMOVE ANTENNA OFFSET TO GET MARKER COORDINATES
C-----------------------------------------------------------------------
C
      CALL XYZPL2 (DTM(3),DTM(4),DTM(5),DTM(1),DTM(2),XRVEPO(1),
     &             XRVEPO(2),XRVEPO(3),PLHEPO(1),PLHEPO(2),PLHEPO(3))
      CALL ANTEX ( DTM, PLHEPO(1), PLHEPO(2), PLHEPO(3),
     &             ANTN(1), ANTE(1),  ANTH(1), ANTX )
      DO I=1,3 
        XRVDIF(I) = XRVEPO(I) - XRVMRK(I) - ANTX(I)
      END DO
C
      IF ( IPC .GT. 1 ) THEN
        WRITE(*,2310) IHR, IMIN, SEC, PDOP, VTVPR, XRVDIF(1), 
     &                  XRVDIF(2) , XRVDIF(3), XRVEPO(4)*1.D9,
     &                  DRYEPO, XRVEPO(5),  XRVEPO(8)*1.D9
     &                 ,XRVEPO(9)*1.D9, XRVEPO(10)*1.D9
C
        WRITE(*,2311) IHR, IMIN, SEC, PDOP, VTVPR, 
     &             DSQRT(VX(1,1)),DSQRT(VX(2,2)),DSQRT(VX(3,3)),
     &             DSQRT(VX(4,4)),DSQRT(VX(5,5)),DSQRT(VX(8,8))
     &            , DSQRT(VX(9,9)), DSQRT(VX(10,10))
      END IF
C
      DO I=1,3
        XRVOUT(I)=XRVEPO(I)-ANTX(I)
      END DO
      CALL XYZPL2 (DTM(3),DTM(4),DTM(5),DTM(1),DTM(2),
     &                   XRVOUT(1),XRVOUT(2),XRVOUT(3),
     &                   PLHOUT(1), PLHOUT(2), PLHOUT(3))
      DO I=1,3
        PLHDIF(I) = PLHOUT(I) - PLHMRK(I)
      END DO
C
C    POSITION STATISTICS COMPUTATION 
C
      IF(ISMEPO.EQ.1) THEN
        NFIX = NFIX + 1
        IF(NAMBFX.GE.3 ) NEPFIX=NEPFIX+1
        CALL POSSIG ( XRVDIF, XRVAVG, XRVSUM, XRVSIG, NFIX )
        CALL POSSIG ( PLHDIF, PLHAVG, PLHSUM, PLHSIG, NFIX )
C      
        DO I=1,3
          XRVRMS(I)=XRVAVG(I)*XRVAVG(I)+XRVSIG(I)*XRVSIG(I)
        XRVRMS(I)=DSQRT(XRVRMS(I))
        PLHRMS(I)=PLHAVG(I)*PLHAVG(I)+PLHSIG(I)*PLHSIG(I)
        PLHRMS(I)=DSQRT(PLHRMS(I))
        END DO        
C
        CALL VX2VP  ( DTM, PLHEPO, VX, VP, SDXYZ, SDPLH )
        CALL DPLH2M ( DTM, PLHEPO, PLHDIF, PLHDIFM )     
        CALL DPLH2M ( DTM, PLHEPO, PLHAVG, PLHAVGM )     
        CALL RADMS ( PLHEPO(1), IDEGP, IMINP, SECP )
        write(CDEGP,'(I6)') IDEGP
        if(IDEGP.eq.0 .and. PLHEPO(1).lt.0.0) CDEGP=NEG_ZERO
        CALL RADMS ( PLHEPO(2), IDEGL, IMINL, SECL )
        write(CDEGL,'(I6)') IDEGL
        if(IDEGL.eq.0 .and. PLHEPO(2).lt.0.0) CDEGL=NEG_ZERO
      END IF
C
C     APPLY OFFSET TO CARTESIAN COORDINATE VARIANCES AND
C     STORE FORMAL OUTPUT XYZ & PLH SIGMAS FOR STATIC MODE 
C
      IF(IDIR.EQ.1.OR. IMODE.GE.2) THEN
        DO I=1,MAXPAR2
          DO J=1,MAXPAR2
          OVX(I,J)=VX(I,J)*VSCALE*SO
        END DO
      END DO    
        CALL VX2VP  ( DTM, PLHEPO, OVX, OVP, OSDXYZ, OSDPLH )
      END IF
C
C
C RECOMPUTE GDOP
C
      PDOP= DSQRT((VX(1,1)+VX(2,2)+VX(3,3))/SDPR/SDPR)
c!    WRITE(*,*) 'SEC,INT(SEC)',SEC,INT(SEC)
      IF(GPS) THEN
        GPSCLK=-(XRVEPO(4)+CLKOFF/C)*1.D9
        SGPSCLK=SQRT(VX(4,4))
      ELSE
        GPSCLK=0.D0
        SGPSCLK=0.D0
      ENDIF
      IF(GLN) THEN
        GLNCLK=-(XRVEPO(8)+CLKOFF/C)*1.D9
        SGLNCLK=SQRT(VX(8,8))
      ELSE
        GLNCLK=0.D0
        SGLNCLK=0.D0
      ENDIF
      IF(GAL) THEN
        GALCLK=-(XRVEPO(9)+CLKOFF/C)*1.D9
        SGALCLK=SQRT(VX(9,9))
      ELSE
        GALCLK=0.D0
        SGALCLK=0.D0
      ENDIF
      IF( GAL ) CLKOFF2=DINT(DABS(GALCLK/1.D6)+.5D0)*DSIGN(1.D6,GALCLK)
      IF(BEI) THEN
        BEICLK=-(XRVEPO(10)+CLKOFF/C)*1.D9
        SBEICLK=SQRT(VX(10,10))
      ELSE
        BEICLK=0.D0
        SBEICLK=0.D0
      ENDIF
      IF( BEI ) CLKOFF2=DINT(DABS(BEICLK/1.D6)+.5D0)*DSIGN(1.D6,BEICLK)
      IF( GLN ) CLKOFF2=DINT(DABS(GLNCLK/1.D6)+.5D0)*DSIGN(1.D6,GLNCLK)
      IF( GPS ) CLKOFF2=DINT(DABS(GPSCLK/1.D6)+.5D0)*DSIGN(1.D6,GPSCLK)
      IF( CLKOFF2 .NE. 0 ) THEN
        CALL TOWHMS( IWKDAY, TTAG(1)-CLKOFF2*1.D-9, IHR, IMIN, SEC, 0 )
        CALL GPSDC ( JULD,IYEAR,IMTH,IDAY,IGPSWK,IWKDAY, 4 )
      IF( GLN ) GLNCLK=GLNCLK-CLKOFF2                     
      IF( GPS ) GPSCLK=GPSCLK-CLKOFF2
      IF( GAL ) GALCLK=GALCLK-CLKOFF2
      IF( BEI ) BEICLK=BEICLK-CLKOFF2
      ENDIF
      IF(.NOT.IAROFF) THEN
      IF( GPS ) GPSCLK=GPSCLK - RAVGALL(1)/C*1.D9
C!! DO NOT CORRECT GLN, GAL, BEI CLKs FOR AVRG PR RESD's
C!! Code Beg ==================================================================
C!!   IF( GLN ) GLNCLK=GLNCLK - RAVGALL(2)/.299792D0         
C!!   IF( GAL ) GPSCLK=GPSCLK - RAVGALL(3)/C*1.D9
C!!   IF( BEI ) BEICLK=BEICLK - RAVGALL(4)/C*1.D9
C!! Code End ==================================================================
      ENDIF
      IF(ISMEPO.EQ.1) THEN
        IF ( IREFIN .NE. IREFOUT ) THEN
           CALL TOREF( XRVOUT, XRVTRF, IREFIN, IREFOUT, TRFPAR, 
     &                 EPOCH )
           CALL XYZPL2 (DTM(3),DTM(4),DTM(5),DTM(1),DTM(2),
     &                 XRVTRF(1),XRVTRF(2),XRVTRF(3),
     &                 PLHTRF(1),PLHTRF(2),PLHTRF(3))
         CALL RADMS ( PLHTRF(1), IDEGP, IMINP, SECP )
           write(CDEGP,'(I6)') IDEGP
         if(IDEGP.eq.0 .and. PLHTRF(1).lt.0.0) CDEGP=NEG_ZERO
         CALL RADMS ( PLHTRF(2), IDEGL, IMINL, SECL )
           write(CDEGL,'(I6)') IDEGL
         if(IDEGL.eq.0 .and. PLHTRF(2).lt.0.0) CDEGL=NEG_ZERO
           IF ( ICOROUT .EQ. 1 ) THEN
           WRITE(LPOS,2410) DIR((1-IDIR)/2+1),RFNAME, 
     &          STNA, JULD+FMJDDT,
     &          IYEAR, IMTH, IDAY, IHR, IMIN,
     &          INT(DINT(SEC*1000+.5)/1000.),
     &          MOD(INT(SEC*1000+0.5),1000), NSVO, 
     &          GDOP, VTVPR, VTVCP, 
     &          PLHDIFM(1), PLHDIFM(2), PLHDIFM(3), 
     &          GPSCLK,DRYEPO+XRVEPO(5),
     &          OSDPLH(1), OSDPLH(2), OSDPLH(3), 
     &          SGPSCLK, SQRT(VX(5,5)),
     &          CDEGP, IMINP, SECP,
     &          CDEGL, IMINL, SECL, PLHTRF(3), IAMBSUM,
     &          XRVEPO(6)*1.d3, XRVEPO(7)*1.d3,
     &          sqrt(VX(6,6))*1.d3, sqrt(VX(7,7))*1.d3
     &         ,XRVEPO(5)
     &          ,GLNCLK,SGLNCLK, GALCLK, SGALCLK, BEICLK, SBEICLK
     &          ,DABS(FLTPAR(1)),DABS(FLTPAR(2)),AVGNL,AVGWL
     &          ,HORDION(2)
     &          ,HORDION(1)/C*1.D9, HORDION(3)/C*1.D9, RIFRATE, NAMBFX
     &          ,NSVDWGT
           ELSE
           WRITE(LPOS,2411) DIR((1-IDIR)/2+1),RFNAME, 
     &          STNA, JULD+FMJDDT,
     &          IYEAR, IMTH, IDAY, IHR, IMIN,
     &          INT(DINT(SEC*1000+.5)/1000.),
     &          MOD(INT(SEC*1000+0.5),1000), NSVO, 
     &          GDOP, VTVPR, VTVCP, 
     &          XRVDIF(1), XRVDIF(2), XRVDIF(3), 
     &          GPSCLK,DRYEPO+XRVEPO(5),
     &          OSDXYZ(1), OSDXYZ(2), OSDXYZ(3), 
     &          SGPSCLK, SQRT(VX(5,5)),
     &          XRVTRF(1), XRVTRF(2), XRVTRF(3), IAMBSUM,
     &          XRVEPO(6)*1.d3, XRVEPO(7)*1.d3,
     &          sqrt(VX(6,6))*1.d3, sqrt(VX(7,7))*1.d3
     &         ,XRVEPO(5)
     &          ,GLNCLK,SGLNCLK, GALCLK, SGALCLK, BEICLK, SBEICLK
     &          ,DABS(FLTPAR(1)),DABS(FLTPAR(2)),AVGNL,AVGWL
     &          ,HORDION(2)
     &          ,HORDION(1)/C*1.D9, HORDION(3)/C*1.D9, RIFRATE,NAMBFX
     &          ,NSVDWGT
          END IF
C
        ELSE
          IF ( ICOROUT .EQ. 1 ) THEN
           CALL RADMS ( PLHOUT(1), IDEGP, IMINP, SECP )
             write(CDEGP,'(I6)') IDEGP
           if(IDEGP.eq.0 .and. PLHOUT(1).lt.0.0) CDEGP=NEG_ZERO
           CALL RADMS ( PLHOUT(2), IDEGL, IMINL, SECL )
             write(CDEGL,'(I6)') IDEGL
           if(IDEGL.eq.0 .and. PLHOUT(2).lt.0.0) CDEGL=NEG_ZERO
           WRITE(LPOS,2410) DIR((1-IDIR)/2+1),RFNAME, 
     &          STNA, JULD+FMJDDT,
     &          IYEAR, IMTH, IDAY, IHR, IMIN,
     &          INT(DINT(SEC*1000+.5)/1000.),
     &          MOD(INT(SEC*1000+0.5),1000), NSVO, 
     &          GDOP, VTVPR, VTVCP, 
     &          PLHDIFM(1), PLHDIFM(2), PLHDIFM(3), 
     &          GPSCLK,DRYEPO+XRVEPO(5),
     &          OSDPLH(1), OSDPLH(2), OSDPLH(3), 
     &          SGPSCLK, SQRT(VX(5,5)),
     &          CDEGP, IMINP, SECP,
     &          CDEGL, IMINL, SECL, PLHOUT(3), IAMBSUM,
     &          XRVEPO(6)*1.d3, XRVEPO(7)*1.d3,
     &          sqrt(VX(6,6))*1.d3, sqrt(VX(7,7))*1.d3
     &         ,XRVEPO(5)
     &          ,GLNCLK,SGLNCLK, GALCLK, SGALCLK, BEICLK, SBEICLK
     &          ,DABS(FLTPAR(1)),DABS(FLTPAR(2)),AVGNL,AVGWL
     &          ,HORDION(2)
     &          ,HORDION(1)/C*1.D9, HORDION(3)/C*1.D9, RIFRATE,NAMBFX
     &          ,NSVDWGT
           ELSE
           WRITE(LPOS,2411) DIR((1-IDIR)/2+1),RFNAME, 
     &          STNA, JULD+FMJDDT,
     &          IYEAR, IMTH, IDAY, IHR, IMIN,
     &          INT(DINT(SEC*1000+.5)/1000.),
     &          MOD(INT(SEC*1000+0.5),1000), NSVO, 
     &          GDOP, VTVPR, VTVCP, 
     &          XRVDIF(1), XRVDIF(2), 
     &          XRVDIF(3), 
     &          GPSCLK,DRYEPO+XRVEPO(5),
     &          OSDXYZ(1), OSDXYZ(2), OSDXYZ(3), 
     &          SGPSCLK, SQRT(VX(5,5)),
     &          XRVOUT(1), XRVOUT(2), XRVOUT(3), IAMBSUM,
     &          XRVEPO(6)*1.d3, XRVEPO(7)*1.d3,
     &          sqrt(VX(6,6))*1.d3, sqrt(VX(7,7))*1.d3
     &         ,XRVEPO(5)
     &          ,GLNCLK,SGLNCLK, GALCLK, SGALCLK, BEICLK, SBEICLK
     &          ,DABS(FLTPAR(1)),DABS(FLTPAR(2)),AVGNL,AVGWL
     &          ,HORDION(2)
     &          ,HORDION(1)/C*1.D9, HORDION(3)/C*1.D9, RIFRATE,NAMBFX
     &          ,NSVDWGT
          END IF
       END IF
      END IF
C
370   CONTINUE
C
       IF(IDIR.EQ.-1.AND.IOBTYP.EQ.2.AND.UTTAG.NE.STRTTAG) THEN
c!       WRITE(*,*) ' MATRIX OPX , VX BEFORE UPDPX'
c!       WRITE(*,'(5F10.3)') ((OPX(I,I),I=1,NPAR))
c!       WRITE(*,'(5F10.3)') ((VX(I,I),I=1,NPAR))
         CALL UPDPX ( NPAR, ICLKSOL, ITRPSOL, OPX, PX)
c!       WRITE(*,*) ' DIAGONAL OF MATRIX PX, AFTER UPDPX '
c!       WRITE(*,'(15D9.3)') (PX(I,I),I=1,NPAR)
c!       WRITE(*,*) ' MATRIX PX, AFTER UPDPX '
C  
         DO I=1, NFPAR
          XRVEPO(I) = XRVAPR(I)
         END DO
       ELSE 
         CALL UPDPX ( NPAR, ICLKSOL, ITRPSOL, VX, PX )
c!       WRITE(*,*) ' DIAGONAL OF MATRIX PX, AFTER UPDPX '
c!       WRITE(*,'(15D9.3)') (PX(I,I),I=1,NPAR)
c!       WRITE(*,'(15F5.3)') (DSQRT(1.D0/PX(I,I)),I=1,MAXPAR2)
c!       WRITE(*,'(5F10.3)') ((PX(I,J),I=1,NPAR),J=1,NPAR)
      END IF
      DO I=1, NFPAR
          XRVAPR(I) = XRVEPO(I)
      END DO
      DO I=1,NSVO
          OCPAMB(ISVO(I)) = CPAMB(ISVO(I))
      END DO
C
C SAVE AMB and THE COR VX FOR FWD RUN
C
c!    WRITE(*,*) 'NDIR,IDIR,IOBTYP',NDIR,IDIR,IOBTYP
      IF(IDIR.EQ.1.AND.IOBTYP.EQ.2) THEN
c!      WRITE(*,*) 'WRITING TO IPX'
        WRITE(LUPX) UTTAG,(XRVEPO(I),I=1,NFPAR), 
     &              ((VX(I,J),J=I,NFPAR),I=1,NFPAR)
        DO I=1,NFPAR
           LSTFWDVX(I)=VX(I,I)
        END DO
        IF(STRTTAG.LT.0.0D0) STRTTAG=UTTAG
        REWIND(LUIPX)
        WRITE(LUIPX) IRLEASE
        WRITE(LUIPX) UTTAG,NFPAR,NSVO,NSVO2
        XRVEPO(5)=  XRVEPO(5)+ DRYEPO
        WRITE(LUIPX) (XRVEPO(I),I=1,NFPAR) 
        XRVEPO(5)=  XRVEPO(5)- DRYEPO
        WRITE(LUIPX) (ISVO(I),EL(IDX(ISVO(I))),CPAMB(ISVO(I)),I=1,NSVO)
        WRITE(LUIPX) ((PX(I,J),J=I,NFPAR+NSVO),I=1,NFPAR+NSVO)
        WRITE(LUIPX) ((PL(I,J),J=I,NSVO2),I=1,NSVO2)
      END IF
      PTTAG= UTTAG
C
C     TOO MANY ITERATIONS,
C     RESTORE PARAMETERS TO LATEST ESTIMATES
C
997   CONTINUE
      IF(ITER.GT.MAXIT .OR. IEOF .EQ. 1 .OR. PDOP.GT.100D0) THEN
        IF( NSVO-NSVDWGT .GE. MINSAT ) THEN
          CALL RSETPX ( NFPAR, NSVO, NSVOL, ISVO, 
     &                  XRVEPO, XRVAPR, CPAMB, OCPAMB, PX, OPX )
          DO I=1,NSVOL
           ISVO(I)= ISVOL(I)
           LCSLIP(I)=ICSLIP(I)
           END DO
          NSVO=NSVOL
          DO I=1,NSVO 
           ISVO(I)= ISVOL(I)
          END DO
        END IF
        IF( IEOF .NE. 1 ) NEPOCHDEL=NEPOCHDEL+1
      END IF
C SKIN
      IF( ITER.LE.MAXIT ) THEN
      NOBS = NOBS + NSVO-1
      IF(IMIX.EQ.2) NOBS = NOBS-3
      VPV = VPV + DVPV
      IF(IOBTYP.EQ.2.AND.NOBS.GT.20) SO= VPV/NOBS
      ENDIF
C
C     ZERO SOME ADJUSTMENT MATRICES
C     ( U, EW, X, N, V, W, A, T )
C
      DO I=1,NPAR
      U(I,1)    = 0.D0
      X(I,1)    = 0.0D0
      END DO
C
      DO I=1,NSVO2
      V(I,1) = 0.0D0
      W(I,1) = 0.0D0
      DO J=1,NPAR
        A(I,J)  =  0.0D0
        T(J,I)  =  0.0D0
        END DO
      END DO
C
C     PROCESS NEXT EPOCH
C
C
      RELAXAMB=.FALSE.
      IF ( IEOF .EQ. 0 ) GO TO 90
C
C------------------------------------------------------------------------
C     INITIATE BACWARDS RUN OR SUMMARIZE RESULTS
C------------------------------------------------------------------------
C
  500 CONTINUE
      IF(IDIR.EQ.1.AND.IOBTYP.EQ.2) THEN
        IF(NFIX.GT.0) SRIFRT= SQRT(SRIFRT/NFIX)
        WRITE(*,*) 'REACHED EOF, SAVE AND RESET FILTER COUNTERS'
        WRITE(LUIPX) IOBTYP, SDPR, SDCP
        WRITE(LUIPX) ((FLTSUM(J,I),J=1,MAXFLT),I=1,MAXSAT)
        WRITE(LUIPX) (TWUPCOR(I), PWUPCOR(I), I=1,MAXSAT)
        WRITE(LUIPX) NCSLIP15,(ICSLIP15(I), I=1,MAXSAT)
        WRITE(LUIPX) LFIXNL, LFIXWL, DMXNLSAV, DMXWLSAV,
     &               (FLTPAR(I),I=1,MAXFLT)
        WRITE(LUIPX) (HORDION(I),I=1,MAXHOION)
C
C RESET STATION POS FOR BWD RUN
C
        DO I=1,3
        XRVEPO(I)=XRVAPR(I)
        IF( IMODE .GT. 1 ) XRVVEL(I) = 0.D0
        END DO
      END IF
      NCSLIP15 = 0
      IF(NSVO.EQ.0) NSVO=NSVOL
      IABRST= 0
      DO I=1,NSVO
      FLTSUM(13,ISVO(I)) = 0.D0
      END DO
      DO I=1,MAXSAT
      END DO
      DO J=1,MAXSAT
       FLTSUM(10,J)=0.D0
       FLTSUM(9, J)=0.D0
       FLTSUM(13,J )= 0.D0
       IF(UPDEPO) THEN
        DO I=1,NSVO 
         IF(J.EQ.ISVO(I))THEN
          FLTSUM(13,J)=FCP(I)*C
          FLTSUM( 8,J)=FCP(I)*C
         END IF
        END DO
       END IF
C for nos sol epoch use the last sol epoch!
      IF(.NOT.UPDEPO) THEN
        DO  I=1,NSVO
        DO  K=1,NSVOL 
        IF(J.EQ.ISVO(I).AND.ISVO(I).EQ.ISVOL(K))THEN
          FLTSUM(13,J)=FCP(I)*C
          FLTSUM( 8,J)=FCP(I)*C
         ENDIF
        ENDDO
        END DO
       ENDIF
       IF(FLTSUM(13,J).EQ.0.D0) THEN 
        IF(FLTSUM(1,J).GT.0.D0)
     &  FLTSUM(MAXFLT,J)= FLTSUM(MAXFLT,J)/FLTSUM(1,J)
        DO I=1,MAXFLT-1
        FLTSUM(I,J)=0.D0
        END DO
       END IF
      END DO
      ENDTTAG=PTTAG
C      
610   CONTINUE
      IDIR=IDIR-2
c!    WRITE(*,*) 'IDIR,NDIR',IDIR,NDIR
C COMPUTE FWD MEAN RES TO BE APPLIED TO BWD CLKS! (ESSENTIAL FOR AR)
      DO I=1,4
       RAVGALL(I)= 0.D0
       NOBALL(I) = 0
      ENDDO
      DO I=1, MAXSAT
       IF(IARC(I).NE.0) THEN
        ID=1
        IF(I.GT.32.AND.I.LE.64) ID=2
        IF(I.GT.64.AND.I.LE.100) ID=3
        IF(I.GT.100.AND.I.LE.136) ID=4
        DO J= 1, IARC(I)
         RAVGALL(ID) = RAVGALL(ID)+ RCAVG(I,J)*NRC(I,J)
         NOBALL(ID)  = NOBALL(ID) + NRC(I,J)
        ENDDO
       END IF
      END DO
      IF (NOBALL(1).GT.0)RAVGALL(1)= RAVGALL(1)/NOBALL(1)
      IF (NOBALL(2).GT.0)RAVGALL(2)= RAVGALL(2)/NOBALL(2)
      IF (NOBALL(3).GT.0)RAVGALL(3)= RAVGALL(3)/NOBALL(3)
      IF (NOBALL(4).GT.0)RAVGALL(4)= RAVGALL(4)/NOBALL(4)
      IF (IDIR .GE. NDIR .AND. IOBTYP .EQ. 2) THEN
        BACKSPACE(LUPX)
        IF ( ISVCLK .EQ. 2 ) THEN
          CALL SAPOS ( NSVCLK, LLUCLK, IEOFSA, 
     &                 NBPBUF, IBPBUF, IEPBUF,
     &                 ITMBUF, IODBUF )
        END IF
        DO J=1,MAXSAT
         CNTAMB(J)=0
        END DO
        IF(IPC.GE.1)WRITE(*,*) "AR REF SEARCH: LOOK FOR BWD REF SAT"
        ID=0
        IF(UPDEPO) THEN
         DO I=1,NSVO 
          CNTAMB(ISVO(I))=1
          IF(IPC.GE.2)
     &     WRITE(*,*) "AR REF SEARCH: ",ISVO(I),PX(NFPAR+I,NFPAR+I),
     &     FLTSUM(1,ISVO(I)),FLTSUM(14,ISVO(I)),FLTSUM(15,ISVO(I))
     &    ,CPAMB(ISVO(I))
          IF( PX(NFPAR+I,NFPAR+I).LE.1.D-6 ) THEN
           IF( ID .EQ. 0 ) THEN
            ID=I
            IF(IPC.GE.1)
     &     WRITE(*,*) "AR REF SELECT: ",ISVO(I),PX(NFPAR+I,NFPAR+I),
     &     FLTSUM(1,ISVO(I)),FLTSUM(14,ISVO(I)),FLTSUM(15,ISVO(I))
     &    ,CPAMB(ISVO(I))
           ELSE IF( FLTSUM(1,ISVO(I))*FLTINT/60.D0.GT.MINFX.AND.
     &              ABS(CPAMB(ISVO(I))).LT.ABS(CPAMB(ISVO(ID)))) THEN
             ID=I
            IF(IPC.GE.1)
     &     WRITE(*,*) "AR REF SELECT: ",ISVO(I),PX(NFPAR+I,NFPAR+I),
     &     FLTSUM(1,ISVO(I)),FLTSUM(14,ISVO(I)),FLTSUM(15,ISVO(I))
     &    ,CPAMB(ISVO(I))
            ENDIF
           ENDIF
         END DO
         IF(ID.NE.0) ID=ISVO(ID)
        ELSE
         DO K=1,NSVOL 
           CNTAMB(ISVOL(K))=1
           IF(IPC.GE.2)
     &      WRITE(*,*) "AR REF SEARCH: ",ISVOL(K),PX(NFPAR+K,NFPAR+K),
     &      FLTSUM(1,ISVOL(K)),FLTSUM(14,ISVOL(K)),FLTSUM(15,ISVOL(K))
     &     ,CPAMB(ISVOL(K))
           IF( PX(NFPAR+K,NFPAR+K).LE.1.D-6 ) THEN
            IF( ID .EQ. 0 ) THEN
             ID=K
             IF(IPC.GE.1)
     &     WRITE(*,*) "AR REF SELECT: ",ISVOL(K),PX(NFPAR+K,NFPAR+K),
     &     FLTSUM(1,ISVOL(K)),FLTSUM(14,ISVOL(K)),FLTSUM(15,ISVOL(K))
     &     ,CPAMB(ISVOL(K))
            ELSE IF( FLTSUM(1,ISVOL(K))*FLTINT/60.D0.GT.MINFX.AND.
     &               ABS(CPAMB(ISVOL(K))).LT.ABS(CPAMB(ISVOL(ID)))) THEN
             ID=K
             IF(IPC.GE.1)
     &     WRITE(*,*) "AR REF SELECT: ",ISVOL(K),PX(NFPAR+K,NFPAR+K),
     &     FLTSUM(1,ISVOL(K)),FLTSUM(14,ISVOL(K)),FLTSUM(15,ISVOL(K))
     &     ,CPAMB(ISVOL(K))
            ENDIF
           ENDIF
         END DO
         IF(ID.NE.0) ID=ISVOL(ID)
        ENDIF
        IF( ID .NE. 0 ) THEN
         IPRNREF=ID
         IF(IPC.EQ.1) write(*,*)' SELECTING REF SAT FOR BWD: ', IPRNREF
        ENDIF
c!    write(*,*) 'going to 89'
        GO TO 89
      ELSE
        CLOSE ( LUPX, STATUS='DELETE' )
C
C        PUT FORMAL XYZ & PLH SIGMAS OF FWD RUN FOR STATIC PPP
C
        IF(IMODE.EQ.1) THEN
        DO I=1,3
          XRVSIG(I) = OSDXYZ(I)
          PLHSIG(I) = OSDPLH(I)
        END DO
        END IF
C
C       CORRECT NO. OF EPOCHS FOR FWD+BWD RUNS
C             IF(NDIR.EQ.-1) NFIX=NFIX/2
      CLKRMS=0.D0
      RCLKRMS=0.D0
      DCLKRMS=0.D0
        IF (NCLKFIT.GT.3) CLKRMS=
     &                    SQRT(SUMLR(8,1)/(NCLKFIT-2))*1.D9
        IF (RNCLKFIT.GT.3) RCLKRMS=
     &                    SQRT(SUMLR(8,2)/(RNCLKFIT-2))*1.D9
        IF (DNCLKFIT.GT.3) DCLKRMS=
     &                    SQRT(SUMLR(8,3)/(DNCLKFIT-2))*1.D9
        IF (ENCLKFIT.GT.3) ECLKRMS=
     &                    SQRT(SUMLR(8,4)/(ENCLKFIT-2))*1.D9
        IF (DENCLKFIT.GT.3) DECLKRMS=
     &                    SQRT(SUMLR(8,5)/(DENCLKFIT-2))*1.D9
        IF (CNCLKFIT.GT.3) CCLKRMS=
     &                    SQRT(SUMLR(8,6)/(CNCLKFIT-2))*1.D9
        IF (DCNCLKFIT.GT.3) DCCLKRMS=
     &                    SQRT(SUMLR(8,7)/(DCNCLKFIT-2))*1.D9
      IF ( IMODE .EQ. 1 ) THEN
          DO I=1,3
          XRVAVG(I)=XRVEPO(I)-XRVMRK(I)-ANTX(I)
        END DO
      END IF
C
        CALL SUMOBS ( LPR, LUSES, STNA, IARC, STIME, 
     &              ETIME, FLTINT, UPDINT, NRC, NRCRJCT,
     &              CNTSLIP,
     &              OUTLIERACTION,
     &              IOBTYP,
     &              RCAVG, RCRMS, CPAVG, CPRMS, NFIX, 
     &              NRCFX, NEPFIX,
     &              CNTFIX, CNTAMB,
     &              NEPOCHDEL,
     &              NSVARC, RESARC, IMODE, IFREQ, NECLIPS, IPEPACC,
     &              LNG , SOBWD/SO, FLTPAR,
     &              HORDION(1), IBLK )
C      
        CALL SUMPOS ( LPR,  LUSES, STNA, IYEARS, IMTHS, IDAYS,
     &              NFIX, NFIXR, DTM, IREFIN , IREFOUT, RFREAL, 
     &              RFRAME, TRFPAR, EPOCH, XRVINP, XRVINI, XRVMRK, 
     &              XRVAVG, XRVRMS, XRVSIG, PLHRMS, PLHSIG, 
     &              IXRVRNX,XRVCOD,
     &              OVX, OVP,
     &              IMODE, ANTH(1), LNG )
C
C
C       BRING CLOCK MODELS TO SAVED REFERENCE TIME
C
        IF( REFTM0 .NE. REFTM ) THEN
          OFFSET=OFFSET+
     &        (REFTM-REFTM0)*(DRIFT+DRIFTRATE*(REFTM-REFTM0)/2.D0)
          DRIFT=DRIFT+(REFTM-REFTM0)*DRIFTRATE
          ROFFSET=ROFFSET+
     &        (REFTM-REFTM0)*(RDRIFT+RDRIFTRATE*(REFTM-REFTM0)/2.D0)
          RDRIFT=RDRIFT+(REFTM-REFTM0)*RDRIFTRATE
          DOFFSET=DOFFSET+
     &        (REFTM-REFTM0)*(DDRIFT+DDRIFTRATE*(REFTM-REFTM0)/2.D0)
          DDRIFT=DDRIFT+(REFTM-REFTM0)*DDRIFTRATE
C BRING  GAL, BEI CLKs TO REF TIME! 
          EOFFSET=EOFFSET+
     &        (REFTM-REFTM0)*(EDRIFT+EDRIFTRATE*(REFTM-REFTM0)/2.D0)
          EDRIFT=EDRIFT+(REFTM-REFTM0)*EDRIFTRATE
          COFFSET=COFFSET+
     &        (REFTM-REFTM0)*(CDRIFT+CDRIFTRATE*(REFTM-REFTM0)/2.D0)
          CDRIFT=CDRIFT+(REFTM-REFTM0)*CDRIFTRATE
C
          DEOFFSET=DEOFFSET+
     &        (REFTM-REFTM0)*(DEDRIFT+DEDRIFTRATE*(REFTM-REFTM0)/2.D0)
          DEDRIFT=DEDRIFT+(REFTM-REFTM0)*DEDRIFTRATE
          DCOFFSET=DCOFFSET+
     &        (REFTM-REFTM0)*(DCDRIFT+DCDRIFTRATE*(REFTM-REFTM0)/2.D0)
          DCDRIFT=DCDRIFT+(REFTM-REFTM0)*DCDRIFTRATE
        ENDIF
      IF(.NOT.IAROFF) THEN
      OFFSET= OFFSET- RAVGALL(1)/.299792D9
      DOFFSET = DOFFSET + RAVGALL(1)/.299792D9
      DEOFFSET= DEOFFSET+ RAVGALL(1)/.299792D9
      DCOFFSET= DCOFFSET+ RAVGALL(1)/.299792D9
      ENDIF
        CALL SUMCLK ( LPR,  LUSES, STNA, IYEARS, IMTHS, IDAYS, ICLKFIT,
     &              REFM, NCLKFIT,OFFSET*1.d9,DRIFT*1.d9,
     &              DRIFTRATE*1.d9,SDOFF*1.d9,
     &              SDRIFT*1.d9,SDRIFTRATE*1.d9,CLKRMS,
     &              RNCLKFIT,ROFFSET*1.d9,RDRIFT*1.d9,
     &              RDRIFTRATE*1.d9,RSDOFF*1.d9,
     &              RSDRIFT*1.d9,RSDRIFTRATE*1.d9,RCLKRMS,
     &              DNCLKFIT,DOFFSET*1.d9,DDRIFT*1.d9,
     &              DDRIFTRATE*1.d9,DSDOFF*1.d9,
     &              DSDRIFT*1.d9,DSDRIFTRATE*1.d9,DCLKRMS,
     &              ENCLKFIT,EOFFSET*1.d9,EDRIFT*1.d9,
     &              EDRIFTRATE*1.d9,ESDOFF*1.d9,
     &              ESDRIFT*1.d9,ESDRIFTRATE*1.d9,ECLKRMS,
     &              DENCLKFIT,DEOFFSET*1.d9,DEDRIFT*1.d9,
     &              DEDRIFTRATE*1.d9,DESDOFF*1.d9,
     &              DESDRIFT*1.d9,DESDRIFTRATE*1.d9,DECLKRMS,
     &              CNCLKFIT,COFFSET*1.d9,CDRIFT*1.d9,
     &              CDRIFTRATE*1.d9,CSDOFF*1.d9,
     &              CSDRIFT*1.d9,CSDRIFTRATE*1.d9,CCLKRMS,
     &              DCNCLKFIT,DCOFFSET*1.d9,DCDRIFT*1.d9,
     &              DCDRIFTRATE*1.d9,DCSDOFF*1.d9,
     &              DCSDRIFT*1.d9,DCSDRIFTRATE*1.d9,DCCLKRMS,
     &              NMSOFF, NMSJMP, IMODE, LNG,
     &              ICLKAP,CLKY0,CLKD0,UCLKY0,UCLKD0,CLKSD0,SDCLK0,
     &              NMSCPJ, NMSCLJ, ICORRTT, ICORRPR, ICORRCP, IDIR,
     &              NDATJMP, DATJMP, RIFRATE ,SRIFRT, RAVGALL, SMTHCLK)
C     
        CALL SUMRES ( LPR, IOBTYP, NSVARC, RESARC,
     &                OUTLIERACTION,
     &                NRESREJ, RESREJ, LNG )
C
      END IF
C
  600 CONTINUE
      CLOSE(LUMEA)
      CLOSE(LPR)
      DO 660 ISV=1,NSVCLK
        CLOSE ( LLUCLK(ISV), STATUS='DELETE' )
  660 CONTINUE   
C
      WRITE(*,*) '*END - NORMAL COMPLETION'
      WRITE(LUSES,*) '*END - NORMAL COMPLETION'
  690 CONTINUE   
C
C------------------------------------------------------------------------
C     FORMAT STATEMENTS
C------------------------------------------------------------------------
C
  710 FORMAT( '+','Enter MEASUREMENT input file name    :')
  720 FORMAT(   A80 )
  730 FORMAT( ' ERROR GPSPPP ',I9,'trying to open FILE ',  A15 )
  800 FORMAT( 20X,' SUMMARY OF BROADCAST EPHEMERIS RECORDS      ',/,
     &           20X,' --------------------------------------      ',//,
     &           ' PRN   SEQ#  HEALTH  IODC       REFERENCE TIME      ',
     &           '    SATELLITE CLOCK PARAMETERS                ',/,
     &           '                           (hr:mn:sec)        ',
     &           'OFFSET       DRIFT      PERIOD                ',/,
     &            46X,'(nsec)     (nsec/hr)  (hr:mn:sec)             ')
  820 FORMAT( 3(2X,I2,2X),1X,I4,2X,1X,7X,2(I2,':'), F4.1,3X, 2F11.2,5X,
     &            2(I2,':'),F4.1 )
  900 FORMAT( /,1X,I4,2('/',I2), 1X,2(I2,':'), F6.3 ,1X,'PRNS # ',36I6)
 1000 FORMAT( ' EPHEMERIS TIME  (hr:mn) ',7X,10(1X,I2,':',I2) )
 1135 FORMAT( ' RANGE CORRECTION   (m.) ',7X,10F6.1 )
 1138 FORMAT( ' SV MISMATCH EFFECT (m.) ',7X,10F6.1 )
 1140 FORMAT( ' MISCLOSURE         (m.) ',7X,10F6.1 )
 1200 FORMAT( ' CODSOLS          (m.) ',7X,10F6.1 )
 1210 FORMAT("(I3 ,3X,2(I2.2,':'),I2.2,'.',I3.3,3X,",
     &       A1,"10.2,F10.2,",A1,"10.2,F10.2,I3)")
 1211 FORMAT(1X,A3,1X,I4,2('/',I2),1X,2(I2.2,':'),I2.2,'.',I3.3,3X,3I10)
 1212 FORMAT(1X,A7,I3,3X,2(I2.2,':'),I2.2,'.',I3.3,3X, 3F15.5 )
 1213 FORMAT(1X,A7,I3,3X,2(I2.2,':'),I2.2,'.',I3.3,3X, 5F15.5 )
 1300 FORMAT(1X,I5,F10.2,1X,F4.0,1X,F15.3,F12.3,F12.3)
 1400 FORMAT (A1,1X,A3,1X,A3,I2.2,1X,I4,1X,4(I2.2,1X),F8.4,2F15.12)
 1500 FORMAT (A1,1X,A3,1X,A3,I2.2,1X,I4,1X,4(I2.2,1X),F8.4,2F15.3)
 2000 FORMAT(' TIME: ',F12.2,' PDOP: ',F6.1,' SATELLITES : ',10I4)
 2100 FORMAT( I5,4F15.3)
 2200 FORMAT(3I4,I3,F10.3,I3,F10.3,I3,F10.3,I3,F10.3,1X,F15.3,F5.1)
 2290 FORMAT( /,1X,I4,2('/',I2), 1X,2(I2,':'), F4.1 ,1X,
     &          'RECEIVER CLOCK RESET',5F7.1)
 2300 FORMAT( /,'PDOP,VTV,DX,DY,DZ,CLK,TRO ',/,
     &          F4.1,F6.1,3(F8.2),2F12.2,/,
     &          10X, 3(F8.2),2F12.2,/ )
 2310 FORMAT( 'XUP-PAR ',2(I2,':'),F4.1, F4.1,F6.1,3(F10.3),6F12.3)
 2311 FORMAT( 'XUP-ERR ',2(I2,':'),F4.1, F4.1,F6.1,3(F10.3),F12.3,
     &        12X,4F12.3)
 2400 FORMAT('DIR',1X,'FRAME',8X,'STN',9X,'DOY',1X,'YEAR-MM-DD',1X,
     &     'HR:MN:SS.SSS',1X,'NSV',1X,'GDOP',4X,'SDC',4X,'SDP',7X,
     &       'DLAT(m)',7X,'DLON(m)',7X,'DHGT(m)',9X,'CLK(ns)',3X,
     &       'TZD(m)',2X,'SLAT(m)',2X,'SLON(m)',2X,'SHGT(m)',1X,
     &       'SCLK(ns)',2X,'STZD(m)',1X,'LAT(d)',1X,'LAT(m)',4X,
     &       'LAT(s)',1X,'LON(d)',1X,'LON(m)',4X,'LON(s)',3X,'HGT(m)',
     &       1X,'AM',1X,'GRAD1',1X,'GRAD2',1X,'SGRD1',1X,'SGRD2',
     &       1X,'WETZD(m)',1X,'GLNCLK(ns)',1X,'SGLNCLK(ns)',
     &       1X,'GALCLK(ns)',1X,'SGALCLK(ns)',
     &       1X,'BEICLK(ns)',1X,'SBEICLK(ns)',
     &       1X,'MAXNL',1X,'MAXWL',1X,'AVGNL(m)',1X,'AVGWL(m)'
     &       ,1X,'VTEC(.1TECU)',1X,'GPS_DP1P2(ns)',1X,'GLN_DP1P2(ns)'
     &       ,1X,'RIFRATE',1X,'NAMBFIX',1X,'NSVDWGT')
 2401 FORMAT('DIR',1X,'FRAME',8X,'STN',9X,'DOY',1X,'YEAR-MM-DD',1X,
     &     'HR:MN:SS.SSS',1X,'NSV',1X,'GDOP',4X,'SDC',4X,'SDP',9X,
     &       'DX(m)',9X,'DY(m)',9X,'DZ(m)',9X,'CLK(ns)',3X,'TZD(m)',4X,
     &       'SX(m)',4X,'SY(m)',4X,'SZ(m)',1X,'SCLK(ns)',2X,
     &       'STZD(m)',19X,'X(m)',19X,'Y(m)',19X,'Z(m)',
     &       1X,'AM',1X,'GRAD1',1X,'GRAD2',1X,'SGRD1',1X,'SGRD2',
     &       1X,'WETZD(m)',1X,'GLNCLK(ns)',1X,'SGLNCLK(ns)',
     &       1X,'GALCLK(ns)',1X,'SGALCLK(ns)',
     &       1X,'BEICLK(ns)',1X,'SBEICLK(ns)',
     &       1X,'MAXNL(m)',1X,'MAXWL(m)',1X,'AVGNL(m)',1X,'AVGWL(m)'
     &       ,1X,'VTEC(.1TECU)',1X,'GPS_DP1P2(ns)',1X,'GLN_DP1P2(ns)'
     &       ,1X,'RIFRATE',1X,'NAMBFIX',1X,'NSVDWGT')
 2410 FORMAT(A3,1X,A11,1X,A4,1X,F11.7,1X,I4,'-',I2.2,'-',
     &       I2.2,1X,
     &       I2.2,':',I2.2,':',I2.2,'.',I3.3,1X,I3,1X,F4.1,1X,F6.2,1X,
     &       F6.4,1X,3(F13.3,1X),F15.3,1X,F8.4,1X,4(F8.3,1X),F8.4,1X,
     &       2(A6,1X,I6,1X,F8.5,1X),F13.3,1X,I2,4(1X,f5.1),
     &       1X,F8.4,1X,3(F15.3,1X,F8.3),4(1X,F10.4),4(1X,F8.1),2I3 )
 2411 FORMAT(A3,1X,A11,1X,A4,1X,F11.7,1X,I4,'-',I2.2,'-',
     &       I2.2,1X,
     &       I2.2,':',I2.2,':',I2.2,'.',I3.3,1X,I3,1X,F4.1,1X,F6.2,1X,
     &       F6.4,1X,3(F13.3,1X),F15.3,1X,F8.4,1X,4(F8.3,1X),F8.4,1X,
     &       3(F16.3,1X),I2,4(1X,f5.1),
     &       1X,F8.4,1X,3(F15.3,1X,F8.3),4(1X,F10.4),4(1X,F8.1) ,2I3)
 2500 FORMAT(I10,F15.3)
 2600 FORMAT('DIR',1X,'DATE',8X,'DOY',9X,'HH:MM:SSS',5X,
     &       'PRN',7X,'AZI',7X,'ELV',7X,'VPR',7X,'VCP',7X,
     &       'FAM',7X,'DAM',7X,'IAM',7X,'AMB',15X,'NEW',
     &       1X,'IONO2(mm)',1X,'MAXNL(m)',1X,'MAXWL(m)',1X,'WLAR',
     &       1X,'LOGWGT')
 2610 FORMAT("(A3,1X,I4,2('-',I2.2),1X,F12.7,1X,2(I2.2,':'),",
     &       "I2.2,'.',I3.3,3X,'PRN',I3.3,1X,2(2X,F7.1),3X,",
     &       A1,"10.4,3X,",A1,"10.4,",
     &       "3(3X,F10.4),3X,F15.3,3X,I2,1X,F8.3,3(1X,F9.3),F5.0)")
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** ADDPX
C
C Copyright (c) 2018 Government of Canada. Under MIT Licence terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
      SUBROUTINE ADDPX ( NSV, ISV, NSVL, ISVL, NPAR, NFPAR, IPOSSOL, 
     &                   ICLKCOR, ITRPCOR, IOBTYP, XRMS, PX, OPX,
     &                   IPX, IMODE, SDP, CPBIAS, P, PTTAG, UTTAG,
     &                   SDTROP, C, LCSLIP, CNTAMB, SDCLK, PCLKSIG )
C
C     NAME              ADDPX
C
C     PURPOSE           ADD STOCHASTIC WEIGHTS TO PARAMETERS
C
C     PARAMETERS        DESCRIPTION
C
C          NSV          NUMBER OF SATELLITES OBSERVE AT CURRENT EPOCH
C          ISV          LIST OF PRN NUMBERS AT CURRENT EPOCH
C          NSVL         NUMBER OF SATELLITES OBSERVED AT LAST EPOCH
C          ISVL         LIST OF PRN NUMBERS OBSERVED AT LAST EPOCH 
C          NPAR         NUMBER OF PARAMETERS
C          BFPAR        NUMBER OF PERMANENT PARAMETERS
C          IPOSSOL      SOLVE POSITION (1=NO, 2=YES)
C          ICLKCOR      SOLVE RECEIVER CLOCK FLAG
C          ITRPCOR      SOLVE TROPOSPHERIC SCALE FLAG
C          IOBTYP       SOLVE INITIAL SATELLITE AMBIGUITY
C          XRMS         
C          PX           PARAMETER WEIGHT MATRIX
C          OPX          OLD PARAMETER WEIGHT MATRIX
C          IPX          INITIAL PX (1=TRUE,0=FALSE)
C          IMODE        STATIC, KIN, RAPID-STATIC
C          SDP          PSEUDORANGE UNCERTAINTY
C          CPBIAS       ARRAY OF AMBIGUITIES
C          PTTAG        PREVIOUS TTAG IN SEC
C          UTTAG        TTAG IN SEC
C          SDTROP       RANDOM WALK (TROPO) S.D. (m/sqrt(h))
C          C            SPEED OF LIGHT
C          LCSLIP       AMBIGUITY RESET INDICATOR
C          CNTAMB       AMBIGUITY COUNTS
C          SDCLK        CLOCK UNCERTAINTY
C          PCLKSIG      CLOCK UNCERTAINTY
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4  NSV,     ISV(*)
      INTEGER*4  NSVL,    ISVL(*)
      INTEGER*4  LCSLIP(*)
      INTEGER*4  CNTAMB(*)
      INTEGER*4  NPAR,    NFPAR
      INTEGER*4  IPX,     IPOSSOL
      INTEGER*4  ICLKCOR,  ITRPCOR,   IOBTYP,   IMODE
      REAL*8     CPBIAS(*) , SDTROP,  SDP, C
      REAL*8     SDCLK, PCLKSIG
C
      REAL*8     XRMS(3), UTTAG, PTTAG, TROSIG, GRDSIG
      REAL*8     PX(MAXPAR2,MAXPAR2)
      REAL*8     OPX(MAXPAR2,MAXPAR2)
      REAL*8     DET, DTTAG
      INTEGER*4  IDEXP, IPOSPX(MAXPAR2),  IFP
      REAL*8     APX(MAXPAR2,MAXPAR2)
      REAL*8     P(MAXOBS2,MAXOBS2)
C
C     CHARACTER*11  PXFMT
C
      INTEGER*4 I,J,IS,IL,IC
      REAL*8    DXDT
      REAL*8    CLKSIG
      DATA IPOSPX/MAXPAR2*0/
c!    WRITE(*,*) ' PX, ENTERING ADDPX '
c!    WRITE(PXFMT,'(A,I2.2,A5)') '(',NFPAR+NSVL,'D9.3)' 
c!    WRITE(*,PXFMT) (( PX(I,J), I=1,NFPAR+NSVL ), J=1,NFPAR+NSVL )
C
C     UPDATE PARAMETER WEIGHTS USING STOCHASTIC PROCESS
C
C     IF KINEMATIC (IMODE=2) & POSITION SOLVE (IPOSSOL=2)
C     -> ADD PROCESS NOISE TO POSITION VARIANCES
C
      IF (IPOSSOL .EQ. 2 .AND. IMODE .EQ. 2) THEN
        DO I= 1,3
          DXDT = XRMS(I)*XRMS(I)
          PX(I,I)= PX(I,I) +  1.D10 + DXDT
        END DO
c!    WRITE(*,*) 'IN ADDPX, DXDT,PX',DXDT,PX(1,1),PX(2,2),PX(3,3)
      END IF
C
C     IF TROPO SCALE SOLVE (ITRPCOR=1) & AMBIGUITY SOLVE (IOBTYP=2)
C     ADD PROCESS NOISE ( .001 MM/SEC )**2 TO VARIANCE
C                         .010 m*sqrt(h) @ .25h = .0025m
C     ELSE FIX TROPO SCALE
C
c!    WRITE(*,*) 'TTAG,PTTAG',TTAG(1),PTTAG
      DTTAG=UTTAG-PTTAG
      DTTAG=DMOD(DTTAG,604800.D0)
C
C     IF CLOCK SOLVE (ICLKCOR=1) -> ADD UNCERTAINTY TO VARIANCE
C
       IF ( ICLKCOR .EQ. 1 ) THEN
       CLKSIG=1.D20
C Glonass clk
         PX(8,8) = PX(8,8)+ CLKSIG
C Galileo clk
         PX(9,9) = PX(9,9)+ CLKSIG
C Beidou  clk
         PX(10,10) = PX(10,10)+ CLKSIG
         IF ( IOBTYP .EQ. 2 .AND. SDCLK .GT. 0 )
     &     CLKSIG=1.D18*(SDCLK**2)*DABS(DTTAG)
C GPS clk
         PX(4,4)=PX(4,4)+CLKSIG
       ELSE
         PX(4,4) = 1.D-20
         PX(8,8) = 1.D-20
       END IF
       trosig= SDTROP*sqrt(DABS(DTTAG)/3600.d0)
       grdsig= 1.D-04*sqrt(DABS(DTTAG)/3600.d0)
      IF ( MOD(ITRPCOR,10) .GE. 2 .AND. IOBTYP .EQ. 2 ) THEN
        PX(5,5) = PX(5,5) + trosig**2
        IF( ITRPCOR .GT. 100 ) THEN
          PX(6,6) = PX(6,6) + grdsig**2
          PX(7,7) = PX(7,7) + grdsig**2
        END IF
        IF(PTTAG.eq.0.d0) THEN
          PX(5,5) =           1.d-2
          IF(MOD(ITRPCOR,100).GT.20.AND.PTTAG.eq.0.d0) PX(5,5)=4.d-4
C trop gradient rw 0.1 mm/sqrt(hour) (1.d-8 m2/h)
          IF( ITRPCOR .GT. 100 ) THEN
            PX(6,6) =           1.d-06
            PX(7,7) =           1.d-06
        END IF
        ENDIF
C constrain tropo to 2 cm, vmf available!
C trop gradient rw 0.1 mm/sqrt(hour) (1.d-8 m2/h)
      ELSE
        PX(5,5) = 1.D-20
        PX(6,6) = 1.D-20
        PX(7,7) = 1.D-20
      END IF
C
C     IF AMBIGUITY SOLVE, UPDATE VARIANCES OF SATELLITES
C
      IF ( IOBTYP .EQ. 2 ) THEN
C
C       ASSIGN POSITION OF STATION PARAMETERS
C
        DO IFP=1,NFPAR
          IPOSPX(IFP) = IFP
        END DO
C
C       ASSIGN POSITION OF SATELLITES WITH AMBIGUITY ESTIMATES
C
        DO IS=1,NSV
          IPOSPX(NFPAR+IS)=0
          DO IL=1,NSVL
            IF ( ISV(IS) .EQ. ISVL(IL) ) IPOSPX(NFPAR+IS)=NFPAR+IL
          END DO
C
C   Open up sigma of old ambiguities when break detected
C
          IF ( IS .LE. NSV .AND.
     &         LCSLIP(ISV(IS)) .NE. 0 ) IPOSPX(NFPAR+IS)=0
        END DO
C
C       ASSIGN VARIANCES TO SATELLITES WITH AMBIGUITY ESTIMATES
C
c!      WRITE(*,*) ' APX, DURING ASSIGN OLD SAT VARIANCES '
        DO IS=1,NSV
          IF ( IPOSPX(NFPAR+IS) .NE. 0 ) THEN
            DO IC=1,NPAR
            IF ( IPOSPX(IC) .EQ.0 ) THEN
              APX(IC,IS)=0.D0
            ELSE
                APX(IC,IS) = PX(IPOSPX(IC),IPOSPX(NFPAR+IS)) 
            END IF
            END DO
c!          WRITE(PXFMT,'(A,I2.2,A5)') '(',NPAR,'D9.3)' 
c!          WRITE(*,PXFMT) ( APX(I,IS), I=1,NPAR )
          END IF
        END DO
C
c!      WRITE(*,*) ' APX, AFTER ASSIGN OLD SAT VARIANCES '
c!      WRITE(PXFMT,'(A,I2.2,A5)') '(',NPAR,'D9.3)' 
c!      WRITE(*,PXFMT) (( APX(I,J), I=1,NPAR ), J=1,NSV )
C
C       INITIALIZE VARIANCES OF NEW SATELLITES
C
c!      WRITE(*,*) ' APX, DURING INIT NEW SAT VARIANCES '
        DO IS=1,NSV
          IF ( IPOSPX(NFPAR+IS) .EQ. 0 ) THEN
c!          WRITE(*,"('UPD-SAT INI PRN',I2.2)") ISV(IS)
            DO IC=1,NPAR
              APX(IC,IS) =  0.D0
            IF ( IC .EQ. NFPAR+IS ) APX(IC,IS) =  1.D 18/(C/SDP/3.D0)**2
            END DO
c!          WRITE(PXFMT,'(A,I2.2,A5)') '(',NPAR,'D9.3)' 
c!          WRITE(*,PXFMT) ( APX(I,IS), I=1,NSV )
            CNTAMB(ISV(IS))=CNTAMB(ISV(IS))+1
          END IF
        END DO
c!      WRITE(*,*) ' APX, AFTER INIT NEW SAT VARIANCES '
c!      WRITE(*,PXFMT) (( APX(I,J), I=1,NPAR ), J=1,NPAR )
C
        DO IC=1,NPAR
          DO IS=1,NSV
            PX(IC,NFPAR+IS) = APX(IC,IS) 
            PX(NFPAR+IS,IC) = APX(IC,IS)
          END DO
        END DO
C
      END IF  
C
C     INVERT UP-TO-DATE NORMALS
C
c!    WRITE(PXFMT,'(A,I2.2,A5)') '(',NPAR,'D9.3)' 
c!    WRITE(*,PXFMT) (( PX(I,J), I=1,NPAR ), J=1,NPAR )
c!    WRITE(*,PXFMT) (PX(J,J),J=1,NPAR)
      CALL SPIN ( PX, NPAR, MAXPAR2, DET, IDEXP )
c!    WRITE(*,*) 'PX IN ADDPX, AFTER SPIN '
c!    WRITE(PXFMT,'(A,I2.2,A5)') '(',NPAR,'D9.3)' 
c!    WRITE(*,PXFMT) (PX(J,J),J=1,NPAR)
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C***************************************************************** ADJPX
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE ADJPX ( LPR, IPC, NPAR, NSVO, ISVO, NSVO2, 
     &                   PX, A, P, W, VX, X, EA, EVX )
C
C     NAME              ADJPX
C
C     PURPOSE         ADJUST PARAMETERS USING EPOCH OBSERVATIONS
C
C     PARAMETERS        DESCRIPTION
C
C          LPR          LOGICAL UNIT OF PRINT FILE
C          IPC          PRINT CODE
C          NPAR         NUMBER OF PARAMETERS TO SOLVE
C          NSVO         NUMBER OF SATELLITE OBSERVATIONS 
C          ISVO         SATELLITE NUMBER
C          NSVO2
C          PX           A-PRIORI PARAMETER VARIANCES
C          A            DESIGN MATRIX
C          P            OBSERVATION WEIGHTS
C          VX           UPDATED PARAMETER VARIANCES
C          X            CORRECTION TO PARAMETERS
C          EA           INSTANTANEOUS DESIGN MATRIX
C          EVX          INSTANTANEOUS VARCOV
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4 ISVO(*),LPR,IPC,NPAR,NSVO,NSVO2,I,J,IDEXP
      REAL*8    A(MAXOBS2,MAXPAR2)
      REAL*8    P(MAXOBS2,MAXOBS2)
      REAL*8    VX(MAXPAR2,MAXPAR2)
      REAL*8    PX(MAXPAR2,MAXPAR2)
      REAL*8    X(MAXPAR2,1)
      REAL*8    W(MAXOBS2,1)
      REAL*8    EA(MAXOBS,MAXPAR2), EVX(MAXPAR2,MAXPAR2)
C
      REAL*8    T(MAXPAR2,MAXOBS2)
      REAL*8    ET(MAXPAR2,MAXOBS)
      LOGICAL*4 NO_GPS,NO_GLN
      REAL*8    U(MAXPAR2,1),DET
C
      CHARACTER*8  AFMT
C
C MULTIPLY EAT * EA -> EVX (ATA)
C
      CALL MATMPY (EA, EA, EVX, 5, NSVO, 5, MAXOBS, 
     &             MAXOBS, MAXPAR2, 2)
C
C FIGURE CONSTELLATIONS PRESENCE
C
      NO_GPS = ( EVX(4,4) .EQ. 0.D0 )
      NO_GLN = ( EVX(5,5) .EQ. 0.D0 )
C
C FIGURE IF SYSTEM SOLVABLE
C
      IF( NSVO .GE. 5 .OR.
     &    ( ( NO_GPS .OR. NO_GLN ) .AND. NSVO .GE. 4 ) ) THEN
C
C FIX UNOBSERVED CONSTELLATION-SPECIFIC CLOCK PARAMETERS
C
         IF( NO_GPS ) EVX(4,4) = 1.D-20
         IF( NO_GLN ) EVX(5,5) = 1.D-20
C
C SOLVE
C
         CALL SPIN (EVX, 5, MAXPAR2, DET, IDEXP )
C
C FIX UNOBSERVED CONSTELLATION-SPECIFIC CLOCK PARAMETERS
C
         IF( NO_GPS ) EVX(4,4) = 0.D0
         IF( NO_GLN ) EVX(5,5) = 0.D0
      ELSE
C
C SYSTEM UNSOLVABLE SET LARGE VARIANCES
C
         DO I=1,3
            EVX(I,I)=1.D4
         END DO
         EVX(4,4) = 0.D0
         EVX(5,5) = 0.D0
      END IF
C
C***  MULTIPLY AT * P -> T  (ATP)
C
      IF ( IPC .GT. 3) THEN
        WRITE(*,*) ' MATRIX A NPAR,NSVO2', NPAR, NSVO2
        WRITE(AFMT,'(A,I2.2,A5)') '(',NPAR,'F5.2)' 
        WRITE(*,AFMT) (( A(I,J), J=1,NPAR ), I=1,NSVO2 )
      END IF
C
      CALL MATMPY (A, P, T, NPAR, NSVO2, NSVO2, MAXOBS2, 
     &             MAXOBS2, MAXPAR2, 2)
      IF ( IPC .GT. 3 ) THEN
        WRITE(*,*) ' AFTER ATP'
        WRITE(AFMT,'(A,I2.2,A5)') '(',NPAR,'D9.3)' 
        WRITE(*,AFMT) (((T(I,J)), I=1,NPAR),J=1,NSVO2 )
      END IF
C
C***  MULTIPLY T  * A -> VX  (ATPA)
C
      CALL MATMPY (T, A, VX, NPAR, NSVO2, NPAR, MAXPAR2, MAXOBS2,
     &             MAXPAR2, 1)
      IF ( IPC .GT. 3 ) THEN
        WRITE(*,*) ' NORMALS, AFTER ATPA'
        WRITE(AFMT,'(A,I2.2,A5)') '(',NPAR,'D9.3)'
        WRITE(*,AFMT) ((VX(I,J), J=1,NPAR),I=1,NPAR )
      END IF
C
C     COMBINE EPOCH WEIGHTS (VX) WITH A-PRIORI ONES (PX)
C
      DO I= 1,NPAR
      DO  J= 1,NPAR
        VX(I,J)     = VX(I,J) + PX(I,J)
        END DO
      END DO
C
C***  INVERT VX INVERSE(ATPA + PX)
C
      IF ( IPC .GT. 3 ) THEN
        WRITE(*,*) ' NORMALS, BEFORE SPIN'
        WRITE(AFMT,'(A,I2.2,A5)') '(',NPAR,'D9.3)'
        WRITE(*,AFMT) ((VX(I,J), J=1,NPAR),I=1,NPAR )
      END IF
      CALL SPIN (VX, NPAR, MAXPAR2, DET, IDEXP )
      IF ( IPC .GT. 3 ) THEN
        WRITE(*,*) ' NORMALS, AFTER SPIN'
        WRITE(AFMT,'(A,I2.2,A5)') '(',NPAR,'D9.3)'
        WRITE(*,AFMT) ((VX(I,J), J=1,NPAR),I=1,NPAR )
      WRITE(*,*) ' MATRIX W '
        WRITE(*,'(I2,2F15.3)') ( ISVO(J),W(J*2-1,1),W(J*2,1), 
     &                              J=1,NSVO )
      END IF
C
C***  MULTIPLY T * W -> U  (ATPW)  (FOR PSEUDORANGE OBSERVATIONS)
C
      CALL MATMPY (T, W, U, NPAR, NSVO2, 1, MAXPAR2, MAXOBS2, 
     &             MAXPAR2,1)
C
      IF ( IPC .GT. 3 ) THEN
      WRITE(*,*) ' MATRIX U '
        WRITE(*,'(I2,F15.3)') ( J,U(J,1),J=1,NPAR )
      END IF
C
C***  MULTIPLY NINV * U -> X     X = INV(ATPA+PX) (ATPW)
C
      CALL MATMPY (VX, U, X, NPAR, NPAR, 1, MAXPAR2, MAXPAR2, 
     &             MAXPAR2,1)
C
      IF ( IPC .GT. 3 ) THEN
      WRITE(*,*) ' MATRIX X '
        WRITE(*,'(I2,F15.3)') ( J,X(J,1),J=1,NPAR )
      END IF
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C****************************************************************** ADJV
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE ADJV ( IOBTYP, NSVO, W, AX, VPRTOL, VCPTOL, VPR, VCP,
     &                  VPRMAX, VCPMAX, VTVPR, VTVCP, SDCP, DVPV,
     &                  SDPR, PL, IRJCTPR, IRJCTCP )
C
C     NAME              ADJV
C
C     PURPOSE   PROCESS ADJUSTMENT RESIDUALS 
C
C     PARAMETERS        DESCRIPTION
C
C          IOPTYP       OBSERVATION TYPES
C          NSVO         NUMBER SATELLITES
C          W            MISCLOSURES
C          AX           DESIGN MATRIX
C          VPRTOL       PSEUDORANGE OUTLIER THRESHOLD
C          VCPTOL       CARRIER PHASE OUTLIER THRESHOLD
C          VPR          PSEUDORANGE RESIDUALS
C          VCP          CARRIER-PHASE RESIDUALS
C          VPRMAX       PSEUDORANGE OUTLIER VALUE
C          VCPMAX       CARRIER PHASE OUTLIER VALUE
C          VTVPR        SUMSQUARES PSEUDORANGE RESIDUALS
C          VTVCP        SUMSQUARES CARRIER PHASE RESIDUALS
C          SDCP         CARRIER PHASE UNCERTAINTY
C          DVPV         DELTA VTPV
C          SDPR         PSEUDORANGE UNCERTAINTY
C          PL           OBSERVATION WEIGHTS
C          IRJCTPR      REJECTED PSEUDORANGE INDEX
C          IRJCRCP      REJECTED CARRIER PHASE INDEX
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4 IOBTYP,NSVO,IRJCTPR,IRJCTCP
      REAL*8    VPRMAX,VCPMAX,VPRTOL,VCPTOL,SDCP,DVPV
      REAL*8    VTVPR, VTVCP
      REAL*8    W(MAXOBS2,*),AX(MAXOBS2,*)
      REAL*8    VCP(MAXOBS,*),VPR(MAXOBS,*) 
      REAL*8    SDPR, PL(MAXOBS2,MAXOBS2)
C
      INTEGER*4 I,IOBPR,IOBCP
C
      VPRMAX=0.D0
      VCPMAX=0.D0
      VTVPR =0.D0
      VTVCP =0.D0
      DVPV  =0.D0
C
      DO I=1,NSVO
        IF ( IOBTYP .EQ. 1 ) THEN
           IOBPR = I
        ELSE
           IOBPR = I*2-1
        ENDIF
        VPR(I,1) = W(IOBPR,1) - AX(IOBPR,1)
C
        IF ( IOBTYP .EQ. 2 ) THEN
          IOBCP = I*2
          VCP(I,1) = W(IOBCP,1) - AX(IOBCP,1)
          DVPV= DVPV+ VCP(I,1)**2*PL(IOBCP,IOBCP)
          VTVCP = VTVCP+VCP(I,1)*VCP(I,1)*SDCP*DSQRT(PL(IOBCP,IOBCP))
        END IF
C
        VTVPR = VTVPR+VPR(I,1)*VPR(I,1)*SDPR*DSQRT(PL(IOBPR,IOBPR))
      END DO
C
      IF (NSVO .GT. 1) THEN
        VTVPR=DSQRT(VTVPR/(NSVO-1))
        VTVCP=DSQRT(VTVCP/(NSVO-1))
      ELSE
        VTVPR=0.D0
        VTVCP=0.D0
      END IF      
C
C     FIND MAXIMUM PSEUDORANGE RESIDUAL
C
      DO I=1,NSVO
        IOBCP=I*2
        IF ( IOBTYP .EQ. 2 .AND.
     &       DABS(VCP(I,1))*SDCP*DSQRT(PL(IOBCP,IOBCP)) .GT.
     &                                               DABS(VCPMAX) ) THEN
          VCPMAX   = VCP(I,1)*SDCP*DSQRT(PL(IOBCP,IOBCP))
          IRJCTCP= I
        END IF
C
C     FIND MAXIMUM CARRIER RESIDUAL
C
            IOBPR=(I-1)*IOBTYP+1
            IF ( DABS(VPR(I,1))*SDPR*DSQRT(PL(IOBPR,IOBPR)) .GT.
     &                                            DABS(VPRMAX) ) THEN
              VPRMAX   = VPR(I,1)*SDPR*DSQRT(PL(IOBPR,IOBPR))
              IRJCTPR= I
            END IF
          END DO
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C************************************************************* AMSTAT
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE AMSTAT (NSVO, ISVO, IAMB, VCPAMB, SCPAMB, RMS, WRMS)
C
C
C     PURPOSE: COMPUTE STATISTIC ON AMBIGUITY RESIDUALS AND
C              CHECK CONVERGENCE
C
C     PARAMETER         DESRIPTION
C
C          NSVO         NUMBER OF SATELLITES OBSERVED AT THIS EPOCH
C          ISVO         PRNS SATELLITES OBSERVED
C          IAMB         AMBIGUITY FLAG (0=OLD,1=NEW AMBIGUITY)
C          VCPAMB       AMBIGUITY RESIDUAL
C          SCPAMB       AMBIGUITY SIGMA
C          RMS          AMBIGUITY RESIDUAL RMS
C          WRMS         AMBIGUITY RESIDUAL WEIGHTED RMS
C
C
      IMPLICIT NONE
C
      INTEGER*4  NSVO, ISVO(*),IAMB(*)
      REAL*8     VCPAMB(*), SCPAMB(*)
      REAL*8     RMS, WRMS
C
      INTEGER*4  I, IPRN, NAMB 
      REAL*8     V2, S2
      REAL*8     W, WSUM
C
C     COMPUTE EPOCH RMS AND WEIGHTED RMS OF AMBIGUITY RESIDUALS 
C
      NAMB=0
      RMS=0.D0
      WRMS=0.D0
      WSUM=0.D0
C
      DO I=1,NSVO
        IPRN=ISVO(I)
        IF ( IAMB(IPRN) .EQ. 0 ) THEN
        NAMB=NAMB+1
        V2=(VCPAMB(IPRN)*VCPAMB(IPRN))
        S2=(SCPAMB(IPRN)*SCPAMB(IPRN))
          RMS=RMS+V2
        W=1.D0/S2
        WSUM=WSUM+W
          WRMS=WRMS+V2*W
      END IF      
      END DO
C
      IF ( NAMB .NE. 0 ) THEN
        RMS=RMS/NAMB
      RMS=DSQRT(RMS)
        WRMS=WRMS/WSUM
      WRMS=DSQRT(WRMS)
      END IF
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** ANML2
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE ANML2(AMYM,ORBEC,AMYE,AMYT,IFLAG,PI)
C
C     PURPOSE:   CONVERT ECCENTRICITY AND MEAN ANOMALY TO ECCENTRIC AND
C                TRUE ANOMALY
C
C     PARAMETERS
C               I AMYM = MEAN ANOMALY (RAD)
C               I ORBEC= ORBITAL ECCENTRICITY
C               O AMYE = ECCENTRIC ANOMALY (RAD)
C               O AMYT = TRUE ANOMALY (RAD)
C               O IFLAG= 0 OK
C                        1 NONCONVERGENCE ON KEPLERS EQUATION FOR ECC ANOM
C               I PI
C
      IMPLICIT NONE
C
      INTEGER*4 IFLAG,I
      REAL*8    AMYM,ORBEC,AMYE,AMYT,PI,PI2,ORBECS,S,A,B,C,
     &          E1,SE,DIFF,SF,CF
C
      IFLAG = 0
      PI2 = PI * 2.0D0
      ORBECS = ORBEC * ORBEC
      AMYM = DMOD( AMYM,PI2 )
C-----------------------------------------------------------------
C            COMPUTE FIRST APPROXIMATION TO ECCENTRIC ANOMALY
C-----------------------------------------------------------------
      S = DSIN(AMYM)
      A = ORBEC * S
      B = A * ORBEC * DCOS(AMYM)
      C = ORBECS * A * (1.0D0 - 1.5D0 * S * S)
      AMYE = AMYM + A + B + C
C ----------------------------------------------------------------------
C            ITERATE ON ECCENTRIC ANOMALY
C ----------------------------------------------------------------------
      I = 0
   10 I = I + 1
      E1 = AMYE
      AMYE = E1+(AMYM-E1+ORBEC * DSIN(E1))/(1.0D0 - ORBEC * DCOS(E1))
      IF ( I .LE. 8 ) GO TO 30
      IFLAG = 1
      GO TO 40
   30 IF ( DABS(AMYE-E1) .GT. 1.0D-10 ) GO TO 10
C---------------------------------------------------------------------
C                   ITERATIONS COMPLETE
C---------------------------------------------------------------------
   40 CONTINUE
      SE = DSIN(AMYE)
      DIFF = DABS(AMYM-(AMYE-ORBEC*SE))
      IF ( DIFF .LT. 1.0D-10 ) GO TO 60
      IFLAG = 1
c!    WRITE(LU,50) DIFF, I, AMYM, AMYE
c! 50 FORMAT(' /ANML2: ECCENTRICITY MISCLOSURE='D20.10/
c!   # '         ITERATIONS='I4/'          AMYM='D20.10' AMYE='D20.10)
   60 CONTINUE
C-------------------------------------------------------------------
C                     COMPUTE TRUE ANOMALY
C-------------------------------------------------------------------
      SF = DSQRT ( 1.0D0 - ORBECS ) * SE
      CF = DCOS ( AMYE ) - ORBEC
      AMYT = DATAN2 ( SF , CF )
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** ANOMLY
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE ANOMLY(EPH,TIME,LPR,AMYM,AMYE,AMYT,PHIK,IFLAG,CORRMM)
C
C     PURPOSE:        TO COMPUTE ORBIT ANOMALIES
C
C     PARAMETERS      DESCRIPTION
C        EPH          BROADCAST EPHEMERIS PARAMETERS
C        TIME         TIME OF COMPUTATION
C        LPR          PRINT UNIT
C        AMYM         MEAN ANOMALY
C        AMYE         ECCENTRIC ANOMALY
C        AMYT         TRUE ANOMALY
C        PHIK         
C        IFLAG        
C        CORRMM       DELTA-ANOMALY
C
      IMPLICIT NONE
      INTEGER*4 LPR,IFLAG,ITER
      REAL*8    EPH(*),TIME,AMYM,AMYE,AMYT,PHIK,CORRMM,ECC,
     &          AMYE0,AMYM1,DE,COSV,SINV
C
      IFLAG = 1
      ITER = 0
      ECC = EPH(17)
C
C ---------------------------------------------------------------------
C      SOLVE KEPLER'S LAW FOR THE ECCENTRIC ANOMALY
C ---------------------------------------------------------------------
C
C COMPUTE MEAN ANOMOLY AT OBSERVATION TIME
      AMYM = EPH(15) + CORRMM * TIME
C COMPUTE APPROX ECCENTRIC ANOMOLY
      AMYE0 = AMYM+ECC *DSIN(AMYM)+ECC*2.0D0*DSIN(2.0D0*AMYM)/2.0D0
C ITERATE TO SOLVE FOR ECCENTRIC ANOMOLY
    5 CONTINUE
      AMYM1 = AMYE0 - ECC * DSIN(AMYE0)
      DE = (AMYM - AMYM1) / (1.0D0-ECC*DCOS(AMYE0))
      AMYE0 = AMYE0 + DE
      ITER = ITER + 1
      IF(ITER .LT. 10 .AND. DABS(DE) .GT. 1.D-10) GO TO 5
      IF(DABS(DE) .GT. 1.D-10)  WRITE(LPR,1000) DABS(DE)
C
   10 IFLAG = 0
      AMYE = AMYE0
C
C ---------------------------------------------------------------------
C      COMPUTE TRUE ANOMALY
C ---------------------------------------------------------------------
C
      COSV = DCOS(AMYE) - ECC
      SINV = DSQRT(1.D0 - ECC**2) * DSIN(AMYE)
      AMYT = DATAN2(SINV , COSV)
C
      PHIK = AMYT + EPH(27)
C
C-----------------------------------------------------------------------
C       FORMAT STATEMENTS
C-----------------------------------------------------------------------
C
 1000 FORMAT(//,5X,'*****  NO CONVERGENCE IN "ANOMLY".  AFTER 10 ',
     #  'ITERATIONS    ABS(DE) = ',G20.8,'    *****',//)
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C **************************************************************** ANTEX
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE ANTEX ( DTM, ELAT, ELON, EHGT, DN, DE, DH, DXYZ )
C
C     NAME              ANTEX
C
C     PURPOSE   COMPUTE ANTENNA EXCENTRICITY IN CARTESIAN
C                       COORDINATES FROM STATION NORTHING, EASTING 
C                       AND HEIGHT OFFSETS
C
C     PARAMETERS        DESCRIPTION
C
C          DTM          DATUM PARAMETERS
C          ELAT         STATION LATITUDE (RADIANS)
C          ELON         STATION LONGITUDE (RADIANS)
C          EHGT         STATION HEIGHT (METRES)
C          DN           ANTENNA NORTHING FROM MARKER (METRES)
C          DE           ANTENNA EASTING FROM MARKER (METRES)
C          DH           ANTENNA HEIGHT FROM MARKER (METRES)
C          DXYZ         ANTENNA EXCENTRICITY IN CARTESIAN COORDINATE
C
C *********************************************************************
C
      IMPLICIT NONE
      REAL*8 DTM(*),     DXYZ(*)
      REAL*8 ELAT,       ELON,        EHGT
      REAL*8 DN,         DE,          DH      
C
      REAL*8 SLAT,       CLAT
      REAL*8 SLON,       CLON
      REAL*8 E2,         M,           N
C
      SLAT = DSIN(ELAT)      
      CLAT = DCOS(ELAT)      
      SLON = DSIN(ELON)
      CLON = DCOS(ELON)
C
      E2= DTM(2)*DTM(2)
      M = DTM(1) * (1.0D0 - E2) / (1.0D0 - E2 * SLAT * SLAT) ** 1.5
      M=  M + EHGT
      N = DTM(1) / DSQRT (1.0D0 - E2 * SLAT * SLAT)
      N = N + EHGT
      DXYZ(1)= - (CLON*SLAT*DN) - (SLON*DE) + (CLAT*CLON*DH)
      DXYZ(2) =- (SLON*SLAT*DN) + (CLON*DE) + (CLAT*SLON*DH)
      DXYZ(3) =  (CLAT*DN)                      + (SLAT*DH)
      RETURN
      END            
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** ANTPCV
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C     
      SUBROUTINE ANTPCV(IFREQ, IPRN, PCVNEU, ANTN, ANTE, ANTH)
C
C       NAME            ANTPCV
C
C       PURPOSE         APPLY ANTENNA L1/L2 PHASE CENTER VARIATIONS
C                       USING IGS PCV TABLE
C
C       PARAMETERS      DESCRIPTION
C
C          IFREQ        CORRECTION L-BAND FREQUENCY(1=L1,2=L2,3=L3)
C          IPRN         SATELLITE PRN
C          PCVNEU       PHASE CENTER VARIATION (NORTH,EAST,UP)
C          ANTN         NORTH COMPONENT
C          ANTE         EAST COMPONENT
C          ANTH         VERTICAL COMPONENT
C
C *********************************************************************
C
      IMPLICIT NONE
C      
      INTEGER*4  IFREQ
      REAL*8     PCVNEU(*),ANTN,ANTE,ANTH
      REAL*8     F1,F2,F1S,F2S,F12S,PCVCOR,PCVNL1,PCVNL2,
     &           PCVNL3,PCVEL1,PCVEL2,PCVEL3,PCVUL1,PCVUL2,PCVUL3
      INTEGER*4 IPRN
      REAL*8 F1ION, F2ION, AL1, AL2, AL3, AL4
C GPS/GLN F1, F2
      CALL FREQ12( IPRN, F1, F2, F1S, F2S, F12S, F1ION, F2ION,
     &                   AL1, AL2, AL3, AL4, IFREQ )
C
      PCVCOR  = 0.D0
C
      PCVNL1= PCVNEU(1)/1.D3
      PCVNL2= PCVNEU(4)/1.D3
      PCVNL3= PCVNL1*F1S/F12S - PCVNL2*F2S/F12S
C
      PCVEL1= PCVNEU(2)/1.D3
      PCVEL2= PCVNEU(5)/1.D3
      PCVEL3= PCVEL1*F1S/F12S - PCVEL2*F2S/F12S
C
      PCVUL1= PCVNEU(3)/1.D3
      PCVUL2= PCVNEU(6)/1.D3
      PCVUL3= PCVUL1*F1S/F12S - PCVUL2*F2S/F12S
      IF ( IFREQ .EQ. 1 ) THEN
        ANTN     =ANTN+PCVNL1
        ANTE     =ANTE+PCVEL1
        ANTH     =ANTH+PCVUL1
      END IF
      IF ( IFREQ .EQ. 2 ) THEN
        ANTN     =ANTN+PCVNL2
        ANTE     =ANTE+PCVEL2
        ANTH     =ANTH+PCVUL2
      END IF
      IF ( IFREQ .GE. 3 ) THEN
        ANTN     =ANTN+PCVNL3
        ANTE     =ANTE+PCVEL3
        ANTH     =ANTH+PCVUL3
      END IF
C
c!    WRITE(*,'(3(A3,F10.3))') 'ELV',ELV,'ZEN',ZEN,'IEL',IELV 
c!    WRITE(*,'(3(A3,F10.3))') 'L1',PCVNL1,'L2',PCVNL2,'L3',PCVNL3 
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** EXTERNAL_YAW
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE APPLY_EXTYAW( IBLK, TTAG, MJD, DMJDT, SIDT, XSV, VSV,
     &                         EROT, YAWMODEL, YAW, SANTXYZ, PI )
C
C     NAME              APPLY_EXTYAW
C
C     PURPOSE         APPLY EXTERNALLY PROVIDED YAW ANGLE
C
C     PARAMETERS        DESCRIPTION
C
C          IBLK         SATELLITE BLOCK NUMBER
C          TTAG         TIME
C          MJD          MODIFIED JULIAN DAY
C          DMJDT        FRACTIONAL MJD
C          SIDT         SIDEREAL TIME
C          XSV          SATELLITE POSITION VECTOR
C          VSV          SATELLITE VELOCITY VECTOR
C          EROT         EARTH ROTATION RATE
C          YAWMODEL     YAW REFERENCE INDICATOR (0) UNKNOWN
C                                               (1) SUN DIRECTION
C                                               (2) JPL's W-VECTOR
C          YAW          YAW ANGLE (RAD)
C          SANTXYZ      SATELLITE X UNIT VECTOR
C          PI           PI VALUE
C
C *********************************************************************
C
      IMPLICIT NONE   
C
C ARGUMENT DEFINITIONS
C
      INTEGER*4 IDIR, IBLK, YAWMODEL, MJD
      REAL*8    TTAG, DMJDT, SIDT, YAW, EROT, PI, XSV(3), VSV(3),
     &          SANTXYZ(3)
C
C LOCAL DEFINITIONS
C
      INTEGER*4 I
     &         , XAXIS
      REAL*8    NORM, DMJD, BETA, YAW_ROT, YANGLE, COSYAW, SINYAW
      REAL*8    Z(3), Y(3), X(3), V(3), VI(3), W(3), WI(3), O(3),
     &          XS(3), DS(3)
C
C VALIDATE YAW MODEL
C
      IF( YAWMODEL .LE. 0 .OR. YAWMODEL .GT. 2 ) RETURN
      XAXIS=1
      IF(IBLK.EQ.4.OR.IBLK.EQ.5) XAXIS=-1
C
C
C COMPUTE SATELLITE BODY UNIT VECTORS
C
C V-vector
      NORM=SQRT(VSV(1)**2+VSV(2)**2+VSV(3)**2)
      DO I=1,3
       V(I)=VSV(I)/NORM
      END DO
C Z-vector
      NORM=SQRT(XSV(1)**2+XSV(2)**2+XSV(3)**2)
      DO I=1,3
       Z(I)=-XSV(I)/NORM
      END DO
C W-vector
      NORM=Z(1)*V(1)+Z(2)*V(2)+Z(3)*V(3)
      DO I=1,3
       W(I)=V(I)-Z(I)*NORM
      END DO
      NORM=SQRT(W(1)**2+W(2)**2+W(3)**2)
      DO I=1,3
       W(I)=W(I)/NORM
      END DO
C SUN POSITION
      DMJD=MJD+DMJDT
      CALL SUNXYZ (DMJD,SIDT,XS(1),XS(2),XS(3))
C SAT->SUN VECTOR
      DO I=1,3
       DS(I) = XS(I)-XSV(I)
      END DO
      NORM=SQRT(DS(1)**2+DS(2)**2+DS(3)**2)
      DO I=1,3
       DS(I) = DS(I)/NORM
      END DO
C CORRECT INLINE CASE
      NORM=Z(1)*DS(1)+Z(2)*DS(2)+Z(3)*DS(3)
      IF( DABS(NORM) > (1.D0-1.D-20) ) THEN
       NORM=W(1)*DS(1)+W(2)*DS(2)+W(3)*DS(3)
       DO I=1,3
        IF( NORM < 0.D0 ) THEN
         DS(I) = DS(I)-W(I)
        ELSE
         DS(I) = W(I)
        END IF
       END DO
      END IF
C Y-vector = Z x SAT->SUN
      Y(1) = Z(2)*DS(3) - Z(3)*DS(2)
      Y(2) = Z(3)*DS(1) - Z(1)*DS(3)
      Y(3) = Z(1)*DS(2) - Z(2)*DS(1)
      NORM=SQRT(Y(1)**2+Y(2)**2+Y(3)**2)
      DO I=1,3
       Y(I)=Y(I)/NORM
      END DO
C X-vector = Y x Z
      X(1) = Y(2)*Z(3) - Y(3)*Z(2)
      X(2) = Y(3)*Z(1) - Y(1)*Z(3)
      X(3) = Y(1)*Z(2) - Y(2)*Z(1)
      NORM=SQRT(X(1)**2+X(2)**2+X(3)**2)
      DO I=1,3
       X(I)=X(I)/NORM
      END DO
C WHEN EXTERNAL YAW IS REFERENCED TO JPL'S W-VECTOR
C
      IF( YAWMODEL.EQ.2 ) THEN
C
C ORBITPLANE NORMAL = P x VI
       VI(1) = VSV(1) - EROT * XSV(2);
       VI(2) = VSV(2) + EROT * XSV(1);
       VI(3) = VSV(3)
       O(1) = XSV(2)*VI(3) - XSV(3)*VI(2)
       O(2) = XSV(3)*VI(1) - XSV(1)*VI(3)
       O(3) = XSV(1)*VI(2) - XSV(2)*VI(1)
       NORM=SQRT(O(1)**2+O(2)**2+O(3)**2)*
     &      SQRT(XS(1)**2+XS(2)**2+XS(3)**2)
       BETA=PI/2.D0 - DACOS((O(1)*XS(1)+O(2)*XS(2)+O(3)*XS(3))/NORM)
C WI-vector
       NORM=Z(1)*VI(1)+Z(2)*VI(2)+Z(3)*VI(3)
       DO I=1,3
        WI(I)=VI(I)-Z(I)*NORM
       END DO
       NORM=SQRT(WI(1)**2+WI(2)**2+WI(3)**2)
       DO I=1,3
        WI(I)=WI(I)/NORM
       END DO
C YANGLE IS ANGLE BTW WI-VECTOR AND INTERNAL
       YANGLE=DACOS(X(1)*WI(1)+X(2)*WI(2)+X(3)*WI(3))
       YANGLE=DSIGN(YANGLE,(-BETA))
C
C
C WHEN EXTERNAL YAW IS REFERENCED TO SUN X-VECTOR
C
C
      ELSE
       YANGLE = 0.D0
      ENDIF
C
      YAW_ROT = YAW - YANGLE
C
C ROTATE SATELLITE X UNIT VECTOR
C
      COSYAW=DCOS(YAW_ROT)
      SINYAW=DSIN(YAW_ROT)
      SANTXYZ(1) = (COSYAW * X(1) + SINYAW * Y(1))*XAXIS
      SANTXYZ(2) = (COSYAW * X(2) + SINYAW * Y(2))*XAXIS
      SANTXYZ(3) = (COSYAW * X(3) + SINYAW * Y(3))*XAXIS
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*****************************************************************ARCTIM
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE ARCTIM ( IS, IP, NEPTIM, EPHTIM, NARC, TB, TE )
C
C
C     PURPOSE:   DETERMINE NUMBER OF ARCS PER SATELLITE
C                AND SET TIME INTERVALS FOR APPROXIMATION
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C       IS              SATELLITE POSITION IN LIST
C       IP              SATELLITE PRN NUMBER
C       NEPTIM          NUMBER OF EPHEMERIS DOWNLOADED PER SATELLITE
C       EPHTIM          ARRAY OF EPHEMERIS REFERENCE TIMES
C       NARC            NUMBER OF ARCS PER SATELLITE
C       TB              SATELLITE/ARC START TIME
C       TE              SATELLITE/ARC END TIME
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE        'MAXDIM'
C
      INTEGER*4 IT,IS,IA,IP
      INTEGER*4 NEPTIM(MAXSAT),NARC(MAXSAT)
      REAL*8    EPHTIM(MAXSAT,MAXEPH),TB(MAXSAT,MAXARC),
     &          TE(MAXSAT,MAXARC),DEPHTIM,DARCTIM
C
      IF ( IS .GT. 0 .AND. NEPTIM(IS) .GT. 0 ) THEN
        IA=1
      DO 40 IT=1,NEPTIM(IS)
C
C       FIRST EPHEMERIS FOR THIS SATELLITE, SET ARC START TIME
C
        IF (IT .EQ. 1) THEN
          TB(IP,IA) = EPHTIM(IS,IT) - 7200.D0
          TB(IP,IA) = IDNINT(TB(IP,IA)/3600.D0) * 3600.D0
          GO TO 35
        END IF
C
C       CHECK IF THIS IS NEW ARC (DEPHTIM > 4 HRS OR DARCTIM > 10 HRS)
C
        DEPHTIM = EPHTIM(IS,IT) - EPHTIM(IS,IT-1)
        DARCTIM = EPHTIM(IS,IT) - TB(IP,IA)
        IF ( DEPHTIM .GT. 14400.D0 .OR. DARCTIM .GT. 36000.D0 ) THEN
             IF ( (IA+1) .GT. MAXARC ) GO TO 40
           TE(IP,IA) = EPHTIM(IS,IT-1) + 7200.D0
           TE(IP,IA) = ( IDNINT(TE(IP,IA)/3600.D0) + 1 ) * 3600.D0
           IA = IA + 1
           TB(IP,IA) = EPHTIM(IS,IT) - 7200.D0
           TB(IP,IA) = IDNINT(TB(IP,IA)/3600.D0) * 3600.D0
        END IF
   35   CONTINUE
        TE(IP,IA) = EPHTIM(IS,IT) + 7200.D0
        TE(IP,IA) = ( IDNINT(TE(IP,IA)/3600.D0) + 1 ) * 3600.D0
c!      WRITE(*,*) IP,IA,TB(IP,IA),TE(IP,IA)
   40 CONTINUE
        NARC(IS) = IA
      END IF
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890 C
C
C***************************************************************** AZELD
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE AZELD ( X1,Y1,Z1,PHI,PLAM,X2,Y2,Z2,AZ,EL,DIST)
C
C     PURPOSE:   COMPUTE AZIMUTH , ELEVATION AND DISTANCE
C                BETWEEN 2 POINTS
C
C     PARAMETERS         DESCRIPTION
C        X1              STATION X COMPONENT
C        Y1              STATION Y COMPONENT
C        Z1              STATION Z COMPONENT
C        PHI             STATION LATITUDE
C        PLAM            STATION LONGITUDE
C        X2              SATELLITE X COMPONENT
C        Y2              SATELLITE Y COMPONENT
C        Z2              SATELLITE Z COMPONENT
C        AZ              AZIMUTH
C        EL              ELEVATION
C        DIST            DISTANCE
C
      IMPLICIT NONE
C
      REAL*8 X1,Y1,Z1,X2,Y2,Z2
      REAL*8 PHI,PLAM
      REAL*8 AZ,EL,DIST
C
      REAL*8 RLAT , RLON ,PI
      REAL*8 SRLON , CRLON
      REAL*8 SRLAT , CRLAT
      REAL*8 DX,DY,DZ
      REAL*8 DU,DV,DW
C
      PI = (DATAN(1.D0)) * 4.D0
      RLAT = PHI-PI/2.0D0
      RLON = PLAM-PI
      SRLAT= DSIN(RLAT)
      CRLAT= DCOS(RLAT)
      SRLON= DSIN(RLON)
      CRLON= DCOS(RLON)
C
      DX = X2-X1
      DY = Y2-Y1
      DZ = Z2-Z1
C
      DU = CRLAT * CRLON * DX + CRLAT *SRLON * DY - SRLAT * DZ
      DV = SRLON * DX - CRLON * DY
      DW = SRLAT * CRLON * DX + SRLAT * SRLON *DY + CRLAT * DZ
C
      DIST = DSQRT(DU*DU+DV*DV+DW*DW)
      AZ = DATAN2(DV,DU)
      EL = DASIN(DW/DIST)
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** BEIPR
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
       REAL*8 FUNCTION BEIPR (IFREQ, ELEV, IBLK)
C
C
C                     - REFERENCES    - Wanninger and   Beer 2014    
C BeiDou satellite-induced code pseudorange variations: diagnosis
C and therapy, GPS Solut.  DOI 10.1007/s10291-014-0423-3
C
C         VARIABLES USED     -IFREQ , ELEV , IBLK       ,
C           IFREQ - 1, 2, 3 FOR BEIDOU FREQ B1, B2, B3
C           ELEV  - SAT ELVATION IN DEG
C           IBLK  - BEIDOU MEO(21, 25), IGEO(22, 26), GEO(23, 27)
C           NOTE: IGEO Table used also fo GEO satellites
C 
C         VARIABLES ALTERED  -BEIPR   ,        ,        , 
C 
C         VARIABLES RETURNED -BEIPR   ,        ,        , 
C 
C         EXTERNAL ROUTINES  - NONE   ,        ,        , 
C 
C         I/O DEVICES        -*NONE*  ,        ,        , 
C 
C 
C        [BEIPR] RETURNS THE BEIDOU PR CORRECTION FOR SPECIF FREQ AND
C        TYPE (IBLK)
C        THE PR CORRECTION (M) TO BE ADDED TO THE OBSERVED PR
C 
       IMPLICIT NONE
C
       REAL*8 ELEV ,  PRCOR(10,3,3)
C 
       INTEGER*4 IFREQ, IBLK, I, IELV, IBL
C Wanninger and   Beer 2014, Table 1:
C MEO B1
       DATA ( PRCOR(I, 1, 1) ,I=1,10)
     & /-.55, -.40, -.34, -.23, -.15, -.04, .09, .19, .27, .35/
C MEO B2
       DATA ( PRCOR(I, 2, 1) ,I=1,10)
     & /-.71, -.36, -.33, -.19, -.14, -.03, .08, .17, .24, .33/
C MEO B3
       DATA ( PRCOR(I, 3, 1) ,I=1,10)
     & /-.27, -.23, -.21, -.15, -.11, -.04, .05, .14, .19, .32/
C IGEO B1
       DATA ( PRCOR(I, 1, 2) ,I=1,10)
     & /-.47, -.38, -.32, -.23, -.11,  .06, .34, .69, .97,1.05/
C IGEO B2
       DATA ( PRCOR(I, 2, 2) ,I=1,10)
     & /-.40, -.31, -.26, -.18, -.06,  .09, .28, .48, .64, .69/
C IGEO B3
       DATA ( PRCOR(I, 3, 2) ,I=1,10)
     & /-.22, -.15, -.13, -.10, -.04,  .05, .14, .27, .36, .47/
C  GEO B1
       DATA ( PRCOR(I, 1, 3) ,I=1,10)
     & /-.47, -.38, -.32, -.23, -.11,  .06, .34, .69, .97,1.05/
C  GEO B2
       DATA ( PRCOR(I, 2, 3) ,I=1,10)
     & /-.40, -.31, -.26, -.18, -.06,  .09, .28, .48, .64, .69/
C  GEO B3
       DATA ( PRCOR(I, 3, 3) ,I=1,10)
     & /-.22, -.15, -.13, -.10, -.04,  .05, .14, .27, .36, .47/
C 
C 
       IELV= 1 + (ELEV)/10
       IBL = IBLK-20
C BEIDOU 3 IBLK .GE. 25 !
       IF(IBL.GT.4) IBL= IBL-4
C BEIPR IS TO BE ADDED TO THE OBSERVED PR
       BEIPR = PRCOR(IELV, IFREQ, IBL)+(PRCOR(IELV+1, IFREQ,IBL) 
     &        -PRCOR(IELV, IFREQ, IBL))*(INT(ELEV)-IELV*10+10)/10 
       RETURN 
       END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*****************************************************************BEPXYZ
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE BEPXYZ ( LUI, LUO, LPR, ISV, NEPSV, IEPSV,
     &                    NEPTIM, EPHTIM, EPHTBL, TB, TE,
     &                    STEP, NUMBER, DTM, XRV, T, X, Y, Z, 
     &                    DT, C )
C
C     PURPOSE:   GET SATELLITE COORDINATES AND CLOCK OFFSET
C            FROM BROADCAST OR PRECISE EPHEMERIS
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     LUI               LOGICAL UNIT OF INPUT
C     LUO               LOGICAL UNIT OF OUTPUT
C     LPR               LOGICAL UNIT OF PRINTER
C     ISV               SATELLITE POSITION IN IEPSV ARRAY
C     NEPSV             NUMBER OF SATELLITES WITH BROADCAST EPHEMERIS
C     IEPSV             BROADCAST SATELLITE ID'S
C     NEPTIM            NUMBER OF BROADCAST EPHEMERIS DOWNLOADED/SATELLITE
C     EPHTIM            ARRAY OF BROADCAST EPHEMERIS REFERENCE TIMES
C     EPHTBL            TABLE OF BROADCAST EPHEMERIDES
C     IEPRN             PRN NUMBER OF SATELLITE
C     TB                SATELLITE/ARC START TIME
C     TE                SATELLITE/ARC END TIME
C     STEP              TIME INTERVAL FOR SATELLITE POSITION COMPUTATION
C     NUMBER            NUMBER OF SATELLITE TIME AND POSITIONS
C     T         ARRAY OF SATELLITE TIMES
C     DT                ARRAY OF SATELLITE CLOCK ERRORS
C     XYZ               ARRAY OF SATELLITE COORDINATES
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE   'MAXDIM'
C
      INTEGER*4 IEPSV(MAXSAT), NEPTIM(MAXSAT), IPRN
      REAL*8    DTM(*),       XRV(*)
      REAL*8    T(*)
      REAL*8    X(MAXPFIT,*),Y(MAXPFIT,*),Z(MAXPFIT,*)
      REAL*8    DT(MAXPFIT,*)
      REAL*8    EPHTIM(MAXSAT,MAXEPH)
      REAL*8    EPHTBL(MAXKEP,MAXSAT,MAXEPH)
      REAL*8    EPH(30), XSV(3), XSVD(3)
      INTEGER*4 NUMBER,ISV,NEPSV,IVEL,ITIM,LUO,LUI,LPR
      REAL*8    TT,TB,TE,TIM,C,DELTAT,RELT,STEP
C
C     LOOP BETWEEN ARC TIME LIMITS AT SELECTED INTERVAL
C     AND EVALUATE SATELLITE COORDINATES
C
      TT = TB
      IPRN=IEPSV(ISV)
  110 CONTINUE
      NUMBER = NUMBER + 1
C
C     GET BEST EPHEMERIS FOR THIS SATELLITE AND TIME
C
      CALL EPFIND ( IEPSV(ISV), TT, 0, NEPSV, IEPSV, NEPTIM,
     &              EPHTIM, EPHTBL, EPH )
C
      TIM  = TT - EPH(20) - EPH(2) * 604800.D0
      ITIM = 0
C
      IVEL = 1
      CALL KLORB( LUO, EPH, XSV, XSVD, C, XRV, DTM,
     &            TIM, ITIM, LPR, IVEL )
      CALL KLCLK (EPH,DTM,TIM,DELTAT,RELT)
C
      T(NUMBER)    = TT
      X(NUMBER,IPRN)= XSV(1)
      Y(NUMBER,IPRN)= XSV(2)
      Z(NUMBER,IPRN)= XSV(3)
      DT(NUMBER,IPRN)   = DELTAT
      TT = TB + NUMBER*STEP
c!     WRITE(*,'(I4,2F10.1,3F12.1,F12.9)') NUMBER, EPH(2), EPH(20), 
c!    &                                     XSV(1), XSV(2), XSV(3), DELTAT
c!     WRITE(*,*) 'TT,TE',TT,TE
      IF ( TT .LT. TE ) GO TO 110
C
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** BODYT
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE BODYT(DLAT,DLON, XRV, IY, IM, ID, DMJD, SIDT, TUP,TEAST
     &                 ,TNORTH)
C
C FUNCTION: BODYT CALCULATES DISPLACEMENTS DUE TO BODY TIDES
C
C INPUT: XRV   = RX EPOCH X,Y,Z IN M                       
C        IY,IM,ID =  YEAR, MONTH, DAY (UTC)                     
C        DMJD  = MOD JULIAN DAY                 
C        SIDT  = SIDERIAL TIME                 
C
C OUTPUT: TUP    = RADIAL DISPLACEMENT IN METRES (+ UP)
C         TNORTH = N-S DISPLACEMENT IN METRES (+ NORTH)
C         TEAST  = E-W DISPLACEMENT IN METRES (+ EAST)
C
C
      IMPLICIT NONE
      REAL*8   DLAT,DLON, DMJD, SIDT, TUP,TEAST,TNORTH, DXTIDE(3),
     &         FHR,F,W
      REAL*8   XMOON(3),XSUN(3),XRV(3),            DSINF,DCOSF,DCW, DSW
      INTEGER*4 IY, IM, ID
C
      F   = DLAT                             
      W   = DLON
      DSINF= DSIN(F)
      DCOSF= DCOS(F)
      DCW  = COS(W)
      DSW  = SIN(W)
      CALL       SUNXYZ (DMJD,SIDT, XSUN(1),XSUN(2),XSUN(3))
      CALL       MOONXYZ(DMJD,SIDT, XMOON(1),XMOON(2),XMOON(3))
      FHR=(DMJD-INT(DMJD))*24.d0
C  CALL IERS2003 TIDE Subroutine
      CALL DEHANTTIDEINEL(XRV, iY ,iM ,iD , FHR, XSUN, XMOON, DXTIDE)
      TNORTH = -DSINF*(DCW*DXTIDE(1)+DSW*DXTIDE(2))+DCOSF*DXTIDE(3)
      TEAST  =        -DSW*DXTIDE(1)+DCW*DXTIDE(2)                 
      TUP    =  DCOSF*(DCW*DXTIDE(1)+DSW*DXTIDE(2))+DSINF*DXTIDE(3)
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C************************************************************* CHBPOL
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE CHBPOL (XS, XE, N, X, Y, NDEG, CY, RMSY)
C
C     NAME              CHEBPOL
C
C     PURPOSE   FIT CHEBYCHEV POLYNOMIAL TO TIME SERIES
C
C     PARAMETERS        DESCRIPTION
C
C          XS           INDEPENDENT VARIABLE AT START OF FIT WINDOW
C          XE           INDEPENDENT VARIABLE AT END OF FIT WINDOW
C          N            NUMBER OF VARIABLES
C          X            ARRAY OF INDEPENDENT VARIABLES
C          Y            ARRAY OF DEPENDENT VARIABLES
C          NDEG         DEGREE OF POLYNOMIAL
C          CY           POLYNOMIAL COEFFICIENTS
C          YE           ESTIMATED DEPENDANT VARIABLE
C          RMS          RMS OF RESIDUALS
C         
C          
C
C     CHEBYCHEV POLYNOMIAL FIT
C
      IMPLICIT NONE
C
      INCLUDE  'MAXDIM'
C
C     DIMENSIONING OF COORDINATE ARRAYS FOR APPROXIMATION
C
C
      INTEGER*4  NDEG, N
      REAL*8     XS, XE, X(*), Y(*), RMSY
C
C     DIMENSIONING FOR CHEBYSHEW POLYNOMIAL COEFFICIENTS
C     ( MAXIMUM COEFFICIENTS MAXDEG )
C
      REAL*8    CY(*)
C
      INTEGER*4 NP,MAXC,NC,I,J,K,L,IDEXP,NDF
      REAL*8    XINT,XPLUS,XT,PK,DET,ATAKL,CYI,RESY
      REAL*8    ATA(MAXORD,MAXORD)
      REAL*8    ATLY(MAXORD)
      REAL*8    POL(MAXORD)
C
c!     WRITE(LPR,*) 'ENTERING CHEBFIT',N,NDEG
      NP = MAXORD
      MAXC = MAXDEG
C
      IF(XE.LT.XS) RETURN
      XINT = XE-XS
      XPLUS= XE+XS
      NC   = MIN(MAXC,NDEG,NP)
      IF (NDEG .GT. N)
     &  WRITE(*,*) 'DEGREE OF POLYNOMIAL > NUMBER OF SAMPLES'
C
C     INITIALIZE
C
      DO 80 I = 1,NC
        CY(I)   = 0.D0
   80 CONTINUE
C
      DO 90 I=1,NP
        ATLY(I) = 0.D0
        DO 85 J=1,NP
          ATA(I,J) = 0.D0
 85     CONTINUE
 90   CONTINUE
C
C     COMPUTE CHEBYSHEV POLYNOMIAL COEFFICIENTS FOR X, Y, Z, DT
C
      DO 100 I = 1,N
        XT   = X(I)
        IF(XT.LT.XS) RETURN
        XT   = (2*XT-XPLUS)/XINT
        CALL TPOL(XT,POL,NC)
        DO 100 K = 1,NC
          PK = POL(K)
          ATLY(K)          = ATLY(K)     +   Y(I)  * PK
          DO 95 L = 1,NC
            ATA(K,L)       = ATA(K,L)    +   POL(L)    * PK
   95     CONTINUE    
  100 CONTINUE
C
C     INVERT NORMALS
C
      CALL SPIN(ATA,NC,NP,DET,IDEXP)
C
      DO 110 K=1,NC
        DO 105 L=1,NC
          ATAKL   =  ATA(K,L)
          CY(K)   =  CY(K)      + ATAKL * ATLY(L)
 105    CONTINUE
 110  CONTINUE
C
C     COMPUTE SATELLITE ORBIT AND CLOCK RESIDUALS
C
      RMSY = 0.D0
C
      DO 130 I = 1,N
      CYI = 0.D0
      XT   = X(I)
      IF(XT.LT.XS) RETURN
      XT   = (2*XT-XPLUS)/XINT
      CALL TPOL(XT,POL,NC)
c!    WRITE(*,*) 'IN CHBPOL XT,POL,NC',X(I),XT,POL,NC
C
      DO 120 K = 1,NC
        PK = POL(K)
        CYI       = CYI  +      CY(K)  * PK
c!      WRITE(*,*) 'IN CHBPOL K,CK,PK', K, CY(K),PK,CYI
  120 CONTINUE
C
      RESY        =    Y(I) - CYI
      RMSY = RMSY + RESY**2
c!    WRITE(*,*) 'IN CHBPOL', I, X(I), Y(I), CYI
  130 CONTINUE
        NDF=N-NC
      IF ( NDF .GT. 0 ) RMSY = DSQRT(RMSY/NDF)
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C ************************************************************** CHBXYZ
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE CHBXYZ ( TTAG, ISV, IARC, NDEG, TB, TE, CX, CY, CZ,
     &                    SVXYZ, SVVEL )
C
C     NAME            CHBXYZ
C
C     PURPOSE         COMPUTE SATELLITE POSITION AND VELOCITY
C                     FROM POLYNOMIAL COEFFICIENTS
C
C     PARAMETERS      DESCRIPTION
C
C      TTAG           GPS TIME TAG
C      NDEG           DEGREE OF POLYNOMIAL FOR ARC
C      TB             ARC START TIME
C      TE             ARC END TIME
C      CX             POLYNOMIAL COEFFICIENTS FOR X COORDINATE
C      CY             POLYNOMIAL COEFFICIENTS FOR Y COORDINATE
C      CZ             POLYNOMIAL COEFFICIENTS FOR Z COORDINATE
C      SVXYZ          SATELLITE XYZ COORDINATES
C      SVVEL          SATELLITE XYZ VELOCITIES
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER ISV,    IARC
      INTEGER NDEG(MAXSAT,MAXARC)
C
      REAL*8  TTAG
      REAL*8  TB(MAXSAT,MAXARC),     TE(MAXSAT,MAXARC)
      REAL*8  CX(MAXSAT,MAXARC,MAXDEG),  CY(MAXSAT,MAXARC,MAXDEG)
      REAL*8  CZ(MAXSAT,MAXARC,MAXDEG)
      REAL*8  SVXYZ(*),     SVVEL(*)
C
      INTEGER I,J
      REAL*8  TPLUS,  TINT,   TTAGI, TT
      REAL*8  POL(30)
      REAL*8  SVPOS(3,3)
C
      TPLUS = TB(ISV,IARC) + TE(ISV,IARC)
      TINT  = TE(ISV,IARC) - TB(ISV,IARC)
C
C     INITIALIZE SV COORDINATES FOR 3 EPOCHS
C
      DO 100 I=1,3
        DO 50 J=1,3
        SVPOS(I,J) = 0.D0
   50   CONTINUE  
  100 CONTINUE
C
C     COMPUTE SATELLITE POSITION AT 3 EPOCHS
C     ( AT TRANSMIT TIME, AND 1 SEC BEFORE AND AFTER )
C
      DO 150 I=1,3
        TTAGI = TTAG + I - 2
        TT   = (2*TTAGI-TPLUS)/TINT
        CALL TPOL(TT,POL,NDEG(ISV,IARC))
c!      WRITE(*,*) 'IN CHBXYZ TT,POL,NC',TT,POL,NDEG(ISV,IARC)
        DO 120 J = 1,NDEG(ISV,IARC)
        SVPOS(1,I)         = SVPOS(1,I)  +  CX(ISV,IARC,J)  * POL(J)
        SVPOS(2,I)         = SVPOS(2,I)  +  CY(ISV,IARC,J)  * POL(J)
        SVPOS(3,I)         = SVPOS(3,I)  +  CZ(ISV,IARC,J)  * POL(J)
c!      WRITE(*,*) 'IN CHBXYZ K,CK,PK', J,CX(ISV,IARC,J),POL(J),
c!   &                SVPOS(1,I)
  120   CONTINUE
  150 CONTINUE
C
      DO 200 I=1,3
         SVXYZ(I) = SVPOS(I,2)
         SVVEL(I) = ( SVPOS(I,3) - SVPOS(I,1) ) / 2.D0
  200 CONTINUE    
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C************************************************************** CHEBP
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE CHEBP (XE, X, Y, N, NDEG, CY, YE, RMSY)
C
C     NAME              CHEBP
C
C     PURPOSE   FIT CHEBYCHEV POLYNOMIAL TO TIME SERIES
C
C     PARAMETERS        DESCRIPTION
C
C        LPR            LOGICAL UNIT OF PRINTER
C          XE           INDEPENDENT VARIABLE AT ESTIMATION POINT
C          X            ARRAY OF INDEPENDENT VARIABLES
C          Y            ARRAY OF DEPENDENT VARIABLES
C          N            NUMBER OF VARIABLES
C          NDEG         DEGREE OF POLYNOMIAL
C          CY           POLYNOMIAL COEFFICIENTS
C          YE           ESTIMATED DEPENDANT VARIABLE
C          RMS          RMS OF RESIDUALS
C         
C          
C
C     CHEBYCHEV POLYNOMIAL FIT
C
      IMPLICIT NONE
C
      INCLUDE  'MAXDIM'
C
C     DIMENSIONING OF COORDINATE ARRAYS FOR APPROXIMATION
C
C
      REAL*8    X(*),      Y(*)
C
C     DIMENSIONING FOR CHEBYSHEW POLYNOMIAL COEFFICIENTS
C     ( MAXIMUM COEFFICIENTS MAXDEG )
C
      REAL*8    CY(*)
C
      INTEGER*4 N, NDEG
      REAL*8    XE, YE, RMSY
C
      INTEGER*4 NP,MAXC,NC,I,J,K,L,IDEXP,NDF
      REAL*8    X1,X2,XINT,XPLUS,XT,PK,DET,ATAKL,RESY
      REAL*8    ATA(MAXORD,MAXORD)
      REAL*8    ATLY(MAXORD)
      REAL*8    POL(MAXORD)
      REAL*8    CYI
C
c!    WRITE(LPR,*) 'ENTERING CHEBFIT',N,NDEG
      NP = MAXORD
      MAXC = MAXDEG
C
      X1   = X(1)
      X2   = X(N)
      IF(X2.LT.X1) RETURN
      XINT = X2-X1
      XPLUS= X2+X1
      NC   = MIN(MAXC,NDEG,NP)
      IF (NDEG .GT. N)
     &  WRITE(*,*) 'DEGREE OF POLYNOMIAL > NUMBER OF SAMPLES'
C
C     INITIALIZE
C
      DO 80 I = 1,NC
        CY(I)   = 0.D0
   80 CONTINUE
C
      DO 90 I=1,NP
        ATLY(I) = 0.D0
        DO 85 J=1,NP
          ATA(I,J) = 0.D0
 85     CONTINUE
 90   CONTINUE
C
C     COMPUTE CHEBYSHEV POLYNOMIAL COEFFICIENTS FOR X, Y, Z, DT
C
      DO 100 I = 1,N
        XT   = X(I)
        IF(XT.LT.X1) RETURN
        XT   = (2*XT-XPLUS)/XINT
        CALL TPOL(XT,POL,NC)
        DO 100 K = 1,NC
          PK = POL(K)
          ATLY(K)          = ATLY(K)     +   Y(I)  * PK
          DO 95 L = 1,NC
            ATA(K,L)       = ATA(K,L)    +   POL(L)    * PK
   95     CONTINUE    
  100 CONTINUE
C
C     INVERT NORMALS
C
      CALL SPIN(ATA,NC,NP,DET,IDEXP)
C
      DO 110 K=1,NC
        DO 105 L=1,NC
          ATAKL   =  ATA(K,L)
          CY(K)   =  CY(K)      + ATAKL * ATLY(L)
 105    CONTINUE
 110  CONTINUE
C
C     COMPUTE SATELLITE ORBIT AND CLOCK RESIDUALS
C
      RMSY = 0.D0
C
      DO 130 I = 1,N
      CYI = 0.D0
      XT   = X(I)
      IF(XT.LT.X1) RETURN
      XT   = (2*XT-XPLUS)/XINT
      CALL TPOL(XT,POL,NC)
C
      DO 120 K = 1,NC
        PK = POL(K)
        CYI       = CYI  +      CY(K)  * PK
  120 CONTINUE
C
      RESY        =    Y(I) - CYI
      RMSY = RMSY + RESY**2
  130 CONTINUE
        NDF=N-NC
      IF ( NDF .GT. 0 ) RMSY = DSQRT(RMSY/NDF)
C
      YE = 0.D0
      IF(XE.LT.X1) RETURN
      XE   = (2*XE-XPLUS)/XINT
      CALL TPOL(XE,POL,NC)
C
      DO 140 K = 1,NC
        PK = POL(K)
        YE        = YE  +       CY(K)  * PK
  140 CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** CHKCLK
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE CHKCLK (LPR,NEPSV,IEPSV,NEPTIM,EPHTIM,EPHTBL,EPHCLK)
C
C     PURPOSE:   LINEAR REGRESSION ON SATELLITE CLOCK OFFSETS
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE  'MAXDIM'
C
      INTEGER*4      LPR,NEPSV
      INTEGER*4      IEPSV(MAXSAT),        NEPTIM(MAXSAT)
      REAL*8         EPHTIM(MAXSAT,MAXEPH)
      REAL*8         EPHTBL(MAXKEP,MAXSAT,MAXEPH)
      REAL*8         EPHCLK(7,MAXSAT)
C
      INTEGER*4 IS,NCLK,IE
      REAL*8    HEALTH,SUMX,SUMY,SUMXX,SUMXY,SUMDR,SUMCLK
      REAL*8    REFTM,DT,CLKOF,CLKDR,SUMX2,DELTA,RESCLK,VFACT
C
      REFTM=0.D0
      DO 80 IS=1,NEPSV
        NCLK = 0
          HEALTH= 0.D0
        SUMX    = 0.D0
        SUMY    = 0.D0
        SUMXX = 0.D0
        SUMXY = 0.D0
        SUMDR = 0.D0
        SUMCLK = 0.D0
C
        DO 70 IE=1,NEPTIM(IS)
C
C         SET REFERENCE TIME TO BEGINNING OF DAY
C
          IF ( IE .EQ. 1 )
     &          REFTM = EPHTIM(IS,IE) - DMOD(EPHTIM(IS,IE),86400.D0)
C
          NCLK =  NCLK + 1
          DT      = EPHTIM(IS,IE) - REFTM
          CLKOF = EPHTBL(11,IS,IE)*1.D9
          CLKDR = EPHTBL(10,IS,IE)*1.D9
            HEALTH= HEALTH + EPHTBL(5,IS,IE)
C            IF ( EPHTBL(5,IS,IE) .NE. 0.D0 )
C     &            WRITE(*,1000) IEPSV(IS),EPHTIM(IS,IE)
C
C         IF ONLY ONE BROADCAST EPHEMERIS,
C         COMPUTE OFFSET FOR REFERENCE TIME AND STORE
C
          IF ( NEPTIM(IS) .EQ. 1 ) THEN
            EPHCLK(1,IS) = REFTM
            EPHCLK(2,IS) = NCLK
              EPHCLK(3,IS) = HEALTH
            EPHCLK(4,IS) = CLKOF + ( REFTM - EPHTIM(IS,IE) )*CLKDR
            EPHCLK(5,IS) = CLKDR
            EPHCLK(6,IS) = 0.D0
            EPHCLK(7,IS) = 0.D0
          END IF
C
          SUMDR = SUMDR + CLKDR
          SUMX  = SUMX + DT
          SUMY  = SUMY + CLKOF
          SUMXX = SUMXX + DT*DT
          SUMXY = SUMXY + DT*CLKOF
C
          SUMX2    = SUMX*SUMX
          DELTA    = NCLK*SUMXX - SUMX2
C
          IF ( DELTA .NE. 0.D0 ) THEN
            EPHCLK(1,IS) = REFTM
            EPHCLK(2,IS) = NCLK
              EPHCLK(3,IS) = HEALTH
            EPHCLK(4,IS) = ( SUMXX*SUMY - SUMX*SUMXY ) / DELTA
            EPHCLK(5,IS) = ( NCLK*SUMXY - SUMX*SUMY  ) / DELTA
            RESCLK         = CLKOF - ( EPHCLK(4,IS) + EPHCLK(5,IS)*DT )
            SUMCLK         = SUMCLK + RESCLK*RESCLK
            VFACT          = DSQRT (SUMCLK / NCLK )
            EPHCLK(6,IS) = VFACT*DSQRT(SUMXX / DELTA)
            EPHCLK(7,IS) = VFACT*DSQRT(NCLK / DELTA)
C           ADRIFT         = SUMDR / NCLK
          END IF
   70   CONTINUE
   80 CONTINUE
C
 1000 FORMAT (' SATELLITE PRN ',I2,' SET UNHEALTHY IN EPHEMERIS AT ',
     &          F10.1)
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C *************************************************************** CHSFX
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
        SUBROUTINE CHSFX( INAM, ONAM, SFX )
C
C       NAME            CHSFX
C
C       PURPOSE         CHANGE SUFFIX OF FILENAME
C
C       PARAMETERS      DESCRIPTION
C
C          INAM         NAME OF IMPUT FILE
C          ONAM         NAME OF OUTPUT FILE
C          SFX          SUFFIX OF OUTPUT FILE
C
C *********************************************************************
C
      IMPLICIT NONE
      INTEGER NCH, LCH, ISFX, IPOS, RCH
      CHARACTER  INAM*(*), ONAM*(*)
      CHARACTER  SFX*(*)
C
C GET FILENAME OF INPUT FILE
C
      CALL GETNAM ( INAM, ONAM, NCH )
C
C APPEND DESIRED SUFFIX
C
      CALL STRLIM(SFX,LCH,RCH)
c!    WRITE(*,*) 'LCH,NCH',LCH,NCH
      DO ISFX = LCH,RCH
         IPOS = NCH + ISFX-LCH+1
         ONAM(IPOS:IPOS) =  SFX(ISFX:ISFX)
      END DO
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** CLKFIT
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE CLKFIT ( TTAG,CLKOF,SUMLR,REFTM,OFFSET,DRIFT,
     &                        DRIFTRATE,SDOFF, SDRIFT,SDRIFTRATE,
     &                    NCLK, ICLKFIT )
C
C     PURPOSE:   SEQUENTIAL LINEAR REGRESSION TO COMPUTE
C            RECEIVER CLOCK OFFSET AND DRIFT
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C       TTAG            TIME OF COMPUTED CLOCK OFFSET
C       CLKOF   CLOCK OFFSET AT TTAG
C       SUMLR   SUMMATIONS USED IN LINEAR REGRESSION
C               (1) SUM OF TTAG
C               (2) SUM OF CLKOF
C               (3) SUM OF TTAG*TTAG
C               (4) SUM OF TTAG*CLKOF
C               (5) SUM OF TTAG*TTAG*CLKOF
C               (6) SUM OF TTAG*TTAG*TTAG
C               (7) SUM OF TTAG*TTAG*TTAG*TTAG
C               (8) SUM OF RES**2
C       REFTM   REFERENCE TIME OF CLOCK OFFSET
C       OFFSET  CLOCK OFFSET AT FIRST TTAG
C       DRIFT   CLOCK DRIFT
C       DRIFTRATE     CLOCK DRIFTRATE
C       SDOFF   STANDARD DEVIATION OF CLOCK OFFSET
C       SDRIFT  STANDARD DEVIATION OF CLOCK DRIFT
C       SDRIFTRATE STANDARD DEVIATION OF CLOCK DRIFTRATE
C       NCLK            NUMBER OF CLOCK ESTIMATES
C       ICLKFIT       DEGREE OF POLYNOMIAL (1 or 2)
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4      NCLK
     &              , ICLKFIT
      REAL*8         TTAG,      CLKOF
      REAL*8         OFFSET,    DRIFT
     &              , DRIFTRATE
      REAL*8         RESCLK
      REAL*8         SDOFF,     SDRIFT
     &            , SDRIFTRATE
      REAL*8         SUMLR(8),  REFTM
      REAL*8         VFACT
C
      REAL*8         SX1,SX2,SX3,SX4,SX5, DELTA,DT
C
      IF( NCLK .EQ. 0 ) REFTM=TTAG
      NCLK = NCLK + 1
      DT       = (TTAG - REFTM)/86400.D0
      SUMLR(1) = SUMLR(1) + DT
      SUMLR(2) = SUMLR(2) + CLKOF
      SUMLR(3) = SUMLR(3) + DT*DT
      SUMLR(4) = SUMLR(4) + DT*CLKOF
      SUMLR(5)=  SUMLR(5) + 0.5D0*DT*DT*CLKOF
      SUMLR(6) = SUMLR(6) + DT*DT*DT
      SUMLR(7) = SUMLR(7) + DT*DT*DT*DT
C
      IF( ICLKFIT .EQ. 1 ) THEN
      SX2      = SUMLR(1)*SUMLR(1)
      DELTA    = NCLK*SUMLR(3) - SX2
      ELSE
      SX1= 0.25D0*NCLK*SUMLR(3)*SUMLR(7)
      SX2= 0.25D0*SUMLR(3)*SUMLR(3)*SUMLR(3)
      SX3= 0.5D0*SUMLR(1)*SUMLR(3)*SUMLR(6)
      SX4= 0.25D0*SUMLR(7)*SUMLR(1)*SUMLR(1)
      SX5= 0.25D0*NCLK*SUMLR(6)*SUMLR(6)
      DELTA= SX1-SX2+SX3-SX4-SX5
      ENDIF
C
c!    WRITE(*,*) 'DELTA',DELTA
      IF ( DELTA .EQ. 0.D0 .OR.
     &     NCLK - ICLKFIT .LT. 1 ) THEN
        OFFSET   = CLKOF
      DRIFT    = 0.D0
      DRIFTRATE= 0.D0
      SDOFF=0.D0
      SDRIFT=0.D0
      SDRIFTRATE=0.D0
      ELSE
       IF ( ICLKFIT .EQ. 1 ) THEN
      OFFSET     = ( SUMLR(3)*SUMLR(2) - SUMLR(1)*SUMLR(4) ) / DELTA
      DRIFT      = ( NCLK    *SUMLR(4) - SUMLR(1)*SUMLR(2) ) / DELTA
      DRIFTRATE= 0.D0
       END IF
       IF ( ICLKFIT .EQ. 2 ) THEN
      OFFSET= (0.25D0*SUMLR(2)*SUMLR(3)*SUMLR(7)
     &         - 0.25D0*SUMLR(2)*SUMLR(6)*SUMLR(6)
     &         + 0.25D0*SUMLR(4)*SUMLR(3)*SUMLR(6)
     &         - 0.25D0*SUMLR(4)*SUMLR(1)*SUMLR(7)
     &         + 0.50D0*SUMLR(5)*SUMLR(1)*SUMLR(6)
     &         - 0.5D0*SUMLR(5)*SUMLR(3)*SUMLR(3)) / DELTA
      DRIFT= (0.25D0*SUMLR(2)*SUMLR(3)*SUMLR(6)
     &        - 0.25D0*SUMLR(2)*SUMLR(1)*SUMLR(7)
     &        + 0.25D0*SUMLR(4)*NCLK*SUMLR(7)
     &            - 0.25D0*SUMLR(4)*SUMLR(3)*SUMLR(3)
     &        + 0.50D0*SUMLR(5)*SUMLR(1)*SUMLR(3)
     &        - 0.50D0*SUMLR(5)*NCLK*SUMLR(6)) / DELTA
      DRIFTRATE= (0.5D0*SUMLR(2)*SUMLR(1)*SUMLR(6)
     &            - 0.5D0*SUMLR(2)*SUMLR(3)*SUMLR(3)
     &                + 0.5D0*SUMLR(4)*SUMLR(1)*SUMLR(3)
     &            - 0.5D0*SUMLR(4)*NCLK*SUMLR(6)
     &            + SUMLR(5)*NCLK*SUMLR(3)
     &            - SUMLR(5)*SUMLR(1)*SUMLR(1)) / DELTA
       END IF
       RESCLK    = CLKOF - ( OFFSET + DRIFT*DT )
     &              - 0.5D0*DRIFTRATE*DT*DT
       SUMLR(8) = SUMLR(8) + RESCLK*RESCLK
c!     WRITE(*,*) 'O/S,DR,RES',OFFSET,DRIFT,RESCLK
c!     WRITE(*,*) 'O/S,DR,DRR,RES',OFFSET,DRIFT,DRIFTRATE,RESCLK
C
       VFACT=DSQRT(SUMLR(8)/NCLK)
       IF ( ICLKFIT .EQ. 1 ) THEN
        SDOFF    = VFACT*DSQRT(SUMLR(3) / DELTA)
        SDRIFT = VFACT*DSQRT(NCLK / DELTA)
        SDRIFTRATE = 0.D0
       ENDIF
       IF ( ICLKFIT .EQ. 2 ) THEN
          SDOFF  = VFACT*DSQRT((0.25D0*SUMLR(3)*SUMLR(7)
     &                      - 0.25D0*SUMLR(6)*SUMLR(6))/DELTA)
        SDRIFT = VFACT*DSQRT((0.25D0*NCLK*SUMLR(7)
     &                      - 0.25D0*SUMLR(3)*SUMLR(3))/DELTA)
        SDRIFTRATE = VFACT*DSQRT((NCLK*SUMLR(3)
     &                      - SUMLR(1)*SUMLR(1))/DELTA)
C 
       ENDIF
c!    WRITE(*,*) 'VF,SDO,SDD,SDDR',VFACT,SDOFF,SDRIFT,SDRIFTRATE
C
       DRIFT=DRIFT/86400.D0
       DRIFTRATE=DRIFTRATE/86400.D0/86400.D0
       SDRIFT=SDRIFT/86400.D0
       SDRIFTRATE=SDRIFTRATE/86400.D0/86400.D0
      END IF
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** CLKJMP
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE CLKJMP (LPR, NSVO, ISVO, IFREQ, IOBTYP, IDIR, OBSINT,
     &                   C, TTAG, PR1, PR2, CP1, CP2, OBSBUF, 
     &                   IGPSWK,
     &                   NMSOFF, NMSJMP, NMSCPJ, NMSCLJ, CLKOFF,
     &                   ICORRTT, ICORRPR, ICORRCP )
C
C
C     PURPOSE: DETECT 1 MS CLOCK JUMPS IN TIME TAG OR OBSERVATIONS
C              AND APPLY TO RECEIVER CLOCK OFFSET
C
C     PARAMETER         DESRIPTION
C
C     NMSOFF            NUMBER OF MILLISECOND JUMP EVENTS IN TIMETAG
C     NMSJMP            NUMBER OF MILLISECOND JUMP EVENTS IN DATA
C     CLKOFF            RECEIVER CLOCK OFFSET CORRECTED FOR MILLIECOND JUMPS
C     NMSCPJ            NUMBER OF MILLISECOND JUMP EVENTS IN WIDELANE
C     ICORRTT           CURRENT TTAG MS CORRECTION
C     ICORRPR           CURRENT CODE MS CORRECTION
C     ICORRCP           CURRENT PHASE MS CORRECTION
C
C
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4  IGPSWK
      INTEGER*4  LPR, NSVO, IFREQ, IDIR, IOBTYP
      INTEGER*4  ISVO(*)
      INTEGER*4  NMSOFF,NMSJMP
      INTEGER*4  NMSCLJ, NMSCPJ, ICORRTT, ICORRPR, ICORRCP
      REAL*8     TTAG(*)
      REAL*8     PR1(*), PR2(*)
      REAL*8     CP1(*) , CP2(*)
      REAL*8     OBSBUF(6,*)
      REAL*8     OBSINT
      REAL*8     CLKOFF, C
C
C     LOCAL VARIABLES
C
      INTEGER*4  I, IPRN
      INTEGER*4  MSCOR
      REAL*8    F1,F2,AL1,AL2,AL3,F1S,F2S,F12S
      REAL*8    ONEMS,ONEUS,DTIME,DTIMEMIN
      REAL*8    DPRDT,DCPDT
      REAL*8    DPRCP,DMSCOR
      REAL*8    PR1M, PR2M
      REAL*8    CP1M, CP2M
      INTEGER*4 IXVOTES, MXVOTES, J
      INTEGER*4 PRMS(MAXOBS), CPMS(MAXOBS), WDMS(MAXOBS), VOTES(MAXOBS)
      LOGICAL   L1PR, L2PR, L3PR, L1CP, L2CP, L3CP
C MS jump flags and amounts
      LOGICAL   LTTJMP, LPRJMP, LCPJMP, LWDJMP, LOBSFIND
      INTEGER*4 NSVPR, NSVCP, NSVWD,
     &          NSVTSTWD, NSVTSTPR, NSVTSTCP
      INTEGER*4 NTTJMP, NPRJMP, NCPJMP, NWDJMP
      INTEGER*4 NPRJMP1, NCPJMP1, NWDJMP1
      INTEGER*4 NPRJMP2, NCPJMP2, NWDJMP2
C Corrected timetag
      REAL*8    TTAGC
C Treshold for code/phase doppler M/S
      REAL*8    DOPLMAX
      REAL*8 AL4, F1ION, F2ION
      DOPLMAX=2800.0D0
      F1      = 1575.42D+06
      F2      = 1227.60D+06
      AL1     = C/F1
      AL2     = C/F2
      AL3     = C/(F1-F2)
      F1S     = F1*F1
      F2S     = F2*F2
      F12S    = F1S - F2S
      ONEMS = C*1.D-3
      ONEUS = C*1.D-6
      NSVPR=0
      NPRJMP=0
      NCPJMP=0
      NWDJMP=0
      NSVWD=0
      NSVCP=0
      NSVTSTWD=0
      NSVTSTPR=0
      NSVTSTCP=0
      NPRJMP1=0
      NCPJMP1=0
      NWDJMP1=0
      NPRJMP2=0
      NCPJMP2=0
      NWDJMP2=0
C
C First check if ms jump in time tag
C
      DTIMEMIN=0.0D0
      DO I=1,NSVO
      TTAGC=TTAG(I)+ICORRTT*0.001D0+IGPSWK*604800.D0 
        IPRN=ISVO(I)
        IF (OBSBUF(1,IPRN) .NE. 0.0D0) THEN
          DTIME = (TTAGC - OBSBUF(2,IPRN))*IDIR
          IF (DTIMEMIN .EQ. 0 .OR.
     &        ( DTIME .GT. 0.D0 .AND. DTIMEMIN .GT. DTIME ) )
     &      DTIMEMIN  = DTIME
        END IF
      END DO
      NTTJMP = IDNINT((DTIMEMIN-IDNINT(DTIMEMIN/OBSINT)*OBSINT)*1.D3)
      NTTJMP = NTTJMP * IDIR
      LTTJMP = NTTJMP .NE. 0
C
C Now Check for ms jump in data
C
      DO I=1,NSVO
        IPRN=ISVO(I)
       CALL FREQ12( IPRN, F1, F2, F1S, F2S, F12S, F1ION, F2ION,
     &                   AL1, AL2, AL4, AL3, IFREQ )
      PR1M=PR1(I)*C
      PR2M=PR2(I)*C
      CP1M=CP1(I)*AL1
      CP2M=CP2(I)*AL2
      DPRDT=0.D0
      DCPDT=0.D0
      DPRCP=0.D0
C
C     SET OBSERVATION VALIDITY FLAG
C       
        L1PR=( PR1M .NE. 0.D0 )
        L2PR=( PR2M .NE. 0.D0 )
      L3PR=( L1PR .AND. L2PR )
        L1CP=( CP1M .NE. 0.D0 )
        L2CP=( CP2M .NE. 0.D0 )
      L3CP=( L1CP .AND. L2CP )
      LOBSFIND = ( IFREQ .EQ. 1 .AND. L1PR .AND.
     &                 ( IOBTYP .EQ. 1 .OR. L1CP ) ) .OR.
     &             ( IFREQ .EQ. 2 .AND. L2PR .AND. 
     &                 ( IOBTYP .EQ. 1 .OR. L2CP ) ) .OR.
     &             ( IFREQ .GE. 3 .AND. L3PR .AND. 
     &                 ( IOBTYP .EQ. 1 .OR. L3CP ) )
      PR1M=PR1M+ICORRPR*ONEMS
      PR2M=PR2M+ICORRPR*ONEMS
      CP1M=CP1M+ICORRCP*ONEMS
      CP2M=CP2M+ICORRCP*ONEMS
      TTAGC=TTAG(I)+ICORRTT*0.001D0+IGPSWK*604800.D0 
C
C       DETECT MILLISECOND OFFSET IN EPOCH TIME TAG
C
        IF ( LOBSFIND .AND. OBSBUF(1,IPRN) .NE. 0.0D0) THEN
          DTIME  = (TTAGC - OBSBUF(2,IPRN))*IDIR
C
c!        WRITE(*,*) IPRN,DTIME,OBSINT,MSOFF
C
C         DETECT MILLISECOND JUMP OVER OBSERVATION INTERVAL
C
C         COMPUTE CODE, PHASE and WIDELANE DIFF OVER TIME INTERVAL
C
C         DUAL FREQUENCY
C
          IF ( IFREQ .GE. 3 .AND. L3PR ) THEN   
          DPRDT  = (F1S*PR1M - F2S*PR2M) / F12S
     &             - (F1S*OBSBUF(3,IPRN) - F2S*OBSBUF(4,IPRN)) / F12S
C
C           CARRIER PHASE TOO
C
          IF ( IOBTYP .EQ. 2 .AND. L3CP ) THEN
              DCPDT = (F1S*CP1M - F2S*CP2M) / F12S
     &                - (F1S*OBSBUF(5,IPRN)*AL1 
     &                - F2S*OBSBUF(6,IPRN)*AL2)/F12S
              DPRCP = DPRDT - DCPDT
          END IF          
          END IF
C
C         SINGLE FREQUENCY L1
C      
          IF ( IFREQ .EQ. 1 .AND. L1PR ) THEN   
          DPRDT  = PR1M - OBSBUF(3,IPRN)
C
C           CARRIER PHASE TOO
C
          IF ( IOBTYP .EQ. 2 .AND. L1CP ) THEN
            DCPDT = CP1M-OBSBUF(5,IPRN)
              DPRCP = DPRDT - DCPDT
          END IF
          END IF
C
C         SINGLE FREQUENCY L2
C
          IF ( IFREQ .EQ. 2 .AND. L2PR ) THEN   
          DPRDT  = PR2M - OBSBUF(4,IPRN)
C
C           CARRIER PHASE TOO
C
          IF ( IOBTYP .EQ. 2 .AND. L2CP ) THEN
            DCPDT = CP2M-OBSBUF(6,IPRN) 
              DPRCP = DPRDT - DCPDT
          END IF
          END IF
C
C Perform WIDELANE tests only if DTIME below 5min
C
        IF( DTIME .LT. 300.D0 ) THEN
          NSVTSTWD=NSVTSTWD+1
C Check code/phase consistency MS jump
            MSCOR=IDNINT(DPRCP/ONEMS)
          DMSCOR=DABS(DPRCP-MSCOR*ONEMS)
            IF ( MSCOR .NE. 0 .AND. DMSCOR .LT. ONEUS ) THEN
            NWDJMP1=NWDJMP1+MSCOR
            NWDJMP2=NWDJMP2+MSCOR*MSCOR
            NSVWD=NSVWD+1
            WDMS(NSVWD)=MSCOR
          END IF
        END IF
C
C Perform CODE and PHASE tests only if DTIME is mininum found
C
        IF( DTIME .EQ. DTIMEMIN ) THEN
          NSVTSTPR=NSVTSTPR+1
C Check code MS jump
          IF ( DABS(DPRDT/DTIME) .GT. DOPLMAX ) THEN
              MSCOR=IDNINT(DPRDT/ONEMS)
            DMSCOR=DABS(DPRDT-MSCOR*ONEMS)
              IF ( MSCOR .NE. 0 .AND. DMSCOR .LT. ONEMS*.1D0 .AND.
     &             DMSCOR/DTIME .LT. DOPLMAX ) THEN
              NPRJMP1=NPRJMP1+MSCOR
              NPRJMP2=NPRJMP2+MSCOR*MSCOR
              NSVPR=NSVPR+1
              PRMS(NSVPR)=MSCOR
            END IF
          END IF
C Check phase MS jump
          NSVTSTCP=NSVTSTCP+1
          IF ( DABS(DCPDT/DTIME) .GT. DOPLMAX ) THEN
              MSCOR=IDNINT(DCPDT/ONEMS)
            DMSCOR=DABS(DCPDT-MSCOR*ONEMS)
              IF ( MSCOR .NE. 0 .AND. DMSCOR .LT. ONEMS*.1D0 .AND.
     &             DMSCOR/DTIME .LT. DOPLMAX ) THEN
              NCPJMP1=NCPJMP1+MSCOR
              NCPJMP2=NCPJMP2+MSCOR*MSCOR
              NSVCP=NSVCP+1
              CPMS(NSVCP)=MSCOR
            END IF
          END IF
        END IF
      END IF
      END DO
C
C Decide what to do with widelane MS jumps detected
C We must have at least 4 satellites tested and >80% of
C the satellites tested agree on the phase/code inconsistency
C 
      LWDJMP = .FALSE.
      IF( NSVWD .GT. 0 )
     & LWDJMP = NSVTSTWD .GT. 3 .AND. NSVWD .GT. 0.8D0 * NSVTSTWD .AND.
     &          NWDJMP1 .NE. 0 .AND. MOD(NWDJMP1,NSVWD) .EQ. 0 .AND. 
     &          DABS(DBLE(NWDJMP1)/DBLE(NSVWD)) .EQ.
     &                            DSQRT(DBLE(NWDJMP2)/DBLE(NSVWD))
      IF ( LWDJMP ) THEN
      NWDJMP1 = NWDJMP1/NSVWD
      NWDJMP = NWDJMP1
      ELSE IF( NSVTSTWD .GT. 3 .AND. NSVWD .GT. 0.8D0 * NSVTSTWD ) THEN
      IF( MOD(NWDJMP1,NSVWD) .NE. 0 ) THEN
        MXVOTES=0
        DO J=1,NSVWD
         VOTES(J)=0
         DO I=1,NSVWD
          IF( WDMS(I) .EQ. WDMS(J) ) VOTES(J)=VOTES(J)+1
         ENDDO
         IF( VOTES(J) .GT. MXVOTES ) THEN
          MXVOTES=VOTES(J)
          IXVOTES=J
         ENDIF
        ENDDO
        LWDJMP= MXVOTES .GT. 0.8*NSVWD .AND. MXVOTES .GT. 2
        IF( LWDJMP ) NWDJMP1=WDMS(IXVOTES)
        IF( LWDJMP ) NWDJMP =WDMS(IXVOTES)
      END IF
      ELSE 
        NWDJMP = 0
      END IF
C
C Decide what to do with code MS jumps detected
C We must have at least 4 satellites tested and >80% of
C the satellites tested agree on the code jump
C
      LPRJMP = .FALSE.
      IF( NSVPR .GT. 0 )
     & LPRJMP = NSVTSTPR .GT. 3 .AND. NSVPR .GT. 0.8D0 * NSVTSTPR .AND.
     &          NPRJMP1 .NE. 0 .AND. MOD(NPRJMP1,NSVPR) .EQ. 0 .AND.
     &          DABS(DBLE(NPRJMP1)/DBLE(NSVPR)) .EQ.
     &                            DSQRT(DBLE(NPRJMP2)/DBLE(NSVPR))
      IF ( LPRJMP ) THEN
        NPRJMP1 = NPRJMP1/NSVPR
        NPRJMP = NPRJMP1
      ELSE IF( NSVTSTPR .GT. 3 .AND. NSVPR .GT. 0.8D0 * NSVTSTPR ) THEN
      IF( MOD(NPRJMP1,NSVPR) .NE. 0 ) THEN
        MXVOTES=0
        DO J=1,NSVPR
         VOTES(J)=0
         DO I=1,NSVPR
          IF( PRMS(I) .EQ. PRMS(J) ) VOTES(J)=VOTES(J)+1
         ENDDO
         IF( VOTES(J) .GT. MXVOTES ) THEN
          MXVOTES=VOTES(J)
          IXVOTES=J
         ENDIF
        ENDDO
        LPRJMP= MXVOTES .GE. 4
        IF( LPRJMP ) NPRJMP1=PRMS(IXVOTES)
        IF( LPRJMP ) NPRJMP =PRMS(IXVOTES)
      END IF
      ELSE
        NPRJMP = 0
      END IF
C
C Decide what to do with phase MS jumps detected
C We must have at least 4 satellites tested and >80% of
C the satellites tested agree on the phase jump
C
      LCPJMP = .FALSE.
      IF( NSVCP .GT. 0 )
     & LCPJMP = NSVTSTCP .GT. 1 .AND. NSVCP .GT. 0.8D0 * NSVTSTCP .AND.
     &          NCPJMP1 .NE. 0 .AND. MOD(NCPJMP1,NSVCP) .EQ. 0 .AND.
     &          DABS(DBLE(NCPJMP1)/DBLE(NSVCP)) .EQ.
     &                            DSQRT(DBLE(NCPJMP2)/DBLE(NSVCP))
      IF ( LCPJMP ) THEN
        NCPJMP1 = NCPJMP1/NSVCP
        NCPJMP = NCPJMP1
      ELSE IF( NSVTSTCP .GT. 1 .AND. NSVCP .GT. 0.8D0 * NSVTSTCP ) THEN
      IF( MOD(NCPJMP1,NSVCP) .NE. 0 ) THEN
        MXVOTES=0
        DO J=1,NSVCP
         VOTES(J)=0
         DO I=1,NSVCP
          IF( CPMS(I) .EQ. CPMS(J) ) VOTES(J)=VOTES(J)+1
         ENDDO
         IF( VOTES(J) .GT. MXVOTES ) THEN
          MXVOTES=VOTES(J)
          IXVOTES=J
         ENDIF
        ENDDO
        LCPJMP= MXVOTES .GT. 0.8*NSVCP .AND. MXVOTES .GT. 2
        IF( LCPJMP ) NPRJMP1=CPMS(IXVOTES)
        IF( LCPJMP ) NPRJMP =CPMS(IXVOTES)
      END IF
      ELSE
        NCPJMP = 0
      ENDIF
C
C CORRECT CODE/PHASE INCONSISTENCY
C only if all tested jumps agree
C
      IF ( LWDJMP .AND. (LPRJMP .OR. LCPJMP) .AND.
     &     NWDJMP .EQ. NPRJMP-NCPJMP ) THEN
        ICORRCP=ICORRCP+NWDJMP
      NMSCPJ=NMSCPJ+1
      END IF
C
C CORRECT TIMESTAMP/DATA INCONSISTENCY
C Case: timestamp  and code jumps simultaneously
C       Always correct TIMESTAMP 
C       If CODE and TIMESTAMP jumps agree correct code and phase
C       Note that if all goes well, code/phase are consistent by now
C
      IF ( LTTJMP .AND. LPRJMP ) THEN
      ICORRTT=ICORRTT-NTTJMP
      NMSOFF=NMSOFF+1
      IF ( NTTJMP .EQ. NPRJMP ) THEN
        NMSJMP=NMSJMP+1
        ICORRPR=ICORRPR-NTTJMP
        ICORRCP=ICORRCP-NTTJMP
C -------------------------------------------------
C Have yet to find this case where the size of jumps differ
C and figure the signs
C     ELSE 
C       ICORRPR=ICORRPR-(NTTJMP-NPRJMP)
C       ICORRCP=ICORRCP-(NTTJMP-NPRJMP)
C       CLKOFF = (NPRJMP-NTTJMP)*ONEMS
C -------------------------------------------------
      ENDIF
C
C IMPOSE 1MS JUMPS WHEN JUMP IN TIMESTAMP ONLY
C
      ELSE IF( LTTJMP .AND. .NOT. ( LPRJMP .OR. LCPJMP ) ) THEN
       ICORRTT=ICORRTT-NTTJMP
       ICORRPR=ICORRPR-NTTJMP
       ICORRCP=ICORRCP-NTTJMP
       NMSJMP=NMSJMP+1
       NMSCLJ=NMSCLJ+1
       CLKOFF=CLKOFF+(NTTJMP)*ONEMS
C
C CORRECT DATA JUMPS THROUGH THE CLOCK PARAMETER OR DATA
C Case: timestamp not jump but code jump
C If CODE, PHASE and WIDELANE agree setup a CLOCK jump
C Note that if all goes well, code/phase are consistent by now
C
      ELSE IF( LPRJMP .AND.
     &         ( ( LCPJMP .AND. NPRJMP .EQ. NCPJMP ) .OR.
     &           ( LWDJMP .AND. NPRJMP .EQ. NWDJMP ) ) ) THEN
        NMSCLJ=NMSCLJ+1
      CLKOFF = CLKOFF-(NPRJMP)*ONEMS
      END IF
C
C Correct data if required
C 
      IF( ICORRTT .NE. 0 .OR. ICORRPR .NE. 0 .OR.
     &    ICORRCP .NE. 0 ) THEN
       DO I=1,NSVO
        IPRN=ISVO(I)
        CALL FREQ12( IPRN, F1, F2, F1S, F2S, F12S, F1ION, F2ION,
     &                   AL1, AL2, AL3, AL3, IFREQ )
C
C     SET OBSERVATION VALIDITY FLAG
C       
        L1PR=( PR1(I) .NE. 0.D0 )
        L2PR=( PR2(I) .NE. 0.D0 )
      L3PR=( L1PR .AND. L2PR )
        L1CP=( CP1(I) .NE. 0.D0 )
        L2CP=( CP2(I) .NE. 0.D0 )
      L3CP=( L1CP .AND. L2CP )
C
      TTAG(I)=TTAG(I)+ICORRTT*0.001D0
C
      IF ( IFREQ .GE. 3 .AND. L3PR ) THEN       
        PR1(I)=PR1(I)+ICORRPR*ONEMS/C
          PR2(I)=PR2(I)+ICORRPR*ONEMS/C
        DPRDT  = (F1S*PR1(I)*C - F2S*PR2(I)*C) / F12S
     &             - (F1S*OBSBUF(3,IPRN) - F2S*OBSBUF(4,IPRN)) / F12S
        IF ( IOBTYP .EQ. 2 .AND. L3CP ) THEN
            CP1(I)=CP1(I)+ICORRCP*ONEMS/AL1
          CP2(I)=CP2(I)+ICORRCP*ONEMS/AL2
            DCPDT = (F1S*CP1(I)*AL1 - F2S*CP2(I)*AL2) / F12S
     &                - (F1S*OBSBUF(5,IPRN)*AL1 
     &                - F2S*OBSBUF(6,IPRN)*AL2)/F12S
        END IF
        END IF
        IF ( IFREQ .EQ. 1 .AND. L1PR ) THEN     
        PR1(I)=PR1(I)+ICORRPR*ONEMS/C
        DPRDT  = PR1(I)*C - OBSBUF(3,IPRN)
        IF ( IOBTYP .EQ. 2 .AND. L1CP ) THEN
            CP1(I)=CP1(I)+ICORRCP*ONEMS/AL1
          DCPDT = CP1(I)*AL1-OBSBUF(5,IPRN) 
        END IF
        END IF
        IF ( IFREQ .EQ. 2 .AND. L2PR ) THEN     
        PR2(I)=PR2(I)+ICORRPR*ONEMS/C
        DPRDT  = PR2(I)*C - OBSBUF(4,IPRN)
        IF ( IOBTYP .EQ. 2 .AND. L2CP ) THEN
            CP2(I)=CP2(I)+ICORRCP*ONEMS/AL2
          DCPDT = CP2(I)*AL2-OBSBUF(6,IPRN) 
        END IF
        END IF
       END DO
      END IF
C
C MANAGE THE OBSERVATION BUFFERS
C
      IF( (NSVO .GT. 3 .AND. 
     &     ( DTIMEMIN .EQ. 0.0D0 .OR. DTIMEMIN .GT. 300.D0 ) ) .OR.
     &    ( NSVTSTPR .GT. 3 ) ) THEN
       DO I=1,NSVO
         IPRN=ISVO(I)
         L1PR=( PR1(I) .NE. 0.D0 )
         L2PR=( PR2(I) .NE. 0.D0 )
       L3PR=( L1PR .AND. L2PR )
         L1CP=( CP1(I) .NE. 0.D0 )
         L2CP=( CP2(I) .NE. 0.D0 )
       L3CP=( L1CP .AND. L2CP )
       LOBSFIND = ( IFREQ .EQ. 1 .AND. L1PR .AND.
     &                 ( IOBTYP .EQ. 1 .OR. L1CP ) ) .OR.
     &             ( IFREQ .EQ. 2 .AND. L2PR .AND. 
     &                 ( IOBTYP .EQ. 1 .OR. L2CP ) ) .OR.
     &             ( IFREQ .GE. 3 .AND. L3PR .AND. 
     &                 ( IOBTYP .EQ. 1 .OR. L3CP ) )
       IF( LOBSFIND ) THEN
         OBSBUF(1,IPRN)=IPRN
         OBSBUF(2,IPRN)=TTAG(I)+IGPSWK*604800.D0
           OBSBUF(3,IPRN)=PR1(I)*C
           OBSBUF(4,IPRN)=PR2(I)*C
           OBSBUF(5,IPRN)=CP1(I)
           OBSBUF(6,IPRN)=CP2(I)
         END IF
       END DO
      END IF
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** CLKSORT
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE CLKSORT ( LUCLK, CLKFILE, ILUCLK, LLUCLK, NSVCLK,
     &                      WSBCOR, PSBCOR,
     &                      ISVCLK, LTSVCLK, PRDC, IERR, IEND, INTCLK, 
     &                      YAWMODEL,
     &                      NBDAY, IPC  )
C
C     NAME       :  CLKSORT
C
C     PURPOSE    :  READ CLOCK FILE, SORT BY SATELLITE
C                   AND STORE IN TEMPORARY  FILES
C
C     PARAMETERS        DESCRIPTION
C
C     LUCLK             LOGICAL UNIT OF CLOCK FILE
C     CLKFILE           NAME OF CLOCK FILE
C     ILUCLK            INITIAL LU NUMBER OF SATELLITE CLOCK FILES
C     LLUCLK            ARRAY OF LU FOR SATELLITE CLOCK FILES
C     NSVCLK            NUMBER OF SATELLITES WITH PRECISE CLOCKS
C     ISVCLK            PRN'S OF SATELLITES WITH PRECISE CLOCKS
C     LTSVCLK           LAST TIME TAG WITH PRECISE SATELLITE CLOCK
C
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      CHARACTER*80  CLKFILE(*)
      INTEGER*4 YAWMODEL
      INTEGER*4 LUCLK,ILUCLK,NSVCLK,IERR,IEND,INTCLK,NBDAY,IPC
      INTEGER*4 LLUCLK(*)
      INTEGER*4 ISVCLK(*)
      INTEGER*4 LTSVCLK(*)
      REAL*8    WSBCOR(*),PSBCOR(*)
C
      CHARACTER*80  FNAME
      CHARACTER*240  RECORD
      CHARACTER*5   IEXT
      CHARACTER*2   PRNID
      CHARACTER*2   CLKTYP
      CHARACTER*4   CLKNAM
      INTEGER*4 ID,IOS,ICLKFMT,IYEAR,IMTH,IDAY,IHR,IMIN
      INTEGER*4 NECLK,IEPRN,JULD,IGPSWK,IWKDAY,IGPSWKF
      INTEGER*4 LTTAG,NDTTAG,IODE,IPRN,ITTAG
      REAL*8    SEC,CLKEST,CLKRMS,TTAG,DTTAG
     &         ,WLPERIOD,L1PERIOD,L2PERIOD,P1B,P2B
      REAL*8    PSB, PSBRMS, WSB, WSBRMS, PRDC(10,*)
      LOGICAL*4 CLKAMB
      INTEGER*4 IODA,IODASAV(MAXSAT)
      REAL*8    OUTYAW,DELTAYAW,FULLYAW,YAWRATE,PI
      DATA IODA,DELTAYAW,FULLYAW,YAWRATE/0, 0.D0, 0.D0, 0.D0/
      DATA IODASAV/MAXSAT*-1/
      DATA      PSB, PSBRMS, WSB, WSBRMS /4*0.0D0/
C
      DATA LTTAG, NDTTAG, DTTAG /0,0,0.D0/
C
      WLPERIOD=1.d0/ 34.d0/10.23d6
      L1PERIOD=1.d0/154.d0/10.23d6
      L2PERIOD=1.d0/120.d0/10.23d6
      IERR  = 0
      IEND  = 0
      NSVCLK = 0
C
      PI=2*DACOS(0.D0)
      DO ID=1,NBDAY
        OPEN  ( LUCLK, FILE=CLKFILE(ID), STATUS='OLD',IOSTAT=IOS )
C
C       DETERMINE SATELLITE CLOCK FORMAT AND INITIAL EPOCH
C
        CALL HDCLX ( LUCLK, INTCLK, ICLKFMT )
        READ(LUCLK,'(A240)',ERR=45,END=600) RECORD
        BACKSPACE(LUCLK)
        IF (ICLKFMT .EQ. 5) THEN
          READ(RECORD,1101) IEPRN,IYEAR,IMTH,IDAY,IHR,IMIN, 
     &                      SEC, CLKEST, CLKRMS,
     &                      PSB, PSBRMS, WSB, WSBRMS, IODA
        ELSE
          IF( RECORD(1:2).EQ.'WL') THEN   
51          READ(RECORD,'(4X,I2,2X,I4,4I3,F10.6,6X,E13.6)')
     &      NECLK,IYEAR,IMTH,IDAY,IHR,IMIN,SEC,CLKRMS       
            IF(PRDC(9,NECLK).EQ.0.D0) 
     &      PRDC(9,NECLK) = CLKRMS*299792458.D0*WLPERIOD
            READ(LUCLK,'(A240)',ERR=45,END=600) RECORD
            IF (RECORD(1:2).EQ.'WL') GO TO 51
            READ(LUCLK,'(A240)',ERR=45,END=600) RECORD
            READ(LUCLK,'(A240)',ERR=45,END=600) RECORD
            BACKSPACE(LUCLK)
          ENDIF
          READ(RECORD,1050,ERR=1051)
     &                      CLKTYP,CLKNAM,IYEAR,IMTH,IDAY,IHR,IMIN, 
     &                      SEC, NECLK, CLKEST, CLKRMS
     &                     , PSB, PSBRMS, WSB, WSBRMS
1051      CONTINUE
        END IF
C
        CALL GPSDC ( JULD,IYEAR,IMTH,IDAY,IGPSWK,IWKDAY,2 )
        CALL TOWHMS( IWKDAY, TTAG, IHR, IMIN, SEC, 1 )
C 
C       INITIALIZE SOME VARIABLES AT FIRST EPOCH
C
        IF ( ID .EQ. 1 ) THEN 
          IGPSWKF= IGPSWK
          LTTAG = IDNINT(TTAG+IGPSWK*604800)
          DTTAG=0.D0
          NDTTAG=0          
        END IF
C
C       READ SATELLITE CLOCK FILE AND SORT 
C
   45   CONTINUE
   50   CONTINUE
        IODE = 0
        READ(LUCLK,'(A240)',ERR=45,END=600) RECORD
        IF (ICLKFMT .EQ. 5) THEN
          IF ( RECORD(1:5).NE.'c sat' ) GO TO 50
          READ(RECORD,1101) IEPRN,IYEAR,IMTH,IDAY,IHR,IMIN,SEC,
     &                      CLKEST, CLKRMS,
     &                      PSB, PSBRMS, WSB, WSBRMS, IODA
          READ(RECORD(125:240),*) DELTAYAW,FULLYAW,YAWRATE
          PSB=1.D-9*PSB
          PSBRMS=1.D-9*PSBRMS
          WSB=1.D-9*WSB
          WSBRMS=1.D-9*WSBRMS
          IF(YAWMODEL.NE.0.OR.FULLYAW.NE.0.D0.OR.
     &        DELTAYAW.NE.0.D0.OR.YAWRATE.NE.0.D0) THEN
            IF(YAWMODEL.EQ.0 ) YAWMODEL=1
            OUTYAW=DELTAYAW
          ELSE
            OUTYAW=-999.D0/PI
          ENDIF
          IF(IODASAV(IEPRN).EQ.-1) IODASAV(IEPRN)=IODA
          CLKAMB=IODASAV(IEPRN).NE.IODA
          IODASAV(IEPRN)=IODA
        ELSE
          IF ( RECORD(1:4).NE.'AS G'.AND.RECORD(1:4).NE.'AS R'
     &    .AND.RECORD(1:4).NE.'AS E'.AND.RECORD(1:4).NE.'AS C') GO TO 50
          READ(RECORD,1050,ERR=1052)
     &                     CLKTYP,CLKNAM,IYEAR,IMTH,IDAY,IHR,IMIN, 
     &                     SEC,NECLK,CLKEST,CLKRMS
     &                     , PSB, PSBRMS, WSB, WSBRMS
1052      CONTINUE
          READ(CLKNAM,'(1X,I2.2)') IEPRN
          IF(CLKNAM(1:1).EQ.'R') IEPRN=IEPRN+32
          IF(CLKNAM(1:1).EQ.'E') IEPRN=IEPRN+64
          IF(CLKNAM(1:1).EQ.'C') IEPRN=IEPRN+100
        END IF
c!      WRITE(*,1000) IEPRN, IYEAR, 
c!   &                IMTH, IDAY, IHR, IMIN, SEC, CLKEST, CLKRMS
C
C       PROCESS THIS EPOCH PRN
C
        DO IPRN=1,NSVCLK
        IF ( IEPRN .EQ. ISVCLK(IPRN) ) GO TO 200
        END DO
C
C       UPDATE PRN LIST
C
        NSVCLK = NSVCLK + 1
        LLUCLK(NSVCLK) = ILUCLK + NSVCLK
        ISVCLK(NSVCLK) = IEPRN
        WRITE(IEXT,'(".P",I3.3)') ISVCLK(NSVCLK)
C
C       OPEN NEW SATELLITE FILE
C
        CALL CHSFX ( CLKFILE(1), FNAME, IEXT )
c!      WRITE(*,*) 'OPENING FILE ',FNAME,' UNIT ',LLUCLK(NSVCLK),NSVCLK
        OPEN (LLUCLK(NSVCLK),FILE=FNAME,STATUS='UNKNOWN',ERR=160)
        CLOSE ( LLUCLK(NSVCLK), STATUS='DELETE' )
        OPEN ( LLUCLK(NSVCLK),FILE=FNAME,STATUS='NEW',ERR=160)
        GO TO 170
  160   CONTINUE
        IERR = 1
        GO TO 600
  170   CONTINUE
        IPRN = NSVCLK
C SET WL LEVELING VALUE
        P1B=-WSB*60D0/77D0+PSB*17D0/77D0
        P2B=-WSB*77D0/60D0-PSB*17D0/60D0
        WSBCOR(IPRN)=
     &      -((77D0)*INT(P1B/L1PERIOD+SIGN(0.5D0,P1B))*L1PERIOD+
     &        (60D0)*INT(P2B/L2PERIOD+SIGN(0.5D0,P2B))*L2PERIOD)/
     &       (77D0+60D0)
        PSBCOR(IPRN)=
     &     -(-(77D0**2)*INT(P1B/L1PERIOD+SIGN(0.5D0,P1B))*L1PERIOD+
     &        (60D0**2)*INT(P2B/L2PERIOD+SIGN(0.5D0,P2B))*L2PERIOD)/
     &                                        ((77D0**2)-(60D0**2))
C INITIALIZE WSB AVERAGING
        WSBCOR(IPRN)=WSB
        PSBCOR(IPRN)=1.D0
C
C       WRITE CLOCK ESTIMATE IN APPROPRIATE SATELLITE FILE
C
  200   CONTINUE
        CALL GPSDC ( JULD,IYEAR,IMTH,IDAY,IGPSWK,IWKDAY,2 )
        CALL TOWHMS( IWKDAY, TTAG, IHR, IMIN, SEC, 1 )
C
C       CORRECT  FOR THE WEEK CROSS OVERs
C
        TTAG= TTAG + IGPSWK* 604800.d0
        ITTAG = IDNINT(TTAG)
        LTSVCLK(LLUCLK(IPRN))=ITTAG
C RESET WL LEVELING WHEN CHANGE EXCEEDS 1.5 CYCLES
C ACCUMULATE WSB AVERAGE, CHECKING FOR RESETS
        WRITE(LLUCLK(IPRN),*) ITTAG, CLKEST, CLKRMS,     
     &                        PSB  , PSBRMS, WSB   , WSBRMS, IODE
     &                       ,CLKAMB,OUTYAW*PI
 250    CONTINUE
C
C       PROCESS NEXT EPOCH
C
        IF ( ITTAG .NE. LTTAG ) THEN
          NDTTAG=NDTTAG+1
          DTTAG=DTTAG+ITTAG-LTTAG
        LTTAG=ITTAG
        END IF
        GO TO 50
C
C       REACHED END OF FILE
C  
  600   CONTINUE
        CLOSE (LUCLK)
      END DO
      INTCLK=INT(DTTAG/NDTTAG)    
      IF(INTCLK.GT.20) INTCLK= INT((INTCLK+1)/30)*30
c!    WRITE(*,*) 'INTCLK',INTCLK
      IEND = 1
C
C     REWIND ALL FILES
C
      DO IPRN=1,NSVCLK
        IF ( IPC .GE. 2 )
     &  WRITE(*,*) '    GPSPACE - PROCESSED PRECISE CLOCKS FOR PRN ',
     &       ISVCLK(IPRN),PSBCOR(IPRN),WSBCOR(IPRN),PRDC(9,ISVCLK(IPRN))
      REWIND(LLUCLK(IPRN))
      END DO
      RETURN
C
C     FORMAT STATEMENTS
C 
  190 FORMAT(I12,10I10)
 1000 FORMAT (9X,I2.2,1X,I4,1X,4(I2.2,1X),F8.4,1X,I6,1X,2F15.12,3F10.3)
 1050 FORMAT (A2,1X,A4,1X,I4,4I3,F10.6,I3,2X,6(1X,E19.12))
 1101 FORMAT(9X,I2.2,1X,I4,1X,4(I2.2,1X),F8.4,2F17.13,10X,4F9.4,1X,Z2)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C***************************************************************** CLKUP
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE CLKUP ( TTAG, CLKOF, CLKBUF, CLKTIM, REFTM, OFFSET,
     &                    DRIFT, SDOFF, SDRIFT, NCLK )
C
C     PURPOSE:   SEQUENTIAL LINEAR REGRESSION TO COMPUTE
C            RECEIVER CLOCK OFFSET AND DRIFT USING FIFO
C                BUFFER OF LAST NCLK CLOCK ESTIMATES
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C       TTAG            TIME OF COMPUTED CLOCK OFFSET
C       CLKOF   CLOCK OFFSET AT TTAG
C         CLKBUF        BUFFER CONTAINING NCLK ESTIMATES
C         CLKTIM        BUFFER CONTAINING TIME OF CLK ESTIMATES
C       REFTM   REFERENCE TIME OF UPDATED CLOCK OFFSET
C       OFFSET  CLOCK OFFSET AT REFERENCE TIME
C       DRIFT   CLOCK DRIFT
C       SDOFF   STANDARD DEVIATION OF CLOCK OFFSET
C       SDRIFT  STANDARD DEVIATION OF CLOCK DRIFT
C       NCLK            NUMBER OF CLOCK ESTIMATES
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE        'MAXDIM'
C
      INTEGER*4      NCLK
      REAL*8         TTAG,      CLKOF
      REAL*8         OFFSET,    DRIFT
      REAL*8         SDOFF,     SDRIFT
      REAL*8         REFTM,     CLKBUF(10),  CLKTIM(10)
C
      INTEGER*4      IPCLK,     NCLKBUF,   I
      REAL*8         SUMCLK,    RESCLK,    RESCLK2
      REAL*8         SUMDT,     SUMDT2,    SUMDTC
      REAL*8         SX2,       DELTA,     DT
      REAL*8         VFACT
C
      NCLK = NCLK + 1
      IPCLK = MOD(NCLK-1,MAXCLK) + 1
      CLKTIM(IPCLK) = TTAG
      CLKBUF(IPCLK) = CLKOF
      NCLKBUF = MIN(NCLK,MAXCLK)
      REFTM = TTAG
      SUMDT=0.D0
      SUMDT2=0.D0
      SUMDTC=0.D0
      SUMCLK=0.D0
      RESCLK2=0.D0
      DELTA=0.D0
C
      DO 100 I=1,NCLKBUF
c!      write(*,*) i,clktim(i),clkbuf(i)
        DT     = CLKTIM(I) - REFTM
        SUMCLK = SUMCLK + CLKBUF(I)
        SUMDT  = SUMDT + DT
        SUMDT2 = SUMDT2 + DT*DT
        SUMDTC = SUMDTC + DT*CLKBUF(I)
C
        SX2      = SUMDT*SUMDT
        DELTA    = NCLKBUF*SUMDT2 - SX2
 100  CONTINUE  
C
      IF ( DELTA .NE. 0.D0 ) THEN
      OFFSET     = ( SUMDT2*SUMCLK - SUMDT*SUMDTC ) / DELTA
      DRIFT      = ( NCLKBUF    *SUMDTC - SUMDT*SUMCLK ) / DELTA
      END IF
C
      IF ( NCLKBUF .GT. 2 ) THEN
        DO 200 I=1,NCLKBUF
          DT      = CLKTIM(I) - REFTM
          RESCLK  = CLKBUF(I) - ( OFFSET + DRIFT*DT )
        RESCLK2 = RESCLK2 + RESCLK*RESCLK
 200    CONTINUE  
        VFACT    = DSQRT (RESCLK2 / NCLKBUF )
        SDOFF   = VFACT*DSQRT(SUMDT2 / DELTA)
        SDRIFT  = VFACT*DSQRT(NCLKBUF / DELTA)
      END IF
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** DATUM
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE DATUM(LUI,LUO,DTM,IDTM)
C
C     NAME:      DATUM
C
C     PURPOSE:   DEFINE THE DATUM PARAMETERS
C
C      PARAMETERS
C
C                       DTM(1) SEMI-MAJOR AXIS OF REFERENCE
C                              ELLIPSOID (METRES)
C                       DTM(2) ECCENTRICITY OF REFERENCE
C                              ELLIPSOID
C                       DTM(3) X TRANSLATION COMPONENT
C                              (METRES)
C                       DTM(4) Y TRANSLATION COMPONENT
C                              (METRES)
C                       DTM(5) Z TRANSLATION COMPONENT
C                              (METRES)
C                       DTM(6) GRAVITATIONAL CONSTANT
C                              (M**3/SEC**2)
C                       DTM(7) ANGULAR VELOCITY OF THE EARTH
C                              (RAD/SEC)
C
C
C                I       IDTM = 0   USE WGS 84 VALUES
C                     = 1   USER DEFINED DATUM PARAMETERS
C
C
C**********************************************************************
*
C
      IMPLICIT NONE
C
      INTEGER*4 LUI,LUO,IDTM
      REAL*8    DTM(7)
C
      REAL*8    BDVDA
C
 1    CONTINUE
      IF(IDTM.NE.0) GO TO 3
C
C --------------------------------------------------------------------
C         WGS-84 DATUM PARAMETERS
C --------------------------------------------------------------------
C
      DTM(1) = 6378137.0D0
      DTM(2) = 8.18191908426D-2
      DTM(3) = 0.D0
      DTM(4) = 0.D0
      DTM(5) = 0.D0
      GO TO 4
 3    CONTINUE
C
C --------------------------------------------------------------------
C         IF YOU ARE NOT USING THE WGS-84 DEFINE YOUR PARAMETERS
C --------------------------------------------------------------------
C
      WRITE(LUO,10000)
      WRITE(LUO,10010)
      READ(LUI,*) DTM(1)
      WRITE(LUO,10020)
      READ(LUI,*) DTM(2)
      WRITE(LUO,10030)
      READ(LUI,*) DTM(3), DTM(4), DTM(5)
      BDVDA = DTM(2) / DTM(1)
      DTM(2) = DSQRT ( (1.D0 + BDVDA) * (1.D0 - BDVDA) )
 4    CONTINUE
      DTM(6) = 398600.5D+9
      DTM(7) = .000072921151467D+0
      RETURN
C----------------------------------------------------------------------
C               FORMAT STATEMENTS
C----------------------------------------------------------------------
C
10000 FORMAT( 'INPUT DATUM PARAMETERS:' )
10010 FORMAT( 'ENTER SEMI-MAJOR AXIS OF REFERENCE ELLIPSOID (M) _' )
10020 FORMAT( 'ENTER ECCENTRICITY OF REFERENCE ELLIPSOID        _' )
10030 FORMAT( 'ENTER X, Y, AND Z TRANSLATION COMPONENTS (M)     _' )
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C ************************************************************** DCNAME
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE DCNAME ( LU, LUO, LPR, LUCLK, IDC, NAMCLK,
     &                    IYEAR, IMTH, IDAY, NMID, IERR, LNG )
C
C     NAME:      DCNAME
C
C     PURPOSE:   ASSIGN DIFFERENTIAL CORRECTION
C                FILE NAMES TO LOGICAL UNITS
C
C     PARAMETERS        DESCRIPTION
C
C        LU             LOGICAL UNIT OF SCREEN INPUT
C        LUO            LOGICAL UNIT OF SCREEN OUTPUT
C        LUCLK  LOGICAL UNIT OF INPUT PRECISE CLOCK FILE
C        NAMCLK DIFFERENTIAL CORRECTION FILE NAME
C          IYEAR        YEAR OF OBSERVATIONS
C          IMTH         MONTH OF OBSERVATIONS
C          IDAY         DAY OF OBSERVATIONS
C          NMID         MIDNIGHT CROSSING FLAG
C
      IMPLICIT NONE
C
      INTEGER*4 LU, LUO, LPR, LUCLK, IDC,
     &          IYEAR, IMTH, IDAY, NMID, IERR, LNG
      CHARACTER*80  NAMCLK(*)
C
      INTEGER*4 IYOBS,IMOBS,IDOBS,IMID,IDOY,IWKOBS,IDWKOBS,
     &          IOS,INTCLK,ICLKFMT, IYCOR, IMCOR, IDCOR, IHRCOR,
     &          IMINCOR,NECLK,IDUM,IWKCOR,IDATEC,NERR,IDATEO
      INTEGER*4 ISEC
      REAL*8    SECCOR, CLKOS, CLKSD
      CHARACTER*2 CLKTYP
      CHARACTER*4 CLKNAM
C
      IDATEC=0
      IERR=0
      NERR=3
      IYOBS=IYEAR
      IMOBS=IMTH
      IDOBS=IDAY
C
C     READ CLOCK FILES AND VALIDATE DATES
C
      DO IMID=1,NMID
  100   CONTINUE
        CALL GPSDC ( IDOY, IYOBS, IMOBS, IDOBS, IWKOBS, IDWKOBS, 2)
        IDATEO=IWKOBS*7+IDWKOBS
        IF( IDC .EQ. 2 ) THEN
         IF (LNG .EQ. 1)
     &    WRITE(LUO,10030) MOD(IYOBS,100), IMOBS, IDOBS
         IF (LNG .EQ. 2)
     &    WRITE(LUO,10031) MOD(IYOBS,100), IMOBS, IDOBS
        ELSE IF( IDC .EQ. 3 ) THEN
         IF (LNG .EQ. 1)
     &    WRITE(LUO,10040) MOD(IYOBS,100), IMOBS, IDOBS
         IF (LNG .EQ. 2)
     &    WRITE(LUO,10041) MOD(IYOBS,100), IMOBS, IDOBS
        ELSE IF( IDC .EQ. 4 ) THEN
         IF (LNG .EQ. 1)
     &    WRITE(LUO,10050) MOD(IYOBS,100), IMOBS, IDOBS
         IF (LNG .EQ. 2)
     &    WRITE(LUO,10051) MOD(IYOBS,100), IMOBS, IDOBS
        END IF
        READ(LU,10020) NAMCLK(IMID)
        CLOSE(LUCLK)
        OPEN  ( LUCLK, FILE=NAMCLK(IMID), STATUS='OLD',IOSTAT=IOS, 
     &          ERR=185 )
        CALL HDCLX ( LUCLK, INTCLK, ICLKFMT )
        IF (ICLKFMT .EQ. -1) STOP 'CLK FORMAT NOT RECOGNIZED'
        IF (ICLKFMT .EQ. 1.OR.ICLKFMT .EQ. 5) THEN
         IF (ICLKFMT .EQ. 5) THEN
          READ(LUCLK,'(12X,I4,4I3,F9.4,2F17.13)',
     &    ERR=190)
     &    IYCOR, IMCOR, IDCOR, IHRCOR, IMINCOR, 
     &    SECCOR, CLKOS, CLKSD
         ELSE
          READ(LUCLK,'(A2,1X,A4,1X,I4,4I3,F10.6,I3,2X,2(1X,E19.12))',
     &    ERR=190)
     &    CLKTYP, CLKNAM, IYCOR, IMCOR, IDCOR, IHRCOR, IMINCOR, 
     &    SECCOR, NECLK, CLKOS, CLKSD
         END IF
C
         CALL GPSDC ( IDOY, IYCOR, IMCOR, IDCOR, IWKCOR, IDCOR, 2)
         IDATEC=IWKCOR*7+IDCOR
        ELSE IF ( ICLKFMT .EQ. 2 .OR. ICLKFMT .EQ. 3 ) THEN
         READ(LUCLK,'(I10)') ISEC
         IDATEC=(ISEC/86400)+1
         IWKCOR=(ISEC/604800)
         IDCOR=IDATEC-IWKCOR*7
         CALL GPSDC ( IDOY, IYCOR, IMCOR, IDCOR, IWKCOR, IDCOR, 4)
        END IF
        IF ( IDATEO .EQ. 0 .OR. IDATEC .EQ. IDATEO ) GO TO 190
 185    CONTINUE
        IF ( IDATEC .NE. IDATEO ) THEN 
          IF ( LNG .EQ. 1 )
     &      WRITE(LUO,10090) MOD(IYCOR,100),IMCOR,IDCOR
          IF ( LNG .EQ. 2 )
     &      WRITE(LUO,10091) MOD(IYCOR,100),IMCOR,IDCOR
        ELSE
         WRITE(LUO,10100) IOS, NAMCLK(IMID)
        END IF
        IERR = IERR+1
        IF (IERR .GT. NERR) GO TO 1000
        CLOSE(LUCLK)
        GO TO 100
C
C       PREPARE TO VALIDATE NEXT DATE
C
  190   CONTINUE
        IDWKOBS=IDWKOBS+1
        IF (MOD(IDWKOBS,8).EQ.0) THEN
          IDWKOBS=1
        IWKOBS=IWKOBS+1
        END IF
        CALL GPSDC ( IDOY, IYOBS, IMOBS, IDOBS, IWKOBS, IDWKOBS, 4)
      END DO
C
C
C     ASSIGN FIRST DATE TO LUEPH
C
      CLOSE(LUCLK)
      OPEN  (LUCLK,FILE=NAMCLK(1),STATUS='OLD')  
C
 1000 CONTINUE
C
C-----------------------------------------------------------------------
C               FORMAT STATEMENTS
C-----------------------------------------------------------------------
C
10020 FORMAT( A80 )
10030 FORMAT( ' Enter SATELLITE CLOCK file name for ',
     &          2(I2.2,'/'),I2.2,' :')
10031 FORMAT( " Entrez le nom du fichier d'HORLOGES DE SATELLITES du ",
     &          2(I2.2,'/'),I2.2,' :')
10040 FORMAT( ' Enter MRTCA hex file name for ',
     &          2(I2.2,'/'),I2.2,' :')
10041 FORMAT( " Entrez le nom du fichier MRTCA hexadecimal du ",    
     &          2(I2.2,'/'),I2.2,' :')
10050 FORMAT( ' Enter RTCM-SSR hex file name for ',
     &          2(I2.2,'/'),I2.2,' :')
10051 FORMAT( " Entrez le nom du fichier RTCM-SSR hexadecimal du ",    
     &          2(I2.2,'/'),I2.2,' :')
10090 FORMAT( ' SATELLITE CLOCK file for ', 2(I2.2,'/'),I2.2,
     &        ' does not match OBSERVATION ')
10091 FORMAT( " La date du fichier d'HORLOGES DE SATELLITES du ",
     &          2(I2.2,'/'),I2.2,
     &        ' ne correspond pas a celle des OBSERVATIONS du ', 
     &          2(I2.2,'/'),I2.2)
10100 FORMAT( ' ERROR/ERREUR SR FNAME',I9,' FILE/FICHIER ',  A80 )
20001 FORMAT (9X,I2.2,1X,I4,1X,4(I2.2,1X),F8.4,1X,I6,1X,2F15.12,3F10.3)
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** DMSR
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE DMSR (PI,RAD,DMS,IWAY)
C
C       PURPOSE         CONVERTS RADIANS <-> DMS 
C
C           RAD         INPUT/OUTPUT ANGLE (RADIANS)
C           DMS         INPUT/OUTPUT ANGLE (DMS REPRESENTATION)
C           IWAY        1 -> RAD TO DMS
C                       2 -> DMS TO RAD
C
      IMPLICIT NONE
C
      INTEGER*4 IWAY
      REAL*8    PI,RAD,DMS
C
      INTEGER*4 IDEG,IMIN
      REAL*8    SEC,ADMS
C
      IF (IWAY .EQ. 1) THEN
        CALL RADMS ( RAD, IDEG, IMIN, SEC )
        DMS = IABS(IDEG)*10000 + IMIN*100 + SEC
        IF ( RAD .LT. 0.D0 ) DMS = -DMS
      END IF
C
      IF (IWAY .EQ. 2) THEN
        ADMS = DABS(DMS)
        IDEG = INT(ADMS/10000.D0)
        IMIN = INT((ADMS-IDEG*10000.D0)/100)
        SEC  = ADMS - IDEG*10000 - IMIN*100
        RAD  = (IDEG + IMIN/60.D0 + SEC/3600.D0)*PI/180.D0
        IF ( DMS .LT. 0.D0 ) RAD=-RAD
      END IF
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C ************************************************************** DPLH2M
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE DPLH2M ( DTM, PLH, DPLH, DPLHM )
C
C     NAME              DPLH2M
C
C     PURPOSE   CONVERT ELLIPSOIDAL COORDINATE DIFFERENCES 
C                       FROM RADIANS TO METRES
C
C     PARAMETERS        DESCRIPTION
C
C          DTM          DATUM PARAMETERS
C          PLH          ELLIPSOIDAL COORDINATES OF STATION
C          DPLH         ELLIPSOIDAL COORDINATE DIFFERENCES
C          DPLHM        ELLIPSOIDAL COORDINATE DIFFERENCES (METRES)
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      REAL*8    DTM(*),     PLH(*)
      REAL*8    DPLH(*),    DPLHM(*)
C
      REAL*8    E2,SIN_P,COS_P,RM,RN
C
      E2    = DTM(2)*DTM(2)
      SIN_P = DSIN ( PLH(1) )
      COS_P = DCOS ( PLH(1) )
C
      RM            = DTM(1) * ( 1.0D0 - E2 ) /
     &          ( 1.0D0 - E2 * SIN_P * SIN_P ) ** 1.5
      RN            = DTM(1) / SQRT ( 1.0D0 - E2 * SIN_P * SIN_P )
C
      DPLHM(1)=DPLH(1)*RM
      DPLHM(2)=DPLH(2)*RN*COS_P
      DPLHM(3)=DPLH(3)
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** DPROD3
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      REAL*8 FUNCTION DPROD3( A, B )
C
C FUNCTION: XPROD3 COMPUTES DOT PRODUCT OF 3D VECTORS
C
C INPUT:    A   = VECTOR A
C           B   = VECTOR B
C           C   = A . B
C
C
      IMPLICIT NONE
C
      REAL*8        A(*),B(*)
C
      DPROD3=A(1)*B(1)+A(2)*B(2)+A(3)*B(3)
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** ECLIPS
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE ECLIPS ( IDIR, IPRN, TTAG, SVBCOS, ANOON, ANIGHT,
     &                    NECLIPS, ECLSTM, ECLETM, IECLIPS, PI ,
C Jan 10, 2017
C    &                    xsv, santxyz, vsvc, beta, iblk)
C Dec 5, 2017
C    &                    xsv, santxyz, vsvc, beta, iblk, BETAINI)
     &                    xsv, santxyz, vsvc, beta, iblk, BETAINI,
C Dec 5, 2017
     &                    YRTIN, YBSIN, INPRN)
C Jan 16, 2015
C *******************WARNING************************************
C the IIA body-x orientation (+x=> Sun) is used for all satellites, including
C IIR/IIRM. For the hardware IIR/IIRM orientation (+x=> deep space), the
C eclipsIIR.f version should be used or implemented
C
C NOTE: the IIA body-x orientation (+x=> Sun) IS NOW THE IGS STANDARD
C FOR ALL SATELLITES AND GNSS' !!!
C ************************************************************* 
C
C       NAME            ECLIPS (version Dec  2017)
C
C     PURPOSE   DETECT ECLIPSING & YAW ROTATE ECLIP. SATELLITES
C                       (THE INPUT BODY-X UNIT VECTOR - SANTXYZ IS YAW-ROTATED
C                        BY PHI-YANGLE (THE ECL-NOMINAL) YAW ANGLE DIFFERENCE)  
C
C       CONTACT         kouba@rogers.com      
C
C       UPDATE HISTORY: Aug. 23, 2011:1996-2008 W. AVERAGES of JPL REPROCESSING
C                                YRATE SOLUTIONS FOR ALL II/IIA CODED IN DATA
C                                STATEMENT, THIS ENABLES REPROCESSING FROM 1996
C                       Sep 26, 2011: 1. Corrected bug causing Block IIF shadow 
C                               CROSSING MANEVURE WITH 0.06 DEG/SEC RATE EVEN 
C                               FOR BETADG > 8 DEG
C                                     2. CORRECTED/improved IIA RECOVERY logic
C                       Dec 18, 2013: 1.corrected IIF night turns (USAF Doc.)
C                                     2.small neg beta IIF and small pos IIA noon turn
C                                    (wrong) directions  for |beta| < 0.9deg
C                                     3. PRN/SVN 23 IIA YBIAS= -0.5 deg up to Feb 2004 
C                                     4. All the above changes labeled "C Dec 12, 2013"
C
C                      Jan 24, 2014:  NOON RECOVERY CORRECTED IF IIA/IIF's HAVE YBIAS=0
C                                    (NOT APPLICABLE CURRENTLY,POSSIBLE FOR FUTURE IIF?)
C                                    & SMALL IIA/IIF BETA IF STATEMENT SIMPLIFIED
C
C                      Jan 16, 2015: the IIA body-x orientation
C                                    (+x=>Sun) and logic is implemented also for
C                                    IIR/IIRM eclipsing (no SANTXYZ reversal )  
C
C                      Mar 09, 2016 - upper limits for GLONASS PRN's -64
C                      
C                      Jan 10, 2017  BEIDOU (PRN: 101-136) ECLIPSING
C                                    GEO(BLKs 23, 27) - ON (Orbit normal) YAW
C                                    IGSO(22,26)&MEO(21,25)-ON YAW FOR |BETA|<2DEG
C
C                      Jan 10, 2017 : GALILEO ECLIPSING ACCORDING TO:
C
C   (https://www.gsc-europa.eu/support-to-developers/galileo-iov-satellite-metadata)
C                NOTE: SETTING BETAy=>BETA0 (=0deg DISABLES (ONLY) GAL/BEI ECLIPSING!)
C                ANIGHT = 180+15.0 deg IS SET FOR THE GAL BETAx = 15 DEG
C
C                      Feb 27, 2017 :GPS, GLN, GAL- A POSSIBLE BETA SIGN
C                                    CHANGE DURING NOON OR SHADOW TURNS
C                                    BETAINI- TURN START BETA ANGLE SET WHEN
C                                    |BETA|=< 0.07 DEG (a beta sign change
C                                    possible), OTHERWISE, BETAINI(IPRN) = 0 .
C                                    THEN, WHEN |BETA| =< 0.07 DEG AND
C                                    BETAINI(IPRN).NE.0, THE BETAINI SIGN IS USED
C                                    FOR THE TURN,OTHERWISE THE BETA SIGN IS USED 
C      
C                                    ALSO: IIF YAW BIAS SET TO -0.7 DEG
C                                    AS RECOMMENDED BY KUANG AT AL (2016)
C                                    GPS Solut.
C                                    DOI 10.1007/s10291-016-0562-9
C
C                                    AND ALL GPS IIA WITH BETA (0,+0.5>
C                                    HAVE NOON TURNS IN A WRONG DIRECTION
C                                    DUE TO THE YAW BIAS OF +0.5 DEG
C
C                      May 03, 2017  BEIDOU ON (ORBIT NORMAL) YAW LIMIT CORRECTED 
C                                    FROM 2 to 4 DEG
C                                    GAL UNUSED CODE COMMENTED OUT
C                      Dec 5, 2017 : BEIDOU ECLIPSING YS=>ON and ON=>YS
C                                     SWITCHING NEAR 4 DEG BETA LIMIT
C                                     & NEAR  90 DEG ORBIT ANGLE
C                                     WHEN YAW ~ 0 DEG
C
C                                     YRTIN (INPUT Y RATE) & INPRN
C                                     INPUT BEI PRN TO USE GAL NOON/NIGHT
C                                     TURNS (YRTIN CAN BE USED FOR
C                                     ANY SATs, INLUDING GPS ONES)
C     PARAMETERS        DESCRIPTION
C
C        IDIR           DIRECTION OF PROCESSING (1=FORWARD, -1=BACKWARD)
C        IPRN           SV PRN NUMBER (.LE.32 FOR GPS, .GT.32 FOR GLONASS)
C        TTAG           OBSERVATION EPOCH TIME TAG (EG SEC OF GPS WEEK)
C        SVBCOS         SV BETA ANGLE (BETWEEN SV AND SUN RADIUS) COSINE
C        ANOON          SV BETA ANGLE LIMIT (DEG) FOR A NOON TURN MANEVURE 
C        ANIGHT         SV BETA ANGLE LIMIT (DEG) FOR A NIGHT SHADOW CROSSING
C        NECLIPS        NUMBER OF ECLIPSING FOR THE PRN SATELLITE 
C        ECLSTM         ECLIPSE START TIME(EG SEC OF GPS WEEK)
C        ECLETM         ECLIPSE END TIME  ( "         "      )
C        IECLIPS        SV ECLIPSING (0=NO,1, 2=YES(1=night, 2=noon))
C        PI             = PI=3.1415926536D0
C        XSV(3)         SV X, Y, Z (m)(ITRF)
C        SANTXYZ        BODY-X UNIT VECTOR (ITRF)
C                       WARNING: THE IIA BODY-X ORIENTATION EXPECTED FOR THE IIR
C        VSVC           SV INERTIAL VELOCIRY VECTOR IN ITRF
C        BETA           90 DEG + THE SUN ANGLE WITH ORBITAL PLANE(IN RAD)
C        IBLK           SV BLOCK  1=I, 2=II, 3=IIA, IIR=(4, 5) IIF=6
C Jan 10, 2017
C                                BEI MEO= 21, 25: IGSO= 22, 26: GEO= 23, 27
C        BETAINI        INITIAL (GPS, GLN, GAL) BETA AT TURN START ONLY WHEN
C                       |BETA| =< 0.07 DEG. (MUST BE EXTERNALLY INITILIZED
C                       TO ZEROS!)
C Dec 5, 2017
C        YRTIN          INPUT YAW RATE FOR IPRN (IF 0, DATA Y RATE USED
C        YBSIN          INPUT YBIAS, IF 0, OR ABS(YBSIN)> 4 HARD CODED YBIAS
C                       USED (NON ZERO ABS(YBSIN) =< 0.01 DEG SETS YBIAS=0    
C                       WHICH DISABLES THE WRONG DIR IIF/IIA NOON TURNS)
C        INPRN          BEIDOU NOON/NIGHT TURNs ACCORDING TO GALILEO ECL
C                       (NOT TO BE USED FOR BEIDOU GEO SATELLIES)
C
C        INTERNAL PARAMETRS DESCRIPTION
C        MURATE      COMPUTED SAT ANG ORB VELOCIRY (DEG/S)
C Dec 12, 2013
C        YBIAS       IIA YAW BIAS= 0.5 deg SINCE NOV95,EXCEPT PRN/SVN23?
C Feb 27, 2017
C                        (YBIAS ALSO USED AS BETA LIMIT FOR IIA WRONG DIR NOON
C                        TURNS)
C                    IIF YAW BIAS=-0.7 deg (USED FOR BETA LIMIT 
C                        OF WRONG DIRECTION NOON TURNS)
C                        YBIAS= 0 DISABLES SMALL  BETA IIF/IIA TURNS!
C        YANGLE      THE NOMINAL YAW ANGLE
C        PHI         THE ECLIPSING YAW ANGLE            
C Jan 10, 2017
C        BETA0       GAL, BEIDOU  ECLIPS BETA LIMIT (= 2, 2.8 DEG)
C                    = 0 DISABLES GAL AND BEI MEO(BLK 21, 25), 
C                    IGSO(BLK 22, 26) AND GEO(BLK 23, 27) ECLIPSING 
C Dec 5, 2017
C                    FOR BETA0.NE.0 
C                    BETA0 RECOMPUTED FROM SAT YRATE &  MURATE (=ANOON)
C                    AND BEI GEO (BLKs 23, 27) ALWAYS USE ON MODE!
C                    WARNING: BEI MEO(BLK 25) AND IGSO (BLK 26) USE 
C                             GAL  NIGHT/NOON TURNS RATHER THAN ON MODE,
C                             ALSO INPRN USE GAL NIGHT/NOON TURNS 
C                             (DO NOT USE INPRN FOR BEIDOU GEO SATs!)
C        BETAE       THE GAL MODEL SHy LIMIT
C                    ALSO FOR BEIDOU,  DELTA BETA/REVOLUTION
C REMARKS:
C SVBCOS, the COS of the angle between the sv radius vector and the sun 
C radius vector, (the dot product of the above respective unit vectors), 
C SVBCOS is used to test against CNOON=COS(ANOON), if sv is entering 
C a noon maneuvere (i.e., SVBCOS > CNOON). The ANOON limit 
C (typically < 5.7 deg), is determined within the subroutine and depends 
C on the  sv yaw rate (YRATE)and satellite orbit ang. velocity (MURATE)
c
C ANIGHT , the shadow limit is the "input " in the subroutine 
C call statement, it can be hard coded as it is constant for a GNSS type,
C e.g., 
C 180.D0+-13.25D0 for GPS (IPRN <1, 32>) and 180.D0+-14.20D0 for 
C GLONASS (IPRN <33,64>), resp. CNIGHT=COS(ANIGHT) is used for testing.
C When SVBCOS < CNIGHT (CNIGHT is negative and close to -1), 
C the SV enters, or it is in the shadow. 
C
C Jan 10, 2017
C FOR GAL (IPRN <65,100>)  ANIGHT SET INTERNALLY TO 180 + 15 DEG
C         AND ANOON TO 15 DEG TO APPROXIMATE THE BETAx TURN LIMIT
C Feb 27, 2017
C FOR BEIDOU (IPRN <101, 136>) 180 + 2 DEG (USED FOR ECLIPS REPORT ONLY)
c
C May 03, 2017  BEIDOU ON YAW LIMIT CORRECTED FROM 2 TO 4 DEG
C 
C Dec 5, 2017   BEIDOU ON & YS SWITCHING FOR BETA ~ 4 DEG, ONLY WHEN NEAR
C               90 DEG ORB ANGLE TO MINIMIZE YAW ANGLE JUMPS
C *********************************************************************
C
      IMPLICIT NONE
C
C     MAXSAT - MAXIMUM NUMBER OF SATELLITES, CHANGED IF REQUIRED
C      
      INTEGER MAXSAT
C Jan 10, 2017
C     PARAMETER (MAXSAT=64)
      PARAMETER (MAXSAT=136)
      REAL*8    BETAINI(*)
C
      INTEGER*4 IDIR, IPRN
      INTEGER*4 IECLIPS, NECLIPS(*)
C
      REAL*8    TTAG, TWOHR, HALFHR
      REAL*8    SVBCOS, PI
      REAL*8    ECLSTM(MAXSAT,*)
      REAL*8    ECLETM(MAXSAT,*)
      REAL*8    ANOON, ANIGHT
      REAL*8    CNOON, CNIGHT
      REAL*8    DTR, DTTAG
      REAL*8    XSV(*), SANTXYZ(*), VSVC(*), BETA, MURATE, YANGLE, DET,
C Jan 10, 2017
C    &          YRATE(64), BETADG, PHI, SANTX, SANTY,        v(3),r(3)
     &          YRATE(136),BETADG, PHI, SANTX, SANTY, v(3),r(3), BETA0,
C    &          SMTH, BETAE
     &          BETAE
      REAL*8    YAWEND
C Dec 12, 2013
      REAL*8 YBIAS
      INTEGER*4 IBLK(*), J, I
C
C Dec 5, 2017
      INTEGER*4 INPRN
      REAL*8    YRTIN, YBSIN
      LOGICAL   NOON, NIGHT
C MAX YAW RATES OF CURRENT&PAST BLOCK II/IIA's,(AVER'D 1996-2008 JPL SOLUTIONS)  
C CHANGE IF REQUIRED OR INPUT IF ESTIMATED, using YRTIN call parameter  
C PRN                 01     02      03      04     05       06     07
      DATA YRATE /.1211d0,.1339d0,.123d0,.1233d0,.1180d0,.1266d0,.1269d0
C             08      09     10      11      12      13      14      15
     & ,.1033d0,.1278d0,.0978d0,0.200d0,0.199d0,0.200d0,0.0815d0,.1303d0
C PRN          16     17     18      19      20      21      22     23
     & ,.0838d0,.1401d0,.1069d0, .098d0, .103d0,0.1366d0,.1025d0,.1140d0
C PRN          24     25      26      27     28      29      30     31
     & ,.1089d0,.1001d0,.1227d0,.1194d0,.1260d0, .1228d0,.1165d0,.0969d0
C PRN         32  33-64: GLONASS RATES (DILSSNER 2010)                          
C
C Jan 10, 2017 - start: GALILEO ANOON of 2 DEG => YAW RATE of .203 DEG/s
C                Note: THE BEIDOU HARDWARE RATES NOT NEEDED
C    &  ,.1140d0, 32*0.250d0/
C Dec 5, 2017  BEIDOU YRATES ACCORDING TO DILSSNER (Nov 2017)
C    &  ,.1140d0, 32*0.250d0, 36*0.203d0, 36*0.203d0/
C BEIDOU RATES OF 0.085 & 0.158 ACCORDING TO DILSSNER (Nov 2017) 
     &  ,.1140d0, 32*0.250d0, 36*0.203d0, 10*0.085D0, 26*0.158d0/
C Jan 10, 2017
C     GAL  BETAy => BETA0
C     GAL  BETAx => ANOON=15DEG:  (ANIGHT-180); ANIGHT =180 + 15 DEG
C NOTE:BETA0= 0 DISABLES GALILEO AND/OR BEIDOU IGSO/MEO/GEO ECLIPSING!
       BETA0= 2.0D0
C Jan 10, 2017
C      SMTH = 258.D0
C
C  CHECK FOR BLOCK IIR AND FIX TO NOMINAL YAW RATE
      IF( IPRN .LE. 32 .AND. IBLK(IPRN).GE.4 ) YRATE(IPRN)=0.2D0
C THE NEW GPS BLK IIF YAW RATES ( DILSSNER (2010) INSIDE GNSS)
      IF( IPRN .LE. 32 .AND. IBLK(IPRN).GT.5 ) YRATE(IPRN)=0.11D0
C Dec 5, 2017 -start                       USE THE INPUT YAW RATE IF NON ZERO
C SET BEI IGSO/GEO YRATES CORRESPONDING TO 2.8 DEG BETA LIMIT
      IF(IBLK(IPRN).EQ.22.OR.IBLK(IPRN).EQ.23.OR.IBLK(IPRN).EQ.26
     &   .OR.IBLK(IPRN).EQ.27) YRATE(IPRN)= 0.085D0
C AND FOR BEI MEO, TOO, TO BE SURE
      IF(IBLK(IPRN).EQ.21.OR.IBLK(IPRN).EQ.25) YRATE(IPRN)= 0.158D0
C OR USE THE INPUT YRATE, BUT ONLY IF NON ZERO & REASONABLE
      IF(YRTIN.GT.0.D0.AND.YRTIN.LE.0.3D0) YRATE(IPRN)= YRTIN
C NON ZERO INPRN MUST BE BEIDOU ONLY (IPRN 101-136)
      IF(INPRN.LE.100.OR.INPRN.GT.136) INPRN=0 
C FOR BEI MEO/IGSO BLOCKS 25/26 INPRN INVOKES GAL ECLIPSING TURNS
C BUT ONLY IF INPRN IS ZERO!
C          ***************WARNING********
C IT IS ASSUMED/EXPECTED (ACCORDING DILSSNER Nov 2017) THE BEIDOU 3
C MEO/IGSO (BLKS 25/26) WILL NOT USE ON ECLIPSING and EMPLOY GAL-LIKE YS ECLIPS 
C MODEL. IF THE BEIDOU 3 SATS WILL ALSO USE THE REGULAR BEI. ON ECLIPSING
C DISABLE (COMMENT/DELETE)THE FOLLOWING 3 LINES,  THEN FOR
C ANOMALOUS BEI. (IE YS GAL) ECLIPSING SATs, USE INPRN/YRTIN, INSTEAD BLKS 25/26
C          ***************WARNING********
      IF(IBLK(IPRN).EQ.25.OR.IBLK(IPRN).EQ.26) THEN
       IF(INPRN.EQ.0) INPRN=IPRN
      END IF
C Dec 5, 2017 -end
C Dec 12, 2013
C  YBIAS=-0.5 FOR IIA (IBLK<4) PRN23 (SVN23 UP TO FEB2004,AFTER  IIR SVN60
C Feb 27, 2017
C   AND NOT USED), IIF (IBLK=6)=-0.7, USED FOR SMALL NEG BETA NOON TURNS ONLY!
      YBIAS=0.0D0
      IF(IBLK(IPRN).LE.3) YBIAS= 0.5D0
C Feb 27, 2017
C     IF(IPRN.EQ.23.OR.IBLK(IPRN).EQ.6) YBIAS=-0.5D0
C YBIAS=0 DISABLES SMALL NEGATIVE BETA IIF TURNS
C IF REQUIRED, CHANGE IIF YBIAS (BETA) LIMIT 
      IF(IBLK(IPRN).EQ.6) YBIAS=-0.7D0
C Dec 5, 2017
C USE INPUT YBSIN IF NON ZERO AND REASONABLE (ABS(YBSIN).LE.4.)
C BUT ONLY FOR GPS BLKs II/IIA and IIF!
      IF(YBSIN.NE.0.0.AND.ABS(YBSIN).LE.4.0.AND.(IBLK(IPRN).LE.3.OR.
     &  IBLK(IPRN).EQ.6)) YBIAS = YBSIN
C FORCED ZERO YBIAS WHEN ABS(YBIN).LE.0.01 DEG (TO DISABLE WRONG IIF/IIA
C NOON TURNS FOR SMALL BETA
      IF(ABS(YBIAS).LE.0.01D0 ) YBIAS= 0.0D0
C Jan 10, 2017 - start
C GAL BETAX => ANIGHT
      IF(IPRN.GT.64.AND.IPRN.LE.100)ANIGHT= 180.D0 +15.D0
C Dec 5, 2017 GAL ECLIPS FOR BEIDOU INPRN!
      IF(IPRN.EQ.INPRN)ANIGHT= 180.D0 +15.D0
C BEIDOU NIGHT TURN => BETA0 DEG (FOR REPORTING ONLY) 
C May 03, 201 THE ON LIMIT 4 DEG
C     IF(IPRN.GT.100.AND.IPRN.LE.136)ANIGHT= 180.D0 + BETA0
C Dec 5, 2017
C     IF(IPRN.GT.100.AND.IPRN.LE.136)ANIGHT= 180.D0 + 2.D0*BETA0
C FOR BETA > 5 DEG NO BEIDOU YS/ON SWITCH POSSIBLE, MEO/IGSO YS IS ON  
      IF(IPRN.GT.100.AND.IPRN.LE.136.AND.IPRN.NE.INPRN)
     &   ANIGHT= 180.D0 + 2.5D0*BETA0
C Jan 10, 2017 -end
C
      IECLIPS=0
      TWOHR = 7200.D0
      HALFHR= 1800.D0
C Jan 10, 2017 - no 1/2h extension for GALILEO
C Dec 5, 2017  - as well as  INPRN (Beidou) SAT!
C       IF(IPRN .GT.64.AND.IPRN.LE.100) HALFHR= 0.D0
        IF((IPRN .GT.64.AND.IPRN.LE.100).OR.IPRN.EQ.INPRN) HALFHR= 0.D0
      DTR=PI/180.D0
C compute the noon beta angle limit (beta zero) FOR A NOON TURN from YRATEs
C & THE ACTUAL SAT ORBIT ANGLE RATE (MURATE) (~0.00836 FOR GPS; ~ 0.00888 GLNS)
       MURATE= sqrt((VSVC(1)**2+VSVC(2)**2+VSVC(3)**2)/
     & (xsv(1)**2+xsv(2)**2+xsv(3)**2))/DTR
      ANOON=ATAN(MURATE/YRATE(IPRN))/DTR
C Dec 5, 2017  reset BETA0 (BUT ONLY IF NON ZERO!)
      IF(BETA0.NE.0.D0) BETA0= ANOON
C Jan 10, 2017
C  GAL & BEI NOON TURN LIMITS
C     IF(IPRN.GT.64.AND.IPRN.LE.100) ANOON=ANIGHT-180.d0
      IF(IPRN.GT.64.AND.IPRN.LE.136) ANOON=ANIGHT-180.d0
      CNOON=DCOS(ANOON*DTR)
      CNIGHT=DCOS(ANIGHT*DTR)
C
      NOON=.FALSE.
      NIGHT=.FALSE.
      BETADG = beta/DTR - 90.d0 
C Mar 09, 2016
C      IF(IPRN.GT.32.AND.ABS(BETADG).LT.ANOON) THEN
       IF(IPRN.GT.32.AND.IPRN.LE.64.AND.ABS(BETADG).LT.ANOON) THEN
C GLONASS NOON TURN MODE ACORDING TO DILSSNER 2010 
         YAWEND=75.D0
C  ITERATION FOR YAWEND OF THE GLONASS  NOON TURN
         DO J=1,3
           YAWEND=ABS(ATAN2(-TAN(BETADG*DTR),SIN(PI-
     &       DTR*MURATE*YAWEND/YRATE(IPRN)))/DTR -      
     &       ATAN2(-TAN(BETADG*DTR),SIN(PI+
     &       DTR*MURATE*YAWEND/YRATE(IPRN)))/DTR)/2.D0 
         END DO
C UPDATE ANOON, CNOON FOR NEW GLONASS NOON TURN LIMITS
          ANOON= MURATE*YAWEND/YRATE(IPRN)
          CNOON= DCOS(ANOON*DTR)
       ENDIF 
C BLK IIR'S
C Jan 10, 2017 - ADD GAL & BEI
C       IF(IBLK(IPRN).EQ.4 .OR. IBLK(IPRN).EQ.5) THEN
        IF(IBLK(IPRN).EQ.4 .OR. IBLK(IPRN).EQ.5.OR.
C    &             (IPRN.GT.64.AND.IPRN.LE.100)) THEN
     &             (IPRN.GT.64.AND.IPRN.LE.136)) THEN
         CNIGHT=DCOS((ANOON+180.d0)*DTR)
C Jan 16, 2015
C NO LONGER THE IGS STANDARD - NO IIR BODY-X REVERSAL!
C      DO J=1,3
C BODY-X U VECTOR REVERSAL FOR IIR ONLY
C       SANTXYZ(J)=-SANTXYZ(J)
C        END DO
        END IF
C
      IF (SVBCOS .LT. CNIGHT) THEN
        NIGHT=.TRUE.
      END IF
      IF (SVBCOS .GT. CNOON) THEN
        NOON=.TRUE.
      END IF
C Jan 10, 2017 - IGNORE GAL ECLIPSING FOR BETA >= BETA0!
C Dec 5, 2017      INVOKE GAL ECLIPSING FOR THE INPUT BEIDOU INPRN
C                  BUT DO NOT USE INPRN FOR BEI GEO!
C     IF(IPRN.GT.64.AND.IPRN.LE.100.AND.ABS(BETADG).GE.BETA0 ) THEN
      IF((IPRN.GT.64.AND.IPRN.LE.100.OR.IPRN.EQ.INPRN).AND.ABS(BETADG)
     &       .GE.BETA0 ) THEN
       NIGHT = .FALSE.
       NOON  = .FALSE.
      END IF
C
C     IF SV IN NIGHT SHADOW OR NOON TURN DURING FORWARD PASS
C     STORE START AND END TIME OF YAW MANEUVRE (FOR THE BACKWARD RUN)
C
C YAW ANLGE
      YANGLE=   acos((santxyz(1)*vsvc(1) +
     &santxyz(2)*vsvc(2)+santxyz(3)*vsvc(3))/sqrt(vsvc(1)**2+vsvc(2)**2+
     & vsvc(3)**2))/DTR                          
C IIR REVERSAL NO LONGER APPLICABLE/USED !
C IIR YANGLE has the same sign as beta, II/IIA has the opposite sign
C Jan 16, 2015
C      IF(BETADG.LT.0.d0.AND.IBLK(IPRN).GE.4.AND.IBLK(IPRN).LE.5)
C    &            YANGLE=-YANGLE
C      IF(BETADG.GT.0.d0.AND.IBLK(IPRN).NE.4.AND.IBLK(IPRN).NE.5)
       IF(BETADG.GT.0.d0)
     &            YANGLE=-YANGLE
C
C Jan 10, 2017 - Start
C BEIDOU ON YAW(=0) FOR GEO ALWAYS and FOR IGSO & MEO when BETADG < 4 DEG
C Dec 5, 2017 - start
      IF(IPRN.GT.100.AND.IPRN.LE.136.AND.IPRN.NE.INPRN
     &                              .AND.BETA0.NE.0.0D0) THEN
       IF(BETAINI(IPRN).EQ.0) THEN
          BETAINI(IPRN)= BETADG
          ECLSTM(IPRN,1) = TTAG
       ENDIF
C DET - APPROX ORBIT ANGLE
       DET= 180.-ACOS(SVBCOS)/DTR
       IF(ABS(YANGLE).GT.90.0) DET= 360.0 -DET
C May 03, 2017 THE ON LIMIT BETADG <= 4 DEG
C  MEO YS/ON SWITCHING DELTA BETA LIMIT
       BETAE= .52D0
C  IGSO YS/ON SWITCHING DELTA BETA LIMIT
       IF(IBLK(IPRN).EQ.22.OR.IBLK(IPRN).EQ.26) BETAE= .97D0
C COMPUTE THE ACTUAL BETAE (HERE BETA INCREASE PER 1 REVOLUTION)
       IF((TTAG-ECLSTM(IPRN,1)).NE.0.D0)
     & BETAE= (BETADG-BETAINI(IPRN))/(TTAG-ECLSTM(IPRN,1))*360./MURATE
       BETAE = ABS(BETAE)
C ON SWITCH FOR SURE FOR GEO (23/27) OR BETAE LIMIT
       IF(IBLK(IPRN).EQ.23.OR.IBLK(IPRN).EQ.27.OR.ABS(BETADG).LE.(4.1D0-
     &  BETAE)) GO TO 2
C YS KEPT FOR SURE
       IF(ABS(BETADG).GT.(3.9D0+BETAE)) GO TO 3
       IF(BETAINI(IPRN).NE.0.D0) THEN
C KEEP YS
        IF(ABS(BETADG).LT.ABS(BETAINI(IPRN)).AND.ABS(BETADG).GE.4.1)
     &   GO TO 3
C KEEP ON
        IF(ABS(BETADG).GT.ABS(BETAINI(IPRN)).AND.ABS(BETADG).LE.3.9)
     &   GO TO 2
        IF(IDIR.GT.0) THEN
C     FORWARD RUN
C ON SWITCH CHECK
C ON WHEN ORBIT ANGLE DET IS/WAS  90  DEG                      
         IF(ABS(BETADG).LT.ABS(BETAINI(IPRN))) THEN
C SHOULD BE ALREADY ON MODE ?
          IF(DET.LE.90.0.AND.(ABS(BETADG)+BETAE*(DET+270.)/360.).LE.4.1)
     &    GO TO 2
          IF(DET.GT.90.0.AND.(ABS(BETADG)+BETAE*(DET-90.)/360.).LE.4.1)
     &    GO TO 2
C YS SWITCH CHECK
C YS WHEN ORBIT ANGLE DET IS/WAS  90  DEG                      
         ENDIF
         IF(ABS(BETADG).GT.ABS(BETAINI(IPRN))) THEN
C SHOULD BE ALREADY ON MODE ?
          IF(DET.LE.90.0.AND.(ABS(BETADG)-BETAE*(DET+270.)/360.).LE.3.9)
     &    GO TO 2
          IF(DET.GT.90.0.AND.(ABS(BETADG)-BETAE*(DET-90.)/360.).LE.3.9)
     &    GO TO 2
         ENDIF
        ENDIF
        IF(IDIR.LT.0) THEN
C     BACKWARD RUN
C ON SWITCH ON CHECK
         IF(ABS(BETADG).LT.ABS(BETAINI(IPRN))) THEN
C SHOULD BE ALREADY ON MODE ?
          IF(DET.LE.90.0.AND.(ABS(BETADG)+BETAE*(DET+270.)/360.).LE.4.1)
     &    GO TO 2
          IF(DET.GT.90.0.AND.(ABS(BETADG)+BETAE*(DET-90.)/360.).LE.4.1)
     &    GO TO 2
C YS SWITCH OFF CHECK
         ENDIF
         IF(ABS(BETADG).GT.ABS(BETAINI(IPRN))) THEN
          IF(ABS(BETADG).GT.3.9D0) THEN
C YS SWITCH?  
C KEEP ON SINCE DET 90 DEG WAS BEFORE 3.9 DEG BETA?
           IF(DET.LE.90.0.AND.(ABS(BETADG)-BETAE*(DET+270.)/360.).LE.3.9
     &     )GO TO 2
           IF(DET.GT.90.0.AND.(ABS(BETADG)-BETAE*(DET-90.)/360.).LE.3.9)
     &     GO TO 2
          ENDIF
         ENDIF
        ENDIF
       ENDIF
C KEEP YS MODE (NO ECLIPSING)
3       IECLIPS =0
        GO TO 1
2       CONTINUE
C ON MODE
         DO J=1,3
C BODY-X ON(ORBIT NORMAL YAW) FOR BEIDOU GEO(BLK 23,27) OR FOR
C |BETA| =< ~ 4 DG (BODYX =>  SAT VELOCITY (YAW PHI=0))
           SANTXYZ(J)= VSVC(J)/sqrt(VSVC(1)**2+VSVC(2)**2+VSVC(3)**2)
          ENDDO
          PHI =  0.D0                       
C Jul 12, 2017
        IF (NIGHT.OR. (IBLK(IPRN).NE.23.AND.IBLK(IPRN).NE.27)) THEN
C BEI ECLIPSE REPORTING: GEO (IBLK 23, 27) NIGHT ONLY
C                        MEO(21,25) & IGSO(22,26) WHEN IN THE ON MODE
              write(*,*)"R",IPRN,TTAG,YANGLE, PHI,DET,
     &        BETADG, BETAINI(IPRN) , BETAE
             IECLIPS=1
             IF(NECLIPS(IPRN).EQ.0) NECLIPS(IPRN)=1
        ENDIF
        IF(NOON) THEN
C BEI NOON ECLIPS REPORTING (ALL IBLKs) IF NOON TRUE
              write(*,*)"S",IPRN,TTAG,YANGLE, PHI,DET,
     &        BETADG, BETAINI(IPRN), BETAE                 
             IECLIPS=2
             IF(NECLIPS(IPRN).EQ.0) NECLIPS(IPRN)=1
        ENDIF
C Dec 5, 2017 - end
       GOTO 1
      END IF
C Jan 10, 2017  end
      IF ( (NIGHT .OR. NOON)) THEN
       DET=SQRT((180.d0-acos(svbcos)/DTR)**2-BETADG**2)
       PHI = PI/2.d0/DTR
C Check if already after a midnight or noon
       IF(NIGHT) THEN
C Jan 16, 2015 - Start (NO IIR X-REVERSAL!)
C        IF(IBLK(IPRN).EQ.4.OR.IBLK(IPRN).EQ.5) THEN
C         IF(DABS(YANGLE).GT.90.d0) DET=-DET
C         IF(DET.NE.0.d0)PHI=ATAN2( TAN(BETADG*DTR),-SIN(-DET*DTR))/DTR
C        ELSE
C BLK IIA & GLONASS & IIR & IIF TOO !
          IF(DABS(YANGLE).LT.90.d0) DET=-DET
          IF(DET.NE.0.d0)PHI=ATAN2(-TAN(BETADG*DTR), SIN(-DET*DTR))/DTR
C        END IF
C Jan 16, 2015- end
       END IF 
       IF(NOON) THEN
       DET=SQRT((acos(svbcos)*180./pi)**2-BETADG**2)
C Jan 16, 2015- start (NO IIR X-REVERSAL!)
C        IF(IBLK(IPRN).EQ.4.OR.IBLK(IPRN).EQ.5) THEN
C         IF(DABS(YANGLE).LT.90.d0) DET=-DET
C         IF(DET.NE.0.d0)PHI=ATAN2(TAN(BETADG*DTR),-SIN(PI-DET*DTR))/DTR
C        ELSE
C BLK IIA & GLONASS !
          IF(DABS(YANGLE).GT.90.d0) DET=-DET
          IF(DET.NE.0.d0)PHI=ATAN2(-TAN(BETADG*DTR),SIN(PI-DET*DTR))/DTR
C        END IF
C Jan 16, 2015 - end
       END IF 
C ONLY FORWARD
       IF (IDIR .GT. 0 ) THEN
C
C       INITIALIZE ECLIPSE START AND TIME TAG ARRAYS  
C
        IF ( NECLIPS(IPRN) .EQ. 0 ) THEN
        NECLIPS(IPRN)=NECLIPS(IPRN)+1
          ECLSTM(IPRN,NECLIPS(IPRN))=TTAG+DET/MURATE
C IIR MIDNIGHT/NOON TURN or II/IIA NOON TURN START
C for IIR/GLONAS NIGHT (turn) only makes sense when |BETADG| < ANOON!
C For IIA it gets here only when NOON is true and that happens only when |BETADG|< ANOON!
          YAWEND=ATAN(MURATE/YRATE(IPRN))/DTR
          IF((IBLK(IPRN).GT.3.AND.IBLK(IPRN).LE.5.OR.NOON).AND.
     &       ABS(BETADG).LT.YAWEND) THEN
C GLONASS
C Mar 09, 2016
C           IF(     IPRN .GT.32) THEN
C jan 10, 2017       - ALSO GAL NOON TURN TIMES(ANOON=ANIGHT-180deg)
C           IF(     IPRN .GT.32.AND.IPRN.LE.64) THEN
C Dec 5, 2017
C           IF(     IPRN .GT.32.AND.IPRN.LE.100) THEN
            IF(    (IPRN .GT.32.AND.IPRN.LE.100).OR.IPRN.EQ.INPRN) THEN
C GLONASS NOON TURN MODE, ANOON ACORDING TO DILSSNER ET AL 2010 
             ECLSTM(IPRN,NECLIPS(IPRN))= ECLSTM(IPRN,NECLIPS(IPRN))-
     &        ANOON/MURATE
             ECLETM(IPRN,NECLIPS(IPRN))= ECLSTM(IPRN,NECLIPS(IPRN))+
     &        2.D0*ANOON/MURATE
            ELSE
C GPS IIA/IIR/IIF NOON OR IIR MIDNIGHT TURNs
             ECLSTM(IPRN,NECLIPS(IPRN))= ECLSTM(IPRN,NECLIPS(IPRN))-
     &        ABS(BETADG)*sqrt(ANOON/ABS(BETADG)-1.d0)/MURATE
             ECLETM(IPRN,NECLIPS(IPRN))= ECLSTM(IPRN,NECLIPS(IPRN))+
     &        2*ABS(BETADG)*sqrt(ANOON/ABS(BETADG)-1.d0)/MURATE
            ENDIF
          END IF
C     II/IIA SHADOW START & END TIMES
C Jan 10, 2017 - ADD GALILEO NIGHT
C         IF((IBLK(IPRN).LE.3.OR.IBLK(IPRN).GT.5).AND.NIGHT) THEN
          IF((IBLK(IPRN).LE.3.OR.IBLK(IPRN).GT.5
C Dec 5, 2017
C    &         .OR.(IPRN .GT.64.AND.IPRN.LE.100)).AND.NIGHT) THEN
     &     .OR.(IPRN .GT.64.AND.IPRN.LE.100).OR.IPRN.EQ.INPRN)
     &     .AND.NIGHT) THEN
           ECLSTM(IPRN,NECLIPS(IPRN))= ECLSTM(IPRN,NECLIPS(IPRN))-
     &      SQRT((ANIGHT-180.d0)**2-BETADG**2)/MURATE
           ECLETM(IPRN,NECLIPS(IPRN))= ECLSTM(IPRN,NECLIPS(IPRN))+
     &      2.d0*SQRT((ANIGHT-180.d0)**2-BETADG**2)/MURATE
          END IF
      END IF
C
C       UPDATE SV COSINE AND TIME TAG ARRAYS
C       (TO BE USED DURING BACKWARDS RUN)
C
        IF( (NIGHT .AND. SVBCOS .LT. CNIGHT)
     &       .OR. (NOON .AND. SVBCOS .GT. CNOON) ) THEN
          DTTAG= ABS(TTAG-ECLSTM(IPRN,NECLIPS(IPRN)))
C
C         ECLIPSE TIME IS MORE THAN 2 HOURS, THIS IS A NEW ECLIPSE!
C
C Feb 27, 2017
C SET GPS, GLN, GAL BETAINI IF APPLICABLE, I.E. FWD & |BETA| =< 0.07 DEG
C Dec 5, 2017
C           IF(IDIR.GT.0.AND.IPRN.LE.100.AND.ABS(BETADG).LE.0.07D0
         IF(IDIR.GT.0.AND.(IPRN.LE.100.OR.IPRN.EQ.INPRN)
     &     .AND.ABS(BETADG).LE.0.07D0
     &     .AND.BETAINI(IPRN).EQ.0.D0) BETAINI(IPRN)= BETADG
         IF( DTTAG .GT. TWOHR ) THEN
          NECLIPS(IPRN)=NECLIPS(IPRN)+1
            ECLSTM(IPRN,NECLIPS(IPRN))=TTAG+DET/MURATE
C IIR MIDNIGHT/NOON TURN  or II/IIA NOON TURN START
C                                  AND GLONASS NOON
            IF(IBLK(IPRN).GT.3.AND.IBLK(IPRN).LE.5.OR.NOON) THEN
C GLONASS
C Mar 09, 2016
C            IF(IPRN.GT.32) THEN
C Jan 10, 2017 - include  ALSO GAL
C            IF(IPRN.GT.32.AND.IPRN.LE.64) THEN
C Dec 5, 2017
C            IF(IPRN.GT.32.AND.IPRN.LE.100) THEN
             IF((IPRN.GT.32.AND.IPRN.LE.100).OR.IPRN.EQ.INPRN) THEN
C GLONASS NOON TURN MODE ACORDING TO DILSSNER ET AL 2010 
              ECLSTM(IPRN,NECLIPS(IPRN))= ECLSTM(IPRN,NECLIPS(IPRN))-
     &          ANOON/MURATE
              ECLETM(IPRN,NECLIPS(IPRN))= ECLSTM(IPRN,NECLIPS(IPRN))+
     &         2.D0*ANOON/MURATE
             ELSE
C GPS TURNS ONLY
              ECLSTM(IPRN,NECLIPS(IPRN))= ECLSTM(IPRN,NECLIPS(IPRN))-
     &         ABS(BETADG)*sqrt(ANOON/ABS(BETADG)-1.d0)/MURATE
              ECLETM(IPRN,NECLIPS(IPRN))= ECLSTM(IPRN,NECLIPS(IPRN))+
     &         2*ABS(BETADG)*sqrt(ANOON/ABS(BETADG)-1.d0)/MURATE
C May 03, 2017 -remove Jan 10 dead code below
C Jan 10, 2017 - GALILEO NOON - start
C             IF(IPRN .GT.64.AND.IPRN.LE.100)THEN
C          ECLSTM(IPRN,NECLIPS(IPRN))= ECLSTM(IPRN,NECLIPS(IPRN))-
C    &      SQRT(ANOON**2-BETADG**2)/MURATE
C          ECLETM(IPRN,NECLIPS(IPRN))= ECLSTM(IPRN,NECLIPS(IPRN))+
C    &      2.d0*SQRT(ANOON**2-BETADG**2)/MURATE
C             END IF
             ENDIF
            END IF
C     II/IIA SHADOW START & END TIMES
C   & GLONASS & IIF AS WELL !
C Jan 10, 2017 - ADD GAL NIGHT
C           IF((IBLK(IPRN).LE.3.OR.IBLK(IPRN).GT.5).AND.NIGHT) THEN
            IF((IBLK(IPRN).LE.3.OR.IBLK(IPRN).GT.5
C Dec 5, 2017
C    &           .OR.(IPRN .GT.64.AND.IPRN.LE.100)).AND.NIGHT) THEN
     &       .OR.(IPRN .GT.64.AND.IPRN.LE.100).OR.IPRN.EQ.INPRN)
     &       .AND.NIGHT) THEN
             ECLSTM(IPRN,NECLIPS(IPRN))= ECLSTM(IPRN,NECLIPS(IPRN))-
     &       SQRT((ANIGHT-180.d0)**2-BETADG**2)/MURATE
             ECLETM(IPRN,NECLIPS(IPRN))= ECLSTM(IPRN,NECLIPS(IPRN))+
     &       2.d0*SQRT((ANIGHT-180.d0)**2-BETADG**2)/MURATE
            END IF
        END IF
        ENDIF
C  END OF FORWARD (FWD) LOOP (IDIR = 1)
       ENDIF
      ENDIF
C
C     BOTH FWD (IDIR= 1) OR BWD (IDIR=-1)
C     SET ECLIPSE FLAG (1=NIGHT SHADOW, 2=NOON TURN) 
C
      IF ( NECLIPS(IPRN) .NE. 0 ) THEN
C CHECK IF IPRN IS ECLIPSING AND WHICH SEQ NO (I)
        I=0
        DO J=1, NECLIPS(IPRN)
         IF( TTAG.GE.ECLSTM(IPRN,J).AND.TTAG.LE.(ECLETM(IPRN,J)+HALFHR))
     &   I= J
        END DO
C CURRENTLY NOT ECLIPSING (i=0)
        IF(I.EQ.0) GO TO 1
        IF ( TTAG .GE. ECLSTM(IPRN,I) .AND.
     &            TTAG .LE.(ECLETM(IPRN,I)+HALFHR) ) THEN
C Feb 27, 2017 
C FOR GPS & GLN ONLY! USE BETAINI FOR ALL TURNS WHEN |BETADG|.LE. 0.07 DEG
C TO ENSURE NO BETA SIGN CHANGE AND IIF |START-END YAW DIFF| < 180 DEG
            IF(ABS(BETADG).LE.0.07D0.AND.IPRN.LE.64
     &         .AND.BETAINI(IPRN).NE.0.0D0) BETADG = BETAINI(IPRN)
C velocity & radius unit vectors V & R
             DO J=1,3
              V(J)=VSVC(J)/SQRT(VSVC(1)**2+VSVC(2)**2+VSVC(3)**2)
              R(J)=XSV(J)/SQRT(XSV(1)**2+XSV(2)**2+XSV(3)**2) 
             END DO
C ORBIT ANGLE MU AT ECLIPSE/TURN START
             DET= MURATE*(ECLETM(IPRN,I)-
     &                        ECLSTM(IPRN,I))/2.d0
C Dec 12, 2013 - start
C YAWEND HERE - IIF SHADOW YAW RATE
C HERE |YAW start-YAW end| ALWAYS < 180 DEG DUE TO POSSIBLE USE OF BETAINI
                  YAWEND=(ATAN2(-TAN(BETADG*DTR), SIN( DET*DTR))- 
     &             ATAN2(-TAN(BETADG*DTR), SIN(-DET*DTR)))/DTR/
     &                  (ECLETM(IPRN,I)-ECLSTM(IPRN,I))
C Dec 12, 2013 - end
           IF (SVBCOS .LT. 0) THEN
C SHADOW CROSSING
C BLK IIA/IIF SHADOW CROSSING
                IF(IPRN.LE.32.AND.(IBLK(IPRN).LE.3.OR.IBLK(IPRN).GT.5))
     &             THEN
                 IF(TTAG.LE.ECLETM(IPRN,I)) THEN
C IIA NIGHT TURN
                  IF(IBLK(IPRN).LE.3) 
     &             PHI=ATAN2(-TAN(BETADG*DTR), SIN(-DET*DTR))/DTR
     &           +SIGN(YRATE(IPRN),YBIAS)*(TTAG-ECLSTM(IPRN,I)) 
C Dec 12, 2013
C    &           +SIGN(YRATE(IPRN),0.5d0)*(TTAG-ECLSTM(IPRN,I)) 
C IIF NIGHT TURN (DILSSNER  2010)
                   IF(IBLK(IPRN).GT.5)
     &             PHI=ATAN2(-TAN(BETADG*DTR), SIN(-DET*DTR))/DTR
C Dec 12, 2013- start
C Correct IIF  NIGHT CROSSING USING COMPUTING YAW RATE (YAWEND)
C ACCORDING TO THE USAF IIF DOCUMENT
C    &           +SIGN(0.06D0, BETADG)*(TTAG-ECLSTM(IPRN,I)) 
     &           +  YAWEND            *(TTAG-ECLSTM(IPRN,I)) 
C Dec 12, 2013 - end
                 ELSE
C **** WARNING
C IIA SHADOW EXIT RECOVERY: USING THE IIA DATA  DURING
C THE IIA RECOVERY (UP TO 30 MIN) IS NOT RECOMMENDED!
C **** WARNING
C GPS IIA  AT SHADOW EXIT
                   IF(IBLK(IPRN).LE.3)
     &             PHI=ATAN2(-TAN(BETADG*DTR), SIN(-DET*DTR))/DTR
C Dec 12, 2013
C    &          +SIGN(YRATE(IPRN),0.5d0)*(ECLETM(IPRN,I)-ECLSTM(IPRN,I))
     &          +SIGN(YRATE(IPRN),YBIAS)*(ECLETM(IPRN,I)-ECLSTM(IPRN,I))
C GPS IIF AT SHADOW EXIT
C Dec 12, 2013
C NO NEED FOR IIF (IBLK=6) RECOVERY, ALREADY AT THE EXIT YAW!
                   IF(IBLK(IPRN).GT.5)GO TO 1
C                  IF(IBLK(IPRN).GT.5)
C    &             PHI=ATAN2(-TAN(BETADG*DTR), SIN(-DET*DTR))/DTR
C    &          +SIGN(0.06D0, BETADG)*(ECLETM(IPRN,I)-ECLSTM(IPRN,I)) 
C YAWEND- HERE THE ACTUAL YAW DIFFERENCE  AT THE SHADOW EXIT
                   YAWEND= YANGLE- PHI   
                   YAWEND=DMOD(YAWEND, 360.D0)
                   IF(ABS(YAWEND).GT.180.D0) YAWEND= YAWEND-360.D0*
     &               YAWEND/ABS(YAWEND)
                   PHI=PHI
     &                   +SIGN(YRATE(IPRN),YAWEND)*(TTAG-ECLETM(IPRN,I))
C SANTX- THE CURRENT ANGLE DIFF, CONSISTENT WITH YAWEND
                   SANTX= YANGLE-PHI
                   SANTX =DMOD(SANTX , 360.D0)
                   IF(ABS(SANTX).GT.180.D0) SANTX = SANTX -360.D0*
     &               SANTX /ABS(SANTX )
C STOP! THE NOMINAL YAW (YANGLE) REACHED!
                  IF(ABS(SANTX).GT.ABS(YAWEND)) GOTO 1
                  IF(YAWEND.NE.0.D0.AND.((SANTX)/YAWEND).LT.0.D0) GOTO 1
C SET PHI <-180,+180>
                   PHI= DMOD(PHI, 360.D0)
                   IF(ABS(PHI).GT.180.D0) PHI= PHI-360.D0*PHI/ABS(PHI)
                 ENDIF
                ENDIF
C GLONASS
C Mar 09, 2016
C               IF(IPRN.GT.32) THEN
                IF(IPRN.GT.32.AND.IPRN.LE.64) THEN
C GLONASS      NIGHT TURN (DILSSNER AT AL 2010 )
                 IF(TTAG.GT.ECLETM(IPRN,I)) GOTO 1
                 YAWEND=YRATE(IPRN) 
                 PHI=ATAN2(-TAN(BETADG*DTR), SIN(-DET*DTR))/DTR
     &      +SIGN(YAWEND     ,BETADG)*(TTAG-ECLSTM(IPRN,I)) 
C YAWEND -YAW ANGLE AT THE (GLONASS) SHADOW EXIT
                  YAWEND=ATAN2(-TAN(BETADG*DTR), SIN( DET*DTR))/DTR
                 IF((YAWEND/PHI).GE.1.d0.OR.(PHI/YAWEND).LT.0.d0) THEN  
                  PHI = YAWEND
                 ENDIF
                ENDIF
C Dec 12, 2013 - start
C                  IF(IPRN.LE.32.AND.IBLK(IPRN).GT.5) THEN
C GPS BLK IIF NIGHT YAW RATE(DILSSNER 2010):
C                   IF(ABS(BETADG).GT.8.D0) GO TO 1
C                  ENDIF
C Jan 10, 2017
C              IF(IBLK(IPRN).GT.3.AND.IBLK(IPRN).LE.5) THEN
              IF(IPRN.LE.32.AND.IBLK(IPRN).GT.3.AND.IBLK(IPRN).LE.5)THEN
C BLK II R SHADOW (MIDNIGHT TURN) CROSSING
C Jan 16, 2015
C               PHI=ATAN2( TAN(BETADG*DTR),-SIN(-DET*DTR))/DTR
                PHI=ATAN2(-TAN(BETADG*DTR), SIN(-DET*DTR))/DTR
     &      +SIGN(YRATE(IPRN),BETADG)*(TTAG-ECLSTM(IPRN,I)) 
C Jan 16, 2015
C               IF((PHI/YANGLE).GE.1.d0.OR.(PHI/YANGLE).LT.0.d0) GO TO 1
                IF((YANGLE/PHI).GE.1.d0.OR.(PHI/YANGLE).LT.0.d0) GO TO 1
               END IF
C jan 10, 2017 - GALILEO night - start
C Dec 5, 2017
C              IF(IPRN.GT.64.AND.IPRN.LE.100) THEN
               IF((IPRN.GT.64.AND.IPRN.LE.100).OR.IPRN.EQ.INPRN) THEN
C  SIN ORB ANGLE MU => YAWEND
               YAWEND=
     &         SIN((ttag-(ECLSTM(IPRN,I)+ECLETM(IPRN,I))/2)*MURATE*DTR)
C Jan 10, 2017 - start
C GAL ECLIPS MODEL: Shy => BETAE
               BETAE=0.5*(-SIGN(SIN(BETA0*DTR),BETADG)-SIN(BETADG*DTR))
     &         +0.5D0*(-SIGN(SIN(BETA0*DTR),BETADG)+SIN(BETADG*DTR))*
     &         COS(PI*ABS(YAWEND*COS(BETADG*DTR))/SIN(ANOON*DTR))
                 IF(ABS(BETADG).LT.0.07D0) THEN
C USE BETAINI IF NOT ZERO, SINCE BETA SIGN CHANGE IS POSSIBLE DURING THE
C MODEL TURN
                  IF(BETAINI(IPRN).NE.0.D0)
     &BETAE=0.5*(-SIGN(SIN(BETA0*DTR),BETAINI(IPRN))-SIN(BETADG*DTR))
     &+0.5D0*(-SIGN(SIN(BETA0*DTR),BETAINI(IPRN))+SIN(BETADG*DTR))*
     &         COS(PI*ABS(YAWEND*COS(BETADG*DTR))/SIN(ANOON*DTR))
                 ENDIF
               PHI   = ATAN2(BETAE, YAWEND*COS(BETADG*DTR))/DTR
               ENDIF
C  GALILEO night - ends 
C Jan 10, 2017 - end
              write(*,*)"R",IPRN,TTAG,YANGLE, PHI,DET,
     & BETADG, ECLETM(IPRN,I), beta0                       
             IECLIPS=1
           ELSE
C NOON TURNS 
           PHI=ATAN2(-TAN(BETADG*DTR),SIN(PI-DET*DTR))/DTR
     &      -SIGN(YRATE(IPRN),BETADG)*(TTAG-ECLSTM(IPRN,I))
C Dec 12, 2013 -start
C SMALL NEGATIVE BETA IIF OR SMALL POSITIVE IIA NOON TURN PROBLEM
C Jan 24, 2014
C               IF((IBLK(IPRN).LE.3.OR.IBLK(IPRN).EQ.6).AND.   
C APPLY WRONG DIRECTIONs TO ALL IIA (IBLK.LE.3) NOON WITH BETA (0,0.5DEG) AND
C IIF (IBLK=6) NOON TURNS WITH BETA (-0.7,0) DEG
C FOR ONLY IIF WRONG NOONS, USE:
C               IF(IPRN.LE.32.AND.IBLK(IPRN).EQ.6.AND.
                IF(IPRN.LE.32.AND.   
C Feb 27, 2017
C USE YBIAS AS  BETA LIMIT FOR WRONG NOON TURN DIRECTION
C    &             (BETADG*SIGN(1.D0,YBIAS)).LE.0.9D0  .AND.
     &             (BETADG*SIGN(1.D0,YBIAS)).LE.ABS(YBIAS).AND.
     &             (BETADG*YBIAS).GT.0.0D0)                  THEN
                    PHI=ATAN2(-TAN(BETADG*DTR),SIN(PI-DET*DTR))/DTR
     &              +SIGN(YRATE(IPRN),YBIAS )*(TTAG-ECLSTM(IPRN,I))
                 ENDIF
C Dec 12, 2013 - end
                IF(IBLK(IPRN).GT.3.AND.IBLK(IPRN).LE.5) THEN
C BLK IIR NOON TURNS ONLY
C Jan 16, 2015
C                PHI=ATAN2( TAN(BETADG*DTR),-SIN(PI-DET*DTR))/DTR
C    &      -SIGN(YRATE(IPRN),BETADG)*(TTAG-ECLSTM(IPRN,I))
C IIR END TURN CHECK
C                IF((YANGLE/PHI).GE.1.d0.OR.(PHI/YANGLE).LT.0.d0) GOTO 1
                 IF((PHI/YANGLE).GE.1.d0.OR.(PHI/YANGLE).LT.0.d0) GOTO 1
                ELSE
C GLONASS END TURN CHECK
C Mar 09, 2016
C                IF(     IPRN .GT.32.AND.TTAG.GT.ECLETM(IPRN,I)) GOTO 1
C Jan 10, 2017
C        IF(IPRN.GT.32.AND.IPRN.LE.64.AND.TTAG.GT.ECLETM(IPRN,I)) GOTO 1
         IF(IPRN.GT.32.AND.IPRN.LE.100.AND.TTAG.GT.ECLETM(IPRN,I))GOTO 1
C IIA OR IIF END TURN CHECK
C Dec 12, 2013 -start
C Feb 27, 2017
C                IF(IPRN.LE.32.AND.BETADG*SIGN(1.D0,YBIAS).LE.0.9D0.AND.
                 IF(IPRN.LE.32.AND.BETADG*SIGN(1.D0,YBIAS).LE.ABS(YBIAS)
     &              .AND.
C Jan 24, 2014
C    &             BETADG*SIGN(1.D0,YBIAS).GT.0.0D0.AND.
     &             BETADG*YBIAS.GT.0.0D0.AND.
     &            (((PHI-SIGN(1.d0,YBIAS)*360.D0)/YANGLE).LE.1.d0.OR.
     &            ((PHI-SIGN(1.D0,YBIAS)*360.D0)/YANGLE).LT.0.d0))GOTO 1
C                IF(IPRN.LE.32.AND.
                 IF(IPRN.LE.32.AND.(BETADG*SIGN(1.D0,YBIAS).GT.
C Jan 24, 2014
C    &              BETADG*SIGN(1.D0,YBIAS).LE.0.0D0).AND.
     &              ABS(YBIAS).OR.BETADG*YBIAS.LE.0.0D0).AND.
     &            ((PHI/YANGLE).GE.1.d0.OR.(PHI/YANGLE).LT.0.d0)) GOTO 1
                ENDIF
C Jan 10, 2017 - GALILEO noon  - start
C Dec 5, 2017
C              IF(IPRN.GT.64.AND.IPRN.LE.100) THEN
               IF((IPRN.GT.64.AND.IPRN.LE.100).OR.IPRN.EQ.INPRN) THEN
C  SIN ORB ANGLE MU => YAWEND
               YAWEND= SIN(
     &         PI +(TTAG-(ECLSTM(IPRN,I)+ECLETM(IPRN,I))/2)*MURATE*DTR)
C Jan 10, 2017
C GAL ECLIPS MODEL: Shy => BETAE
               BETAE=0.5*(-SIGN(SIN(BETA0*DTR),BETADG)-SIN(BETADG*DTR))
     &         +0.5D0*(-SIGN(SIN(BETA0*DTR),BETADG)+SIN(BETADG*DTR))*
     &         COS(PI*ABS(YAWEND*COS(BETADG*DTR))/SIN(ANOON*DTR))
                 IF(ABS(BETADG).LT.0.07D0) THEN
C USE BETAINI IF NOT ZERO, SINCE BETA SIGN CHANGE IS POSSIBLE DURING THE
C MODEL TURN
                  IF(BETAINI(IPRN).NE.0.D0)
     &BETAE=0.5*(-SIGN(SIN(BETA0*DTR),BETAINI(IPRN))-SIN(BETADG*DTR))
     &+0.5D0*(-SIGN(SIN(BETA0*DTR),BETAINI(IPRN))+SIN(BETADG*DTR))*
     &         COS(PI*ABS(YAWEND*COS(BETADG*DTR))/SIN(ANOON*DTR))
                 ENDIF
               PHI   = ATAN2(BETAE, YAWEND*COS(BETADG*DTR))/DTR
C Jan 10, 2017 - end
               ENDIF
C Jan 10, 2017 - GALILEO noon  - ends
C
              write(*,*)"S",IPRN,TTAG,YANGLE, PHI,DET,
     & BETADG, ECLSTM(IPRN,I),beta0                  
             IECLIPS=2
           END IF
C ROTATE X-VECTOR TO ECLIPSING YAW ANGLE PHI 
C ECLIPSING (II/IIA) NOT TO BE USED  A HALF HR AFTER SHADOW !
       SANTX=(COS((PHI-YANGLE)*DTR)*(V(2)-V(3)*R(2)/R(3))-COS(PHI*
     & DTR)*
     &(SANTXYZ(2)-SANTXYZ(3)*R(2)/R(3)))/(SANTXYZ(1)*V(2)-SANTXYZ(2)*v(1
     &)+((SANTXYZ(2)*V(3)-SANTXYZ(3)*V(2))*R(1)+(SANTXYZ(3)*V(1)-SANTXYZ
     &(1)*V(3))*R(2))/R(3))
       SANTY = (COS(PHI*DTR) - (V(1)-V(3)*R(1)/R(3))*SANTX)/
     & (V(2)-V(3)*R(2)/R(3))
C THE BODY-X UNIT VECTOR ROTATED BY (PHI-YANGLE) RETURNED
          SANTXYZ(1)= SANTX
          SANTXYZ(2)= SANTY
          SANTXYZ(3)= (-R(1)*SANTX-R(2)*SANTY)/R(3)
      END IF
      ENDIF
1     CONTINUE
      RETURN
C
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** EPFIND
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE EPFIND ( ISV, TTAG, IODE, NEPSV, IEPSV, NEPTIM,
     +                     EPHTIM, EPHTBL, EPH )
C
C     PURPOSE:   FIND BEST EPHEMERIS FOR THIS SATELLITE AND EPOCH
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     ISV               PRN OF SATELLITE SELECTED
C       IODE            REQUIRED IODE
C     NEPSV             NUMBER OF SATELLITES WITH EPHEMERIS
C     IEPSV             LIST OF SATELLITE PRN NUMBERS
C     NEPTIM            NUMBER OF EPHEMERIS DOWNLOADED PER SATELLITE
C     EPHTIM            ARRAY OF EPHEMERIS REFERENCE TIMES
C     EPHTBL            TABLE OF EPHEMERIDES
C     EPH               SELECTED EPHEMERIS
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE  'MAXDIM'      
C
      INTEGER*4 ISV, IODE, NEPSV
      INTEGER*4 IEPSV(MAXSAT), NEPTIM(MAXSAT)
      REAL*8    TTAG
      REAL*8    EPHTIM(MAXSAT,MAXEPH)
      REAL*8    EPHTBL(MAXKEP,MAXSAT,MAXEPH)
      REAL*8    EPH(MAXKEP)
C
      INTEGER*4 IEPH,IS,IEP,IODEPH,IP
      REAL*8    DTOLD,DTIME
C
      IEPH=0
C
C     SELECT BEST SATELLITE EPHEMERIS FOR THIS EPOCH
C
c!    WRITE(*,*) 'LOOKING FOR ',IODE,' FOR PRN ',ISV
      DO 500 IS=1,NEPSV
      IF ( ISV .EQ. IEPSV(IS) ) THEN
C
C         SELECT EPHEMERIS WITH IODE
C
        DTOLD = 21600.D0
          IF ( IODE .NE. 0 ) THEN
            DO  IEP=1,NEPTIM(IS)
            IODEPH = EPHTBL(12,IS,IEP)
            DTIME = DABS ( TTAG - EPHTIM(IS,IEP) )
c!          WRITE(13,*) 'LOOKING FOR ',IODE,'  FOUND ',
c!   &                  IODEPH,' FOR PRN ',ISV
            IF ( IODE .EQ. IODEPH .AND. DTIME .LT. DTOLD ) THEN
                IEPH = IEP
              DTOLD = DTIME
c!            WRITE(13,*) '  MATCH FOUND FOR PRN ',ISV,IODEPH
              END IF
          END DO
C
C         SELECT EPHEMERIS WITH TTAG
C
          ELSE
          DO  IEP=1,NEPTIM(IS)
C           IF (MOD(IDNINT(EPHTIM(IS,IEP)),3600) .EQ. 0) THEN
              DTIME = DABS ( TTAG - EPHTIM(IS,IEP) )
c!          write(*,*) iep,ttag,ephtim(is,iep),dtime,dtold
              IF ( DTIME .LT. DTOLD 
     &                     .AND. EPHTBL(5,IS,IEP) .EQ. 0 ) THEN
                IEPH = IEP
                DTOLD = DTIME
              END IF
C           END IF
          END DO
          END IF
C
C         IF EPHEMERIS FOUND, STORE IN EPH 
C         ELSE SET UNHEALTHY
C
          IF ( IEPH .NE. 0 ) THEN
          DO IP=1,MAXKEP
            EPH(IP) = EPHTBL(IP,IS,IEPH)
          END DO
          ELSE
              EPH(5) = 1
          END IF
C
      END IF
  500 CONTINUE
      IF ( IEPH .EQ. 0 ) EPH(5) = 1
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** EPNAME
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE EPNAME ( IPEP, LU, LUO, LPR, LUEPH, IFMTE, NAMEP,
     &                    IYEAR, IMTH, IDAY, NMID, IERR, IULTRA, 
     &                    IMINACC,
     &                    LNG )
C
C     NAME:      EPNAME
C
C     PURPOSE:   ASSIGN EPHEMERIS FILE NAMES TO LOGICAL UNITS
C
C     PARAMETERS        DESCRIPTION
C
C        LU             LOGICAL UNIT OF SCREEN INPUT
C        LUO            LOGICAL UNIT OF SCREEN OUTPUT
C        LUEPH  LOGICAL UNIT OF INPUT EPHEMERIS FILE
C        NAMEP  PRECISE EPHEMERIS FILE NAME
C          IYEAR        YEAR OF OBSERVATIONS
C          IMTH         MONTH OF OBSERVATIONS
C          IDAY         DAY OF OBSERVATIONS
C          NMID         MIDNIGHT CROSSING FLAG
C
C
      IMPLICIT NONE
C
      INTEGER*4 IPEP, LU, LUO, LPR, LUEPH,
     &          IYEAR, IMTH, IDAY, NMID, IERR, IULTRA,
     &          LNG,IFMTE
     &         ,IMINACC
      CHARACTER*80  NAMEP(*)
C
      CHARACTER*80  RECORD
      CHARACTER*20  COMMENT
      CHARACTER*5   USEDAT, IFRAME
      CHARACTER*3   ORBTYP
      CHARACTER*4   AGENCY
      INTEGER*4 NERR,IYOBS,IMOBS,IDOBS,IMID,IDOY,IWKOBS,IDWKOBS
     &         ,ISEC,IC
      CHARACTER*64 HEX
      INTEGER*4 IOS,IPRN,IYEPH,IMEPH,IDEPH,IDUM,IHOUR,IMIN
      INTEGER*4 NPEPEPO,IGPSWK,MJULD,IWKEPH,IDATEO,IDATEP
      REAL*8    SEC,SECOW,PEPINT,FJULD
      INTEGER*4 I,J,IFMINACC,IACC(17)
      INTEGER*4 ISIZ
C
      IFMTE=1
      NPEPEPO=0
      IDATEP=0
      IULTRA=0
      IERR=0
      NERR=3
      IYOBS=IYEAR
      IMOBS=IMTH
      IDOBS=IDAY
      IFMINACC=0
C
C     READ EPHEMERIS FILES AND CHECK DATES
C
      DO IMID=1,NMID
  100   CONTINUE
c!      WRITE(*,*) 'IMID,IYOBS,IMOBS,IDOBS',IMID,IYOBS,IMOBS,IDOBS
        CALL GPSDC ( IDOY, IYOBS, IMOBS, IDOBS, IWKOBS, IDWKOBS, 2)
        IDATEO=IWKOBS*7+IDWKOBS
        IF ( IPEP .EQ. 1 .AND. LNG .EQ. 1 ) 
     &    WRITE(LUO,10030) MOD(IYOBS,100), IMOBS, IDOBS
        IF ( IPEP .EQ. 1 .AND. LNG .EQ. 2 ) 
     &    WRITE(LUO,10031) MOD(IYOBS,100), IMOBS, IDOBS
        IF ( IPEP .EQ. 2 .AND. LNG .EQ. 1 ) 
     &    WRITE(LUO,10040) MOD(IYOBS,100), IMOBS, IDOBS
        IF ( IPEP .EQ. 2 .AND. LNG .EQ. 2 ) 
     &    WRITE(LUO,10041) MOD(IYOBS,100), IMOBS, IDOBS
        READ(LU,10020) NAMEP(IMID)
C
        OPEN  (LUEPH,FILE=NAMEP(IMID),STATUS='OLD',IOSTAT=IOS,ERR=120)  
C
C       GET DATE OF BROADCAST EPHEMERIS
C
        IF ( IPEP .EQ. 1 ) THEN
  110     CONTINUE
          READ(LUEPH,'(A80)',END=120,ERR=120) RECORD
          READ(RECORD,'(I10,1X,A64)',ERR=111) ISEC,HEX
          DO IC=1,64
           IF( HEX(IC:IC) .NE. '0' .AND. HEX(IC:IC) .NE. '1' .AND.
     &         HEX(IC:IC) .NE. '2' .AND. HEX(IC:IC) .NE. '3' .AND.
     &         HEX(IC:IC) .NE. '4' .AND. HEX(IC:IC) .NE. '5' .AND.
     &         HEX(IC:IC) .NE. '6' .AND. HEX(IC:IC) .NE. '7' .AND.
     &         HEX(IC:IC) .NE. '8' .AND. HEX(IC:IC) .NE. '9' .AND.
     &         HEX(IC:IC) .NE. 'A' .AND. HEX(IC:IC) .NE. 'a' .AND.
     &         HEX(IC:IC) .NE. 'B' .AND. HEX(IC:IC) .NE. 'b' .AND.
     &         HEX(IC:IC) .NE. 'C' .AND. HEX(IC:IC) .NE. 'c' .AND.
     &         HEX(IC:IC) .NE. 'D' .AND. HEX(IC:IC) .NE. 'd' .AND.
     &         HEX(IC:IC) .NE. 'E' .AND. HEX(IC:IC) .NE. 'e' .AND.
     &         HEX(IC:IC) .NE. 'F' .AND. HEX(IC:IC) .NE. 'f' ) GOTO 111
          END DO
          IFMTE=2
          IDEPH=MOD((ISEC/86400),7)+1
          IWKEPH=(ISEC/604800)
          IDATEP=(ISEC/86400)+1
          CALL GPSDC ( IDOY, IYEPH, IMEPH, IDEPH, IWKEPH, IDEPH, 4)
          REWIND(LUEPH)
          GOTO 115
  111     CONTINUE
          IF(RECORD(16:16).NE.' '.OR.RECORD(11:11).NE.' ') GOTO 112
          READ(RECORD,'(I10,1X,I4)',ERR=112) ISEC,ISIZ
          ISIZ=21+2*ISIZ
          IF(ISIZ.GT.80) ISIZ=80
          DO IC=17,ISIZ
           IF( RECORD(IC:IC) .NE. '0' .AND. RECORD(IC:IC) .NE. '1' .AND.
     &         RECORD(IC:IC) .NE. '2' .AND. RECORD(IC:IC) .NE. '3' .AND.
     &         RECORD(IC:IC) .NE. '4' .AND. RECORD(IC:IC) .NE. '5' .AND.
     &         RECORD(IC:IC) .NE. '6' .AND. RECORD(IC:IC) .NE. '7' .AND.
     &         RECORD(IC:IC) .NE. '8' .AND. RECORD(IC:IC) .NE. '9' .AND.
     &         RECORD(IC:IC) .NE. 'A' .AND. RECORD(IC:IC) .NE. 'a' .AND.
     &         RECORD(IC:IC) .NE. 'B' .AND. RECORD(IC:IC) .NE. 'b' .AND.
     &         RECORD(IC:IC) .NE. 'C' .AND. RECORD(IC:IC) .NE. 'c' .AND.
     &         RECORD(IC:IC) .NE. 'D' .AND. RECORD(IC:IC) .NE. 'd' .AND.
     &         RECORD(IC:IC) .NE. 'E' .AND. RECORD(IC:IC) .NE. 'e' .AND.
     &         RECORD(IC:IC) .NE. 'F' .AND. RECORD(IC:IC) .NE. 'f' )
     &                                                         GOTO 112
          END DO
          IFMTE=3
          IDEPH=MOD((ISEC/86400),7)+1
          IWKEPH=(ISEC/604800)
          IDATEP=(ISEC/86400)+1
          CALL GPSDC ( IDOY, IYEPH, IMEPH, IDEPH, IWKEPH, IDEPH, 4)
          REWIND(LUEPH)
          GOTO 115
  112     CONTINUE
          COMMENT = RECORD(61:80)
          IF ( COMMENT .EQ. '                    ' .OR.
     &            COMMENT .EQ. 'END OF HEADER       ') THEN
            READ(LUEPH,20200,END=120,ERR=120) IPRN, IYEPH, IMEPH, IDEPH
            IF ( IYEPH .GE. 0 .AND. IYEPH .LT. 80 ) THEN
            IYEPH = IYEPH + 2000
            ELSE
            IYEPH = IYEPH + 1900
             END IF
            REWIND (LUEPH)
        ELSE  
            GO TO 110
        END IF
        END IF
C
C       GET DATE OF PRECISE EPHEMERIS
C
        IF ( IPEP .EQ. 2 ) THEN
          READ(LUEPH,20000,END=120,ERR=120) IDUM, IYEPH, IMEPH, IDEPH,
     &           IHOUR, IMIN, SEC, NPEPEPO, USEDAT, IFRAME, ORBTYP,
     &           AGENCY
          READ(LUEPH,20100,END=120,ERR=120) IDUM,IGPSWK,SECOW,PEPINT, 
     &                                    MJULD, FJULD
C
C FIGURE MINIMUM NON-ZERO ACCURACY CODE
C
          IFMINACC = 0
          DO I=1,40
            READ(LUEPH,'(A80)',END=120,ERR=120) RECORD
            IF(RECORD(1:2).EQ.'++') GOTO 10
          END DO
10        BACKSPACE(LUEPH)
          DO I=1,40
            READ(LUEPH,'(A80)',END=120,ERR=120) RECORD
            IF(RECORD(1:2).EQ.'%c') GOTO 20
            READ(RECORD,'(9X,17I3)') (IACC(J),J=1,17)
            DO J=1,17
              IF ( IACC(J) .NE. 0 .AND.
     &             ( IFMINACC .EQ. 0 .OR. IACC(J) .LT. IFMINACC ) )
     &          IFMINACC=IACC(J)
            END DO
          END DO
20        CONTINUE
          REWIND (LUEPH)
        END IF
C      
        CALL GPSDC ( IDOY, IYEPH, IMEPH, IDEPH, IWKEPH, IDEPH, 2)
        IDATEP=IWKEPH*7+IDEPH
c!      WRITE(*,*) 'IMID,IYEPH,IMEPH,IDEPH',IMID,IYEPH,IMEPH,IDEPH
C
C       SET FLAG IF ULTRA RAPID ORBIT
C
        IF ( NPEPEPO .EQ. 192 ) THEN
          IF ( IDATEP .NE. IDATEO ) THEN
           IDATEP=IDATEP+1
           IULTRA=1
          ELSE
           IULTRA=0
          END IF
        END IF
C
C       CHECK THAT OBSERVATION AND EPHEMERIS DATES MATCH
C
  115   CONTINUE
        IF ( IDATEO .EQ. 0 .OR. IDATEP .EQ. IDATEO ) GO TO 130
  120   CONTINUE
        IF ( IDATEP .NE. IDATEO ) THEN 
          IF (LNG .EQ. 1 ) WRITE(LUO,10090) MOD(IYEPH,100), 
     &                     IMEPH, IDEPH, MOD(IYEAR,100), IMTH, IDAY
          IF (LNG .EQ. 2 ) WRITE(LUO,10091) MOD(IYEPH,100), 
     &                     IMEPH, IDEPH, MOD(IYEAR,100), IMTH, IDAY
        ELSE
        WRITE(LUO,10100) IOS, NAMEP(IMID)
        END IF
        IERR = IERR+1
        IF (IERR .GT. NERR) GO TO 1000
        CLOSE(LUEPH)
        GO TO 100
C
C       PREPARE TO VALIDATE NEXT DATE
C
  130   CONTINUE
        IDWKOBS=IDWKOBS+1
        IF (MOD(IDWKOBS,8).EQ.0) THEN
          IDWKOBS=1
        IWKOBS=IWKOBS+1
        END IF
        CALL GPSDC ( IDOY, IYOBS, IMOBS, IDOBS, IWKOBS, IDWKOBS, 4)
C
C     ASSIGN FIRST DATE TO LUEPH
C
        CLOSE(LUEPH)
        IF ( IPEP .EQ. 2 .AND. IFMINACC .NE. 0 .AND.
     &       ( IMINACC .EQ. 0 .OR. IFMINACC .LT. IMINACC ) )
     &    IMINACC=IFMINACC
      END DO
      OPEN  (LUEPH,FILE=NAMEP(1),STATUS='OLD',IOSTAT=IOS)  
      IF ( IPEP .EQ. 2 .AND. IMINACC .LT. 3 ) THEN
        IMINACC=3-IMINACC
      ELSE
        IMINACC=0
      END IF
C
 1000 CONTINUE
C
C-----------------------------------------------------------------------
C               FORMAT STATEMENTS
C-----------------------------------------------------------------------
C
10020 FORMAT( A80 )
10030 FORMAT( ' Enter BROADCAST EPHEMERIS file name for ',
     &          2(I2.2,'/'),I2.2,' :')
10031 FORMAT( " Entrez le nom du fichier d'EPHEMERIDES DIFFUSEES du ",
     &          2(I2.2,'/'),I2.2,' :')
10040 FORMAT( ' Enter PRECISE EPHEMERIS file name for ',
     &          2(I2.2,'/'),I2.2,' :')
10041 FORMAT( " Entrez le nom du fichier d'EPHEMERIDES PRECISES du ",
     &          2(I2.2,'/'),I2.2,' :')
10090 FORMAT( ' EPHEMERIS file for ', 2(I2.2,'/'),I2.2,
     &        ' does not match OBSERVATION ', 2(I2.2,'/'),I2.2)
10091 FORMAT( " La date du fichier d'EPHEMERIDES ", 2(I2.2,'/'),I2.2,
     &        ' ne correspond pas a celle des OBSERVATIONS ', 
     &          2(I2.2,'/'),I2.2)
10100 FORMAT( ' ERROR/ERREUR SR FNAME',I9,'FILE/FICHIER ',  A80 )
20000 FORMAT ( A2,1X,I4,1X,4(I2,1X),F11.8,1X,I7,1X,2(A5,1X),A3,1X,A4 )
20100 FORMAT ( A2,1X,I4,1X,F15.8,1X,F14.8,1X,I5,1X,F15.13 )
20200 FORMAT (4I3)
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** FITEPH
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE FITEPH ( LUI, LUO, LPR, LUPEP, NAMEP, NDAY,
     +                    IPC, IPEP, C, DTM, XRV,
     +                    NEPSV, IEPSV, NEPTIM, EPHTIM, EPHTBL, IBEFIT,
     +                    NPEPSV, IPEPSV, IPEPACC, NBARC, NDEG, IPEFIT, 
     +                    PTB, PTE, PCX, PCY, PCZ, PDT, ENDTTAG, IULTRA,
     +                    IMINACC, IPEPINT , SSVX)
C
C     PURPOSE: FIT POLYNOMIALS TO BROADCAST AND PRECISE EPHEMERIS
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     LPR               LOGICAL UNIT OF PRINTER
C     LUPEP             LOGICAL UNIT OF PRECISE EPHEMERIS FILE
C       NAMEP           NAME OF INPUT EPHEMERIS FILES
C     IPEP              USE PRECISE EPHEMERIS FLAG
C     NEPSV             NUMBER OF SATELLITES WITH BROADCAST EPHEMERIS
C     IEPSV             BROADCAST EPHEMERIS SATELLITE ID'S
C     NEPTIM            NUMBER OF BROADCAST EPHEMERIS DOWNLOADED PER SATELLITE
C     EPHTIM            ARRAY OF BROADCAST EPHEMERIS REFERENCE TIMES
C     EPHTBL            TABLE OF BROADCAST EPHEMERIDES
C       IBEFIT          POLYNOMIAL FIT TO BROADCAST ( 0=GOOD, 1=BAD )
C     NPEPSV            NUMBER OF SATELLITES WITH PRECISE EPHEMERIS
C     IPEPSV            ARRAY OF SATELLITE PRN NUMBERS
C       IPEPACC         ARRAY OF SATELLITE ACCURACY CODES
C     NBARC             NUMBER OF PRECISE EPHEMERIS ARCS
C     NDEG              DEGREE OF POLYNOMIAL FIT TO PRECISE ARC
C       IPEFIT          POLYNOMIAL FIT TO PRECISE ( 0=GOOD, 1=BAD )
C     PTB               PRECISE EPHEMERIS ARC TIME OF BEGINNING
C     PTE               PRECISE EPHEMERIS ARC TIME OF END
C     PCX               POLYNOMIAL COEFFICIENTS FOR PRECISE EPHEMERIS X
C     PCY               POLYNOMIAL COEFFICIENTS FOR PRECISE EPHEMERIS Y
C     PCZ               POLYNOMIAL COEFFICIENTS FOR PRECISE EPHEMERIS Z
C       PDT             PRECISE CLOCK ESTIMATES DT
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE  'MAXDIM'
C
      CHARACTER*80   NAMEP(*)
      INTEGER*4 LUI,LUO,LPR,LUPEP,NDAY,IPC,IPEP,NEPSV,NPEPSV,IULTRA
     +         ,IMINACC
      INTEGER*4 IEPSV(MAXSAT), NEPTIM(MAXSAT)
      INTEGER*4 IBEFIT(MAXSAT)
      INTEGER*4 IPEPSV(MAXSAT), IPEPACC(MAXSAT)
      INTEGER*4 NBARC(MAXSAT)
      INTEGER*4 NDEG(MAXSAT,MAXARC)
      INTEGER*4 IPEFIT(MAXSAT,MAXARC)
C
      REAL*8    C
      REAL*8    DTM(*), XRV(*)
      REAL*8    EPHTIM(MAXSAT,MAXEPH)
      REAL*8    EPHTBL(MAXKEP,MAXSAT,MAXEPH)
      REAL*8    PTB(MAXSAT,MAXARC),      PTE(MAXSAT,MAXARC)
      REAL*8    PCX(MAXSAT,MAXARC,MAXDEG)
      REAL*8    PCY(MAXSAT,MAXARC,MAXDEG)
      REAL*8    PCZ(MAXSAT,MAXARC,MAXDEG)
      REAL*8    PDT(MAXSAT,MAXARC,MAXPFIT)
      REAL*8    BAS1, BAS2, SSVX(1440,4,MAXSAT)
      INTEGER*4 ISSVX
C
C     DIMENSIONING OF COORDINATE ARRAYS FOR APPROXIMATION
C
C
      INTEGER*4 ICLKSIGN,ISV,IA,IARC,NEPARC,IDEG
      INTEGER*4 IWKDAY,IBHR,IBMIN,IEHR,IEMIN,IGPSWK,IEND
      INTEGER*4 NPEPEPO,IPEPINT,MARC,INTARC,NEPREAD,IARCTB
      INTEGER*4 IARCTE,IPRN,IEP,NHOURS
      REAL*8    STEP,RMSX,RMSY,RMSZ,RMSDT,BEFIT
      REAL*8    BSEC,ESEC,SECOW,DX
      REAL*8    ENDTTAG            
      REAL*8    TT(MAXPFIT)
      REAL*8    X(MAXPFIT,MAXSAT)
      REAL*8    Y(MAXPFIT,MAXSAT)
      REAL*8    Z(MAXPFIT,MAXSAT)
      REAL*8    DT(MAXPFIT,MAXSAT)
      REAL*8    CX(MAXDEG), CY(MAXDEG), CZ(MAXDEG), CDT(MAXDEG)
C
      LOGICAL NEWPEP, NEWTT
      INTEGER*4 INTARCH,JARC,NEWARC
      INTEGER*4 IMISS,NSVBUF,ISVBUF(MAXSAT),IACBUF(MAXSAT)
      ICLKSIGN = 1
C
C-----------------------------------------------------------------------
C     FIT POLYNOMIAL TO BROADCAST EPHEMERIS
C-----------------------------------------------------------------------
C
      IF (IPEP .EQ. 1) THEN
        IF (IPC .GE. 3) THEN
          WRITE(LPR,1000)
          WRITE(*,1000)
        END IF
      DO 500 ISV=1,NEPSV
        IPRN=IEPSV(ISV)
        IBEFIT(IPRN) = 0
C
      CALL ARCTIM ( ISV, IPRN, NEPTIM, EPHTIM, NBARC, PTB, PTE )
C
C     PROCESS ARCS SEQUENTIALLY USING BROADCAST EPHEMERIS
C
      DO 400 IA=1,NBARC(ISV)
        IARC=MOD(IA-1,4)+1
        STEP     = 900.D0
        NEPARC = 0
        IF ( PTE(IPRN,IARC) .GT. ENDTTAG ) ENDTTAG=PTE(IPRN,IARC)
        CALL BEPXYZ ( LUI, LUO, LPR, ISV, NEPSV, IEPSV, NEPTIM,
     &                  EPHTIM, EPHTBL, PTB(IPRN,IARC), PTE(IPRN,IARC),
     &                  STEP, NEPARC, DTM, XRV, TT, X, Y, Z, DT, C )
C
C       CHEBYSHEW APPROXIMATION
C
        NDEG(IPRN,IARC) =
     &           10 + IDINT((PTE(IPRN,IARC)-PTB(IPRN,IARC))/3600.D0)
        NDEG(IPRN,IARC) = MIN(NDEG(IPRN,IARC),MAXDEG)
c!      WRITE(*,*) ISV,IARC,NDEG(IPRN,IARC)
c!      WRITE(*,'(I5,4F15.3)') 
c!    &          (I, TT(I), X(I,IPRN), Y(I,IPRN), Z(I,IPRN), I=1,NEPARC)
          CALL CHBPOL (PTB(IPRN,IARC),PTE(IPRN,IARC),NEPARC,TT,
     &                   X(1,IPRN),NDEG(IPRN,IARC),CX,RMSX)
          CALL CHBPOL (PTB(IPRN,IARC),PTE(IPRN,IARC),NEPARC,TT,
     &                   Y(1,IPRN),NDEG(IPRN,IARC),CY,RMSY)
          CALL CHBPOL (PTB(IPRN,IARC),PTE(IPRN,IARC),NEPARC,TT,
     &                   Z(1,IPRN),NDEG(IPRN,IARC),CZ,RMSZ)
          CALL CHBPOL (PTB(IPRN,IARC),PTE(IPRN,IARC),NEPARC,TT,
     &                   DT(1,IPRN),NDEG(IPRN,IARC),CDT,RMSDT)
C
          DO IDEG = 1, NDEG(IPRN,IARC)
             PCX(IPRN,IARC,IDEG)  = CX(IDEG)
             PCY(IPRN,IARC,IDEG)  = CY(IDEG)
             PCZ(IPRN,IARC,IDEG)  = CZ(IDEG)
        END DO
          BEFIT = DSQRT (RMSX**2+RMSY**2+RMSZ**2+(RMSDT*C)**2)
          IBEFIT(IPRN) = IBEFIT(IPRN) + IDINT(BEFIT/20.D0)
          IF ( IBEFIT(IPRN) .NE. 0 ) THEN
          IBEFIT(IPRN) = 1
            WRITE(LPR,1020) IPRN, BEFIT
          END IF            
C
        CALL TOWHMS( IWKDAY, PTB(IPRN,IARC), IBHR, IBMIN, BSEC, 0 )
        CALL TOWHMS( IWKDAY, PTE(IPRN,IARC), IEHR, IEMIN, ESEC, 0 )
          IF (IPC .GE. 3) THEN
          WRITE(LPR,1100) IPRN,IARC,IBHR, IBMIN, BSEC,
     &          IEHR, IEMIN, ESEC, RMSX, RMSY, RMSZ, RMSDT*1.D9
          WRITE(*,1100) IPRN,IARC,IBHR, IBMIN, BSEC,
     &          IEHR, IEMIN, ESEC, RMSX, RMSY, RMSZ, RMSDT*1.D9
          END IF
  400 CONTINUE
  500 CONTINUE
      END IF
C
C-----------------------------------------------------------------------
C      FIT POLYNOMIAL TO PRECISE EPHEMERIS
C-----------------------------------------------------------------------
C
c!    WRITE(*,*) 'IN FITEPH',NEWPEP
      IF ( IPEP .GE. 2 ) THEN
      IF ( IPEP .GT. 2 ) WRITE(LPR,1010)
      CALL HDSP3 ( LUPEP, NEWPEP, NEWTT, NPEPSV, IPEPSV,
     &                 IGPSWK, SECOW, IEND, IPEPACC, NPEPEPO,
     &                 IMINACC,
     &                 IPEPINT, BAS1, BAS2)
      INTARC=21600
      INTARCH=INTARC/2
        MARC  = (IULTRA+1)*86400/INTARCH
      NSVBUF=NPEPSV
      DO ISV=1,NPEPSV
       ISVBUF(ISV)=IPEPSV(ISV)
       IACBUF(ISV)=IPEPACC(ISV)
      END DO
      NEPREAD=INTARC/IPEPINT+1
C
C
C     PROCESS ARCS SEQUENTIALLY USING PRECISE EPHEMERIS
C
c!       WRITE(*,*) 'IULTRA,MARC',IULTRA,MARC
        IF ( IPC .GE. 2 ) WRITE(*,'(/,A50,/)') 
     &               '*** GPSPACE - PROCESSING PRECISE EPHEMERIS'
C
      NEPARC = 0
      ISSVX = 0
      DO IA=1,MARC
          JARC=MOD(IA-1,(MARC/(IULTRA+1)))+1
        IARCTB=IGPSWK*604800+SECOW+(JARC-1)*(INTARCH)
          IARCTE=IGPSWK*604800+SECOW+(JARC+1)*(INTARCH)
c!      WRITE(*,*) 'BEFORE PEPXYZ',IARC,IARCTB,IARCTE,NEPREAD
        CALL PEPXYZ ( LPR, LUPEP, NAMEP, NDAY, NSVBUF, ISVBUF, 
     &                  IACBUF, IPEPINT, IARC, NEPREAD, IARCTE, 
     &        NEPARC, TT, X, Y, Z, DT, ENDTTAG, BAS1, BAS2, SSVX, ISSVX)
          IF( NEPARC .GE. INTARC/IPEPINT ) THEN
        NEWARC=JARC
        DO ISV=1,NPEPSV
           IF(IPEPSV(ISV).GT.0.AND.IPEPSV(ISV).LE.MAXSAT) THEN
          IPRN=IPEPSV(ISV)
            IARC=JARC+NBARC(IPRN)
            IPEFIT(IPRN,IARC)=0
            IF ( IPC .GE. 2 )
     &        WRITE(*,*) '    GPSPACE - PROCESSING PRECISE EPHEMERIS',
     &        ' FOR PRN ', IPRN, ' ARC ', (JARC-1)*INTARCH/3600,
     &        ' - ',(JARC+1)*INTARCH/3600
C
C           STORE PRECISE CLOCK TERMS AT 15 MINUTE EPOCHS 
C
            IMISS=0
            DO IEP=1,NEPARC
              PDT(IPRN,IARC,IEP) = DT(IEP,IPRN)
              DX = X(IEP,IPRN)+Y(IEP,IPRN)+Z(IEP,IPRN)
              IF ( DABS(DX) .LT. 1.D0 ) THEN
            IPEFIT(IPRN,IARC)=IPEFIT(IPRN,IARC)+1
            IMISS=IEP
            END IF
            IF (IPC .GT. 3)
     &          WRITE(*,'(2i4,f10.1,3f12.1,f20.3)') IEP,IPRN,
     &                    DMOD(TT(IEP),604800.D0),
     &                    X(IEP,IPRN),Y(IEP,IPRN),Z(IEP,IPRN),
     &                    DT(IEP,IPRN)*1.D6
            END DO
              IF ((IPEFIT(IPRN,IARC) .GT. 1 .OR.
     &             (IPEFIT(IPRN,IARC) .EQ. 1 .AND. IMISS .LT. NEPARC)) 
     &              .AND. IPC .GE. 2 )
     &          WRITE(*,*) '    GPSPACE - UNHEALTHY PRECISE EPHEMERIS',
     &               ' FOR PRN ', IPRN, ' ARC ', (JARC-1)*INTARCH/3600,
     &               ' - ',(JARC+1)*INTARCH/3600
C
C         CHEBYSHEW APPROXIMATION
C
          PTB(IPRN,IARC) = IARCTB - 1.D0
          PTE(IPRN,IARC) = IARCTE + 1.D0
          NHOURS=IDINT((PTE(IPRN,IARC)-PTB(IPRN,IARC))/3600.D0)
          NDEG(IPRN,IARC) = 10 + NHOURS
          NDEG(IPRN,IARC) = MIN(NDEG(IPRN,IARC),MAXDEG)
C
            IF (IPEFIT(IPRN,IARC) .GT. 1 .OR.
     &          (IPEFIT(IPRN,IARC) .EQ. 1 .AND. IMISS .LT. NEPARC)) THEN
           IPEFIT(IPRN,IARC)=1
           DO IDEG=1,NDEG(IPRN,IARC)
             CX(IDEG)=0.D0
             CY(IDEG)=0.D0
             CZ(IDEG)=0.D0
           END DO
            ELSE
           CALL CHBPOL (PTB(IPRN,IARC),PTE(IPRN,IARC),
     &                    NEPARC-IPEFIT(IPRN,IARC),TT,
     &                   X(1,IPRN),NDEG(IPRN,IARC),CX,RMSX)
             CALL CHBPOL (PTB(IPRN,IARC),PTE(IPRN,IARC),
     &                    NEPARC-IPEFIT(IPRN,IARC),TT,
     &                   Y(1,IPRN),NDEG(IPRN,IARC),CY,RMSY)
             CALL CHBPOL (PTB(IPRN,IARC),PTE(IPRN,IARC),
     &                    NEPARC-IPEFIT(IPRN,IARC),TT,
     &                   Z(1,IPRN),NDEG(IPRN,IARC),CZ,RMSZ)
           IPEFIT(IPRN,IARC)=0
          END IF
C
            DO IDEG = 1, NDEG(IPRN,IARC)
             PCX(IPRN,IARC,IDEG)  = CX(IDEG)
             PCY(IPRN,IARC,IDEG)  = CY(IDEG)
             PCZ(IPRN,IARC,IDEG)  = CZ(IDEG)
             IF ( IPC .Gt. 3 )
     &           WRITE(*,'(3I3,3F15.3)') IPRN,IARC,IDEG,
     &                                 PCX(IPRN,IARC,IDEG),
     &                                 PCY(IPRN,IARC,IDEG),
     &                                 PCZ(IPRN,IARC,IDEG)
          END DO
C
C           SAVE LAST EPOCH COORDINATES AND CLOCKS 
C
           END IF
          END DO
        END IF
        DO IEP=1,(NEPARC-1)/2+1
         TT(IEP)=TT((NEPARC-1)/2+IEP)
         TT((NEPARC-1)/2+IEP)=0.D0
         DO ISV=1,NPEPSV
            IF(IPEPSV(ISV).GT.0.AND.IPEPSV(ISV).LE.136) THEN
           IPRN=IPEPSV(ISV)
             X(IEP,IPRN)=X((NEPARC-1)/2+IEP,IPRN)
             Y(IEP,IPRN)=Y((NEPARC-1)/2+IEP,IPRN)
             Z(IEP,IPRN)=Z((NEPARC-1)/2+IEP,IPRN)
             DT(IEP,IPRN)=DT((NEPARC-1)/2+IEP,IPRN)
             X((NEPARC-1)/2+IEP,IPRN)=0.D0
             Y((NEPARC-1)/2+IEP,IPRN)=0.D0
             Z((NEPARC-1)/2+IEP,IPRN)=0.D0
             DT((NEPARC-1)/2+IEP,IPRN)=0.D0
          END IF
         END DO
        END DO
        NEPARC=(NEPARC-1)/2+1
        NEPREAD=INTARCH/IPEPINT          
        END DO
      DO ISV=1,NPEPSV
         IF(IPEPSV(ISV).GT.0.AND.IPEPSV(ISV).LE.136)
     &         NBARC(IPEPSV(ISV))=NBARC(IPEPSV(ISV))+NEWARC
      END DO
      END IF
C
 1000 FORMAT (20X,'SATELLITE ARC CHECK - POLYNOMIAL FIT RESIDUALS',/,
     &        ' PRN # ARC #  START     END         X (m.)     Y (m.)',
     &        '    Z (m.)     CLK (nsec.)',/ )
 1010 FORMAT (' ------------------------------------------------',
     &        '-------------------------------',/,
     &    20X,' ORBIT COMPARISON - PRECISE .vs. BROADCAST',/,
     &        '   PRECISE ORBIT FIT (6 HR ARCS) ',
     &        '       PRECISE/BROADCAST DIFFERENCES ',/,
     &    35X,'    SATELLITE XYZ      SATELLITE CLOCK',/,
     &        ' PRN #   1       2       3       4 ',
     &        '  NB    AVG     RMS   NB    AVG     RMS ',/,
     &        '        (m)     (m)     (m)     (m)',
     &        '        (m)     (m)         (m)     (m) ',/, 
     &        ' ------------------------------------------------',
     &        '-------------------------------')
 1020 FORMAT (' SATELLITE PRN ',I2,' REJECTED ON POLYNOMIAL FIT',F10.1)
 1050 FORMAT (F8.2,$)
 1100 FORMAT (2(I3,2X),2(2X,I2,':',I2,':',F3.0),4F10.2)
 1200 FORMAT (2(I4,2F8.2))
 1250 FORMAT(6F5.1,$)
 1300 FORMAT (I3,4A8,A40 )
 1350 FORMAT (I3,A32,A40 )
 1400 FORMAT ('*** BROADCAST & PRECISE CLOCKS DISAGREE,',
     &        ' CHANGING CLOCK SIGN ***')
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** FITXYZ
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE FITXYZ ( LPR, TTAG, ISV, IARC, NDEG, TB, TE,
     &                    CX, CY, CZ,     SVXYZ, SVVEL,
     &                    IPRN, DSVZ )
C
C     NAME            FITXYZ
C
C     PURPOSE         COMPUTE SATELLITE XYZ COORDINATES AND CLOCK
C                 OFFSET FROM POLYNOMIAL COEFFICIENTS
C
C     PARAMETERS      DESCRIPTION
C
C      LPR            LOGICAL UNIT OF PRINTER
C      TTAG           GPS TIME TAG
C      NDEG           DEGREE OF POLYNOMIAL FOR ARC
C      TB             ARC START TIME
C      TE             ARC END TIME
C      CX             POLYNOMIAL COEFFICIENTS FOR X COORDINATE
C      CY             POLYNOMIAL COEFFICIENTS FOR Y COORDINATE
C      CZ             POLYNOMIAL COEFFICIENTS FOR Z COORDINATE
C        DT           PRECISE SATELLITE CLOCK OFFSETS AT 15 MINUTE EPOCH  
C      SVXYZ          SATELLITE XYZ COORDINATES
C        SVVEL       SATELLITE XYZ VELOCITY
C      SVDT           SATELLITE CLOCK OFFSET
C        IPRN         SATELLITE PRN NUMBER
C        DSVZ         SATELLITE Z OFFSET
C
C *********************************************************************
C
C
      IMPLICIT NONE
C
      INCLUDE  'MAXDIM'
C
      INTEGER*4 LPR 
      INTEGER*4 ISV,    IARC,   IPRN
      INTEGER*4 NDEG(MAXSAT,MAXARC)
C
      REAL*8  TTAG
      REAL*8  TB(MAXSAT,MAXARC),     TE(MAXSAT,MAXARC)
      REAL*8  CX(MAXSAT,MAXARC,MAXDEG),  CY(MAXSAT,MAXARC,MAXDEG)
      REAL*8  CZ(MAXSAT,MAXARC,MAXDEG)
      REAL*8  SVXYZ(3),     SVVEL(3)
      REAL*8  DSVZ(*)
C
      REAL*8    SVVEC
C
      CALL CHBXYZ ( TTAG , ISV, IARC, NDEG, TB, TE,
     &                  CX, CY, CZ, SVXYZ, SVVEL )
c!    WRITE(*,*) 'IN FITXYZ - BODY coordinates'
c!    WRITE(*,'(A3,I2.2,1X,A18,4F14.2)') 'PRN',IPRN,
c!   &                   'X, Y, Z, CLK (m)',SVXYZ(1),SVXYZ(2),SVXYZ(3),
c!   &                    DSVZ(IPRN)
C
C     APPLY OFFSET TO GET SATELLITE COORDINATES AT PHASE CENTER
C     ( BLOCK II = 102.3 CM., BLOCK IIR = 0.0 CM. )
C
      SVVEC = DSQRT(SVXYZ(1)**2 + SVXYZ(2)**2 + SVXYZ(3)**2)
      IF (DSVZ(IPRN).NE. 0.D0) THEN 
        SVXYZ(1) = SVXYZ(1)*(1.D0-DSVZ(IPRN)/SVVEC)
        SVXYZ(2) = SVXYZ(2)*(1.D0-DSVZ(IPRN)/SVVEC)
        SVXYZ(3) = SVXYZ(3)*(1.D0-DSVZ(IPRN)/SVVEC)
      END IF
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** FLTDF
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE FLTDF ( IPC, IPRN, TTAG, PR1, PR2, CA1, P1, P2,
     &                   FLTSUM, DMAXNL, DMAXWL, DMAXTM, DMAXAM,
     &                   LFIXNL, LFIXWL, DMXNLFIX, DMXWLFIX,
     &                   IFLTOP, IQLTY, IFLAG, FLTPR, FLTCP, VARFLT,
     &                   IRJCT, ICSLIP, IDIR, OBSINT, IFLTON, el ,
     &                   I, AVGNL, AVGWL,
     &                   DP1P2,
     &                   STADCB, IFREQ )
C
C     NAME              FLTOBS
C
C     PURPOSE   FILTER PSEUDO-RANGES WITH CARRIER PHASE
C
C     PARAMETERS        DESCRIPTION
C        TTAG   OBSERVATION TIME TAG
C        PR1            P-CODE PSEUDO-RANGE ON L1 (m)
C        PR2            P-CODE PSEUDO-RANGE ON L2 (m)
C          CA1          CA-CODE PSEUDO-RANGE ON L1(M)
C        P1             CARRIER PHASE ON L1 (cycles)
C        P2             CARRIER PHASE ON L2 (cycles)
C          FLTSUM(1)    NUMBER OF SAMPLES INCLUDED IN FILTER
C        FLTSUM(2)      TIME TAG OF LAST OBSERVATION
C        FLTSUM(3)      L1 PSEUDO-RANGE OF LAST OBSERVATION
C        FLTSUM(4)      L2 PSEUDO-RANGE OF LAST OBSERVATION
C        FLTSUM(5)      L1 CARRIER PHASE OF LAST OBSERVATION
C        FLTSUM(6)      L2 CARRIER PHASE OF LAST OBSERVATION
C          FLTSUM(7)    CA PSEUDO-RANGE OF LAST OBSERVATION
C          FLTSUM(8)    AMBIGUITY OF INITIAL SATELLITE RANGE 
C          FLTSUM(9)    FILTERED CORRECTION TO INITIAL SATELLITE RANGE 
C          FLTSUM(10)    SUM OF IONOSPHEIC CARRIER/CODE DIFFERENCES FROM INITIAL
C          FLTSUM(11)   SUM OF AMBIGUITIES
C          FLTSUM(12)   LAST CORRECTION TO AMBIGUITY
C          FLTSUM(13)   INITIAL L3 PHASE(POSSIBLY WITH INTEGER L1,L2) M
C          FLTSUM(14)   EL  - EPOCH EL ANGLE(DEG)
C          FLTSUM(15)   ELP - PREVIOUS EPOCH EL ANGLE(DEG)
C          FLTSUM(16)   INPUT NL TRK LIMIT - DMAXNL (M)
C          FLTSUM(17)   INPUT WL TRK LIMIT - DMAXWL (M)
C          FLTSUM(18)   PREVIOUS TIME EPOCH TTAG (S) 
C          FLTSUM(19)   INITIAL EL ANGLE WEIGHT (see SINEL)            
C          FLTSUM(16)   INPUT NL TRK LIMIT - DMAXNL (M)
C          FLTSUM(20)   SUM OF THE EPOCH  L1 INIT.(L1-PR1+2P1iono)( M)    
C          FLTSUM(21)   SUM OF THE EPOCH  L2 INIT.(L2-PR2+2P2iono)( M)    
C          FLTSUM(22)   SUM OF WL (WIDE LANES) (WL CY)         
C          FLTSUM(23)   SQ SUM OF WL DIFF FROM MEAN (WL CY )^2 
C          FLTSUM(24)   SUM OF (L1-L2)-(P1-P2) IN M FOR VTECs       
C        DMAXNL MAXIMUM NARROWLANE VARIATION BETWEEN OBSERVATION EPOCHS
C        DMAXWL MAXIMUM WIDELANE VARIATION BETWEEN OBSERVATION EPOCHS 
C        DMAXTM MAXIMUM TIME BETWEEN OBSERVATION EPOCHS
C          DMAXAM       MAXIMUM CARRIER PHASE AMBIGUITY
C          LFIXNL       FIXED OR ADAPTIVE NARROWLANE LIMIT
C          LFIXWL       FIXED OR ADAPTIVE WIDELANE LIMIT
C          DMAXNLFIX    ORIGINAL MAXIMUM NARROWLANE LIMIT
C          DMAXWLFIX    ORIGINAL MAXIMUM WIDELANE LIMIT
C        IFLTOP       FILTER OPTION (1=P-L1,2=P-L2,3=L3,4=ION, 5=CA-L1)
C        IQLTY  QUALITY OF FILTERED OBSERVATION
C        IFLAG  FILTER OUTPUT FLAG
C                       0     ( DELTA_TIME == 0.0 )                 
C                       1     ( DELTA_TIME <  0.0 )                 
C                       4     ( P1 == P2 )                          
C                       5     ( DELTA_TIME   > MAX_TIME  )          
C                       6     ( DELTA_ION    > MAX_ION   )          
C                       7     ( DELTA_WLANE  > MAX_WLANE )          
C                       8     ( QUALITY > 9 )
C          IRJCT        REJECT FLAG (0=NO, 1=YES)
C          ICSLIP       CYCLE SLIP FLAG (0=NO, 1=YES)
C          IDIR         DIRECTION OF TIME (1=FORWARD,-1=REVERSE)
C
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
C      
      INTEGER*4 IPC,IPRN,IFLTOP,IQLTY,IFLAG,IRJCT,ICSLIP,IDIR,IFLTON
      REAL*8    TTAG,PR1,PR2,CA1,P1,P2,FLTSUM(*),DMAXNL,DMAXWL
     &         ,DMXNLFIX, DMXWLFIX
C RUNNING AVERAGE OVER WLAVG EPOCHS!
     &         , WLAVG
      LOGICAL*4 LFIXNL, LFIXWL
      REAL*8    DMAXTM,DMAXAM,FLTPR,FLTCP,VARFLT,OBSINT
C
      REAL*8    C,F1,F2,AL1,AL2,AL3,F1S,F2S,F12S,F1ION,F2ION
      REAL*8    F1IONP,F2IONP,DIFRNG,DTIME,CURNL,OLDNL,DIFNL
      REAL*8    DIFWL,ONEMS,DIFCP,DELTA,CURCP,OLDCP
      REAL*8    CURRNG,OLDRNG,ONEUS           
      REAL*8    EL, SINEL
       INTEGER*4 I
       INTEGER*4 IFREQ
       REAL*8 AVGNL, AVGWL
     &       , DP1P2
     &       , STADCB(*)
      REAL*8 MXNLUSE, MXWLUSE
      REAL*8 LOWNL,HIHNL,LOWWL,HIHWL
C
C RECOVER GOCE PHASE AMB OF 2^20/3 between 1.5 RNX FILES
      REAL*8   GOCEAMB, DP1, DP2
      REAL*8  ELP
      REAL*8 FRACYCLE
      REAL*8 AL4
      DATA FRACYCLE / 0.15D0 /
      DATA LOWNL,HIHNL,LOWWL,HIHWL / 0.016D0,0.400D0,0.520D0,2.600D0/
      GOCEAMB = 2.d0**20/3.d0
      DP1= 0.d0
      DP2= 0.d0
C
      IRJCT   = 0
      ICSLIP  = 0
      IFLAG=0
      C       = 299792458.0D0
      F1      = 1575.42D+06
      F2      = 1227.60D+06
      AL1     = C/F1
      AL2     = C/F2
      AL3     = C/(F1-F2)
      F1S     = F1*F1
      F2S     = F2*F2
      F12S    = F1S - F2S
      F1ION   = F2S / F12S
      F2ION   = F1S / F12S
      CALL FREQ12( IPRN, F1, F2, F1S, F2S, F12S, F1ION, F2ION,
     &                   AL1, AL2, AL4, AL3, IFREQ )
      F1IONP=F1ION*AL2
      F2IONP=F2ION*AL1
      ONEMS=C*1.D-3
      ONEUS=C*1.D-6
      DIFCP=0.0D0
      DELTA=0.0D0
C
C     CHECK IF SINGLE FREQUENCY DATA 
C
      DTIME=OBSINT
      DIFRNG = PR2- PR1
      IF (FLTSUM(1) .NE. 0.0D0) THEN
        DTIME  = (TTAG - FLTSUM(2))*IDIR
      END IF
c!    WRITE(*,*) 'IN FLTOBS-DTIME=TTAG-FLTSUM(2)*IDIR',
c!   &            DTIME,TTAG,FLTSUM(2),IDIR
C     
C     SINGLE FREQUENCY: RETURN P1 
C
      IF ( DABS(DIFRNG) .GT. 1000.0 .OR.
     &                 PR2 .EQ. 0.0D0 .OR. P2 .EQ. 0.0D0
     &     .OR. PR1. EQ. 0.D0.OR.P1.EQ.0.D0.OR.ABS(PR2-PR1).GT.2.D2)THEN
        IFLAG = 4
        IQLTY = 0
        IRJCT = 1
        FLTPR = 0.D0
        FLTCP = 0.D0
        IF ( IFLTOP .NE. 4 ) THEN
          FLTPR = PR1
          FLTCP = PR1
        END IF
        ICSLIP= 1
        FLTSUM(1)=0.0D0
        FLTSUM(MAXFLT)=0.0D0
       RETURN
      END IF
C
C     FIRST OBSERVATION: INITIALIZE FILTER
C
      IF (FLTSUM(1) .EQ. 0.0D0) THEN
c!      WRITE(*,*) 'IN FLTOBS CALL FLTINI FOR PRN',IPRN
        CALL FLTINI ( IPC, TTAG, PR1, PR2, CA1, P1, P2, FLTSUM, IFLTOP,
     &                     IQLTY, IPRN, FLTPR, DP1P2, STADCB, IFREQ )
C ONLY IN FWD, BWD USING FWD AMB
C
          ICSLIP = 1
C
        FLTSUM(MAXFLT) = 
     &    +P2*AL2-P1*AL1+PR2-PR1
        FLTCP = FLTSUM(13)
        FLTSUM(19)=1.D0
        IF(el.gt.0.d0.and.el.le.90.d0) THEN
          FLTSUM(14)=EL
          FLTSUM(18)=TTAG
         FLTSUM(19)= sqrt(DABS(sin(el/57.296d0)))
        ENDIF
        FLTSUM(15)=0.d0
        FLTSUM(16)=DABS(DMAXNL)   
        FLTSUM(17)=DABS(DMAXWL)   
        RETURN
      END IF
C     
C     IF TIME INCREMENT IS 0.0 SET FLAGS BIT AND RETURN CRITICAL 
C     
      IF( DTIME .EQ. 0.0D0 ) THEN
        IFLAG = 1
        FLTPR= (F1S*PR1 - F2S*PR2)/(F1S-F2S) + FLTSUM(9) + FLTSUM(10)
        FLTCP = FLTSUM(13) + FLTSUM(9) + FLTSUM(10) 
        RETURN
      END IF
C                                                  
C     TIME INCREMENT IS NEGATIVE, INITIALIZE FILTER AND SET FLAG
C  
      IF( DTIME .LT. 0.0D0 ) THEN
        IFLAG = 1
        CALL FLTINI ( IPC, TTAG, PR1, PR2, CA1, P1, P2, FLTSUM, IFLTOP,
     &                     IQLTY, IPRN, FLTPR, DP1P2, STADCB, IFREQ )
        FLTSUM(MAXFLT) = 
     &    +P2*AL2-P1*AL1+PR2-PR1
        FLTCP = FLTSUM(13)
        FLTSUM(19)=1.0d0
        IF(el.gt.0.d0.and.el.le.90.d0) THEN
          FLTSUM(14)=EL
          FLTSUM(18)=TTAG
         FLTSUM(19)= sqrt(DABS(sin(el/57.296d0)))
        ENDIF
        FLTSUM(15)=0.d0
        FLTSUM(16)=DABS(DMAXNL)   
        FLTSUM(17)=DABS(DMAXWL)   
        RETURN
      END IF
C
C     SELECT LIMITS
C     BOTH NEGATIVE -> FIXED & NO CY FIXING
C     ONE NEGATIVE  -> GLOBAL ADAPTIVE
C     BOTH POSITIVE -> SAT SPECIFIC ADAPTIVE
C FOR ADAPTIVE LIMITS, CY FIXING DEPENDS ON INPUT VALUES
C
      MXNLUSE=MAX(FLTSUM(16),DMAXNL)
      MXWLUSE=FLTSUM(17)
      IF(LFIXNL .AND. LFIXWL) THEN
        MXNLUSE=ABS(DMXNLFIX)
        MXWLUSE=ABS(DMXWLFIX)
      ELSE IF(LFIXNL .OR. LFIXWL) THEN
        MXNLUSE=ABS(DMAXNL)
        MXWLUSE=ABS(DMAXWL)
      ENDIF
      MXNLUSE=MIN(MAX(MXNLUSE,LOWNL),HIHNL)
      MXWLUSE=MIN(MAX(MXWLUSE,LOWWL),HIHWL)
C 
C     TIME INCREMENT IS POSITIVE, TRY FILTER 
C
      IF ( DTIME .GT. 0.0D0 ) THEN
C
             CURNL   = ( P2*AL2    - P1*AL1)
         OLDNL   = ( FLTSUM(6)*AL2    - FLTSUM(5)*AL1)
         DIFNL = CURNL - OLDNL      
         DIFWL = ( P1 -  P2 )*AL3 - ( FLTSUM(5) -  FLTSUM(6) )*AL3 
     &  - (PR1*F1+PR2*F2)/(F1+F2)+(FLTSUM(3)*F1+FLTSUM(4)*F2)/(F1+F2)
c!     WRITE(*,'(A20,6F10.2)')  'in FLTOBS DIFWL',TTAG,DIFWL
C
C        TOLERANCE FAILURE: RE-INITIALIZE
C
          ELP = (EL-FLTSUM(14))*(TTAG-FLTSUM(18))*FLTSUM(14)*FLTSUM(18)
          IF(EL.NE.0.0.AND.ELP.NE.0.D 0) THEN
            ELP= (EL-FLTSUM(14))/(TTAG-FLTSUM(18))
            FLTSUM(18)=TTAG
            FLTSUM(14)=EL
            FLTSUM(15)=ELP
          ENDIF
          IF(FLTSUM(18).NE.0.D0.AND.FLTSUM(14).EQ.0.D0) THEN
            FLTSUM(18)=TTAG
            FLTSUM(14)=EL
          ENDIF
          ELP=FLTSUM(15)
C
           sinel=1.d0
        if(el.gt.0.d0.and.el.le.90.d0) then
         sinel= sqrt(DABS(sin(el/57.296d0)))
            IF(FLTSUM(19).EQ.1.D0) FLTSUM(19)= SINEL
        DIFNL = DIFNL-( STADCB(2)*40.309D15*0.87253*sin(EL/28.638)/(1.D0  
     & -0.87253*(1.D0-sinel**4))**1.5*ELP/57.296 -STADCB(5)*80.618D15/
     &  sqrt(1.D0-0.87253*(1.D0-sinel**4)))*DTIME*IDIR*(1./F2S-1./F1S)/2
        endif
           difnl= difnl*sinel
           difwl= difwl*sinel
C CONSIDER NOISIER GLONASS PR!
           IF(IPRN.GT.32.AND.IPRN.LE.64) difwl=difwl/2.d0
         IF( DABS(DIFNL) .GT. MXNLUSE   .OR.
     &       DABS(DIFWL) .GT. MXWLUSE
     &         .OR. DTIME .GT. DMAXTM )  THEN
C
C DO NOT REJECT SMALL  WHEN CONSISTENT WITH AVERAGES
C
          IF (DTIME .LE. DMAXTM .AND.
     &        DABS(DIFNL).LE.0.1D0.AND.DABS(DIFWL).LE.0.9D0) THEN
           IF(DABS(DIFNL-AVGNL*SINEL).LE.MXNLUSE.AND.
     &        DABS(DIFWL-AVGWL*SINEL).LE.MXWLUSE) GO TO 10
C AVERAGE 1st VALUE REGARDLESS
           IF(I.EQ.1) THEN    
            AVGNL= (AVGNL*(I  ) + DIFNL/sinel)/(I+1)
            AVGWL= (AVGWL*(I  ) + DIFWL/sinel)/(I+1)
           ENDIF 
          ENDIF
C ******************
C CHECK IF CONSTANT NL & WL ARE ASKED FOR (FLTPAR(14),15 > 1000 cm)
C CY slip recovery
C ACCOUNT FOR GLONASS
           IF(IPRN.GT.32.AND.IPRN.LE.64) difwl=difwl*2.d0
            DP1= (difnl*al3+difwl*al2)/(al2-al1)/al3/sinel 
            DP2= (difnl*al3+difwl*al1)/(al2-al1)/al3/sinel  
C CHECK FOR THE GOCE 2^20/3 PHASE "AMBIGUITY"
       IF(ABS(DP1).GT.349.5d3.OR.ABS(DP2).GT.349.5d3) THEN
          IF(ABS(DP1-INT(ABS(DP1)/GOCEAMB+2.d-5)*GOCEAMB*DP1/ABS(DP1))
     &       .LT.12.D0) THEN
          IF(ABS(DP2-INT(ABS(DP2)/GOCEAMB+2.d-5)*GOCEAMB*DP2/ABS(DP2))
     &       .LT.12.D0) THEN
c!    write(*,*)"IPRN",IPRN,"# OF GOCE 2^20/3 L1&L2 PHASE AMBs: "
c!   &           ,DP1/GOCEAMB,DP2/GOCEAMB
           DP1=INT(ABS(DP1)/GOCEAMB+2.d-5)*GOCEAMB*DP1/ABS(DP1)
           DP2=INT(ABS(DP2)/GOCEAMB+2.d-5)*GOCEAMB*DP2/ABS(DP2)
           DIFNL= DIFNL + (DP1*AL1-DP2*AL2)*SINEL
           DIFWL= DIFWL + (DP2-DP1)*AL3*SINEL
           IF(IPRN.GT.32.AND.IPRN.LE.64) difwl=difwl/2.d0
           IF(DABS(DIFNL-AVGNL*SINEL).LE.MXNLUSE.AND.
     &        DABS(DIFWL-AVGWL*SINEL).LE.MXWLUSE) THEN
             FLTSUM(5) = FLTSUM(5) + DP1
             FLTSUM(6) = FLTSUM(6) + DP2
             FLTSUM(MAXFLT) = FLTSUM(MAXFLT)-(DP1*AL1-DP2*AL2)*FLTSUM(1)
             GO TO 10
           ENDIF
C UNDO GOCEAMB NOT RECOVERED
           IF(IPRN.GT.32.AND.IPRN.LE.64) difwl=difwl*2.d0
           DIFNL= DIFNL - (DP1*AL1-DP2*AL2)*SINEL
           DIFWL= DIFWL - (DP2-DP1)*AL3*SINEL
          ENDIF
          ENDIF
       ENDIF
C END OF GOCE AMB RECOVERY
C
C USE CONSTANT NL/WL WHEN INPUT LIMITS(DMXNLFIX,DMXWLFIX) < 0
      IF(LFIXNL.AND.LFIXWL)  THEN
        IF(DABS(DIFNL-AVGNL*SINEL).LE.MXNLUSE
     &     .AND.DABS(DIFWL-AVGWL*SINEL).LE.MXWLUSE
     &     .AND. DTIME .LE. DMAXTM ) THEN
          GO TO 10
        ELSE
C FLAG CY SLIP !
        GO TO 20
        ENDIF
      ENDIF
C
C INTEGER CY SLIP RECOVERY ONLY WHEN ADAPT SIGMAS  (DMAX*/6).LT.1/10 CY*
C AND DTIME.LT. DMAXTM
C KEEPING THE SAT_SPECIFIC LIMITS TO TEST FEASABILITY OF CY FIXING
      IF(FLTSUM(16).LT.ABS(DMXNLFIX).AND.FLTSUM(17).LT.ABS(DMXWLFIX)
     &                          .AND. DTIME .LT. DMAXTM )  THEN
C WL CY RECOVERY P2-P1 (DP2 now)
       DP2=-(difwl            )/al3/sinel
C PROCEED ONLY IF WL DP2 is  INTEGER WITHIN +- 0.20 Cy
C AND DIFNL IS SUFFICIANTLY LARGE
        IF(ABS(DP2-INT(ABS(DP2)+FRACYCLE)*DP2/ABS(DP2)).LT.FRACYCLE.AND.
     &                        DABS(DIFNL-AVGNL*SINEL).GT.0.008D0 ) THEN
          IF(DP2.NE.0.D0)
     &    DP2=INT(ABS(DP2)+FRACYCLE)*DP2/ABS(DP2)
       DP1= (difnl-avgnl*sinel-DP2*AL2*sinel)/(AL2-AL1)/sinel
       DP2= DP1+DP2
           IF(IPRN.GT.32.AND.IPRN.LE.64) difwl=difwl/2.d0
C IF ABS DP1 and DP2.LT. 0.25 LIKELY NOT A SLIP, IGNORE!
          IF(ABS(DP1).LE.FRACYCLE.AND.ABS(DP2).LE.FRACYCLE) GO TO 10
C AND PROCEED IF DP1, DP2 are INTEGER WITHIN +- 0.25 Cy
          IF(ABS(DP1-INT(ABS(DP1)+FRACYCLE)*DP1/ABS(DP1)).LT.
     &                                             FRACYCLE) THEN
           IF(IPRN.GT.32.AND.IPRN.LE.64) difwl=difwl/2.d0
           IF(DP1.NE.0.D0)
     &    DP1=INT(ABS(DP1)+FRACYCLE)*DP1/ABS(DP1)
           IF(DP2.NE.0.D0)
     &    DP2=INT(ABS(DP2)+FRACYCLE)*DP2/ABS(DP2)
           DIFNL= DIFNL + (DP1*AL1-DP2*AL2)*SINEL
           DIFWL= DIFWL + (DP2-DP1)*AL3*SINEL
           IF(IPRN.GT.32.AND.IPRN.LE.64) difwl=difwl/2.d0
C IGNORE THE FALSE 9/7, 5/4 & 4/3 L1/L2 COMBOs! (NL=.004, 0.025 & .028 rep.) ETC
           IF(ABS(DP1*(AL2-AL1)-(DP1-DP2)*AL2).GT.0.032D0) THEN
C TO BE SAFE, USE MORE CONSERVATIVE NL LIMITS (3SIGMA RATHER THEN USUAL 6 SIGMA)
C AND INCREASE DMAXNL&WL FOR A GAP
C KEEPING THE SAT_SPECIFIC LIMITS TO TEST FEASABILITY OF CY FIXING
             IF(DABS(DIFNL-AVGNL*SINEL).LE.FLTSUM(16).AND.
     &          DABS(DIFWL-AVGWL*SINEL).LE.FLTSUM(17)) THEN
               write(*,*)"IPRN",IPRN," PHASE CY CORRECTED", DP1, DP2 
               FLTSUM(5) = FLTSUM(5) + DP1
               FLTSUM(6) = FLTSUM(6) + DP2
               FLTSUM(20) = FLTSUM(20) + DP1*AL1
               FLTSUM(21) = FLTSUM(21) + DP2*AL2
               FLTSUM(MAXFLT)=FLTSUM(MAXFLT)-(DP1*AL1-DP2*AL2)*FLTSUM(1)
               GO TO 10
             ENDIF
           ENDIF
C RESTORE ALL FOR PRINTING  & NEXT EPOCH 
           DIFNL= DIFNL - (DP1*AL1-DP2*AL2)*SINEL
           DIFWL= DIFWL - (DP2-DP1)*AL3*SINEL
           IF(IPRN.GT.32.AND.IPRN.LE.64) difwl=difwl/2.d0
          ENDIF
        ENDIF
      ENDIF
20    CONTINUE
C ************************************
          IF( IPC .GT. 0 )
     &    WRITE(*,'(A,1X,I03,11(1X,F9.5))') 'DIF NL WL TM',
     &         IPRN,DIFNL,DIFWL,DTIME,
     &         MXNLUSE,MXWLUSE,DMAXNL,DMAXWL,FLTSUM(16),FLTSUM(17),
     &         AVGNL,AVGWL
         IF ( DABS(DIFNL) .GT. MXNLUSE ) IFLAG = 6
         IF ( DABS(DIFWL) .GT. MXWLUSE ) IFLAG = 7    
         IF ( DTIME .GT. DMAXTM ) IFLAG = 5
           CALL FLTINI ( IPC, TTAG, PR1, PR2, CA1, P1, P2, FLTSUM,
     &               IFLTOP, IQLTY, IPRN, FLTPR, DP1P2, STADCB, IFREQ )
           FLTSUM(MAXFLT) = 
     &       +P2*AL2-P1*AL1+PR2-PR1
        FLTCP = FLTSUM(13)
         FLTSUM(19)=1.d0
        IF(EL.GT.0.d0.AND.EL.LE.90.D0)
     &   FLTSUM(19)= sqrt(DABS(sin(el/57.296d0)))
         ICSLIP=1
         RETURN
       END IF
10       CONTINUE
C adaptive tracking limits
        IF( DMAXNL .GT. 0.D0 )
     &  DMAXNL= 6.0d0*SQRT(((DMAXNL/6.0d0)**2*2000.d0+DIFNL**2)/2001.d0)
         FLTSUM(16)=SQRT((FLTSUM(16)**2*99+36*DIFNL**2)/100)
        FLTSUM(16)=MIN(MAX(MAX(FLTSUM(16),DMAXNL),LOWNL),HIHNL)
        IF( DMAXWL .GT. 0.D0 )
     &  DMAXWL= 6.0d0*SQRT(((DMAXWL/6.0d0)**2*2000.d0+DIFWL**2)/2001.d0)
         FLTSUM(17)=SQRT((FLTSUM(17)**2*99+36*DIFwL**2)/100)
        FLTSUM(17)=MIN(MAX(FLTSUM(17),LOWWL),HIHWL)
        difnl = difnl/sinel
        difwl = difwl/sinel
        AVGNL= (AVGNL*(I  ) + DIFNL)/(I+1)
        AVGWL= (AVGWL*(I  ) + DIFWL)/(I+1)
C IONO AVERAGED P2
C      
C        FILTERING P-L1 
C      
         IF ( IFLTOP .EQ. 1 ) THEN
            DIFCP = (P1 - FLTSUM(5))*AL1 - 2D0*F1ION*DIFNL
            DIFRNG = ( PR1 - FLTSUM(3) )
          DELTA = DIFRNG - DIFCP
         END IF
C      
C        FILTERING P-L2 
C      
         IF ( IFLTOP .EQ. 2 ) THEN
            DIFCP = ( P2 - FLTSUM(6))*AL2 - 2D0*F2ION*DIFNL
            DIFRNG = ( PR2 - FLTSUM(4) )
          DELTA = DIFRNG - DIFCP
         END IF
C
C        FILTERING L3 (IONOSPHERIC FREE COMBINATION) 
C
         IF ( IFLTOP .EQ. 3 ) THEN
          CURCP   = (F1S*P1*AL1 - F2S*P2*AL2) / F12S
          OLDCP   = (F1S*FLTSUM(5)*AL1 - F2S*FLTSUM(6)*AL2) / F12S
C L3 GLONASS CORRECTION (-0.0145(P1-P2))
          IF( IPRN.GT.32.AND.IPRN.LE.64 ) THEN
           CURCP = CURCP - 0.014478D0*(P1*AL1 - P2*AL2)
           OLDCP = OLDCP - 0.014478D0*(FLTSUM(5)*AL1 - FLTSUM(6)*AL2)
          ENDIF
          DIFCP   = CURCP - OLDCP
          CURRNG  = (F1S*PR1 - F2S*PR2) / F12S
          OLDRNG  = (F1S*FLTSUM(3) - F2S*FLTSUM(4)) / F12S
          DIFRNG = CURRNG - OLDRNG
          DELTA = DIFRNG - DIFCP
         END IF
C      
C        FILTERING L4 (IONOSPHERIC DELAY) 
C            
c!       WRITE(*,*) 'IN FLTOBS-IFLTOP',IFLTOP
         IF ( IFLTOP .EQ. 4 ) THEN
            DIFCP  = -DIFNL
            CURRNG = PR2- PR1 
          OLDRNG = FLTSUM(4)- FLTSUM(3) 
          DIFRNG = CURRNG - OLDRNG
          DELTA  = DIFRNG - DIFCP
c!        WRITE(*,*) 'IN FLTOBS',DIFCP,DIFRNG,DELTA
        END IF
C      
C        FILTERING CA-L1 
C      
         IF ( IFLTOP .EQ. 5 ) THEN
            DIFCP = (P1 - FLTSUM(5))*AL1 - 2D0*F1ION*DIFNL
            DIFRNG = ( CA1 - FLTSUM(7) )
          DELTA = DIFRNG - DIFCP
         END IF
C      
         FLTSUM(1) = FLTSUM(1) + 1
         FLTSUM(2) = TTAG
         FLTSUM(3) = PR1
         FLTSUM(4) = PR2
         FLTSUM(5) = P1
         FLTSUM(6) = P2
         FLTSUM(7) = CA1
         FLTSUM(10) = FLTSUM(10) + DIFCP
         FLTSUM(11)= FLTSUM(11) + DELTA
         FLTSUM(12) = (FLTSUM(11)-FLTSUM(9))/FLTSUM(1)
C L1-L2 AMB (L1-L2-(P1-P2)) SUM IN FLTSUM(MAXFLT)
         FLTSUM(MAXFLT) = FLTSUM(MAXFLT)+ CURNL + PR2 - PR1
      WLAVG=FLTSUM(1)
      IF(FLTSUM(1).GT.36) WLAVG=36.D0
      FLTSUM(22) =( FLTSUM(22)*(WLAVG    -1) +
     &((P1-P2-fltsum(20)/al1+fltsum(21)/al2)
     &*c/(f1-f2)-(f1*pr1+f2*pr2)/(f1+f2))/AL3)/WLAVG
C
      END IF
C
c!    WRITE(*,'(A6,I2.2,6F15.3)') 'FLTOBS',IPRN,FLTSUM(8),FLTSUM(9),
c!   &                                 FLTSUM(10),
c!   &                                 FLTSUM(12), FLTSUM(11), DELTA
C
C     CHECK THAT CARRIER PHASE AMBIGUITY IS BELOW TOLERANCE DMAXAM
C
c!    WRITE(*,*) 'IN FLTOBS FLTSUM(9), DMAXAM',FLTSUM(9),DMAXAM
      IF( DABS(FLTSUM(9)*FLTSUM(19)) .GT. DMAXAM ) THEN
        IFLAG = 8
        write(*,*)"DMAXAM" , IPRN, FLTSUM(9), FLTSUM(19), DMAXAM
c!      WRITE(*,*) 'IN FLTOBS CALL FLTINI FOR
c!   &  PRN',IPRN,FLTSUM(9),DMAXAM
        CALL FLTINI ( IPC, TTAG, PR1, PR2, CA1, P1, P2, FLTSUM,
     &                IFLTOP, IQLTY, IPRN, FLTPR, DP1P2, STADCB, IFREQ )
        FLTSUM(MAXFLT) = 
     &    +P2*AL2-P1*AL1+PR2-PR1
        FLTCP = FLTSUM(13)
        FLTSUM(19)=1.d0
        IF(EL.GT.0.D0.AND.EL.LE.90)
     &   FLTSUM(19)= sqrt(DABS(sin(el/57.296d0)))
        IRJCT = 1
        ICSLIP= 1
        RETURN
      END IF
        IF(FLTSUM(9).NE.0.d0)
     &  DMAXAM= 4.4d0*SQRT(((DMAXAM/ 4.4d0)**2*2000.d0+
     &       (FLTSUM(9)*FLTSUM(19))**2)/2001.d0)
         FLTSUM(9)  = FLTSUM(9) + FLTSUM(12)
C
      FLTPR = FLTSUM(8) + FLTSUM(9) + FLTSUM(10)
      FLTCP = FLTSUM(13) + FLTSUM(10)
C correct iono trk when OBSINT.NE.UPDINT
        IF(el.gt.0.d0.and.el.le.90.d0.AND.EL.NE.FLTSUM(14)) THEN
         FLTSUM(18)=TTAG
         FLTSUM(14)= EL 
        ENDIF
      VARFLT = DABS(FLTSUM(12))
      IQLTY =  IDINT(VARFLT*10D0) + 1
C
C     USE UNFILTER DUAL-FREQUENCY CODE (0=YES,1=NO) 
C
      IF (IFLTON .EQ. 0) FLTPR= (F1S*PR1-F2S*PR2)/F12S     
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** FLTINI
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE FLTINI ( IPC, TTAG, PR1, PR2, CA1, P1, P2, FLTSUM, 
     &               IFLTOP, IQLTY, IPRN, OBSFLT, DP1P2, STADCB, IFREQ )
C
C     NAME              FLTINI
C
C     PURPOSE   INITIALIZE PSEUDO-RANGE FILTER
C
C     PARAMETERS        DESCRIPTION
C
C          LUO          LOGICAL UNIT OF OUTPUT 
C        TTAG   OBSERVATION TIME TAG
C        PR1            PSEUDO-RANGE ON L1
C        PR2            PSEUDO-RANGE ON L2
C        P1             CARRIER PHASE ON L1
C        P2             CARRIER PHASE ON L2
C          FLTSUM(1)    NUMBER OF SAMPLES INCLUDED IN FILTER
C        FLTSUM(2)      TIME TAG OF LAST OBSERVATION
C        FLTSUM(3)      L1 PSEUDO-RANGE OF LAST OBSERVATION
C        FLTSUM(4)      L2 PSEUDO-RANGE OF LAST OBSERVATION
C        FLTSUM(5)      L1 CARRIER PHASE OF LAST OBSERVATION
C        FLTSUM(6)      L2 CARRIER PHASE OF LAST OBSERVATION
C          FLTSUM(7)    CA PSEUDO-RANGE OF LAST OBSERVATION
C          FLTSUM(8)    INITIAL EPOCH PSEUDO-RANGE 
C          FLTSUM(9)    FILTERED CORRECTION TO INITIAL SATELLITE RANGE 
C          FLTSUM(10)    SUM OF IONOSPHEIC CARRIER/CODE DIFFERENCES FROM INITIAL
C          FLTSUM(11)   SUM OF AMBIGUITIES
C          FLTSUM(12)   LAST CORRECTION TO AMBIGUITY
C          FLTSUM(13)   INITIAL EPOCH CARRIER PHASE 
C          FLTSUM(13)   INITIAL L3 PHASE(POSSIBLY WITH INTEGER L1,L2) M
C          FLTSUM(14)   EL  - EPOCH EL ANGLE(DEG)
C          FLTSUM(15)   ELP - PREVIOUS EPOCH EL ANGLE(DEG)
C          FLTSUM(16)   INPUT NL TRK LIMIT - DMAXNL (M)
C          FLTSUM(17)   INPUT WL TRK LIMIT - DMAXWL (M)
C          FLTSUM(18)   PREVIOUS TIME EPOCH TTAG (S) 
C          FLTSUM(19)   INITIAL EL ANGLE WEIGHT (see SINEL)            
C          FLTSUM(16)   INPUT NL TRK LIMIT - DMAXNL (M)
C          FLTSUM(20)   SUM OF THE EPOCH  L1 INIT.(L1-P1+2P1iono)( M)    
C          FLTSUM(21)   SUM OF THE EPOCH  L2 INIT.(L2-P2+2P2iono)( M)    
C          FLTSUM(22)   SUM OF WL (WIDE LANES) (WL CY)         
C          FLTSUM(23)   SQ SUM OF WL DIFF FROM MEAN (WL CY )^2 
C          FLTSUM(24)   SUM OF (L1-L2)-(P1-P2) IN M FOR VTECs       
C        IFLTOP       FILTER OPTION (1=P-L1,2=P-L2,3=L3,4=ION,5=CA-L1)
C        IQLTY  QUALITY OF FILTERED OBSERVATION
C
C *********************************************************************
      IMPLICIT NONE
C
      INTEGER*4 IPC,IFLTOP,IQLTY
      INTEGER*4 IFREQ
     &         , IPRN
      REAL*8    TTAG,PR1,PR2,CA1,P1,P2,FLTSUM(*),OBSFLT 
     &      ,   DP1P2, STADCB(*)
      REAL*8    F1,F2,F1S,F2S,RNGDIF
      REAL*8    C, AL1, AL2
C
      REAL*8 F12S, F1ION, F2ION, AL3, AL4
      F1   = 1575.42D+06
      F2   = 1227.60D+06
      F1S  = F1*F1
      F2S  = F2*F2
      C    = 299792458.D0
      AL1  = C/F1
      AL2  = C/F2
      CALL FREQ12( IPRN, F1, F2, F1S, F2S, F12S, F1ION, F2ION,
     &                   AL1, AL2, AL3, AL4 , IFREQ)
C
      IQLTY = 10
      RNGDIF =  PR2 - PR1
      IF ( RNGDIF .EQ. 0.0 ) IQLTY = 0
      FLTSUM(1) = 1.0D0
      FLTSUM(2) = TTAG
      FLTSUM(3) = PR1
      FLTSUM(4) = PR2
      FLTSUM(5) = P1
      FLTSUM(6) = P2
      FLTSUM(7) = CA1
      FLTSUM(8) = 0.0D0
      FLTSUM(9) = 0.0D0
      FLTSUM(10)= 0.0D0
      FLTSUM(11)= 0.0D0
      FLTSUM(12)= 0.0D0
      IF ( IFLTOP .EQ. 1 ) FLTSUM(13) = P1*AL1
      IF ( IFLTOP .EQ. 2 ) FLTSUM(13) = P2*Al2
C INITILIZE L1 L2 INTEGE CYCLES OF P1-PR1 & P2-PR2 IN M 
      FLTSUM(20)=DINT(-(PR1-2.D0*F2S*RNGDIF/(F1S-F2S))/AL1+P1)*AL1
      FLTSUM(21)=DINT(-(PR1 -F2S*RNGDIF/(F1S-F2S)
     & -F1S*RNGDIF/(F1S-F2S))/AL2+P2)*AL2
C THE INITIAL L3-P3 DIFFERENCE (M)
      FLTSUM(22) =
     &((P1-P2-fltsum(20)/al1+fltsum(21)/al2)
     &*c/(f1-f2)-(f1*pr1+f2*pr2)/(f1+f2)
     &)*(f1-f2)/c
C start WL sig with 1 WL cycle
        FLTSUM(23)= 1.D0
      IF ( IFLTOP .EQ. 3 ) FLTSUM(13) =
     &        (F1S*(P1*AL1-FLTSUM(20)) 
     &       - F2S*(P2*AL2-FLTSUM(21)))/(F1S-F2S)
      IF ( IFLTOP .EQ. 4 ) FLTSUM(13) = P1 - P2
      IF ( IFLTOP .EQ. 5 ) FLTSUM(13) = P1
      IF ( IFLTOP .EQ. 1 ) FLTSUM(8) = PR1
      IF ( IFLTOP .EQ. 2 ) FLTSUM(8) = PR2
      IF ( IFLTOP .EQ. 3 ) FLTSUM(8) = (F1S*PR1 - F2S*PR2)/(F1S-F2S)
      IF ( IFLTOP .EQ. 4 ) FLTSUM(8) = PR2 - PR1
      IF ( IFLTOP .EQ. 5 ) FLTSUM(8) = CA1
      OBSFLT = FLTSUM(8)
c!    WRITE(*,*) 'IN FLTINI OBSFLT',OBSFLT
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** FLTOBS
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE FLTOBS ( IPC, IOBTYP, IFREQ, IDIR, IPRN,
     &                   TTAG, PR1, PR2, CA1, P1, P2, SDPR, PN,
     &                   FLTSUM, DMAXNL, DMAXWL, DMAXTM, DMAXAM,
     &                   LFIXNL, LFIXWL, DMXNLFIX, DMXWLFIX,
     &                   IFLTOP, IQLTY, IFLAG, FLTPR, FLTCP, VARFLT,
     &                   IRJCT, ICSLIP, OBSINT, IFLTON, el,
     &                   I, AVGNL, AVGWL,
     &                   DP1P2,
     &                   STADCB )
C
C       NAME            FLTOBS
C
C     PURPOSE   FILTER PSEUDO-RANGE WITH CARRIER PHASE
C                       AND DETECT CYCLE SLIPS AND MILLISECOND JUMPS
C
C     PARAMETERS        DESCRIPTION
C
C          LPR          LOGICAL UNIT OF PRINTER
C          IOBTYP       OBSERVATION TYPE PROCESSED (1=CODE, 2=CODE/PHASE)
C          IFREQ        FREQUENCY PROCESSED (1=L1,2=L2,3=L3)
C          IDIR         DIRECTION OF PROCESSING (1=FWD,2=BWD)
C          IPRN         SATELLITE PRN NUMBER
C        TTAG   OBSERVATION TIME TAG
C        PR1            P-CODE PSEUDO-RANGE ON L1 (m)
C        PR2            P-CODE PSEUDO-RANGE ON L2 (m)
C          CA1          CA-CODE PSEUDO-RANGE ON L1(M)
C        P1             CARRIER PHASE ON L1 (cycles)
C        P2             CARRIER PHASE ON L2 (cycles)
C          FLTSUM(1)    NUMBER OF SAMPLES INCLUDED IN FILTER
C        FLTSUM(2)      TIME TAG OF LAST OBSERVATION
C        FLTSUM(3)      L1 PSEUDO-RANGE OF LAST OBSERVATION
C        FLTSUM(4)      L2 PSEUDO-RANGE OF LAST OBSERVATION
C        FLTSUM(5)      L1 CARRIER PHASE OF LAST OBSERVATION
C        FLTSUM(6)      L2 CARRIER PHASE OF LAST OBSERVATION
C          FLTSUM(7)    CA PSEUDO-RANGE OF LAST OBSERVATION
C          FLTSUM(8)    AMBIGUITY OF INITIAL SATELLITE RANGE 
C          FLTSUM(9)    FILTERED CORRECTION TO INITIAL SATELLITE RANGE 
C          FLTSUM(10)   SUM OF CARRIER/CODE DIFFERENCES 
C          FLTSUM(11)   SUM OF AMBIGUITIES
C          FLTSUM(12)   LAST CORRECTION TO AMBIGUITY
C        DMAXNL MAXIMUM NARROWLANE VARIATION BETWEEN OBSERVATION EPOCHS
C        DMAXWL MAXIMUM WIDELANE VARIATION BETWEEN OBSERVATION EPOCHS 
C        DMAXTM MAXIMUM TIME BETWEEN OBSERVATION EPOCHS
C          DMAXAM       MAXIMUM VARIATION FROM INITIAL CARRIER PHASE AMBIGUITY
C          LFIXNL       FIXED OR ADAPTIVE NARROWLANE CYCLE SLIP DETECTION
C          LFIXWL       FIXED OR ADAPTIVE WIDELANE CYCLE SLIP DETECTION
C          DMXNLFIX     INPUT NARROWLANE CYCLE SLIP DETECTION
C          DMXWLFIX     INPUT WIDELANE CYCLE SLIP DETECTION
C        IFLTOP       FILTER OPTION (1=P-L1,2=P-L2,3=L3,4=ION, 5=CA-L1)
C        IQLTY  QUALITY OF FILTERED OBSERVATION
C        IFLAG  FILTER OUTPUT FLAG
C                       0     ( DELTA_TIME == 0.0 )                 
C                       1     ( DELTA_TIME <  0.0 )                 
C                       4     ( P1 == P2 )                          
C                       5     ( DELTA_TIME   > MAX_TIME  )          
C                       6     ( DELTA_ION    > MAX_ION   )          
C                       7     ( DELTA_WLANE  > MAX_WLANE )          
C                       8     ( QUALITY > 9 )
C          IRJCT        REJECT FLAG (0=NO, 1=YES)
C          ICSLIP       CYCLE SLIP FLAG (0=NO, 1=YES)
C          IDIR         DIRECTION OF TIME (1=FORWARD,-1=REVERSE)
C          IFLTON       CARRIER FILTER DUAL-FREQUENCY CODE (0=NO,1=YES)
C
C
C *********************************************************************
C
      IMPLICIT NONE
C      
      INTEGER*4 IPC,IPRN,IFLTOP,IQLTY,IFLAG,IRJCT,ICSLIP,IFREQ,IDIR
      INTEGER*4 IOBTYP, IFLTON
      REAL*8    TTAG,PR1,PR2,CA1,P1,P2,FLTSUM(*),DMAXNL,DMAXWL
      REAL*8    DMAXTM,DMAXAM,FLTPR,FLTCP,VARFLT,OBSINT
      REAL*8    CODE, PHASE
      REAL*8    SDPR, PN
      REAL*8    el
       INTEGER*4 I
       REAL*8 AVGNL, AVGWL
     &       ,DP1P2
     &       ,STADCB(*)
      LOGICAL*4 LFIXNL, LFIXWL
      REAL*8    DMXNLFIX, DMXWLFIX
C
      IF ( IFREQ .GE. 3 ) THEN
        CALL FLTDF ( IPC, IPRN, TTAG, PR1, PR2, CA1, P1, P2,
     &               FLTSUM, DMAXNL, DMAXWL, DMAXTM, DMAXAM,
     &               LFIXNL, LFIXWL, DMXNLFIX, DMXWLFIX,
     &               IFLTOP, IQLTY, IFLAG, FLTPR, FLTCP, VARFLT,
     &               IRJCT, ICSLIP, IDIR, OBSINT, IFLTON, el ,
     &               I, AVGNL, AVGWL, DP1P2, STADCB, IFREQ )
C
      ELSE
        IF ( IFREQ .EQ. 1 ) THEN
        CODE=PR1
        PHASE=P1
      ELSE
        CODE=PR2
        PHASE=P2
      END IF
C
        CALL FLTSF ( IPC, IPRN, IFREQ, IDIR, 
     &               TTAG, CODE, PHASE, SDPR, PN, FLTSUM, 
     &               DMAXWL, DMAXTM, IQLTY, IFLAG, 
     &               FLTPR, FLTCP, IRJCT, ICSLIP,
     &               IOBTYP, el, stadcb )
      END IF
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** FLTSF
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE FLTSF ( IPC, IPRN, IFREQ, IDIR, 
     &                   TTAG, CODE, PHASE, SDPR, PN, FLTSUM, 
     &                   DMAXDV, DMAXTM, IQLTY, IFLAG, 
     &                   FLTPR, FLTCP, IRJCT, ICSLIP,
     &                   IOBTYP, el, stadcb )
C     NAME              FLTSF
C
C     PURPOSE   FILTER SINGLE FREQUENCY OBSERVATIONS
C                       (PSEUDO-RANGES WITH CARRIER PHASE)
C
C     PARAMETERS        DESCRIPTION
C
C          IPRN         SATELLITE PRN NUMBER
C        TTAG   OBSERVATION TIME TAG
C        CODE         PSEUDO-RANGE OBSERVATION
C        PHASE  CARRIER PHASE OBSERVATION
C          FLTSUM(1)    NUMBER OF SAMPLES INCLUDED IN FILTER
C        FLTSUM(2)      TIME TAG OF LAST OBSERVATION
C        FLTSUM(3)      CODE OF LAST OBSERVATION
C        FLTSUM(4)      PHASE OF LAST OBSERVATION
C        FLTSUM(5)    AMBIGUITY OF INITIAL PHASE 
C          FLTSUM(6)    CODE/CARRIER DIVERGENCE FROM INITIAL EPOCH
C        DMAXDV MAXIMUM CODE/CARRIER DIVERGENCE BETWEEN EPOCHS
C        DMAXTM MAXIMUM TIME BETWEEN OBSERVATION EPOCHS
C        IQLTY  QUALITY OF FILTERED OBSERVATION
C        IFLAG  FILTER OUTPUT FLAG
C                       0     ( DELTA_TIME == 0.0 )                 
C                       1     ( DELTA_TIME <  0.0 )                 
C                       4     ( PHASE == P2 )                          
C                       5     ( DELTA_TIME   > MAX_TIME  )          
C                       6     ( DELTA_ION    > MAX_ION   )          
C                       7     ( DELTA_WLANE  > MAX_WLANE )          
C                       8     ( QUALITY > 9 )
C          IRJCT        REJECT FLAG (0=NO, 1=YES)
C          ICSLIP       CYCLE SLIP FLAG (0=NO, 1=YES)
C          IDIR         DIRECTION OF TIME (1=FORWARD,-1=REVERSE)
C
C
C *********************************************************************
C
      IMPLICIT NONE
C      
      INTEGER*4 IPC,IPRN,IFREQ,IDIR,IQLTY,IFLAG,IRJCT,ICSLIP,IOBTYP
      REAL*8    TTAG,CODE,PHASE,SDPR,PN,FLTSUM(*),DMAXDV,DMAXTM
      REAL*8    DCPPR,FLTPR, FLTCP
C 
      REAL*8    C,F1,F2,WL,PHASEM,DTIME,PNDT,P,DIFCP,DIFPR,ONEMS,VPR
      REAL*8   EL, STADCB(*), DCPPRT, ELP
      LOGICAL   ICODE, IPHASE
C
      VPR=SDPR*SDPR
      ICODE=.FALSE.
      IPHASE=.FALSE.
      IF ( CODE .GT. 2.0D2 ) ICODE=.TRUE.
      IF ( PHASE .NE. 0.0D0 ) IPHASE=.TRUE.
      IRJCT   = 0
      ICSLIP  = 0
      IFLAG   = 0
      C       = 299792458.0D0
      F1      = 1575.42D+06
      F2      = 1227.60D+06
C   GALILEO IF IPRN (64, 100> ! USE E5a (L5) INSTEAD OF L2
      IF(IPRN.GT.64.AND.IPRN.LE.100) F2= 1176.450D+06
C   BEIDOU (IPRN(100,132> ! USE B1 & B2
      IF(IPRN.GT.100.AND.IPRN.LE.136) THEN
       F1   = 1561.098D+06
       F2   = 1207.140D+06
      ENDIF
      ONEMS   = C*1.D-3
      DCPPR=0.D0
      DIFCP=0.D0
C
C     
C     NO CODE OR NO PHASE (IF CODE/PHASE PROCESSING)
C     SET REJECT FLAG AND RETURN 
C
      IF ( .NOT. ICODE .OR. 
     &           (IOBTYP .EQ. 2 .AND. .NOT. IPHASE) ) THEN
          IFLAG = 4
          IQLTY = 0
          IRJCT = 1
          FLTPR = 0.D0
          FLTCP = 0.D0
          RETURN
      END IF
C
      IF (IFREQ .EQ. 1 ) THEN
        WL     = C/F1
      ELSE
        WL     = C/F2
      END IF
      PHASEM = PHASE*WL
C
C     FIRST OBSERVATION: INITIALIZE FILTER
C
      IF (FLTSUM(1) .EQ. 0.0D0) THEN
        CALL IFLTSF ( IPC, TTAG, CODE, PHASEM, FLTSUM )
        FLTPR = CODE
        FLTCP = FLTPR
        FLTSUM(8)=TTAG
       IF(el.gt.0.d0.and.el.le.90.d0) FLTSUM(9)=EL  
        FLTSUM(10)=0.d0
        FLTSUM(11)= 0.                 
        FLTSUM(12)= 100.D0*DMAXDV**2
C IF THE FLT FILE DMAXDV TOO SMALL USE 3 m TO INITILIZE
        IF(DMAXDV.LT.3.0D0) FLTSUM(12)= 900.D0
        RETURN
      END IF
C      
      DTIME  = (TTAG - FLTSUM(2))*IDIR
C     
C     IF TIME INCREMENT IS 0.0 SET FLAGS BIT AND RETURN CRITICAL 
C     
      IF( DTIME .EQ. 0.0D0 ) THEN
        IFLAG = 1
        FLTPR = CODE
        FLTCP = FLTPR
        RETURN
      END IF
C                                                  
C     TIME INCREMENT IS NEGATIVE, INITIALIZE FILTER AND SET FLAG
C  
      IF( DTIME .LT. 0.0D0 ) THEN
        IFLAG = 1
        CALL IFLTSF ( IPC, TTAG, CODE, PHASEM, FLTSUM )
        FLTPR = CODE
        FLTCP = CODE
        FLTSUM(8)=TTAG
       IF(el.gt.0.d0.and.el.le.90.d0) FLTSUM(9)=EL  
        FLTSUM(10)=0.d0
        RETURN
      END IF
C 
C     IF POSITIVE TIME INCREMENT
C
      IF ( DTIME .GT. 0.0D0 ) THEN
C
C     IF CODE/CARRIER PROCESSING
C     APPLY FILTER TO DETECT CYCLE SLIPS        
C
        P     = 1.D0/VPR
          PNDT  = PN*DTIME
          DIFCP = (PHASEM - FLTSUM(4))
          DIFPR = (CODE  - FLTSUM(3))
          DCPPR = DIFPR - DIFCP
          IF ( PN .GT. 1.D-6 ) P= 1.D0/(FLTSUM(7)+PNDT) + 1.D0/VPR
       IF(EL.GT.0.D0.AND.EL.LE.90.D0.AND.FLTSUM(9).NE.0.D0) THEN
       ENDIF
          ELP = (EL-FLTSUM(9))*(TTAG-FLTSUM(8))*FLTSUM(8)*FLTSUM(9)
          IF(EL.NE.0.0.AND.ELP.NE.0.D 0) THEN
            ELP= (EL-FLTSUM(9))/(TTAG-FLTSUM(8))
            FLTSUM(8)=TTAG
            FLTSUM(9)=EL
            FLTSUM(10)=ELP
          ENDIF
          IF(FLTSUM(8).NE.0.D0.AND.FLTSUM(9).EQ.0.D0) THEN
            FLTSUM(9)=EL
            FLTSUM(8)=TTAG
          ENDIF
          ELP=FLTSUM(10)
C CORRECT FOR MEAN
          DCPPRT= DCPPR -FLTSUM(11)
       IF(EL.GT.0.D0.AND.EL.LE.90.D0.AND.FLTSUM(9).NE.0.D0) THEN
C ACCOUNT FOR IONO DIVERGENCE CHANGE BY USING RATES/DERIVATIVES
        IF(IFREQ.EQ.1)
     &  DCPPRT=(DCPPRT+(STADCB(2)*40.309D15*0.87253*sin(EL/28.638)/(1.D0  
     & -0.87253*cos(el/57.296)**2)**1.5*ELP/57.296 -STADCB(5)*80.618D15/
     &  sqrt(1.-0.87253*cos(el/57.296)**2))*DTIME*IDIR/F1/F1)/P/VPR 
        IF(IFREQ.EQ.2)
     &  DCPPRT=(DCPPRT+(STADCB(2)*40.309D15*0.87253*sin(EL/28.638)/(1.D0  
     & -0.87253*cos(el/57.296)**2)**1.5*ELP/57.296 -STADCB(5)*80.618D15/
     &  sqrt(1.-0.87253*cos(el/57.296)**2))*DTIME*IDIR/F2/F2)/P/VPR 
C ACCOUNT FOR PR ELEV WEIGHTING NORMILIED BY SIN(37DeG)=0.6018
          ELP= SQRT(sin(el/57.296D0)/0.6018D0)
          DCPPRT= DCPPRT*ELP                             
      ENDIF
          DCPPRT    = DCPPRT/P/VPR
          DCPPR     = DCPPR/P/VPR
c!        CALL TOWHMS( IWKDAY, TTAG, IHR, IMIN, SEC, 0 )
c!        WRITE(*,"(A10,A3,I2.2,2(I2,':'), F4.1,4F12.2)") 
c!   &                     'DIVERGENCE','PRN',
c!   &                      IPRN,IHR,IMIN,SEC,DIFCP,DIFPR,DCPPR
C      
C         CYCLE SLIP DETECTED - RESET FILTER SUMMATIONS
C
          IF( IOBTYP .EQ. 2 .AND.
     &      (DABS(DCPPRT) .GT.SQRT(FLTSUM(12)/(FLTSUM(1)+100)) .OR.
     &        DTIME .GT. DMAXTM) )  THEN
            IFLAG = 6
            IF ( DTIME .GT. DMAXTM ) IFLAG = 5
          WRITE(*,*) 'DIF  WL TM',IPRN,DCPPRT,DTIME
     &     , sqrt(FLTSUM(12)/(FLTSUM(1)+100)), DMAXTM
            CALL IFLTSF ( IPC, TTAG, CODE, PHASEM, FLTSUM )
            FLTPR = CODE
            FLTCP = CODE
            ICSLIP=1
            IF ( DTIME .GE. DMAXTM ) IRJCT=1
            RETURN
          END IF
C
C       CYCLE SLIP FREE OR CODE ONLY - UPDATE FILTER SUMMATIONS
C
        FLTSUM(1) = FLTSUM(1) + 1.0D0
        FLTSUM(2) = TTAG
        FLTSUM(3) = CODE
        FLTSUM(4) = PHASEM
        FLTSUM(5) = FLTSUM(5) + DIFCP
        FLTSUM(6) = FLTSUM(6) + DCPPR
        FLTSUM(7) = 1.D0/P
        FLTSUM(11)= (FLTSUM(11)*99+ DCPPRT)/100
C USING 4.4 SIGMA LIMITS
        FLTSUM(12)= FLTSUM(12)+ 20.d0*DCPPRT**2
      END IF
c!    WRITE(*,'(A10,A3,I2.2,3F12.2)') 'DIVERGENCE','PRN',
c!   &                                   IPRN,TTAG,FLTSUM(6)
      FLTCP = FLTSUM(5)
      FLTPR = FLTSUM(5) + FLTSUM(6)
      IF ( IOBTYP .EQ. 2 ) THEN
      FLTCP = (FLTCP+FLTPR)/2.D0
      END IF
      IQLTY =  IDINT(FLTSUM(7)*10D0) + 1
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** FNAME
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE FNAME( INAM, JNAM, LU, LUO, LUMEA, IPEP,
     &                  IFMTE, LUEPH,
     &                  LPR, LPOS, LRES, LIPX, LUCOR, LDAY, 
     &                  LUCLK, LUSLM, IDC, NAMCLK, NAMEPH, NAMSLM,
     &                  IDCFREQ, ISLM, REFNAM,  REFXYZ, REFHGT, NBDAY,
     &                  IYEARS, IMTHS, IDAYS, ISLMFMT, IERR,
     &                  IULTRA, IMINACC, LNG )
C
C     NAME:      FNAME
C
C     PURPOSE:   ASSIGN FILE NAMES TO LOGICAL UNITS
C
C     PARAMETERS        DESCRIPTION
C
C        LU             LOGICAL UNIT OF SCREEN INPUT
C        LUO            LOGICAL UNIT OF SCREEN OUTPUT
C        LUMEA  LOGICAL UNIT OF INPUT MEASUREMENT FILE
C        IPEP         EPHEMERIS FLAG
C        LUEPH  LOGICAL UNIT OF INPUT EPHEMERIS FILE
C        LPR            LOGICAL UNIT OF SUMMARY FILE
C        LPOS   LOGICAL UNIT OF POSITION PLOT FILE
C        LRES   LOGICAL UNIT OF RESIDUAL PLOT FILE
C          LIPX         LOGICAL UNIT OF LAST EPOCH ESTIMATES
C        LUCOR  LOGICAL UNIT OF RANGE CORRECTION FILE
C        LDAY   LOGICAL UNIT OF DAILY SUMMARY
C        LUCLK  LOGICAL UNIT OF SATELLITE AND RECEIVER CLOCKS
C        IDC            APPLY DIFFERENTIAL CORRECTIONS (1=NO,2=YES)
C        NAMCLK DIFFERENTIAL CORRECTION FILE NAME
C        NAMEPH        PRECISE EPHEMERIS FILE NAME
C        NAMSLM       SINGLE LAYER MODEL FILE NAME
C
C *********************************************************************
C
      IMPLICIT NONE
C
      CHARACTER*80  INAM, JNAM
      CHARACTER*80  NAMEPH(*)
      CHARACTER*80  NAMCLK(*)
      CHARACTER*80  NAMSLM(*)
      INTEGER*4     LU, LUO, LUMEA, LUEPH, LUCOR, IULTRA, LNG
      INTEGER*4     LPR, LPOS, LRES, LDAY, LIPX, LUCLK, LUSLM, ISLM
      INTEGER*4     IDC, IERR, IPEP, IDCFREQ, NBDAY
      INTEGER*4     IYEARS, IMTHS, IDAYS, ISLMFMT,IFMTE
     &              , IMINACC
C
      CHARACTER*40  REFNAM
      REAL*8        REFXYZ(3),    REFHGT
C
      CHARACTER*80  KNAM
      INTEGER*4 IOS,NERR,IDOBS
C
      IERR = 0
      NERR = 3
      IDOBS = IYEARS*10000+IMTHS*100+IDAYS
      IMINACC = 0
C
C-----------------------------------------------------------------------
C     SUMMARY FILE NAME IS INPUT FILE NAME
C     WITH SUFFIX 'SUM'
C-----------------------------------------------------------------------
C
  100 CONTINUE
      WRITE(KNAM,10020) INAM
      CALL CHSFX ( INAM, KNAM, '.sum' )
      OPEN ( LPR, FILE=KNAM, STATUS='UNKNOWN', IOSTAT=IOS, ERR=150 )
      CLOSE ( LPR, STATUS='DELETE' )
      OPEN ( LPR, FILE=KNAM, STATUS='NEW', IOSTAT=IOS, ERR=150 )
      GO TO 160
  150 WRITE(LUO,10100) IOS, KNAM
      IERR = 1
      GO TO 1000
  160 CONTINUE
C
C-----------------------------------------------------------------------
C     GET EPHEMERIS INPUT FILE NAME.
C-----------------------------------------------------------------------
C
  300   CONTINUE
        CALL EPNAME ( IPEP, LU, LUO, LPR, LUEPH, IFMTE, NAMEPH,
     &                IYEARS, IMTHS, IDAYS, NBDAY, IERR, IULTRA,
     &                IMINACC, LNG )
        IF (IERR .NE. 0) GO TO 1000
C
C-----------------------------------------------------------------------
C     POSITION PLOT FILE NAME IS INPUT FILE NAME
C     WITH SUFFIX 'POS'
C-----------------------------------------------------------------------
C
  400 CONTINUE
      CALL CHSFX ( INAM, KNAM, '.pos' )
      OPEN ( LPOS, FILE=KNAM, STATUS='UNKNOWN', IOSTAT=IOS, ERR=450 )
      CLOSE ( LPOS, STATUS='DELETE' )
      OPEN ( LPOS, FILE=KNAM, STATUS='NEW', IOSTAT=IOS, ERR=450 )
      GO TO 460
  450 WRITE(LUO,10100) IOS, KNAM
      IERR = 1
      GO TO 1000
  460 CONTINUE
C
C-----------------------------------------------------------------------
C     RESIDUAL PLOT FILE NAME IS INPUT FILE NAME
C-----------------------------------------------------------------------
C
  500 CONTINUE
        CALL CHSFX ( INAM, KNAM, '.res' )
        OPEN ( LRES, FILE=KNAM, STATUS='UNKNOWN', IOSTAT=IOS, ERR=550 )
        CLOSE ( LRES, STATUS='DELETE' )
        OPEN ( LRES, FILE=KNAM, STATUS='NEW', FORM='FORMATTED', 
     &             IOSTAT=IOS, ERR=550 )
        GO TO 560
C   
  550 WRITE(LUO,10100) IOS, KNAM
      IERR = 1
      GO TO 1000
  560 CONTINUE
C
C-----------------------------------------------------------------------
C     DAILY SESSION FILE NAME IS INPUT FILE NAME
C-----------------------------------------------------------------------
C
  600 CONTINUE
      CALL CHSFX ( INAM, KNAM, '.ses' )
      OPEN ( LDAY, FILE=KNAM, STATUS='UNKNOWN', IOSTAT=IOS, ERR=650 )
      CLOSE ( LDAY, STATUS='DELETE' )
      OPEN ( LDAY, FILE=KNAM, STATUS='NEW', IOSTAT=IOS, ERR=650 )
      GO TO 660
  650 WRITE(LUO,10100) IOS, KNAM
      IERR = 1
      GO TO 1000
  660 CONTINUE
C
C-----------------------------------------------------------------------
C     DAILY SESSION FILE NAME IS INPUT FILE NAME
C-----------------------------------------------------------------------
C
  700 CONTINUE
      CALL CHSFX ( INAM, KNAM, '.ipx' )
      OPEN ( LIPX, FILE=KNAM, STATUS='UNKNOWN', IOSTAT=IOS, ERR=750 )
      CLOSE ( LIPX, STATUS='DELETE' )
      OPEN ( LIPX, FILE=KNAM, STATUS='NEW', FORM='UNFORMATTED',
     &       IOSTAT=IOS, ERR=750 )
      GO TO 760
  750 WRITE(LUO,10100) IOS, KNAM
      IERR = 1
      GO TO 1000
  760 CONTINUE
C
C-----------------------------------------------------------------------
C     GET SATELLITE CLOCK FILE NAME IF REQUIRED
C-----------------------------------------------------------------------
C
 800  CONTINUE
      IF (IDC .GE. 2)
     &                CALL DCNAME ( LU, LUO, LPR, LUCOR, IDC, 
     &                  NAMCLK, IYEARS, IMTHS, IDAYS, NBDAY, IERR, 
     &                  LNG )
      IF ( IERR .NE. 0 ) GO TO 1000
C
C----------------------------------------------------------------------
C     GET IONOSPHERIC GRID FILE NAME IF REQUIRED
C----------------------------------------------------------------------
C
  900 CONTINUE
c!    WRITE(*,*) 'CALLING SLMNAME',ISLM,ISLMFMT
      IF ( ISLM .GE. 2 ) 
     &  CALL SLMNAME ( LU, LUO, LPR, LUSLM, NAMSLM,
     &                 IYEARS, IMTHS, IDAYS, NBDAY, ISLMFMT, IERR,
     &                 LNG )
C
 1000 CONTINUE
C
C-----------------------------------------------------------------------
C               FORMAT STATEMENTS
C-----------------------------------------------------------------------
C
10000 FORMAT(/)
10020 FORMAT( A80 )
10060 FORMAT( '+','Enter PRECISE STATION CLOCK file name            :')
10100 FORMAT( ' ERROR SR FNAME',I9,'trying to open FILE ',  A80 )
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** FREQ12
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE FREQ12( IPRN, F1, F2, F1S, F2S, F12S, F1ION, F2ION, 
     &                   AL1, AL2, AL3, AL4, IFREQ ) 
C
C     NAME              FREQ12
C
C     PURPOSE         ASSIGN F1, F2 FREQS & COMPUTE ALL THE NECESSARY COMBS
C
C     PARAMETERS        DESCRIPTION
C
C          INPUT:
C          IPRN         SATELLITE PRN : GPS <0,32>, GLONASS <33,64>,
C                                 GALILEO <65, 100>, BEIDOU <101,132>,
C          F1           THE 1ST  (L1) FREQ IN Hz             
C          F2           THE 2ND  (L2) FREQ IN Hz             
C          OUTPUT:
C          F1S          F1*F1                                   
C          F2S          F2*F1                                   
C          F12S         F1S-F2S            
C          F1ION        F2S/F12S                 
C          F2ION        F1S/F12S                        
C          AL1          F1 WAVE LENGTH WL (M) = C/F1  
C          AL2          F2 WAVE LENGTH WL (M) = C/F2
C          AL3          IF WL (M) = F2ION*AL1-F1ION*AL2
C          AL4          WIDE LANE(M) = C/(F1-F2)      
C          IFREQ        FREQ COMB (1, 2, 3, for GAL
C                                  5=(L1,L5),7=(L1,L7), 8=(L1,L8) 
C *********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4 IPRN, IFREQ
C
      REAL*8 C, F1, F2, F1S, F2S, F12S, F1ION, F2ION, AL1, AL2, AL3, AL4
C
      C  = 299792458.0D0
      F1   = 1575.42D+06
      F2   = 1227.60D+06
C   GALILEO IF IPRN (64, 100> ! USE E5a (L5) INSTEAD OF L2
      IF(IPRN.GT.64.AND.IPRN.LE.100)THEN
C   GAL Ea
        IF(IFREQ.LE.5) F2= 1176.450D+06 
C GAL Eb
        IF(IFREQ.EQ.7) F2= 1207.140D+06 
C GAL (Ea+Eb)/2
        IF(IFREQ.EQ.8) F2= 1191.795D+06 
      ENDIF
C   GALILEO IF IPRN (64, 100> ! USE (E5a+E5b)/2  (L8) INSTEAD OF L2
C     IF(IPRN.GT.64.AND.IPRN.LE.100) F2= 1191.795D+06 
C   BEIDOU (IPRN(100,132> ! USE B1 & B2
      IF(IPRN.GT.100.AND.IPRN.LE.136) THEN
       F1   = 1561.098D+06
       F2   = 1207.140D+06
      ENDIF
C    OUTPUT LANE COMBINATIONS
      F1S  = F1*F1
      F2S  = F2*F2
      F12S = F1S - F2S
      F1ION = F2S / F12S
      F2ION = F1S / F12S
      AL1  = C/F1
      AL2  = C/F2
      AL3  = F2ION*AL1-F1ION*AL2
C AL4- WL WAVE LENGTH
      AL4= C/(F1-F2)
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
C*************************************************************** GEO_TO_MAG
C
C
C  Names: geo_to_mag, magLon_to_geo, magHour_to_geo
C         magHour_to_magLon, magLon_to_magHour
C         compute_geomag_const, apparentSunMagLon

C  Purpose : convert btw geographic and geomagnetic coordinates

C  Note:        Time dependent computation for pole coordinates,
C               dipole center and sun apparent position are stored
C               in static memory so computation load for multiple
C               observations at same time, with resolution of 1 day,
C               is reduced.

C  Parameters: all angles retrieved are in [0,2*PI]
C         Year          year 4-digits
C         Doy           day of year [1-366]
C         Time          time of day (seconds) (can be GPStime)
C         geoLat        geographic latitude(rad)
C         geoLon        geographic longitude(rad)
C         magLat        geomagnetic latitude(rad)
C         magLon        geomagnetic longitude(rad)
C         magHour       geomagnetic hour angle(rad)
C         eccentric     dipole option
C                       (0=centered,1=excentric)

C  XMAG= R2(COLAT)*R3(LON)*[XGEO-ECC]
C  XGEO= [R3(-LON)*R2(-COLAT)*XMAG]+ECC

C  where: R2 = | COS      0     -SIN | and: R3 = | COS     SIN      0  |
C              |  0       1       0  |           |-SIN     COS      0  |
C              | SIN      0      COS |           |  0       0       1  |


C  Modifications :      When       Who       What
C                       96/05/10   PH        developed in FORTRAN
C                       02/12/17   FL        converted to C
C                                            and added reverse transform
C                                            and static memory values

C  Externals : dmod

C
      SUBROUTINE compute_geomag_const( Year, Doy )
C
      IMPLICIT NONE
C
C ARGUMENTS
C
      INTEGER*4 Year, Doy
C
C Local variables
C
      INTEGER*4  i;
      REAL*4  curYear, fracYear;

C
C IGRF2015 12th generation G10, G11 and H11 coefficients *10
C
      REAL*8 geo_mo1_1995(3)
      REAL*8 geo_mo1_2000(3)
      REAL*8 geo_mo1_2005(3)
      REAL*8 geo_mo1_2010(3)
      REAL*8 geo_mo1_2015(3)
      REAL*8 geo_mo1_rate(3)
C
C IGRF2015 12th generation G20, G21, H21, G22, H22 coeff *10
C
C Note these should probably not be forcasted beyond 2015
C But for our purpose it is sufficient
C
      DATA geo_mo1_1995/ -296820.0D0, -17840.0D0, 53060.0D0 /
      DATA geo_mo1_2000/ -296194.0D0, -17282.0D0, 51861.0D0 /
      DATA geo_mo1_2005/ -295463.3D0, -16690.5D0, 50779.9D0 /
      DATA geo_mo1_2010/ -294965.7D0, -15864.2D0, 49442.6D0 /
      DATA geo_mo1_2015/ -294420.0D0, -15010.0D0, 47971.0D0 /
      DATA geo_mo1_rate/     103.0D0,    181.0D0,  -266.0D0 /
C
C
      REAL*8 geo_mo(3)
      REAL*8 dca, d2, ka, kb
      REAL*8 betaAngle
C
C For DEG vs RAD conversion
      REAL*8 GEOMAG_PI
C Maximum latitude allowed for polar loop back problem
      REAL*8 GEOMAG_MAXLAT
C Previous Year used in computation
      REAL*4 prevYear
C Previous DOY used in computation
      REAL*4 prevDoy
C Austral and boreal pole positions
      REAL*8 australPoleCoLat, australPoleLon, borealPoleCoLat,
     &        borealPoleLon
C Dipole center
      REAL*8 dipoleCenter(3)
C Apparent sun magnetic position
      REAL*8 sunDec, Epsilon

      COMMON /GEOMAG/ GEOMAG_PI, GEOMAG_MAXLAT, prevYear,prevDoy,
     &       australPoleCoLat, australPoleLon, borealPoleCoLat,
     &       borealPoleLon, dipoleCenter,sunDec, Epsilon
C
      DATA GEOMAG_PI/3.141592653589793D0/
      DATA GEOMAG_MAXLAT/.89999999D+2/
      DATA prevYear,prevDoy/ 0.,0./
C
C Compute current fractional year
C
      IF( (MOD(Year,400).EQ.0).OR.
     &    (MOD(Year,100).NE.0.AND.MOD(Year,4).EQ.0) ) THEN
        fracYear = Doy/366.D0
      ELSE
        fracYear = Doy/365.D0
      ENDIF
      curYear = Year+fracYear;
C
C Compute year dependent stuff only when year changes
C
      IF( prevYear .EQ. 0.0 .OR. prevYear .NE. curYear ) THEN
C
C Compute lat and lon of austral and boreal poles
C
        DO i=1,3
C
C Fix values prior to 1995 to the 1995 values
          if( curYear .LE. 1995.D0 ) THEN
             geo_mo(i) = geo_mo1_1995(i)
C
C Interpolate previous 5yr values
          else if( curYear .GT. 1995.D0  .AND.
     &             curYear .LE. 2000.D0  ) THEN
            geo_mo(i) = (curYear-1995.D0 )/5.D0  * geo_mo1_2000(i) +
     &                  (2000.D0 -curYear)/5.D0  * geo_mo1_1995(i)
          else if( curYear .GT. 2000.D0  .AND.
     &             curYear .LE. 2005.D0  ) THEN
            geo_mo(i) = (curYear-2000.D0 )/5.D0  * geo_mo1_2005(i) +
     &                  (2005.D0 -curYear)/5.D0  * geo_mo1_2000(i)
          else if( curYear .GT. 2005.D0  .AND.
     &             curYear .LE. 2010.D0  ) THEN
            geo_mo(i) = (curYear-2005.D0 )/5.D0  * geo_mo1_2010(i) +
     &                  (2010.D0 -curYear)/5.D0  * geo_mo1_2005(i)
          else if( curYear .GT. 2010.D0  .AND.
     &             curYear .LE. 2015.D0  ) THEN
            geo_mo(i) = (curYear-2010.D0 )/5.D0  * geo_mo1_2015(i) +
     &                  (2015.D0 -curYear)/5.D0  * geo_mo1_2010(i)
C
C Extrapolate beyond 2015 with published rates
          else
            geo_mo(i) = geo_mo1_2015(i) +
     &                  (curYear-2015D0 ) * geo_mo1_rate(i)
          ENDIF
        END DO
        australPoleCoLat =
     &     Datan2( Dsqrt( geo_mo(2)**2 + geo_mo(3)**2 ),
     &                    geo_mo(1) )
        australPoleLon = Datan2( geo_mo(3), geo_mo(2) )
        borealPoleCoLat =
     &     Datan2( Dsqrt( geo_mo(2)**2 + geo_mo(3)**2 ),
     &                    -geo_mo(1) )
        borealPoleLon = Datan2( -geo_mo(3), -geo_mo(2) )
C
C Compute translation for excentric dipole center
C
C ==========================================================================
C Note:
C The z translation computation is uncertain to me but only x and y are used
C I think it should be:  dipoleCenter(3) += kb * cos(borealPoleCoLat);
C ========================================================================== 
        prevYear = curYear;
      END IF
C
C Compute doy dependent stuff only when doy changes
C
      if( prevDoy .EQ. 0.0D0  .OR. prevDoy .NE. Doy ) THEN
        betaAngle = fracYear*GEOMAG_PI*2.0D0
        Epsilon = 0.004297180D0 +
     &            0.1070290D0 * Dcos(betaAngle) -
     &            1.837880D0 * Dsin(betaAngle) - 
     &            0.8373780D0 * Dcos(2.0D0 * betaAngle) -
     &            2.340480D0 * Dsin(2.0D0 * betaAngle)
        sunDec = 0.396370D0 -
     &           22.9130D0 * Dcos(betaAngle) -
     &           4.02540D0 * Dsin(betaAngle) -
     &           0.387200D0 * Dcos(2.0D0 * betaAngle) +
     &           0.051970D0 * Dsin(2.0D0 * betaAngle)
        sunDec =sunDec * GEOMAG_PI/180.D0
        prevDoy = Doy
      ENDIF

      RETURN
      END

      REAL*8 FUNCTION apparentSunMagLon( Year, Doy, Time )
C
      IMPLICIT NONE
C
C ARGUMENT DECLARATION
C
      INTEGER*4 Year, Doy, Time
      REAL*8 sec
C
C Local variables
C
C Apparent sun time
      REAL*8 appSunTime
C Apparent sun longitude
      REAL*8 sunLon
C For DEG vs RAD conversion
      REAL*8 GEOMAG_PI
C Maximum latitude allowed for polar loop back problem
      REAL*8 GEOMAG_MAXLAT
C Previous Year used in computation
      REAL*4 prevYear
C Previous DOY used in computation
      REAL*4 prevDoy
C Austral and boreal pole positions
      REAL*8 australPoleCoLat, australPoleLon, borealPoleCoLat,
     &        borealPoleLon
C Dipole center
      REAL*8 dipoleCenter(3)
C Apparent sun magnetic position
      REAL*8 sunDec, Epsilon

      COMMON /GEOMAG/ GEOMAG_PI, GEOMAG_MAXLAT, prevYear,prevDoy,
     &       australPoleCoLat, australPoleLon, borealPoleCoLat,
     &       borealPoleLon, dipoleCenter,sunDec, Epsilon
C
C Compute time dependent values
C
      CALL compute_geomag_const( Year, Doy )
C
C Compute local apparent sun magnetic longitude
C
      appSunTime = (180.0D0 - 15.0D0 *MOD(Time,86400)/3600.D0 -
     &                              Epsilon) * GEOMAG_PI/180.D0
      sunLon = Datan2( Dcos(sunDec)*Dsin(appSunTime - borealPoleLon),
     &                 Dcos(sunDec)*Dcos(borealPoleCoLat)*
     &                 Dcos(appSunTime - borealPoleLon) -
     &                 Dsin(sunDec)*sin(borealPoleCoLat) )
      apparentSunMagLon = sunLon
      RETURN
      END
C
      REAL*8 FUNCTION magHour_to_magLon( Year, Doy, Time, magHour )
C
      IMPLICIT NONE
C
C ARGUMENT DECLARATION
C
      INTEGER*4 Year, Doy, Time
      REAL*8 magHour
C
C Local variable
C
C apparent sun longitude
      REAL*8 sunLon
C magnetic longitude
      REAL*8 magLon
C
C External function
C
      REAL*8 apparentSunMagLon
C For DEG vs RAD conversion
      REAL*8 GEOMAG_PI
C Maximum latitude allowed for polar loop back problem
      REAL*8 GEOMAG_MAXLAT
C Previous Year used in computation
      REAL*4 prevYear
C Previous DOY used in computation
      REAL*4 prevDoy
C Austral and boreal pole positions
      REAL*8 australPoleCoLat, australPoleLon, borealPoleCoLat,
     &        borealPoleLon
C Dipole center
      REAL*8 dipoleCenter(3)
C Apparent sun magnetic position
      REAL*8 sunDec, Epsilon

      COMMON /GEOMAG/ GEOMAG_PI, GEOMAG_MAXLAT, prevYear,prevDoy,
     &       australPoleCoLat, australPoleLon, borealPoleCoLat,
     &       borealPoleLon, dipoleCenter,sunDec, Epsilon
C
C Compute apparent sun magnetic longitude
C
      sunLon = apparentSunMagLon( Year, Doy, Time )
C
C Compute geomagnetic longitude
C
      magLon = dmod(sunLon+magHour-GEOMAG_PI,2.0D0*GEOMAG_PI)
      if( magLon .LT. 0.0 ) magLon =magLon + 2.0D0*GEOMAG_PI
C
      magHour_to_magLon = magLon 
C
      return
      END
C
      REAL*8 FUNCTION magLon_to_magHour( Year, Doy, Time, magLon )
C
      IMPLICIT NONE
C
C ARGUMENT DECLARATION
C
      INTEGER*4 Year, Doy, Time
      REAL*8 magLon
C
C Local variables
C
C apparent sun longitude
       REAL*8 sunLon
C magnetic hour angle
       REAL*8 magHour
C
C External function
C
      REAL*8 apparentSunMagLon
C For DEG vs RAD conversion
      REAL*8 GEOMAG_PI
C Maximum latitude allowed for polar loop back problem
      REAL*8 GEOMAG_MAXLAT
C Previous Year used in computation
      REAL*4 prevYear
C Previous DOY used in computation
      REAL*4 prevDoy
C Austral and boreal pole positions
      REAL*8 australPoleCoLat, australPoleLon, borealPoleCoLat,
     &        borealPoleLon
C Dipole center
      REAL*8 dipoleCenter(3)
C Apparent sun magnetic position
      REAL*8 sunDec, Epsilon

      COMMON /GEOMAG/ GEOMAG_PI, GEOMAG_MAXLAT, prevYear,prevDoy,
     &       australPoleCoLat, australPoleLon, borealPoleCoLat,
     &       borealPoleLon, dipoleCenter,sunDec, Epsilon
C
C Compute apparent sun magnetic longitude
C
       sunLon = apparentSunMagLon( Year, Doy, Time )
C
C Compute geomagnetic hour angle
C
      magHour = dmod(GEOMAG_PI + (magLon - sunLon),2.0D0*GEOMAG_PI)
      if( magHour .LT. 0.0 ) magHour =magHour + 2.0D0*GEOMAG_PI
C
      magLon_to_magHour = magHour
C
      RETURN
      END
C
      SUBROUTINE geo_to_mag( Year, Doy, Time, geoLat, geoLon,
     &                       magLat, magLon, magHour, eccentric )
C
      IMPLICIT NONE
C
C ARGUMENT DECLARATION
C
      INTEGER*4 Year, Doy, Time, eccentric
      REAL*8 geoLat, geoLon, magLat, magLon, magHour
C
C Local variables
C
C Cartesian geographic 
      REAL*8 cartGeo(3)
C Cartesian magnetic 
      REAL*8 cartMag(3)
C
C External function
C
      REAL*8 magLon_to_magHour
C For DEG vs RAD conversion
      REAL*8 GEOMAG_PI
C Maximum latitude allowed for polar loop back problem
      REAL*8 GEOMAG_MAXLAT
C Previous Year used in computation
      REAL*4 prevYear
C Previous DOY used in computation
      REAL*4 prevDoy
C Austral and boreal pole positions
      REAL*8 australPoleCoLat, australPoleLon, borealPoleCoLat,
     &        borealPoleLon
C Dipole center
      REAL*8 dipoleCenter(3)
C Apparent sun magnetic position
      REAL*8 sunDec, Epsilon

      COMMON /GEOMAG/ GEOMAG_PI, GEOMAG_MAXLAT, prevYear,prevDoy,
     &       australPoleCoLat, australPoleLon, borealPoleCoLat,
     &       borealPoleLon, dipoleCenter,sunDec, Epsilon
C Compute time dependent values
C
      CALL compute_geomag_const( Year, Doy )
C
C alidate input coordinates 
C
      geoLon = dmod( geoLon, GEOMAG_PI*2. )
      geoLat = dmod( geoLat, GEOMAG_PI )
      if( geoLat .GT. GEOMAG_PI/2. )
     &  geoLat = GEOMAG_PI - geoLat
      if( geoLat .LT. -GEOMAG_PI/2. )
     &  geoLat = - GEOMAG_PI - geoLat
      if( geoLat*180/GEOMAG_PI > GEOMAG_MAXLAT )
     &  geoLat = GEOMAG_MAXLAT*GEOMAG_PI/180
      if( geoLat*180/GEOMAG_PI < -GEOMAG_MAXLAT )
     &  geoLat = -GEOMAG_MAXLAT*GEOMAG_PI/180
C
C Convert to geographic cartesian
C
      cartGeo(1) = Dcos(geoLat) * Dcos(geoLon)
      cartGeo(2) = Dcos(geoLat) * Dsin(geoLon)
      cartGeo(3) = Dsin(geoLat)
C
C Apply translations to geographic cartesian
C
      if( eccentric .NE. 0 ) THEN
       cartGeo(1) =cartGeo(1) - dipoleCenter(1);
       cartGeo(2) =cartGeo(2) - dipoleCenter(2);
      ENDIF
C
C Apply rotations to get geomagnetic cartesian
C
      cartMag(1) =
     &     cartGeo(1) * Dcos(borealPoleCoLat) * Dcos(borealPoleLon) +
     &     cartGeo(2) * Dcos(borealPoleCoLat) * Dsin(borealPoleLon) -
     &     cartGeo(3) * Dsin(borealPoleCoLat)
      cartMag(2) =
     &    -cartGeo(1) * Dsin(borealPoleLon) +
     &     cartGeo(2) * Dcos(borealPoleLon)
      cartMag(3) =
     &     cartGeo(1) * Dsin(borealPoleCoLat) * Dcos(borealPoleLon) +
     &     cartGeo(2) * Dsin(borealPoleCoLat) * Dsin(borealPoleLon) +
     &     cartGeo(3) * Dcos(borealPoleCoLat)
C
C Compute geomagnetic lat and lon from cartesian
C
      magLon = Datan2( cartMag(2), cartMag(1) )
      magLat = Datan2( cartMag(3),
     &    Dsqrt( cartMag(1)*cartMag(1) + cartMag(2)*cartMag(2)) )
      if( magLon .LT. 0.0 ) magLon =magLon + 2.0 * GEOMAG_PI
C
C Compute local apparent magnetic hour angle
C
      magHour= magLon_to_magHour( Year, Doy, Time, magLon )
C
      RETURN
      END
C
      SUBROUTINE magLon_to_geo( Year, Doy, Time, magLat, magLon,
     &                         geoLat, geoLon, eccentric )
C
      IMPLICIT NONE
C
C ARGUMENT DECLARATION
C
      INTEGER*4 Year, Doy, Time, eccentric
      REAL*8 magLat, magLon, geoLat, geoLon
C
C Local variables

C Cartesian geographic
      REAL*8 cartGeo(3)
C Cartesian magnetic
      REAL*8 cartMag(3)
C For DEG vs RAD conversion
      REAL*8 GEOMAG_PI
C Maximum latitude allowed for polar loop back problem
      REAL*8 GEOMAG_MAXLAT
C Previous Year used in computation
      REAL*4 prevYear
C Previous DOY used in computation
      REAL*4 prevDoy
C Austral and boreal pole positions
      REAL*8 australPoleCoLat, australPoleLon, borealPoleCoLat,
     &        borealPoleLon
C Dipole center
      REAL*8 dipoleCenter(3)
C Apparent sun magnetic position
      REAL*8 sunDec, Epsilon

      COMMON /GEOMAG/ GEOMAG_PI, GEOMAG_MAXLAT, prevYear,prevDoy,
     &       australPoleCoLat, australPoleLon, borealPoleCoLat,
     &       borealPoleLon, dipoleCenter,sunDec, Epsilon
C
C Compute time dependent values
C
      CALL compute_geomag_const( Year, Doy )
C
C Validate input coordinates
C
      magLon = dmod( magLon, GEOMAG_PI*2. )
      magLat = dmod( magLat, GEOMAG_PI )
      if( magLat .GT. GEOMAG_PI/2. )
     &  magLat = GEOMAG_PI - magLat
      if( magLat .LT. -GEOMAG_PI/2. )
     &  magLat = - GEOMAG_PI - magLat
      if( magLat*180/GEOMAG_PI .GT. GEOMAG_MAXLAT )
     &  magLat = GEOMAG_MAXLAT*GEOMAG_PI/180
      if( magLat*180/GEOMAG_PI .LT. -GEOMAG_MAXLAT )
     &  magLat = -GEOMAG_MAXLAT*GEOMAG_PI/180
C
C Convert to geomagnetic cartesian
C
      cartMag(1) = Dcos(magLat) * Dcos(magLon)
      cartMag(2) = Dcos(magLat) * Dsin(magLon)
      cartMag(3) = Dsin(magLat)
C
C Apply rotations to get geographic cartesian
C
      cartGeo(1) = cartMag(1) * Dcos(borealPoleCoLat) *
     &                                             Dcos(borealPoleLon) -
     &             cartMag(2) * Dsin(borealPoleLon) +
     &             cartMag(3) * Dsin(borealPoleCoLat) *
     &                                             Dcos(borealPoleLon)
      cartGeo(2) = cartMag(1) * Dcos(borealPoleCoLat) *
     &                                             Dsin(borealPoleLon) +
     &             cartMag(2) * Dcos(borealPoleLon) +
     &             cartMag(3) * Dsin(borealPoleCoLat) *
     &                                             Dsin(borealPoleLon);
      cartGeo(3) =-cartMag(1) * Dsin(borealPoleCoLat) +
     &             cartMag(3) * Dcos(borealPoleCoLat)
C
C Apply translation if required
C
      if( eccentric .NE. 0 ) THEN
        cartGeo(1) =cartGeo(1) + dipoleCenter(1)
        cartGeo(2) =cartGeo(2) + dipoleCenter(2)
      ENDIF
C
C Compute geographic lat and lon from cartesian
C
      geoLon = Datan2( cartGeo(2), cartGeo(1) )
      geoLat = Datan2( cartGeo(3),
     &     Dsqrt( cartGeo(1)*cartGeo(1) + cartGeo(2) * cartGeo(2)) )
      if( geoLon .LT. 0.0 ) geoLon =geoLon + 2.0 * GEOMAG_PI

      RETURN
      END
C
      SUBROUTINE magHour_to_geo( Year, Doy, Time, magLat, magHour,
     &                           geoLat, geoLon, eccentric )
C
      IMPLICIT NONE
C
C ARGUMENT DECLARATION
C
      INTEGER*4 Year, Doy, Time, eccentric
      REAL*8 magLat, magHour, geoLat, geoLon
C
C Local variables
C
      REAL*8 magLon
C
C External function
C
      REAL*8 magHour_to_magLon
C For DEG vs RAD conversion
      REAL*8 GEOMAG_PI
C Maximum latitude allowed for polar loop back problem
      REAL*8 GEOMAG_MAXLAT
C Previous Year used in computation
      REAL*4 prevYear
C Previous DOY used in computation
      REAL*4 prevDoy
C Austral and boreal pole positions
      REAL*8 australPoleCoLat, australPoleLon, borealPoleCoLat,
     &        borealPoleLon
C Dipole center
      REAL*8 dipoleCenter(3)
C Apparent sun magnetic position
      REAL*8 sunDec, Epsilon

      COMMON /GEOMAG/ GEOMAG_PI, GEOMAG_MAXLAT, prevYear,prevDoy,
     &       australPoleCoLat, australPoleLon, borealPoleCoLat,
     &       borealPoleLon, dipoleCenter,sunDec, Epsilon
C
C Compute geomagnetic longitude
C
      magLon = magHour_to_magLon( Year, Doy, Time, magHour )
C
C Compute geographic
C
      CALL magLon_to_geo( Year, Doy, Time, magLat, magLon,
     &                    geoLat, geoLon, eccentric )
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** GETDEF
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE GETDEF(   LUI, LUO, LUDEF, NAMFLT, 
     &                     NAMSVB, NAMOLC, NAMPCV, NAMTRF, NAMMET,
     &                     NAMIPX, NAMORG, NAMERP, NAMSTC, NLNORG, LNG )
C
C     PURPOSE:   GET DEFAULT FILE NAMES AND SELECT LANGUAGE
C
C     PARAMETERS        DESCRIPTION
C
C        LUI            LOGICAL UNIT OF SCREEN INPUT
C        LUO            LOGICAL UNIT OF SCREEN OUTPUT
C        LUDEF        LOGICAL UNIT OF DEFAULT FILE
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4 LUI,LUO,LUDEF,NLNORG,LNG
      CHARACTER*80 NAMFLT
      CHARACTER*80 NAMSVB
      CHARACTER*80 NAMOLC
      CHARACTER*80 NAMPCV
      CHARACTER*80 NAMTRF
      CHARACTER*80 NAMMET
      CHARACTER*80 NAMIPX
      CHARACTER*80 NAMORG(*)
      CHARACTER*80 NAMSTC
      CHARACTER*80 NAMERP
C
      CHARACTER*80 NAMLNG
      CHARACTER*80 NAMDLG(10)
      CHARACTER*80 NAMGSD(10)
      CHARACTER*80 IDSTR
      CHARACTER*80 STRING
      INTEGER*4 NGSDREC,NDLGREC,IREC
C
C     SET DEFAULT LANGUAGE AND FILE NAMES 
C
      NAMFLT='gpsppp.flt'
      NAMSVB='gpsppp.svb'
      NAMOLC='gpsppp.olc'
      NAMPCV='gpsppp.pcv'
      NAMTRF='gpsppp.trf'
      NAMMET='gpsppp.met'
      NAMIPX='gpsppp.ipx'
      NAMSTC='gpsppp.stc'
      NAMERP='gpsppp.erp'
      NGSDREC=0
      NDLGREC=0
C
C     READ CONTENT OF DEFAULT FILE
C
  100 CONTINUE      
      READ (LUDEF,*,END=200) IDSTR,STRING
      IF ( IDSTR .EQ. 'LNG' ) NAMLNG=STRING
      IF ( IDSTR .EQ. 'TRF' ) NAMTRF=STRING
      IF ( IDSTR .EQ. 'SVB' ) NAMSVB=STRING
      IF ( IDSTR .EQ. 'OLC' ) NAMOLC=STRING
      IF ( IDSTR .EQ. 'PCV' ) NAMPCV=STRING
      IF ( IDSTR .EQ. 'FLT' ) NAMFLT=STRING
      IF ( IDSTR .EQ. 'MET' ) NAMMET=STRING
      IF ( IDSTR .EQ. 'IPX' ) NAMIPX=STRING
      IF ( IDSTR .EQ. 'STC' ) NAMSTC=STRING
      IF ( IDSTR .EQ. 'ERP' ) NAMERP=STRING
      IF ( IDSTR .EQ. 'GSD' .AND. NGSDREC .LT. 10 ) THEN
        NGSDREC=NGSDREC+1
      NAMGSD(NGSDREC)=STRING
      END IF      
      IF ( IDSTR .EQ. 'DLG' .AND. NDLGREC .LT. 10 ) THEN
        NDLGREC=NDLGREC+1
      NAMDLG(NDLGREC)=STRING
      END IF      
      GO TO 100
  200 CONTINUE
      CLOSE (LUDEF)  
C
C     SET LANGUAGE AND ORGANISATION NAME
C
      IF (NAMLNG(1:1) .EQ. 'F' .OR. NAMLNG(1:1) .EQ. 'f') THEN
        LNG=2 
        NLNORG=NDLGREC
        DO IREC=1,NDLGREC
          NAMORG(IREC)=NAMDLG(IREC)
        END DO
      ELSE
        LNG=1
        NLNORG=NGSDREC
        DO IREC=1,NGSDREC
          NAMORG(IREC)=NAMGSD(IREC)
        END DO
      END IF
C      
      RETURN
      END      
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** GETNAM
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE GETNAM ( INAM, ONAM, NCH )
C
C       NAME            GETNAM
C
C       PURPOSE         GET FILE NAME ( WITHOUT EXTENSION )
C
C       PARAMETERS      DESCRIPTION
C
C          INAM         INPUT FILE NAME
C          ONAM         OUTPUT FILE NAME  (WITHOUT EXTENSION)
C          NCH          NUMBER OF CHARACTERS IN OUTPUT FILE NAME
C
C *********************************************************************
C
      IMPLICIT NONE
      CHARACTER  INAM*(*), ONAM*(*)
      INTEGER    NCH
      INTEGER    IL, IR, ICH
      CHARACTER  ICHAR*1
C
      ONAM(1:1)=CHAR(0)
      CALL STRLIM(INAM,IL,IR)
      DO ICH = IL,IR
         ICHAR = INAM(ICH:ICH)
         IF ( ICHAR .EQ. '.' .OR. ICHAR .EQ. ' ' .OR.
     &        ICHAR .EQ. CHAR(0) ) THEN
          ONAM(ICH-IL+1:ICH-IL+1)=CHAR(0)
          NCH = ICH - 1
          RETURN
        END IF
        ONAM(ICH-IL+1:ICH-IL+1) = ICHAR
      END DO
      ONAM(ICH-IL+1:ICH-IL+1)=CHAR(0)
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** GPSDC
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE GPSDC ( JULD,IYEAR,IMTH,IDAY,IGPSWK,IWKDAY,IWAY )
C
C     NAME              GPSDC
C
C     PURPOSE   GPS DATE CONVERSION
C               --- -    -
C               FROM: JULIAN DAY, YEAR ==> GPS WEEK, WEEKDAY
C                     MONTH, DAY, YEAR ==> GPS WEEK, WEEKDAY
C                     GPS WEEK, WEEKDAY => JULIAN DAY, YEAR
C                     GPS WEEK, WEEKDAY => MONTH, DAY,YEAR
C
C     PARAMETERS        DESCRIPTION
C
C        JULD   JULIAN DAY
C        IYEAR  YEAR
C        IMTH   MONTH
C        IDAY   DAY OF MONTH
C        IGPSWK GPS WEEK NUMBER (WEEK 1 STARTS JAN 6, 1980)
C        IWKDAY DAY OF GPS WEEK
C        IWAY   DIRECTION OF CONVERSION
C               1. JULIAN DAY, YEAR ==> GPS WEEK, WEEKDAY
C               2. MONTH, DAY, YEAR ==> GPS WEEK, WEEKDAY
C               3. GPS WEEK, WEEKDAY => JULIAN DAY, YEAR
C               4. GPS WEEK, WEEKDAY => MONTH, DAY,YEAR
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4 JULD,IYEAR,IMTH,IDAY,IGPSWK,IWKDAY,IWAY
C
      INTEGER*4 INIYR,INIDY,NDAYS,IDIR,IYR,NDAYR
C
      INIYR = 1980
      INIDY = 6
      NDAYS = 0
C
C
      IF ( IWAY .GE. 3 ) GO TO 200
C
C     CONVERSIONS FROM JULIAN DAY (IWAY=1) OR MONTH, DAY (IWAY=2)
C     TO GPS WEEK AND DAY OF WEEK
C
      IF ( IWAY .EQ. 2 ) THEN
        IDIR = 1
        CALL JULDM ( JULD, IYEAR, IMTH, IDAY, IDIR )
      END IF
C
      DO 100 IYR=INIYR,IYEAR-1
       IF ( MOD(IYR,4) .EQ. 0 .AND. MOD(IYR,100) .NE. 0
     &           .OR. MOD(IYR,400) .EQ. 0 ) THEN
         NDAYS = NDAYS + 366
       ELSE
         NDAYS = NDAYS + 365
       END IF
  100  CONTINUE
       NDAYS = NDAYS + JULD - INIDY
       IWKDAY = MOD(NDAYS,7) + 1
       IGPSWK = NDAYS/7
       GO TO 500
C
C     CONVERSIONS FROM GPS WEEK AND DAY OF WEEK
C     TO JULIAN DAY (IWAY=3) OR MONTH, DAY (IWAY=4)
C
  200 CONTINUE
      NDAYS = IGPSWK * 7
      NDAYS = NDAYS + IWKDAY
      IYEAR = INIYR
  300 CONTINUE
      NDAYR = 365
      IF ( MOD(IYEAR,4) .EQ. 0 .AND. MOD(IYEAR,100) .NE. 0
     &         .OR. MOD(IYEAR,400) .EQ. 0 ) NDAYR = 366
      IF ( IYEAR .EQ. INIYR ) NDAYR = NDAYR - 5
      IF ( NDAYS .LE. NDAYR ) GO TO 400
      NDAYS = NDAYS - NDAYR
      IYEAR = IYEAR + 1
      GO TO 300
  400 CONTINUE
      JULD = NDAYS
      IF ( IWAY .EQ. 4 ) THEN
      IDIR = 0
      CALL JULDM ( JULD, IYEAR, IMTH, IDAY, IDIR )
      END IF
  500 CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** GRDFMT
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE GRDFMT ( LUGRD, LUO, IFMT )
C
C     NAME       :  GRDFMT
C
C     PURPOSE    :  DETERMINE GRID FILE FORMAT
C
C     PARAMETERS       DESCRIPTION
C
C     LUGRD            LOGICAL UNIT OF SINGLE LAYER GRID
C     LUO              LOGICAL UNIT OF OUTPUT
C     IFMT             GRID FILE FORMAT (0=UNKNOWN,1=INX,2=RNX,3=MRTCA,4=SCH,5=SH,6=RTCM)
C
      IMPLICIT NONE
C
      INTEGER*4 LUGRD, LUO, IFMT
C
      CHARACTER*80     RECORD  
      CHARACTER*20     RECID
      CHARACTER*64     HEX
      INTEGER*4        IT,SIZ
      INTEGER*4 IYEAR,IMTH,IDAY,NSTN,NSAT
      REAL*8    SLAT,ELAT,DLAT,SLON,ELON,DLON,SLMHGT,ELVCUT
C
C     READ FIRST RECORD OF FILE AND DETERMINE FORMAT
C
      IF ( IFMT .EQ. 0 ) THEN
        READ(LUGRD,'(A80)',ERR=1000) RECORD
        READ(RECORD,'(60X,A20)',ERR=950) RECID
        IF ( RECID .EQ. 'IONEX VERSION / TYPE' ) IFMT=1
        IF ( RECID .EQ. 'RINEX VERSION / TYPE' ) IFMT=2
        REWIND(LUGRD)
        IF ( IFMT .NE. 0 ) RETURN
  950   CONTINUE
        REWIND (LUGRD)
        DO IT=1,100
         READ(LUGRD,'(A20)',ERR=970,END=960) RECID
         IF ( RECID .EQ. 'START OF SCHA COEF: ' ) IFMT=4
         IF ( RECID(1:18) .EQ. 'START OF SH COEF: ' ) IFMT=5
        END DO
  960   CONTINUE
        REWIND(LUGRD)
        IF ( IFMT .NE. 0 ) RETURN
  970   CONTINUE
        READ(RECORD,'(I10,1X,A64)',ERR=1000) IT,HEX
        DO IT=1,64
         IF( HEX(IT:IT) .NE. '0' .AND. HEX(IT:IT) .NE. '1' .AND.
     &       HEX(IT:IT) .NE. '2' .AND. HEX(IT:IT) .NE. '3' .AND.
     &       HEX(IT:IT) .NE. '4' .AND. HEX(IT:IT) .NE. '5' .AND.
     &       HEX(IT:IT) .NE. '6' .AND. HEX(IT:IT) .NE. '7' .AND.
     &       HEX(IT:IT) .NE. '8' .AND. HEX(IT:IT) .NE. '9' .AND.
     &       HEX(IT:IT) .NE. 'A' .AND. HEX(IT:IT) .NE. 'a' .AND.
     &       HEX(IT:IT) .NE. 'B' .AND. HEX(IT:IT) .NE. 'b' .AND.
     &       HEX(IT:IT) .NE. 'C' .AND. HEX(IT:IT) .NE. 'c' .AND.
     &       HEX(IT:IT) .NE. 'D' .AND. HEX(IT:IT) .NE. 'd' .AND.
     &       HEX(IT:IT) .NE. 'E' .AND. HEX(IT:IT) .NE. 'e' .AND.
     &       HEX(IT:IT) .NE. 'F' .AND. HEX(IT:IT) .NE. 'f' ) GOTO 990
        END DO
        IFMT=3
 980    CONTINUE
        IF ( IFMT .NE. 0 ) RETURN
 990    CONTINUE
        READ(RECORD,*,ERR=1000,END=1000) IT, SIZ, HEX
        DO IT=1,64
         IF( HEX(IT:IT) .NE. '0' .AND. HEX(IT:IT) .NE. '1' .AND.
     &       HEX(IT:IT) .NE. '2' .AND. HEX(IT:IT) .NE. '3' .AND.
     &       HEX(IT:IT) .NE. '4' .AND. HEX(IT:IT) .NE. '5' .AND.
     &       HEX(IT:IT) .NE. '6' .AND. HEX(IT:IT) .NE. '7' .AND.
     &       HEX(IT:IT) .NE. '8' .AND. HEX(IT:IT) .NE. '9' .AND.
     &       HEX(IT:IT) .NE. 'A' .AND. HEX(IT:IT) .NE. 'a' .AND.
     &       HEX(IT:IT) .NE. 'B' .AND. HEX(IT:IT) .NE. 'b' .AND.
     &       HEX(IT:IT) .NE. 'C' .AND. HEX(IT:IT) .NE. 'c' .AND.
     &       HEX(IT:IT) .NE. 'D' .AND. HEX(IT:IT) .NE. 'd' .AND.
     &       HEX(IT:IT) .NE. 'E' .AND. HEX(IT:IT) .NE. 'e' .AND.
     &       HEX(IT:IT) .NE. 'F' .AND. HEX(IT:IT) .NE. 'f' ) RETURN
        END DO
        IFMT=6
      END IF
 1000 CONTINUE
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** GRDLAY
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE GRDLAY( LPR, IYEAR, IMONTH, IDAY, TOBS, XSTN, XSAT, 
     &                   ZEN, AE, HION, MININC, REFLAT, REFLON, DLAT, 
     &                   DLON, AION, RION, SVCAL, VION, CORION, IONREF, 
     &                   REFTIM, PI )
C
C     NAME       :  GRDLAY
C
C     PURPOSE    :  COMPUTE IONOSPHERIC DELAY FROM SINGLE-LAYER GRID
C
C      PARAMETERS       DESCRIPTION
C
C      LPR              LOGICAL UNIT OF PRINTER
C      IYEAR            YEAR 
C      IMONTH           MONTH
C      IDAY             DAY
C      TOBS             GPS TIME OF OBSERVATION
C      XST              STATION GEOCENTRIC CARTESIAN COORDINATES
C      XSAT             SATELLITE GEOCENTRIC CARTESIAN COORDINATES 
C      ZEN              STATION->SATELLITE ZENITH ANGLE
C      AE               EARTH RADIUS
C      HION             IONOSPHERE SINGLE LAYER HEIGHT
C      MININC           MINIMUM CELL INCREMENT
C      REFLAT           REFERENCE LATITUDE OF GRID
C      REFLON           REFERENCE LONGITUDE OF GRID
C      DLAT             LATITUDE INCREMENT
C      DLON             LONGITUDE INCREMENT
C      AION             AVERAGE VERTICAL IONOSPHERIC DELAY
C      RION             RMS OF VERTICAL IONOSPHERIC DELAY
C      NSATCAL          NUMBER OF SATELLITES CALIBRATED
C      ISATCAL          PRN'S OF SATELLITES CALIBRATED
C      SATCAL           SATELLITE CALIBRATION DELAYS
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4 LPR,IYEAR,IMONTH,IDAY,MININC,IONREF
      REAL*8    TOBS,ZEN,AE,HION,REFLAT,REFLON,DLAT,DLON
      REAL*8    SVCAL,VION,CORION,REFTIM,PI,XSTN(*),XSAT(*)
      REAL*8    AION(MAXLAT,*),RION(MAXLAT,*)
C
      INTEGER*4 IDOY,IDXLAT,IDXLON,IERROR,ICD
      REAL*8    HIONM,XPT(3),PLZ(3),GMAGLAT,GMAGLON,GMAGHR
      REAL*8    PPLAT,PPHRA,DT,TODR,D90
C
      DATA ICD/0/
C
C     COMPUTE COORDINATES OF IONO PIERCE POINT
C
      HIONM=HION*1.D3
c!    WRITE(*,'(A4,3F15.3)') 'XSTN',XSTN(1),XSTN(2),XSTN(3)
c!    WRITE(*,'(A4,3F15.3)') 'XSAT',XSAT(1),XSAT(2),XSAT(3)
c!    WRITE(*,'(3(A4,F10.2))') 'ZEN',ZEN*180.D0/PI,'AE  ',AE,
c!   &                 'HION',HION
      CALL IONPT( XSTN, XSAT, ZEN, AE, HIONM, XPT, PLZ, PI )
c!    WRITE(*,'((A4,F10.2))') 'PLZ3',PLZ(3)*180.D0/PI
C
C     IONOSPHERIC GRID IS SUN-FIXED/GEOMAGNETIC
C
      IF (IONREF .EQ. 1) THEN
         CALL JULDM ( IDOY, IYEAR, IMONTH, IDAY, 1 )
         CALL TOMAG ( IYEAR, IDOY, TOBS, PLZ(1), PLZ(2), 
     &             GMAGLAT, GMAGLON, GMAGHR, ICD )
         PPLAT= GMAGLAT*180.D0/PI
         PPHRA= GMAGHR*15.D0
       IF ( PPHRA .LT. 0.D0 ) PPHRA=PPHRA+360.D0
      END IF
C
C     IONOSPHERIC GRID IS EARTH-FIXED/GEOGRAPHIC
C
      IF (IONREF .EQ. 0) THEN
        DT    = DMOD(TOBS,86400.D0)-DMOD(REFTIM,86400.D0)
      TODR  = DT/86400.D0*(2.D0*PI)
        PPHRA = PLZ(2) + TODR
        PPHRA = DMOD (PPHRA,2.D0*PI)      
        PPHRA = PPHRA*180.D0/PI
      IF ( PPHRA .LT. 0.D0 ) PPHRA=PPHRA+360.D0
      PPLAT = PLZ(1)*180.D0/PI
      END IF
C      
      CALL IDXPP(MININC,REFLAT,REFLON,DLAT,DLON,1,PPLAT,PPHRA,
     &               IDXLAT,IDXLON,IERROR)        
c!    WRITE(*,*) REFLAT,REFLON,DLAT,DLON,PPLAT,PPHRA,IDXLAT,IDXLON
      IF( IERROR .EQ. 1 ) THEN
      VION = AION(IDXLAT,IDXLON)
      CORION = 0.D0
      IF ( VION .NE. 999.D0 ) THEN
        VION = AION(IDXLAT,IDXLON)/1.D2
        D90=DABS(PLZ(3)-PI/2.D0)*180.D0/PI
        IF (D90 .GT. 1.D0) THEN
          CORION = VION/DCOS(PLZ(3)) - SVCAL
      ELSE
        CORION = VION - SVCAL
      END IF
      END IF
c!    WRITE(*,'(A3,I3,4F8.1,2I5,4F10.1)') 'ION',IONREF,PPLAT,PPHRA,
c!   &     PLZ(3)*180/PI,TODR*180/PI,IDXLAT,IDXLON,CORION,
c!   &     TOBS, REFTIM, SVCAL
C
      ELSE
       VION = 999.D0
       CORION = 0.D0
      ENDIF
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** HDCLX
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
        SUBROUTINE HDCLX ( LUCLX, INTVL, IFMT )
C
C     NAME              HDCLX
C
C     PURPOSE   READ HEADER OF RINEX CLOCK FILE
C
C     PARAMETERS        DESCRIPTION
C
C        LUPCLX LOGICAL UNIT OF RINEX CLOCK FILE
C          INTVL        TIME INTERVAL OF CLOCK ESTIMATES
C          IFMT         FORMAT OF CLOCK FILE (-1=Unknown,1=RNX,2=MRTCAhex,3=RTCMhex)
C
C *********************************************************************
C
C
      IMPLICIT NONE
C
      INTEGER*4 LUCLX, INTVL, IFMT
C
      INTEGER*4    IT
      CHARACTER*64 HEX
      CHARACTER*1  FTYPE
      CHARACTER*80 RECORD
      CHARACTER*60 COMMENT
      CHARACTER*55 ACNAM
      CHARACTER*50 ITRF
      CHARACTER*20 LABEL
      CHARACTER*20 PGM
      CHARACTER*20 RUNBY
      CHARACTER*20 CDATE
      CHARACTER*20 REFDOM, STADOM
      CHARACTER*2  CLKT(5)
      CHARACTER*3  AC
      CHARACTER*4  REFNAM, STANAM
      INTEGER*4 SIZE
      INTEGER*4 I,NCLKT,NCLKRF,ISYRRF,ISMTHRF,ISDAYRF,ISHRRF,ISMINRF
      INTEGER*4 IEYRRF,IEMTHRF,IEDAYRF,IEHRRF,IEMINRF,NSTACLK,IEOF
      REAL*8    VERSION,SSECRF,ESECRF,REFSD
      LOGICAL      LBLFOUND
      LOGICAL      TRYRTCA,TRYRTCM
      TRYRTCA=.TRUE.
      TRYRTCM=.TRUE.
C
      LBLFOUND=.FALSE.
      IFMT=-1
C
C------------------------------------------------------------------------
C     READ HEADER RECORD FROM RINEX CLOCK FORMAT
C------------------------------------------------------------------------
C
  100 CONTINUE
      READ(LUCLX,'(A80)',END=500) RECORD
      IF( RECORD(1:5) .EQ. 'c sat' .OR.
     &    RECORD(1:5) .EQ. 'c sat' ) THEN
       IFMT=5
       INTVL=30
       BACKSPACE(LUCLX)
       RETURN
      END IF
      IF( .NOT. TRYRTCA ) GOTO 110
      READ(RECORD,'(I10,1X,A64)',ERR=110) IT,HEX
      DO IT=1,64
       IF( HEX(IT:IT) .NE. '0' .AND. HEX(IT:IT) .NE. '1' .AND.
     &     HEX(IT:IT) .NE. '2' .AND. HEX(IT:IT) .NE. '3' .AND.
     &     HEX(IT:IT) .NE. '4' .AND. HEX(IT:IT) .NE. '5' .AND.
     &     HEX(IT:IT) .NE. '6' .AND. HEX(IT:IT) .NE. '7' .AND.
     &     HEX(IT:IT) .NE. '8' .AND. HEX(IT:IT) .NE. '9' .AND.
     &     HEX(IT:IT) .NE. 'A' .AND. HEX(IT:IT) .NE. 'a' .AND.
     &     HEX(IT:IT) .NE. 'B' .AND. HEX(IT:IT) .NE. 'b' .AND.
     &     HEX(IT:IT) .NE. 'C' .AND. HEX(IT:IT) .NE. 'c' .AND.
     &     HEX(IT:IT) .NE. 'D' .AND. HEX(IT:IT) .NE. 'd' .AND.
     &     HEX(IT:IT) .NE. 'E' .AND. HEX(IT:IT) .NE. 'e' .AND.
     &     HEX(IT:IT) .NE. 'F' .AND. HEX(IT:IT) .NE. 'f' ) GOTO 110
      END DO
      IFMT=2
      INTVL=2
      RETURN
110   CONTINUE
      TRYRTCA=.FALSE.
      IF( .NOT. TRYRTCM ) GOTO 115
      READ(RECORD,'(I10,1X,I4,1X,A64)',ERR=115) IT,SIZE,HEX
      SIZE=SIZE*2
      IF( SIZE .GT. 64 ) SIZE=64
      DO IT=1,SIZE
       IF( HEX(IT:IT) .NE. '0' .AND. HEX(IT:IT) .NE. '1' .AND.
     &     HEX(IT:IT) .NE. '2' .AND. HEX(IT:IT) .NE. '3' .AND.
     &     HEX(IT:IT) .NE. '4' .AND. HEX(IT:IT) .NE. '5' .AND.
     &     HEX(IT:IT) .NE. '6' .AND. HEX(IT:IT) .NE. '7' .AND.
     &     HEX(IT:IT) .NE. '8' .AND. HEX(IT:IT) .NE. '9' .AND.
     &     HEX(IT:IT) .NE. 'A' .AND. HEX(IT:IT) .NE. 'a' .AND.
     &     HEX(IT:IT) .NE. 'B' .AND. HEX(IT:IT) .NE. 'b' .AND.
     &     HEX(IT:IT) .NE. 'C' .AND. HEX(IT:IT) .NE. 'c' .AND.
     &     HEX(IT:IT) .NE. 'D' .AND. HEX(IT:IT) .NE. 'd' .AND.
     &     HEX(IT:IT) .NE. 'E' .AND. HEX(IT:IT) .NE. 'e' .AND.
     &     HEX(IT:IT) .NE. 'F' .AND. HEX(IT:IT) .NE. 'f' ) GOTO 110
      END DO
      IFMT=3
      INTVL=2
      RETURN
115   CONTINUE
      TRYRTCM=.FALSE.
      LABEL = RECORD(61:80)
C
C     BLANK LINE IS END OF HEADER
C
      IF ( LABEL .EQ. '                    ' .OR.
     &            RECORD(1:8).EQ.'WIDELANE'  .OR.
     &            LABEL .EQ. 'END OF HEADER       ') THEN
        LBLFOUND=.TRUE.
      GO TO 200
      END IF
C
C     EXTRACT RINEX FORMAT VERSION AND DATA TYPE
C
      IF ( LABEL .EQ. 'RINEX VERSION / TYPE' ) THEN
        LBLFOUND=.TRUE.
        READ(RECORD,'(F9.2,11X,A1,39X)') VERSION,FTYPE
      END IF
C
C     EXTRACT PROGRAM, AGENCY AND FILE CREATION DATE
C
      IF ( LABEL .EQ. 'PGM / RUN BY / DATE' ) THEN
        LBLFOUND=.TRUE.
        READ(RECORD,'(3A20)') PGM,RUNBY,CDATE
      END IF
C
C     EXTRACT COMMENTS
C
      IF ( LABEL .EQ. 'COMMENT            ' ) THEN
        LBLFOUND=.TRUE.
        READ(RECORD,'(A60)') COMMENT
      END IF
C
C     EXTRACT NUMBER AND TYPES OF DATA
C
      IF ( LABEL .EQ. '# / TYPES OF DATA  ' ) THEN
        LBLFOUND=.TRUE.
        READ(RECORD,'(I6,5(4X,A2))') NCLKT
      IF ( NCLKT .GT. 0 .AND. NCLKT .LE. 5 )
     &    READ(RECORD,'(6X,5(4X,A2))') (CLKT(I), I=1,NCLKT)
      END IF
C
C     EXTRACT ANALYSIS CENTER CODE AND NAME
C
      IF ( LABEL .EQ. 'ANALYSIS CENTER    ' ) THEN
        LBLFOUND=.TRUE.
        READ(RECORD,'(A3,2X,A55)') AC,ACNAM
      END IF
C
C     EXTRACT NUMBER OF CLOCK REFERENCES AND START/END TIMES
C
      IF ( LABEL .EQ. '# OF CLK REF       ' ) THEN
        LBLFOUND=.TRUE.
        READ(RECORD,'(I6,2(1X,I4,4(I3),F10.6))') NCLKRF, 
     &       ISYRRF, ISMTHRF, ISDAYRF, ISHRRF, ISMINRF, SSECRF,
     &       IEYRRF, IEMTHRF, IEDAYRF, IEHRRF, IEMINRF, ESECRF
      END IF
C
C     EXTRACT REFERENCE CLOCK NAMES AND CONSTRAINTS
C
      IF ( LABEL .EQ. 'ANALYSIS CLK REF   ' ) THEN
        LBLFOUND=.TRUE.
        READ(RECORD,'(A4,1X,A20,15X,E19.12,1X)') REFNAM, REFDOM,REFSD 
      END IF
C
C     EXTRACT NUMBER OF STATION CLOCKS SOLVED AND REFERENCE FRAME
C
      IF ( LABEL .EQ. '# OF SOLN STA / TRF' ) THEN
        LBLFOUND=.TRUE.
        READ(RECORD,'(I6,4X,A50)') NSTACLK, ITRF 
      END IF
C
C     EXTRACT STATION NAMES AND COORDINATES
C
      IF ( LABEL .EQ. 'SOLN STA NAME / NUM' ) THEN
        LBLFOUND=.TRUE.
        READ(RECORD,'(A4,1X,A20)') STANAM, STADOM
      END IF
      IF (LBLFOUND) GO TO 100
  200 CONTINUE
      IF (LBLFOUND) IFMT=1
      RETURN
C
  500 CONTINUE
      IEOF = 1
      RETURN
C
C------------------------------------------------------------------------
C     FORMAT STATEMENTS
C------------------------------------------------------------------------
C
 1000 FORMAT (I6,9(4X,A2))
 1010 FORMAT(5I6,F12.6)
20000 FORMAT (9X,I2.2,1X,I4,1X,4(I2.2,1X),F8.4,2F15.12)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** HDRNX
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE HDRNX ( LUMEA, IYEAR, IMTH, IDAYM, STNA,
     &                   OBSINT, NOBTYP, IOBPOS, NFREQ, HDXYZH, 
     &                   ANTNAM, RECNAM, IFREQ, IEOF )
C
C     NAME              HDRNX
C
C     PURPOSE   READ HEADER RECORD IN RINEX DATA FORMAT
C
C     PARAMETERS        DESCRIPTION
C
C        LUMEA  LOGICAL UNIT OF MEASUREMENT FILE
C        STNA   NAME OF STATION OBSERVED
C        IYEAR  YEAR OF DATA COLLECTION
C        IMTH   MONTH OF DATA COLLECTION
C        IDAYM  DAY OF MONTH OF DATA COLLECTION
C        OBSINT DATA RATE
C        NOBTYP NUMBER OF OBSERVATION TYPES (RNX ONLY)
C        IOBPOS POSITION OF L1, L2, P1 & P2 OBSERVATIONS
C        DLAY12 RECEIVER INTER FREQUENCY DELAY (SEC.)
C          HDXYZH       APPROXIMATE RECEIVER COORDINATES & ANTENNA HEIGHT
C          ANTNAM       ANTENNA NAME
C        IEOF   END OF FILE FLAG
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4    LUMEA, IEOF
      INTEGER*4    IYEAR, IMTH, IDAYM
      INTEGER*4   IOBPOS(10), NOBTYP, NFREQ
      REAL*8       HDXYZH(4), OBSINT
      CHARACTER*40 STNA
C
      INTEGER*4    IDUM
      INTEGER*4    IDATE
      INTEGER*4    IO,I
      INTEGER*4    IFREQ
      REAL*8       DUM
C
      CHARACTER*80 RECORD
      CHARACTER*20 COMMENT
      CHARACTER*20 ANTNUM, ANTNAM
      CHARACTER*20 RECNUM, RECNAM, RECSW
C
C manage up to 30 observation types (2.11 is 26)
C
      CHARACTER*2  OBTYP(30)
      INTEGER*4    NOBTYPR
C
C------------------------------------------------------------------------
C     READ HEADER RECORD FROM RINEX FORMAT
C------------------------------------------------------------------------
C
      DO I=1,10
        IOBPOS(I)=0
      END DO
      NOBTYP=0
      NOBTYPR=0
      STNA='N/A '
      NFREQ = 1
  100 CONTINUE
      READ(LUMEA,'(A80)',END=500) RECORD
c!    write(*,*) 'record',record
      COMMENT = RECORD(61:80)
c!    WRITE(*,*) 'COMMENT---',COMMENT,'---'
C
C     BLANK LINE IS END OF HEADER
C
      IF ( COMMENT .EQ. '                    ' .OR.
     &            COMMENT(1:13) .EQ. 'END OF HEADER') GO TO 200
C
C     EXTRACT MARKER NAME
C
      IF ( COMMENT(1:11) .EQ. 'MARKER NAME' ) THEN
        READ(RECORD,'(A40)') STNA
      IF ( STNA(1:4) .EQ. '    ' ) STNA='N/A '
      END IF
C
C     EXTRACT APPROXIMATE POSITION
C
      IF ( COMMENT(1:19) .EQ. 'APPROX POSITION XYZ' )
     &     READ(RECORD,'(3F14.4)') HDXYZH(1),HDXYZH(2),HDXYZH(3)
C
C     EXTRACT ANTENNA HEIGHT
C
      IF ( COMMENT .EQ. 'ANTENNA: DELTA H/E/N' )
     &             READ(RECORD,'(F14.4)') HDXYZH(4)
C
C     EXTRACT ANTENNA NAME
C
      IF ( COMMENT(1:12) .EQ. 'ANT # / TYPE' ) THEN
        READ(RECORD,'(2A20)') ANTNUM, ANTNAM
      END IF
C
C     EXTRACT RECEIVER NAME
C
      IF ( COMMENT(1:19) .EQ. 'REC # / TYPE / VERS' ) 
     &  READ(RECORD,'(3A20)') RECNUM, RECNAM, RECSW
C
C     EXTRACT OBSERVATION TYPE
C
      IF ( COMMENT(1:19) .EQ. '# / TYPES OF OBSERV' ) THEN
        IF( NOBTYPR .EQ. 0 ) READ(RECORD,1001) NOBTYP
      IF( NOBTYPR*9+1 .LE. MIN(30,NOBTYP) )
     &   READ(RECORD,1000)
     &    (OBTYP(I),I=NOBTYPR*9+1,MIN(30,MIN((NOBTYPR+1)*9,NOBTYP)))
      NOBTYPR=NOBTYPR+1
      END IF
C
C     EXTRACT COLLECTION INTERVAL
C
      IF ( COMMENT .EQ. 'INTERVAL' ) THEN
         READ(RECORD,*) OBSINT
c!     WRITE(*,'(a20,F10.3)') 'OBSERVATION INTERVAL IS',OBSINT
      END IF
C
C     EXTRACT FIRST OBSERVATION TIME
C
      IF ( COMMENT .EQ. 'TIME OF FIRST OBS' ) THEN
      READ(RECORD,1010) IYEAR, IMTH, IDAYM, IDUM, IDUM, DUM
c!       write(*,*) record
      END IF
C
      GO TO 100
  200 CONTINUE
      DO IO=1,MIN(30,NOBTYP)
      IF (OBTYP(IO).EQ.'L1') IOBPOS(1) = IO
      IF (OBTYP(IO).EQ.'L2') IOBPOS(2) = IO
      IF (OBTYP(IO).EQ.'P1') IOBPOS(3) = IO
      IF (OBTYP(IO).EQ.'C1') IOBPOS(5) = IO
      IF (OBTYP(IO).EQ.'C2') THEN
        IOBPOS(6) = IO
        NFREQ = 2
      ENDIF
      IF (OBTYP(IO).EQ.'P2') THEN
        IOBPOS(4) = IO
        NFREQ = 2
      END IF
CGALILEO L5/E5a
      IF(IFREQ.LE.8) THEN
C GAL F2 DEFAULT
       IF (OBTYP(IO).EQ.'L5') IOBPOS(7) = IO
       IF (OBTYP(IO).EQ.'C5') IOBPOS(8) = IO
C BEI F2 DEFAULT
       IF (OBTYP(IO).EQ.'L7') IOBPOS(9) = IO
       IF (OBTYP(IO).EQ.'C7') IOBPOS(10) = IO
      ENDIF
C 
      IF(IFREQ.EQ.8) THEN
C GALILEO L8/(Ea+E5b)/2
       IF (OBTYP(IO).EQ.'L8') IOBPOS(7) = IO
       IF (OBTYP(IO).EQ.'C8') IOBPOS(8) = IO
      ENDIF
C 
      IF(IFREQ.EQ.7) THEN
C GALILEO L8/E5b
       IF (OBTYP(IO).EQ.'L7') IOBPOS(7) = IO
       IF (OBTYP(IO).EQ.'C7') IOBPOS(8) = IO
      ENDIF
         NFREQ = 2
      END DO
      IDATE=IYEAR+IMTH+IDAYM
      IF ( IDATE .EQ. 0 ) THEN
        READ(LUMEA,'(A80)',END=500) RECORD
        BACKSPACE(LUMEA)
        READ(RECORD,1020,ERR=100,END=100) IYEAR, IMTH, IDAYM,
     &                                   IDUM, IDUM, DUM, IDUM, IDUM
        IF ( IYEAR .GE. 0 .AND. IYEAR .LT. 80 ) THEN
          IYEAR = IYEAR + 2000
        ELSE
          IYEAR = IYEAR + 1900
        END IF
      END IF
      RETURN
  500 CONTINUE
      IEOF = 1
      RETURN
C
C------------------------------------------------------------------------
C     FORMAT STATEMENTS
C------------------------------------------------------------------------
C
 1000 FORMAT (6X,9(4X,A2))
 1001 FORMAT (I6)
 1010 FORMAT(5I6,F12.6)
 1020 FORMAT(5I3,F11.7,2(1X,I2))
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C***************************************************************** HDSP3
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE HDSP3 ( LUPEP, NEWPEP, NEWTT, NPEPSV, IPEPSV,
     &                   IGPSWK, SECOW, IEND, IPEPACC, NPEPEPO, 
     &                   IMINACC,
     &                   IPEPINT, FLOAT1, FLOAT2)
C
C     NAME:      HDSP3
C
C     PURPOSE:   READ HEADER OF PRECISE SP3 EPHEMERIS
C
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     LUPEP             LOGICAL UNIT OF PRECISE EPHEMERIS FILE
C     NEWPEP            NEW PRECISE EPHEMERIS FLAG
C     NPEPSV            NUMBER OF SATELLITES WITH PRECISE EPHEMERIS
C     IPEPSV            ARRAY OF PRN'S WITH PRECISE EPHEMERIS
C       IPEPACC         PRECISE EPHEMERIS ACCURACY CODES
C       NPEPEPO         NUMBER OF PRECISE EPHEMERIS EPOCHS
C       IPEPINT         PRECISE EPHEMERIS INTERVAL (SECONDS)
C     IEND              END OF FILE FLAG
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      LOGICAL   NEWPEP, NEWTT
      INTEGER*4 LUPEP,NPEPSV,IGPSWK,IEND,NPEPEPO,IPEPINT
      INTEGER*4 IPEPSV(*),IPEPACC(*)
      INTEGER*4 IMINACC
      REAL*8    SECOW
C
      INTEGER*4 IYEAR,IMONTH,IDAY,IHOUR,IMIN,MJULD,IS
      INTEGER*4 I,J,INT1,INT2,INT3,INT4,INT5,INT6,INT7,INT8
C USE 200 as MAX NO SVs IN SP3
      INTEGER*4 IDSV(200),IESV(200)
      REAL*8    FLOAT1,FLOAT2,FLOAT3,FLOAT4
      REAL*8    SEC,PEPINT,FJULD
C
      CHARACTER*1   G(200)
      CHARACTER*2   IDLIN
      CHARACTER*5   USEDAT
      CHARACTER*5   IFRAME
      CHARACTER*3   ORBTYP
      CHARACTER*4   AGENCY
      CHARACTER*57  COMMENT
      CHARACTER*60  RECORD
C
      CHARACTER*2   STR1,       STR2
      CHARACTER*3   STR3,       STR4
      CHARACTER*4   STR5,       STR6,     STR7,   STR8
      CHARACTER*5   STR9,       STR10,    STR11,  STR12
C
C
C  READ HEADER INFORMATION
C  -----------------------
C
       READ(LUPEP,'(A60)',END=900) RECORD
c!        write(*,*) record
       READ(RECORD,1000,END=900) IDLIN, IYEAR, IMONTH, IDAY, IHOUR, 
     &                IMIN, SEC, NPEPEPO, USEDAT, IFRAME, ORBTYP, AGENCY
       READ(LUPEP,'(A60)',END=900) RECORD
c!        write(*,*) record
       READ(RECORD,1100,END=900) IDLIN, IGPSWK, SECOW, PEPINT, MJULD, 
     &                            FJULD
         IPEPINT=IDNINT(PEPINT)
       READ(LUPEP,1200,END=900) IDLIN, NPEPSV, (G(I),IDSV(I),I=1,17)
       DO J=1,40
       READ(LUPEP,'(A60)',END=900) RECORD
       IF(RECORD(1:2).EQ.'++') GO TO 10
       READ(RECORD,1210,END=900) (G(I),IDSV(I),I=J*17+1,(J+1)*17)
       END DO
C
10     READ(RECORD,1300,END=900) (IESV(I),I=1,17 )
       DO J=1,40
       READ(LUPEP,'(A60)',END=900) RECORD
       IF(RECORD(1:2).EQ.'%c') GO TO 20
       READ(RECORD,1300,END=900) (IESV(I),I=J*17+1,(J+1)*17)
       END DO
20     BACKSPACE(LUPEP)
       DO 200 IS=1,NPEPSV
C IGNORE ALL BUT G and R satellites for NOW
         IPEPSV(IS)= 0
         IF(G(IS).EQ.' ' .OR.
     &      G(IS).EQ.'G') IPEPSV(IS) = IDSV(IS)
        IF ( G(IS).EQ.'R' ) THEN
         IPEPSV(IS) = IDSV(IS) + 32 
        ENDIF
C Galileo PRN <63,100>
        IF(G(IS).EQ.'E') IPEPSV(IS) = IDSV(IS)+ 64
        IF(G(IS).EQ.'C') IPEPSV(IS) = IDSV(IS)+ 100
        IF(IPEPSV(IS).GT.0.AND.IPEPSV(IS).LE.MAXSAT) THEN
           IF(IESV(IS).gt.0) IESV(IS)= IESV(IS)+IMINACC
           IPEPACC(IPEPSV(IS)) = 2**IESV(IS)
           IF (IESV(IS).EQ. 0) IPEPACC(IPEPSV(IS))=50000
        END IF
  200  CONTINUE
         READ(LUPEP,'(A60)',END=900) RECORD
c!        write(*,*) record
       READ(RECORD,1400,END=900) IDLIN, STR1, STR2, STR3, STR4,
     &                            STR5, STR6, STR7, STR8,
     &                            STR9, STR10,STR11,STR12
         READ(LUPEP,'(A60)',END=900) RECORD
c!        write(*,*) record
       READ(RECORD,1400,END=900) IDLIN, STR1, STR2, STR3, STR4,
     &                            STR5, STR6, STR7, STR8,
     &                            STR9, STR10,STR11,STR12
         READ(LUPEP,'(A60)',END=900) RECORD
c!        write(*,*) record
       READ(RECORD,1500,END=900) IDLIN, FLOAT1, FLOAT2, FLOAT3, FLOAT4
         READ(LUPEP,'(A60)',END=900) RECORD
c!        write(*,*) record
         READ(LUPEP,'(A60)',END=900) RECORD
c!        write(*,*) record
       READ(RECORD,1600,END=900) IDLIN, INT1, INT2, INT3, INT4,
     &                            INT5, INT6, INT7, INT8
         READ(LUPEP,'(A60)',END=900) RECORD
       READ(RECORD,1600,END=900) IDLIN, INT1, INT2, INT3, INT4,
     &                            INT5, INT6, INT7, INT8
         READ(LUPEP,'(A60)',END=900) RECORD
c!        write(*,*) record
       READ(RECORD,1700,END=900) IDLIN, COMMENT
         READ(LUPEP,'(A60)',END=900) RECORD
c!        write(*,*) record
       READ(RECORD,1700,END=900) IDLIN, COMMENT
c!        write(*,*) record
         READ(LUPEP,'(A60)',END=900) RECORD
c!        write(*,*) record
       READ(RECORD,1700,END=900) IDLIN, COMMENT
         READ(LUPEP,'(A60)',END=900) RECORD
c!        write(*,*) record
       READ(RECORD,1700,END=900) IDLIN, COMMENT
C
       NEWTT    = .TRUE.
       NEWPEP = .FALSE.
C
         IEND = 0
         RETURN
  900  CONTINUE
         IEND = 1
C
C  FORMAT STATEMENTS
C  -----------------
C
 1000 FORMAT ( A2,1X,I4,1X,4(I2,1X),F11.8,1X,I7,1X,2(A5,1X),A3,1X,A4 )
 1100 FORMAT ( A2,1X,I4,1X,F15.8,1X,F14.8,1X,I5,1X,F15.13 )
 1200 FORMAT ( A2,2X,I2, 3X, 17(A1,I2))
 1210 FORMAT ( 9X, 17(A1,I2))
 1300 FORMAT ( 9X, 17(1X,I2))
 1400 FORMAT ( A2,2(1X,A2), 2(1X,A3),4(1X,A4),4(1X,A5) )
 1500 FORMAT ( A2,1X,F10.7,1X,F12.9,1X,F14.11,1X,F18.15 )
 1600 FORMAT ( A2,4(1X,I4),4(1X,I6),1X,I9 )
 1700 FORMAT ( A2,1X,A57 )
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C***************************************************************** HOPF
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE HOPF( TT, P, RH, ELDEG , DRYZEN, WETZEN, 
     &               DRYMAP, WETMAP, TROCOR, XRV )
C
C     PURPOSE:   EVALUATES TROPOSPHERIC REFRACTION USING HOPFIELDS 
C                MODEL AND BLACKS APPROXIMATION FOR SLANT RANGE INTEGRAL
C
C     PARAMETER SPECIFICATIONS:
C
C        TT     - TEMPERATURE (DEG C)
C        P      - PRESSURE (MBAR)
C        RH       - RELATIVE HUMIDITY (%)
C        ELDEG  -  SATELLITE ELEVATION ANGLE (DEGREES)
C          TROCOR - TROPOSHERIC CORRECTION RETURNED (M)
C          XRV    - RECEIVER CARTESIAN COORDINATES
C
      IMPLICIT NONE
C
      REAL*8    TT,P,RH,ELDEG,DRYZEN,WETZEN,DRYMAP,WETMAP,TROCOR
      REAL*8    XRV(*)
C
      REAL*8    RAD,TK,E,ELED,ELER,RO,RHD,RHW,TLC1,CSE1,ROD
      REAL*8    TID1,BEN,DKD,ROW,TIW1,DKW
      REAL*8    LOWE
C
      RAD= 57.29578D0
      TK = TT + 273.13D0
      E =  LOWE (TK) * (RH/100.D0)
      ELED= ELDEG
      ELER= ELED/RAD
C     
C     RO IS THE STATION RADIUS  I.E. SQRT(X**2+Y**2+Z**2)
C
      RO = XRV(1)*XRV(1) + XRV(2)*XRV(2) + XRV(3)*XRV(3)
      RO = DSQRT(RO)
C
C     RHD, RHW ARE HEIGHTS OF DRY AND WET ATMOSPHERE
C     A B O V E  S T A T I O N
C                                 RHD= 40136 +148.72*TT
      RHD= 148.72D0*( TK-3.254D0)
C                                 RHW= 11462 +62.*TT
      RHW=  62.00D0*(TK-88.259D0)
C   
C     APPROXIMATION OF BLACKS' ( 1.- LC) PARAMETR
C
      TLC1=         -(.076D0+.15D-3*TT)
      TLC1 =  TLC1/ EXP(0.3D0*ELED)   +.1667D0
      CSE1=DCOS(ELER    )
C
C     DRY COMPONENT
C
      ROD= RO/RHD
C
C     NOTE -1.92/(ELE**2 +.6)  IS APPROXIMATION OF RAY BENDING  (ELE IN DEG
C
      TID1= 1.D0/(1.D0-( CSE1/(1.D0+TLC1/ROD))**2)
C
C     BEN IS APPROXIAMTION OF RAY BENDING
C
      BEN= 1.92D0/(ELED**2 +.6D0)
      BEN=0.D0
      DKD= 1.552D-05 * (P/TK)*RHD
      DRYMAP = ( SQRT(TID1)   - BEN)  
      DRYZEN = DKD
C
C     WET COMPONENT
C
      ROW=  RO/RHW
      TIW1= 1.D0/(1.D0-( CSE1/(1.D0+TLC1/ROW))**2)
      DKW = 7.46512D-02* E/TK**2* RHW
      WETMAP = (SQRT(TIW1)  - BEN)
      WETZEN = DKW
      TROCOR = DRYZEN*DRYMAP  +  WETZEN*WETMAP
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** IDXLL
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE IDXLL(GPREF,CSIZE,MININC,ICOR,IWAY,GPINT,IDX,IFLAG)
CC
CC NAME       :  IDXLL
CC
CC
CC PURPOSE    :  COMPUTES GRID INDEX FROM LATITUDE OR LONGITUDE  
CC                                  .OR.
CC               LATITUDE OR LONGITUDE FROM GRID INDEX 
C
C
CC
CC PARAMETERS :
CC         IN    GPREF  : GRID POINT REFERENCE LAT/LON (DEG)  R*8
CC               CSIZE  : CELL SIZE (DEG)                     R*8
CC               MININC : MIN INCREMENT SIZE (.1 DEG. UNITS)  I*4
CC               ICOR   : 1=LAT,2=LON                         I*4
CC               IWAY   : 1=DEG->IDX,2=IDX->DEG               I*4
CC        I/O    GPINT  : GRID POINT LAT/LON (DEG)            R*8
CC               IDX    : LAT/LON INDEX ( WRT INITIAL GPREF)  I*4
CC        OUT    IFLAG  : 0=ERROR,1=OK                        I*4
CC
CC
CC EXAMPLE OF INDEXES (IDX) IN LONGITUDE FOR 3 DEG GRID WITH REFLON=-180 
CC IDX .VS. LON
CC IDX 61   66   71   76   81   86   91   96   101  106  111  116 120
CC     |----|----|----|----|----|----|----|----|----|----|----|----|
CC LON 0    15   30   45   60   75   90   105  120  135  150  165  180E
CC
CC IDX 1    6    11   16   21   26   31   36   41   46   51   56   61
CC     |----|----|----|----|----|----|----|----|----|----|----|----|
CC LON-180 -165 -150 -135 -120 -105 -90  -75  -60  -45  -30  -15   0
CC
CC EXAMPLE OF INDEXES (IDX) IN LATITUDE FOR 3 DEG GRID WITH REFLAT=-90 
CC IDX .VS. LAT
CC IDX 1    6    11   16   21   26   31   36   41   46   51   56   61
CC     |----|----|----|----|----|----|----|----|----|----|----|----|
CC LAT-90  -75  -60  -45  -30  -15   0    15   30   45   60   75   90
CC
      IMPLICIT NONE
C     
      INTEGER*4 MININC,ICOR,IWAY,IDX,IFLAG
      REAL*8    GPREF,CSIZE,GPINT
C
      INTEGER*4 LBAND,NHDCELL,NCELLS,INTCELL,INICELL,INTIDX,INIIDX
      REAL*8    SGPINT,SGPREF,DCELL,DEGMAX
C
      IFLAG=1
      LBAND=0
C
      IF ( ICOR .LT. 1 .OR. ICOR .GT. 2 ) THEN
      IFLAG=0
      RETURN
      ELSE
        IF (ICOR .EQ. 1) LBAND = 180
        IF (ICOR .EQ. 2) LBAND = 360
      END IF
C
      NHDCELL=INT(DABS(CSIZE)*10.D0)/MININC
      NCELLS = LBAND*10/NHDCELL/MININC
      IF (ICOR .EQ. 1) NCELLS=NCELLS+1
C
      SGPINT=GPINT
      IF (SGPINT .GE. 179.99D0) SGPINT=GPINT-360.D0
      SGPINT=(-1.D0)*SGPINT
C
      SGPREF=GPREF
      IF (SGPREF.GE. 179.99D0) SGPREF=GPREF-360.D0
      SGPREF=(-1.D0)*SGPREF
C
      IF ( IWAY .EQ. 1 ) THEN
        INTCELL=IDNINT(SGPINT*10.D0)/NHDCELL/MININC
        INTIDX = NCELLS/2 - INTCELL + 1
        INICELL=IDNINT(SGPREF*10.D0)/NHDCELL/MININC
        INIIDX = NCELLS/2 - INICELL + 1
      IDX = INTIDX-INIIDX+1
      IF (CSIZE .LT. 0.D0) IDX=INIIDX-INTIDX+1
      IF (IDX .LT. 1) IDX=IDX+NCELLS
      IF ( IDX .EQ. NCELLS+1 ) IDX=NCELLS
        IF ( IDX .GT. NCELLS ) THEN
        IFLAG=0
        RETURN
      END IF
      END IF
C
      IF ( IWAY .EQ. 2 ) THEN
        DCELL = NHDCELL*MININC/10.D0
        GPINT = (-(NCELLS/2 - IDX + 1))*DCELL
      IF(CSIZE .LT. 0.D0) GPINT=-GPINT
      DEGMAX = NCELLS/2*DCELL
      IF ( ICOR .EQ. 1 ) THEN
        GPINT=GPINT+GPREF+90.D0
        IF ( DABS(GPINT) .GT. DEGMAX ) 
     &      GPINT=GPINT-2.D0*DEGMAX-DCELL
        END IF      
      IF ( ICOR .EQ. 2 ) GPINT=GPINT+GPREF+180.D0
      IF ( DABS(GPINT) .GT. DEGMAX ) THEN
        IFLAG=0
        RETURN
      END IF
      END IF
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** IDXPP
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE IDXPP(MININC,REFLAT,REFLON,SIZLAT,SIZLON,
     &                 IWAY,GPLAT,GPLON,IDXLAT,IDXLON,IERROR)
CC
CC NAME       :  IDXPP
CC
CC
CC PURPOSE    :  COMPUTES GRID LAT/LON INDEXES WRT REFERENCE
CC               USING PIERCE POINT LATITUDE AND LONGITUDE 
CC                             .OR.
CC               COMPUTES PIERCE POINT LATITUDE AND LONGITUDE 
CC               USING GRID LAT/LON INDEXES WRT REFERENCE
CC PARAMETERS :
CC         IN    MININC  : MIN INCREMENT SIZE (.1 DEG. UNITS) I*4
CC               REFLAT  : GRID REFERENCE LATITUDE (DEG)      R*8
CC               REFLON  : GRID REFERENCE LONGITUDE (DEG)     R*8
CC               SIZLAT  : CELL SIZE IN LATITUDE (DEG)        R*8
CC               SIZLON  : CELL SIZE IN LONGITUDE (DEG)       R*8
CC               IWAY    : 1=DEG->IDX,2=IDX->DEG              I*4
CC        I/O    GPLAT   : GRID POINT LATITUDE (DEG)          R*8
CC               GPLON   : GRID POINT LONGITUDE (DEG)         R*8
CC               IDXLAT  : LATITUDE INDEX (WRT REFERENCE)     I*4
CC               IDXLON  : LONGITUDE INDEX (WRT REFERENCE)    I*4
CC         OUT   IERROR  : ERROR FLAG 0=ERROR,1=OK            I*4
CC
      IMPLICIT NONE
C
      INTEGER*4 IWAY,MININC,IDXLAT,IDXLON,IERROR
      REAL*8    REFLAT,REFLON,SIZLAT,SIZLON,GPLAT,GPLON
C
      INTEGER*4 IFLAG
C
      IERROR=1
      IF ( IWAY .EQ. 1 ) THEN
        CALL IDXLL(REFLAT,SIZLAT,MININC,1,IWAY,GPLAT,IDXLAT,IFLAG)
        IF (IFLAG .EQ. 0) IERROR=0
        CALL IDXLL(REFLON,SIZLON,MININC,2,IWAY,GPLON,IDXLON,IFLAG)
        IF (IFLAG .EQ. 0) IERROR=0
      END IF
C
      IF ( IWAY .EQ. 2 ) THEN
        CALL IDXLL(REFLAT,SIZLAT,MININC,1,IWAY,GPLAT,IDXLAT,IFLAG)
        IF (IFLAG .EQ. 0) IERROR=0
        CALL IDXLL(REFLON,SIZLON,MININC,2,IWAY,GPLON,IDXLON,IFLAG)
        IF (IFLAG .EQ. 0) IERROR=0
      END IF
      RETURN
C
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** IFLTSF
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE IFLTSF ( IPC, TTAG, CODE, PHASE, FLTSUM )
C
C       NAME            IFLTSF
C
C     PURPOSE   INITIALIZE SINGLE FREQUENCY FILTER
C
C     PARAMETERS        DESCRIPTION
C
C          LUO          LOGICAL UNIT OF OUTPUT 
C        TTAG   OBSERVATION TIME TAG
C        CODE           CODE OBSERVATION
C        PHASE        CARRIER PHASE OBSERVATION
C          FLTSUM(1)    NUMBER OF SAMPLES INCLUDED IN FILTER
C        FLTSUM(2)      TIME TAG OF LAST OBSERVATION
C        FLTSUM(3)      CODE OF LAST OBSERVATION
C        FLTSUM(4)      PHASE OF LAST OBSERVATION
C        FLTSUM(5)    PHASE SUMMATION FROM INITIAL EPOCH
C          FLTSUM(6)    CODE/CARRIER DIVERGENCE FROM INITIAL EPOCH
C
C *********************************************************************
      IMPLICIT NONE
C
      INTEGER*4 IPC
      REAL*8    TTAG, CODE, PHASE, FLTSUM(*)
C
      FLTSUM(1) = 1.0D0
      FLTSUM(2) = TTAG
      FLTSUM(3) = CODE
      FLTSUM(4) = PHASE
      FLTSUM(5) = CODE
      FLTSUM(6) = 0.0D0
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C***************************************************************** INEPH
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE INEPH (EPHSAT,NEPSV,IEPSV,IEPTIM,NEPTIM,EPHTBL)
C
C     PURPOSE:   TO INITIALIZE EPHEMERIS INFO
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     EPHSAT            EPHEMERIS CURRENTLY USED
C     NEPSV             NUMBER OF SATELLITES WITH EPHEMERIS
C     IEPSV             PRN'S OF SATELLITES WITH EPHEMERIS
C     NEPTIM            NUMBER OF EPHEMERIS PER SATELLITE
C     IEPTIM            EPHEMERIS CURRENTLY STORED IN EPHSAT
C     EPTBL             TABLE OF EPHEMERIDES
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4      NEPSV
      INTEGER*4      IEPSV(MAXSAT)
      INTEGER*4      IEPTIM(MAXSAT), NEPTIM(MAXSAT)
      REAL*8         EPHSAT(MAXKEP,MAXSAT)
      REAL*8         EPHTBL(MAXKEP,MAXSAT,MAXEPH)
C
      INTEGER*4 ISV,IP
C
      DO 500 ISV=1,NEPSV
      DO 400 IP=1,MAXKEP
        EPHSAT(IP,IEPSV(ISV)) = EPHTBL(IP,ISV,1)
400   CONTINUE
      IEPTIM(ISV) = 1
500   CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** INIPX
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE INIPX ( LPR, NPAR, IPOSSOL, ICLKSOL, 
     &                   ITRPSOL, IOBTYP, SDP, SDCP, 
     &                   NFPAR, P, PX, OPX, C, IPX, IMODE)
C
C     NAME              INIPX
C
C     PURPOSE         INITIAL WEIGHTS ON OBSERVATIONS
C               AND PARAMETERS
C
C     PARAMETERS        DESCRIPTION
C
C          NPAR         NUMBER OF PARAMETERS
C          MAXPAR2       MAXIMUM NUMBER OF PARAMETERS
C          MAXOBS2      MAXIMUM NUMBER OF OBSERVATIONS
C          IPOSSOL      SOLVE POSITION FLAG
C          ICLKSOL      SOLVE RECEIVER CLOCK FLAG
C          SDP          OBSERVATION STANDARD DEVIATION
C          P            OBSERVATION WEIGHT MATRIX
C          PX           PARAMETER WEIGHT MATRIX
C          OPX          OLD PARAMETER WEIGHT MATRIX
C          IPX          INITIAL PX (1=TRUE,0=FALSE)
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4  NPAR, LPR, NFPAR
      INTEGER*4  ICLKSOL,  ITRPSOL,      IOBTYP
      INTEGER*4  IPOSSOL,      IPX,      IMODE
C
      REAL*8     SDP, SDCP, C
      REAL*8     P(MAXOBS2,MAXOBS2)
      REAL*8     PX(MAXPAR2,MAXPAR2)
      REAL*8     OPX(MAXPAR2,MAXPAR2)
      REAL*8     DET, SD
      INTEGER*4  IDEXP
      INTEGER*4  I, J
C
      IPX=1
C
C       INITIALIZE OBSERVATION WEIGHTS
C 
      DO I = 1,MAXOBS2
      DO J = 1,MAXOBS2
        P(I,J) = 0.0D0
        END DO
        P(I,I) = 1.0D0/SDP**2
C   
C       CODE & CARRIER PROCESSING - INITIALIZE CARRIER WEIGHTS 
C
        IF (IOBTYP .EQ. 2 .AND. MOD(I,2) .EQ. 0) THEN
        IF ( IPOSSOL .EQ. 2 .OR. ICLKSOL .EQ. 1 
     &          .OR. MOD(ITRPSOL,10) .EQ. 1 .OR. IOBTYP .EQ. 2 )
     &             P(I,I) = 1.0D0/(SDCP    )**2
        END IF
      END DO
C
      SD = 1.D-10
      DO I = 1,NPAR
      DO J = 1,NPAR
       PX(I,J) = 0.0D0
      END DO
C
C       INITIALIZE STATION COORDINATES WEIGHTS IPOSSOL=1 => FIX
C                                              IPOSSOL=2 => SOLVE
C
      IF ( IPOSSOL .EQ. 2 ) THEN
           PX(I,I) = SD**2
      ELSE
         PX(I,I) = 1.D0/SD**2
      END IF
      END DO
C
C      INITIALIZE STATION CLOCK WEIGHT ICLKSOL=1 => SOLVE
C                                      ICLKSOL=2 => FIX
C
       PX(8,8) = 1.D0/SD**2
       IF (ICLKSOL .EQ. 1) THEN
          PX(4,4) = SD**2
          PX(8,8) = SD**2
       ELSE
        PX(4,4) =  1.D0/SD**2
       ENDIF
C
C      INITIALIZE TROPOSPHERE WEIGHTS ITRPSOL=1 => FIX
C                                     ITRPSOL=2 => SOLVE
C
       IF (MOD(ITRPSOL,10) .GE. 2) THEN
        PX(5,5) =  1.D0/1.D-2
C constrain ini tropo for vmf input to 2 cm (NWM dry,wet available!)
         IF(MOD(ITRPSOL,100).GT.20) PX(5,5) =  1.D0/4.D-4
       IF( ITRPSOL .GT. 100 ) THEN
          PX(6,6) = 1.d0/1.d-06
          PX(7,7) = 1.d0/1.d-06
       ELSE
        PX(6,6) =  1.D0/SD**2
        PX(7,7) =  1.D0/SD**2
       ENDIF
       ELSE
        PX(5,5) =  1.D0/SD**2
        PX(6,6) =  1.D0/SD**2
        PX(7,7) =  1.D0/SD**2
       ENDIF
C
C      INITIALIZE AMBIGUITY WEIGHTS IOBTYP=2 => SOLVE
C
       DO 100 I=NFPAR+1,MAXPAR2
         IF ( IOBTYP .EQ. 2 ) THEN
           PX(I,I) =  1.D0/SDP**2
       ELSE
         PX(I,I) = 1.D0/SD**2
       END IF
 100   CONTINUE
C
C       INVERT UP-TO-DATE NORMALS
C
c!      WRITE(*,*) 'IN INIPX, MAXPAR2',MAXPAR2
c!      WRITE(*,*) ' PX, IN INIPX, BEFORE SPIN '
c!      WRITE(*,'(15D9.3)') (PX(J,J),J=1,MAXPAR2)
        CALL SPIN ( PX, MAXPAR2, MAXPAR2, DET, IDEXP )
c!      WRITE(*,*) ' IN INIPX, AFTER SPIN '
c!      WRITE(*,*) ' SIGMAs, IN INIPX, AFTER SPIN '
c!      WRITE(*,'(15D9.3)') (DSQRT(PX(I,I)),I=1,NPAR)
      DO I=1,MAXPAR2
        OPX(I,I)=PX(I,I)
      END DO
C
       RETURN
       END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** INIXRV
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE INIXRV ( DTM, XRVEPO, PLHEPO, XRVAPR,
     &                    XRVMRK, PLHMRK,  XRVAPC, XRVINI,
     &                    ANTX )
C
C     PURPOSE:   INITIALIZE RECEIVER COORDINATES
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     LPR               LOGICAL UNIT OF PRINTER
C       XRVMRK          INITIAL MARKER COORDINATES
C       XRVEPO          EPOCH ANTENNA PHASE CENTER COORDINATES
C       XRVAPR          A-PRIORI ANTENNA PHASE CENTER COORDINATES
C       XRVAPC          INITIAL ANTENNA PHASE CENTER COORDINATES
C       XRVINI          INITIAL MARKER COORDINATES
C
C***********************************************************************
C
C
      IMPLICIT NONE
C
      REAL*8     DTM(*)
      REAL*8     XRVAPR(*),        XRVINI(*)
      REAL*8     XRVEPO(*),        PLHEPO(*)
      REAL*8     XRVMRK(*),        PLHMRK(*)
      REAL*8     XRVAPC(*),        ANTX(*)
C
      INTEGER*4 I
C
C     RESET COORDINATES TO EPOCH ESTIMATES
C
      DO I=1,3
      XRVAPC(I)=XRVEPO(I)
      XRVAPR(I)=XRVEPO(I)
      XRVMRK(I)=XRVEPO(I)-ANTX(I)
      XRVINI(I)=XRVMRK(I)
      END DO
      CALL XYZPL2 (DTM(3),DTM(4),DTM(5),DTM(1),DTM(2),XRVMRK(1),
     &             XRVMRK(2),XRVMRK(3),PLHMRK(1),PLHMRK(2),PLHMRK(3))
      DO I=1,3
      PLHEPO(I)=PLHMRK(I)
      END DO
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** ION_MF1
C
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C

C Return Ionospheric Single Layer mapping function for:
C 1: standard
C 2: modified  (CODE)
C 3: TEST with diffrent radious and formulation but should be same as 1
C 4: Clynch et al [1989]
C 5: Smith et.al [2008]
C 6: Broadcast mapping function
C 7: Klobuchar in its 1975 form
C 8: klobuchar exact in klobuchar [1975]
C 9: TEST: A mapping function resulted from fit to NeQuick over 3 northern hemisphere
C    location at 3 levels of ionization at sept 2013 developed by Ghoddousi-Fard for test purposes
C >100 TEST: R12 based fit to NeQuick where R12=100-islmap  (Developed by Ghoddousi-Fard for test purposes)
C else: WAAS MF implemetation in GSD (same as 1 with different Earth radius

C Input:
C      islmap: 1 (standard mapping function) or 2 OR 3 OR 4 OR 5 OR 6 OR 7 OR 8 OR 9 OR >=100 OR else(WASS)  
C      slmhgt: single layer ionospheric height (Km)
C      zen: zenith angle (rad)
C      station height (km)  [RGF -- May 06, 2014]

C Subroutine returns the mapping function value 

      REAL*8 FUNCTION Ion_MF1 ( islmap, slmhgt, zen, stnhgt)

      IMPLICIT NONE

      INTEGER*4 islmap
      REAL*8 slmhgt, zen, stnhgt

      REAL*8  slmap,alpha

      REAL*8  Ae
      REAL*8  Rsta
      REAL*8  sinzp
      REAL*8  zenh

      REAL*8  a0
      REAL*8  a1
      REAL*8  a2
      REAL*8  a3
      REAL*8  x

      REAL*8  p,a,b
      REAL*8  aa0 
      REAL*8  aa1 
      REAL*8  aa2 
      REAL*8  aa3 
      REAL*8  bb0 
      REAL*8  bb1 
      REAL*8  bb2 
      REAL*8  bb3 

C coef for new test paper mapping function (R12 based fit to NeQuick)
      REAL*8  p1,p2,p3,p4
      INTEGER*4 R12

C Clynch et al [1989]
      DATA  a0/1.0206D0/
      DATA  a1/0.4663D0/
      DATA  a2/3.5055D0/
      DATA  a3/-1.8415D0/

C Smith et.al [2008] Radio Sci, 43, RS6008
      DATA  aa0 / 64.4297D0/
      DATA  aa1 / 0.0942437D0/
      DATA  aa2 / 1.39436D0/
      DATA  aa3 / 19.6357D0/
      DATA  bb0 / 64.3659D0/
      DATA  bb1 / 0.104974D0/
      DATA  bb2 / 1.41152D0/
      DATA  bb3 / -0.0463341D0/

C Note:ERAD is used here as radius of Earth from cnst.h   */
      REAL*8 ERAD, M_PI
      DATA ERAD/6371.000D0/

      M_PI = DACOS(-1.D0)

C Standard
C Station height applied [RGF - May 06, 2014]
      if (islmap .EQ. 1) THEN
        Ion_MF1=1.D0/cos(asin((ERAD+stnhgt)/(ERAD+slmhgt)*sin(zen)))

C CODE
      else if (islmap .EQ. 2) THEN
        alpha= 0.9782D0
        Ion_MF1=1.D0/cos(asin(ERAD/(ERAD+506.7D0)*sin(alpha*zen)))

C TEST with different radius
      else if (islmap .EQ. 3) THEN
C       Earth semimajor axis
        Ae=6378.1370D0
C       Distance from center earth to station [Mar 05, 2010 -- a test value for now]
        Rsta=6378.1370D0
        sinzp=(Rsta/(Ae+slmhgt))*sin(zen)
        zenh=atan(sinzp/sqrt(1.D0-sinzp*sinzp))
        Ion_MF1=1.D0/cos(zenh)

C Clynch et al [1989] (page 104 of Komjathy PhD thesis)
      else if (islmap .EQ. 4) THEN
        x=(zen*180.D0/M_PI)/90.D0
        Ion_MF1=a0+a1*x**2+a2*x**4+a3*x**6

C Smith et.al [2008] Radio Sci, 43, RS6008
      else if (islmap .EQ. 5 ) THEN
        zenh = asin(ERAD/(ERAD+slmhgt)*sin(zen))

        a=(-atan((zenh*180.D0/M_PI-aa0)*aa1)-aa2)*aa3
        b=(-atan((zenh*180.D0/M_PI-bb0)*bb1)-bb2)*bb3
        p=a+b*slmhgt
        Ion_MF1=1.D0/((1.D0-(p/100.D0))*cos(zenh))

C Broadcast
      else if (islmap .EQ. 6 ) THEN
        Ion_MF1= 1.0D0 + 16.0D0 * (0.03D0 + zen/M_PI)**3  

C Klobuchar in its original form Klobucahr [1975]
      else if (islmap .EQ. 7 ) THEN
        Ion_MF1= 1.0D0 + 2.0D0 * ((6.0D0+zen*180.D0/M_PI)/90.D0)**3

C Klobuchar exact mapping function Klobucahr[1975] It is same as 1 with slmhgt =350 and ERAD~=6370
      else if (islmap .EQ. 8 ) THEN
        Ion_MF1= 1.D0/ cos (asin(0.94792D0*sin(zen)))

C NeQuick fited mapping function
      else if (islmap .EQ. 9 ) THEN
        Ion_MF1= -2.9657D-6*(90.0D0-zen*180.0D0/M_PI)**3+
     &           0.00079972D0*(90.0D0-zen*180.0D0/M_PI)**2-
     &           0.073171D0*(90.0D0-zen*180.0D0/M_PI)+3.2701D0


C TEST mapping function (R12 based fit to NeQuick) */
      else if (islmap >= 100 ) THEN
        R12 = islmap - 100
        p1=  1.3976D-8 * R12 - 4.0139D-6
        p2= -2.5578D-6 * R12 + 9.9155D-4
        p3=  1.4875D-4 * R12 - 0.0843D0
        p4= -0.0028D0 * R12 + 3.4786D0
        Ion_MF1= p1*(90.0D0-zen*180.0D0/M_PI)**3+
     &  p2*(90.0D0-zen*180.0D0/M_PI)**2+p3*(90.0D0-zen*180.0D0/M_PI)+p4

C WAAS (is basicaly same as 1 but with different ERAD) */
      else
        Ion_MF1=
     &    1.D0/sqrt(1-(6378.1363D0*
     &                 cos(M_PI/2D0-zen)/(6378.1363D0+slmhgt))**2)
      endif 

      return

      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** IONBRD
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE IONBRD( ALPHA, BETA, EL, AZ, ULAT, ULON, TOW,
     &                   PI, C, DIONCOR, VIONCOR )
C
C     PURPOSE: COMPUTE IONOSPHERIC CORRECTION USING BROADCAST 
C              COEFFICIENTS
C
C     PARAMETER         DESRIPTION
C
C     ALPHA             ALPHA COEFFICIENTS FROM BROADCAST(A0->A3)
C     BETA              BETA COEFFICIENTS FROM BROADCAST(B0->B3)
C     EL                USER->SATELLITE ELEVATION ANGLE(RADIANS)
C     AZ                USER->SATELLITE AZIMUTH (RADIANS)
C     ULAT              USER LATITUDE (RADIANS)
C     ULON              USER LONGITUDE (RADIANS)
C     TOW               GPS TIME (SECONDS OF WEEK)
C     PI                VALUE OF PI
C     C                 SPEED OF LIGHT (M/S)
C     DIONCOR           IONOSPHERIC CORRECTION (M)
C     VIONCOR           VERTICAL IONOSPHERIC DELAY
C
C***********************************************************************
C
      IMPLICIT NONE
C
      REAL*8 ALPHA(*),  BETA(*)
      REAL*8 EL,        AZ
      REAL*8 ULAT,      ULON
      REAL*8 TOW,       DIONCOR
     &                 ,VIONCOR
      REAL*8 PI,        C
C
      REAL*8 ELSC,       AZSC
      REAL*8 ULATSC,      ULONSC
      REAL*8 PPMLAT
      REAL*8 PPLAT,     PPLON
      REAL*8 KAPPA
      REAL*8 TOD
      REAL*8 F, PER, AMP, X, EF
      INTEGER*4 N
C
C     CONVERT AZ, EL, ULAT, ULON ANGLES FROM RADIANS->SEMI-CIRCLES
C
      ELSC=EL/PI
      IF (AZ .GT. PI) AZ=AZ-PI
      AZSC=AZ/PI
      ULATSC=ULAT/PI
      IF (ULON .GT. PI) ULON =ULON-PI
      ULONSC=ULON/PI
C
      KAPPA=0.0137D0/(ELSC+0.11D0)-0.022D0
      PPLAT=ULATSC+KAPPA*DCOS(AZ)
      IF ( PPLAT .GT.  0.416D0 ) PPLAT= 0.416D0
      IF ( PPLAT .LT. -0.416D0 ) PPLAT=-0.416D0
      PPLON=ULONSC+KAPPA*DSIN(AZ)/DCOS(PPLAT*PI)
      PPMLAT=PPLAT+0.064D0*DCOS(PPLON*PI-1.617D0)
      TOD=4.32D4*PPLON+TOW
      TOD=DMOD(TOD,86400.D0)
c!    WRITE(*,*) 'ULAT,ULON,AZDEG,ELDEG,PPLAT,PPMLAT,PPLON,TOD'
c!    WRITE(*,'(8F8.1)') ULAT*180.D0/PI,ULON*180.D0/PI,AZSC*180.D0,
c!   &                    ELSC*180.D0,PPLAT*180.D0,PPMLAT*180.D0, 
c!   &                    PPLON*180.D0,TOD
C
      EF=(0.53D0-ELSC)**3
      F=1.D0+16.D0*EF
      PER=0.D0
      AMP=0.D0
      DO N=0,3
        PER=PER+BETA(N+1)*PPMLAT**N
        AMP=AMP+ALPHA(N+1)*PPMLAT**N
      END DO
      IF ( PER .LT. 72000.D0 ) PER=72000.D0
      IF ( AMP .LT. 0.D0 ) AMP=0.D0
      X=2*PI*(TOD-50400D0)/PER
C
      IF ( DABS(X) .LT. 1.57D0 ) THEN 
        DIONCOR=F*(5.0D-9+AMP*(1.D0-X**2/2.D0+X**4/24.D0))
      ELSE
        DIONCOR=F*5.0D-9
      END IF
      DIONCOR=DIONCOR*C/1.54D0
      VIONCOR=DIONCOR/F
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** IONEX
C
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
C  NAME      : IONEX                                                         
C  PURPOSE   : READ THE HEADER AND RECORDS OF AN IONEX FILE.                 
C  AUTHOR    : MARTIN BOURASSA / PAUL COLLINS                                
C  DATE      : 2004/08/20                                                    
C  REFERENCE : IONEX V.1 FTP://IGSCB.JPL.NASA.GOV/PUB/DATA/FORMAT/IONEX1.PDF 
C                                                                            
C
      INTEGER*4 FUNCTION INXHEADREAD( LUINX, EOF )
C
      IMPLICIT NONE
C
      INTEGER*4 LUINX,EOF
C
C IONEX HEADER COMMON DATA
C
      INTEGER*4 MAXINXCMT, MAXINXDSC, MAXINXMAP,
     &          MAXINXSATDCB, MAXINXSTADCB
      PARAMETER (MAXINXCMT=20)
      PARAMETER (MAXINXDSC=10)
      PARAMETER (MAXINXMAP=288)
      PARAMETER (MAXINXSATDCB=136)
      PARAMETER (MAXINXSTADCB=300)
C
      CHARACTER*1 INXSATBIASSATSYS(MAXINXSATDCB),
     &            INXSTABIASSATSYS(MAXINXSTADCB)
      CHARACTER*4 INXTYPE, INXSTABIASRCV(MAXINXSTADCB), INXMAPFUNCTION
      CHARACTER*20 INXPROGRAM, INXAGENCY, INXDATE
      CHARACTER*60 INXSATSYST, INXOBS_USED, INXDESCRIPTION(MAXINXDSC),
     &             INXCOMMENT(MAXINXCMT)
      INTEGER*4 INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     &          INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     &          INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     &          INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     &          INXSATBIASPRN(MAXINXSATDCB)
     &         ,INXHDPADDING
      REAL*4 INXVERSION, INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASERADIUS
      REAL*8 INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     &       INXLON1, INXLON2, INXDLON, INXMAP_TIME(MAXINXMAP), 
     &       INXSATBIASBIAS(MAXINXSATDCB), INXSATBIASRMS(MAXINXSATDCB),
     &       INXSTABIASBIAS(MAXINXSTADCB), INXSTABIASRMS(MAXINXSTADCB)
C
      COMMON /IONEXHD/INXSATBIASSATSYS, INXSTABIASSATSYS, INXTYPE,
     & INXSATSYST, INXSTABIASRCV, INXMAPFUNCTION, INXPROGRAM, INXAGENCY,
     & INXDATE, INXOBS_USED, INXDESCRIPTION, INXCOMMENT,
     & INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     & INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     & INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     & INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     & INXSATBIASPRN, INXVERSION,
     & INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASERADIUS,
     & INXHDPADDING,
     & INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     & INXLON1, INXLON2, INXDLON, INXMAP_TIME,
     & INXSATBIASBIAS, INXSATBIASRMS, INXSTABIASBIAS, INXSTABIASRMS
C
      CHARACTER*80 LINETEXT
      INTEGER*4 YEAR, MONTH, DAY, HOUR, MINUTE, DOY
      INTEGER*4 WEEK, WEEKDAY
      INTEGER*4 ICMT, IDSC
      REAL*8    SECOND,TEMP
C
      DATA ICMT, IDSC/ 0, 0/
C
C SET INXHEADREAD TO (-) THE NUMBER OF REQUIRED HEADER RECORD
C
      INXHEADREAD=-11
C
C  INITIALISE HEADER DEFAULT VALUES
C  -------------------------------- 
      INXHDEXPONENT = -1
C
C  LOOP THROUGH RECORDS OF HEADER
C  ------------------------------ 
 10   CONTINUE
C
      READ(LUINX,'(A)',END=30,ERR=40) LINETEXT
C
      IF( LINETEXT(61:80) .EQ.      'IONEX VERSION / TYPE' ) THEN
         READ( LINETEXT, * ) INXVERSION
         INXTYPE = LINETEXT(21:24)
         INXSATSYST = LINETEXT(41:60)
         INXHEADREAD=INXHEADREAD+1
C     WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXTYPE,INXSATSYST
      ELSE IF( LINETEXT(61:80) .EQ. 'PGM / RUN BY / DATE ' ) THEN
         INXPROGRAM = LINETEXT(1:20)
         INXAGENCY = LINETEXT(21:40)
         INXDATE = LINETEXT(41:60)
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXPROGRAM,INXAGENCY,
c!   &INXDATE
      ELSE IF( LINETEXT(61:80) .EQ. 'DESCRIPTION         ' ) THEN
         IF( IDSC .LT. MAXINXDSC ) THEN
            IDSC=IDSC+1
            INXDESCRIPTION(IDSC) = LINETEXT(1:60)
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXDESCRIPTION(IDSC)
c!       ELSE IF( IDSC .EQ. MAXINXDSC ) THEN
c!          WRITE( *, *)
c!   & 'WARNING:INXHEADREAD: TOO MANY DESCRIPTION LINES IN IONEX FILE.'
         ENDIF
      ELSE IF( LINETEXT(61:80) .EQ. 'COMMENT             ' ) THEN
         IF( ICMT .LT. MAXINXCMT ) THEN
            ICMT=ICMT+1
            INXCOMMENT(ICMT) = LINETEXT(1:60)
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXCOMMENT(ICMT)
c!       ELSE IF( ICMT .EQ. MAXINXCMT ) THEN
c!          WRITE( *, * )
c!   &      'WARNING:INXHEADREAD: TOO MANY COMMENT LINES IN IONEX FILE.'
         ENDIF
      ELSE IF( LINETEXT(61:80) .EQ. 'EPOCH OF FIRST MAP  ' ) THEN
         READ( LINETEXT, * ) YEAR, MONTH, DAY, HOUR, MINUTE, SECOND
         CALL GPSDC( DOY, YEAR, MONTH, DAY, WEEK, WEEKDAY, 2 )
         INXMAPFIRST = SECOND+60*(MINUTE+60*(HOUR+24*(WEEKDAY+7*WEEK)))
         INXYEARFIRST = YEAR
         INXMONTHFIRST = MONTH
         INXDAYFIRST = DAY
         INXHEADREAD=INXHEADREAD+1
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),YEAR, MONTH, DAY, HOUR,
c!   &MINUTE, SECOND, INXMAPFIRST 
      ELSE IF( LINETEXT(61:80) .EQ. 'EPOCH OF LAST MAP   ' ) THEN
         READ( LINETEXT, * ) YEAR, MONTH, DAY, HOUR, MINUTE, SECOND
         CALL GPSDC( DOY, YEAR, MONTH, DAY, WEEK, WEEKDAY, 2 )
         INXMAPLAST = SECOND+60*(MINUTE+60*(HOUR+24*(WEEKDAY+7*WEEK)))
         INXHEADREAD=INXHEADREAD+1
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),YEAR, MONTH, DAY, HOUR,
c!   &MINUTE, SECOND, INXMAPLAST 
      ELSE IF( LINETEXT(61:80) .EQ. 'INTERVAL            ' ) THEN
         READ( LINETEXT, * )  TEMP
         INXINTERVAL=TEMP
         INXHEADREAD=INXHEADREAD+1
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXINTERVAL
      ELSE IF( LINETEXT(61:80) .EQ. '# OF MAPS IN FILE   ' ) THEN
         READ( LINETEXT, * ) TEMP
         INXNB_MAPS=TEMP
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXNB_MAPS
         IF( INXNB_MAPS .GT. MAXINXMAP ) THEN
            WRITE( *, * ) 'ERROR: TOO MANY MAPS IN IONEX FILE: ',
     &             INXNB_MAPS, '>', MAXINXMAP
            GOTO 20
         ENDIF
         INXHEADREAD=INXHEADREAD+1
      ELSE IF( LINETEXT(61:80) .EQ. 'MAPPING FUNCTION    ' ) THEN
         INXMAPFUNCTION = LINETEXT(3:6)
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXMAPFUNCTION 
      ELSE IF( LINETEXT(61:80) .EQ. 'ELEVATION CUTOFF    ' ) THEN
         READ( LINETEXT, * ) INXELEV_CUTOFF
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXELEV_CUTOFF
      ELSE IF( LINETEXT(61:80) .EQ. 'OBSERVABLES USED    ' ) THEN
         INXOBS_USED = LINETEXT(1:60)
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXOBS_USED 
      ELSE IF( LINETEXT(61:80) .EQ. '# OF STATIONS       ' ) THEN
         READ( LINETEXT, * ) INXNB_STA
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXNB_STA
      ELSE IF( LINETEXT(61:80) .EQ. '# OF SATELLITES     ' ) THEN
         READ( LINETEXT, * ) INXNB_SAT
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXNB_SAT
      ELSE IF( LINETEXT(61:80) .EQ. 'BASE RADIUS         ' ) THEN
         READ( LINETEXT, * ) INXBASERADIUS
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXBASERADIUS
      ELSE IF( LINETEXT(61:80) .EQ. 'MAP DIMENSION       ' ) THEN
         READ( LINETEXT, * ) INXMAPDIM
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXMAPDIM
         IF( INXMAPDIM .NE. 2 ) THEN
            WRITE( *, * )
     &      'ERROR: UNABLE TO PROCESS SUCH DIMENSIONAL MAPS, SORRY',
     &      INXMAPDIM
            GOTO 20
         ENDIF
         INXHEADREAD=INXHEADREAD+1
      ELSE IF( LINETEXT(61:80) .EQ. 'HGT1 / HGT2 / DHGT  ' ) THEN
         READ( LINETEXT(3:60), '(3F6.1)' ) INXHGT1, INXHGT2, INXDHGT
         IF( INXHGT1 .GT. 0 ) THEN
           INXSHELL_HEIGHT = INXHGT1
         ELSE
           INXSHELL_HEIGHT = INXHGT2
         END IF
         INXHEADREAD=INXHEADREAD+1
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXHGT1, INXHGT2, 
c!   &INXDHGT,INXSHELL_HEIGHT 
      ELSE IF( LINETEXT(61:80) .EQ. 'LAT1 / LAT2 / DLAT  ' ) THEN
         READ( LINETEXT(3:60), '(3F6.1)' ) INXLAT1, INXLAT2, INXDLAT
         INXNB_LAT=IDINT( DABS(( INXLAT2 - INXLAT1 )/INXDLAT ) + 1.D0 )
         INXHEADREAD=INXHEADREAD+1
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXLAT1, INXLAT2,
c!   &INXDLAT,INXNB_LAT
      ELSE IF( LINETEXT(61:80) .EQ. 'LON1 / LON2 / DLON  ' ) THEN
         READ( LINETEXT(3:60), '(3F6.1)' ) INXLON1, INXLON2, INXDLON
         INXNB_LON = IDINT( DABS(( INXLON2 - INXLON1 )/INXDLON) + 1.D0 )
         INXHEADREAD=INXHEADREAD+1
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXLON1, INXLON2,
c!   &INXDLON,INXNB_LON 
      ELSE IF( LINETEXT(61:80) .EQ. 'EXPONENT            ' ) THEN
         READ( LINETEXT, * ) INXHDEXPONENT
         INXHEADREAD=INXHEADREAD+1
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXHDEXPONENT
      ELSE IF( LINETEXT(61:80) .EQ. 'START OF AUX DATA   ' ) THEN
         IF( LINETEXT(1:24) .EQ. 'DIFFERENTIAL CODE BIASES' ) THEN
           INXNB_SAT_DCB = 0
           INXNB_STA_DCB = 0
         ENDIF
      ELSE IF( LINETEXT(61:80) .EQ. 'PRN / BIAS / RMS    ' ) THEN
         IF( INXNB_SAT_DCB .LT. MAXINXSATDCB ) THEN
            INXNB_SAT_DCB = INXNB_SAT_DCB + 1
            INXSATBIASSATSYS(INXNB_SAT_DCB)=LINETEXT(4:4)
            READ( LINETEXT(5:60), * )
     &             INXSATBIASPRN(INXNB_SAT_DCB),
     &             INXSATBIASBIAS(INXNB_SAT_DCB),
     &             INXSATBIASRMS(INXNB_SAT_DCB)
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXNB_SAT_DCB,
c!   &INXSATBIASSATSYS(INXNB_SAT_DCB),INXSATBIASPRN(INXNB_SAT_DCB),
c!   &INXSATBIASBIAS(INXNB_SAT_DCB),INXSATBIASRMS(INXNB_SAT_DCB)
         ELSE IF( INXNB_SAT_DCB .EQ. MAXINXSATDCB ) THEN
            WRITE( *, * )
     &      'WARNING:INXHEADREAD: TOO MANY PRN BIAS LINES IN IONEX FILE'
         ENDIF
      ELSE IF( LINETEXT(61:80) .EQ. 'STATION / BIAS / RMS' ) THEN
         IF( INXNB_STA_DCB .LT. MAXINXSTADCB ) THEN
            INXNB_STA_DCB = INXNB_STA_DCB + 1
            INXSTABIASSATSYS(INXNB_STA_DCB)=LINETEXT(4:4)
            INXSTABIASRCV(INXNB_STA_DCB) = LINETEXT(7:10)
            READ( LINETEXT(28:60), * )
     &             INXSTABIASBIAS(INXNB_STA_DCB),
     &             INXSTABIASRMS(INXNB_STA_DCB)
c!    WRITE(*,*) 'INXHEADREAD: ',LINETEXT(61:80),INXNB_STA_DCB,
c!   &INXSTABIASSATSYS(INXNB_STA_DCB),INXSTABIASRCV(INXNB_STA_DCB),
c!   &INXSTABIASBIAS(INXNB_STA_DCB),INXSTABIASRMS(INXNB_STA_DCB)
         ELSE IF( INXNB_STA_DCB .EQ. MAXINXSTADCB ) THEN
            WRITE( *, * )
     &      'WARNING:INXHEADREAD: TOO MANY RCV BIAS LINES IN IONEX FILE'
         ENDIF
      ELSE IF( LINETEXT(61:80) .EQ. 'END OF AUX DATA     ' ) THEN
C        INXHEADREAD=0
      ELSE IF( LINETEXT(61:80) .EQ. 'END OF HEADER       ' ) THEN
         INXHEADREAD=INXHEADREAD+1
         GOTO 20
      ELSE IF( LINETEXT(61:80) .EQ. 'END OF FILE         ' ) THEN
         INXHEADREAD=1
         GOTO 30
      ELSE
         WRITE( *, * ) 'INXHEADREAD: UNKNOWN RECORD IN IONEX FILE :'
         WRITE( *, * ) '(',LINETEXT(1:80),')'
      ENDIF
C
      GOTO 10
 40   CONTINUE
      INXHEADREAD=2
      RETURN
 30   CONTINUE
      EOF=1
      RETURN
 20   CONTINUE
      RETURN
      END
C
C
C ----------------------------------------------------------------------------
C
      INTEGER*4 FUNCTION INXDATAREAD( LUINX, EOF )
C
      IMPLICIT NONE
C
      INTEGER*4 LUINX,EOF
C
C IONEX HEADER COMMON DATA
C
      INTEGER MAXINXCMT, MAXINXDSC, MAXINXMAP,
     &        MAXINXSATDCB, MAXINXSTADCB
      PARAMETER (MAXINXCMT=20)
      PARAMETER (MAXINXDSC=10)
      PARAMETER (MAXINXMAP=288)
      PARAMETER (MAXINXSATDCB=136)
      PARAMETER (MAXINXSTADCB=300)
C
      CHARACTER*1 INXSATBIASSATSYS(MAXINXSATDCB),
     &            INXSTABIASSATSYS(MAXINXSTADCB)
      CHARACTER*4 INXTYPE, INXSTABIASRCV(MAXINXSTADCB), INXMAPFUNCTION
      CHARACTER*20 INXPROGRAM, INXAGENCY, INXDATE
      CHARACTER*60 INXSATSYST, INXOBS_USED, INXDESCRIPTION(MAXINXDSC),
     &             INXCOMMENT(MAXINXCMT)
      INTEGER*4 INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     &          INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     &          INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     &          INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     &          INXSATBIASPRN(MAXINXSATDCB)
     &         ,INXHDPADDING
      REAL*4 INXVERSION, INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASE_RADIUS
      REAL*8 INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     &       INXLON1, INXLON2, INXDLON, INXMAP_TIME(MAXINXMAP),
     &       INXSATBIASBIAS(MAXINXSATDCB), INXSATBIASRMS(MAXINXSATDCB),
     &       INXSTABIASBIAS(MAXINXSTADCB), INXSTABIASRMS(MAXINXSTADCB)
C
      COMMON /IONEXHD/INXSATBIASSATSYS, INXSTABIASSATSYS, INXTYPE,
     & INXSATSYST, INXSTABIASRCV, INXMAPFUNCTION, INXPROGRAM, INXAGENCY,
     & INXDATE, INXOBS_USED, INXDESCRIPTION, INXCOMMENT,
     & INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     & INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     & INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     & INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     & INXSATBIASPRN, INXVERSION,
     & INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASE_RADIUS,
     & INXHDPADDING,
     & INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     & INXLON1, INXLON2, INXDLON, INXMAP_TIME,
     & INXSATBIASBIAS, INXSATBIASRMS, INXSTABIASBIAS, INXSTABIASRMS
C
C IONEX MAP COMMON DATA
C
      INTEGER*4 MAXINXCELLS
      PARAMETER (MAXINXCELLS=10585)
      INTEGER*4 INXMAP_NO,INXNBCELLLAT,INXNBCELLLON,INXMAP_TYPE,
     &          INXDTEXPONENT
     &         ,INXDTPADDING,INXTABLE(MAXINXCELLS)
      REAL*8 INXGPSTIME,INXMINLAT,INXLATCELLSIZE,INXMINLON,
     &       INXLONCELLSIZE
      COMMON /IONEXDT/INXMAP_NO,INXNBCELLLAT,INXNBCELLLON,INXMAP_TYPE,
     & INXDTEXPONENT,
     & INXDTPADDING,
     & INXGPSTIME,INXMINLAT,INXLATCELLSIZE,INXMINLON,INXLONCELLSIZE,
     & INXTABLE
C
      INTEGER*4 I, CTEC, TECVALUE
      REAL*8    LON
C
      CHARACTER*80 LINETEXT
      INTEGER*4 YEAR, MONTH, DAY, HOUR, MINUTE, DOY
      INTEGER*4 WEEK, WEEKDAY
      INTEGER*4 IGPIND, RTEC, NTEC
      REAL*8    SECOND
C 
      INTEGER*4 INCLAT, INCLON
      REAL*8 LAT, LON1, LON2, DLON, HGT
C
      INTEGER*4 INXHEADREAD
C
      DATA RTEC, NTEC / 0, 0 /
C
      IF( EOF .EQ. 1 ) THEN
        INXDATAREAD=1
        RETURN
      ENDIF
C
C SET INXHEADREAD TO (-) THE NUMBER OF REQUIRED HEADER RECORD
C
      INXDATAREAD=-3
C
C INITIALISE GRID LIMITS AND ALLOCATE TABLE
C
      INXDTEXPONENT  = INXHDEXPONENT
      INXMINLAT      = MIN(INXLAT1,INXLAT2)
      INXLATCELLSIZE = ABS(INXDLAT)
      INXNBCELLLAT   = INXNB_LAT
      INXMINLON      = MIN(INXLON1,INXLON2)
      INXLONCELLSIZE = ABS(INXDLON)
      INXNBCELLLON   = INXNB_LON
C
C READ ONE MAP FROM IONEX FILE
C ----------------------------
C
 100  CONTINUE
C
      READ(LUINX,'(A)',END=130,ERR=140) LINETEXT
c!    WRITE(*,*) 'INXDATAREAD: ',LINETEXT(1:60),')(',LINETEXT(61:80)
C
      IF( RTEC .LT. NTEC ) THEN
         CTEC = NTEC - RTEC
         CTEC = MIN(CTEC,16)
         DO I=1,CTEC
            LON = LON1 + RTEC * DLON
            INCLAT=INT(0.5D0+    (LAT-INXMINLAT       )/INXLATCELLSIZE)
            INCLON=INT(0.5D0+DMOD(LON-INXMINLON,360.D0)/INXLONCELLSIZE)
            IGPIND = 1 + INXNBCELLLON * INCLAT + INCLON
            READ( LINETEXT(I*5-4:I*5), '(I5)' )  TECVALUE
            IF( IGPIND .LE. MAXINXCELLS .AND.
     &          INCLAT .GE. 0 .AND. INCLAT .LT. INXNBCELLLAT .AND.
     &          INCLAT .GE. 0 .AND. INCLON .LT. INXNBCELLLON ) THEN
               INXTABLE(IGPIND) = TECVALUE
c!    WRITE(*,*) 'INXDATAREAD: ',IGPIND,INXTABLE(IGPIND)
            ELSE
               WRITE(*,*)
     &         'WARNING:INXDATAREAD: TABLE EXCEEDED: ',
     &         I,RTEC+1,LAT,LON,INCLAT,INCLON,IGPIND
            ENDIF
            RTEC=RTEC+1
         END DO
      ELSE IF( LINETEXT(61:80) .EQ. 'START OF TEC MAP    ' ) THEN
         READ( LINETEXT, * ) INXMAP_NO
         INXMAP_TYPE = 0
         INXDATAREAD=INXDATAREAD+1
c!    WRITE(*,*) 'INXDATAREAD: ',LINETEXT(61:80),INXMAP_NO,INXMAP_TYPE
      ELSE IF( LINETEXT(61:80) .EQ. 'START OF RMS MAP    ' ) THEN
         READ( LINETEXT, * ) INXMAP_NO
         INXMAP_TYPE = 1
         INXDATAREAD=INXDATAREAD+1
c!    WRITE(*,*) 'INXDATAREAD: ',LINETEXT(61:80),INXMAP_NO,INXMAP_TYPE
      ELSE IF( LINETEXT(61:80) .EQ. 'START OF HEIGHT MAP ' ) THEN
         READ( LINETEXT, * ) INXMAP_NO
         INXMAP_TYPE = 2
         INXDATAREAD=INXDATAREAD+1
c!    WRITE(*,*) 'INXDATAREAD: ',LINETEXT(61:80),INXMAP_NO,INXMAP_TYPE
      ELSE IF( LINETEXT(61:80) .EQ. 'EPOCH OF CURRENT MAP' ) THEN
         IF( INXMAP_NO .GT. MAXINXMAP .OR.
     &       INXMAP_NO .GT. INXNB_MAPS ) THEN
           IF( INXMAP_NO .GT. MAXINXMAP ) THEN
             WRITE( *, * )
     &       'ERROR:INXDATAREAD: MAP INDEX EXCEEDS MAXIMUM ',
     &      INXMAP_NO,MAXINXMAP 
           ELSE
             WRITE( *, * )
     &      ' ERROR:INXDATAREAD: MAP INDEX EXCEEDS HEADER SPEC ',
     &      INXMAP_NO,INXNB_MAPS
           ENDIF
           GOTO 120
         ENDIF
         READ( LINETEXT, * ) YEAR, MONTH, DAY, HOUR, MINUTE, SECOND
         CALL GPSDC( DOY, YEAR, MONTH, DAY, WEEK, WEEKDAY, 2 )
         INXMAP_TIME(INXMAP_NO) =
     &    SECOND+60.D0*(MINUTE+60.D0*(HOUR+24.D0*(WEEKDAY-1+7.D0*WEEK)))
         INXDATAREAD=INXDATAREAD+1
c!    WRITE(*,*) 'INXDATAREAD: ',LINETEXT(61:80),YEAR, MONTH, DAY, HOUR,
c!   &MINUTE, SECOND, INXMAP_TIME(INXMAP_NO) 
      ELSE IF( LINETEXT(61:80) .EQ. 'EXPONENT            ' ) THEN
         READ( LINETEXT, * ) INXDTEXPONENT
c!    WRITE(*,*) 'INXDATAREAD: ',LINETEXT(61:80),INXDTEXPONENT
      ELSE IF( LINETEXT(61:80) .EQ. 'LAT/LON1/LON2/DLON/H' ) THEN
         READ( LINETEXT(3:60), '(5F6.1)' ) LAT, LON1, LON2, DLON, HGT
c!    WRITE(*,*) 'INXDATAREAD: ',LINETEXT(61:80),LAT, LON1, LON2, DLON,
c!   &HGT,NTEC
         IF( HGT .NE. INXSHELL_HEIGHT ) THEN
           WRITE( *, * )
     &     'ERROR:INXDATAREAD: MISMATCHED SHELL HEIGHT IN IONEX FILE: ',
     &     HGT, INXSHELL_HEIGHT
           INXDATAREAD=2
           GOTO 120
         ENDIF
         NTEC = 1+(LON2-LON1+DLON/2.0)/DLON
         RTEC = 0
         INXGPSTIME = INXMAP_TIME(INXMAP_NO)
      ELSE IF( LINETEXT(61:80) .EQ. 'END OF TEC MAP      ' .OR.
     &         LINETEXT(61:80) .EQ. 'END OF RMS MAP      ' .OR.
     &         LINETEXT(61:80) .EQ. 'END OF HEIGHT MAP   ' ) THEN
         INXDATAREAD=INXDATAREAD+1
         GOTO 120
      ELSE IF( LINETEXT(61:80) .EQ. 'END OF FILE         ' ) THEN
         INXDATAREAD=3
         GOTO 130
      ELSE IF( LINETEXT(61:80) .EQ. 'IONEX VERSION / TYPE' ) THEN
         INXDATAREAD=10+INXHEADREAD( LUINX, EOF ) 
         IF( INXDATAREAD .NE. 10 ) GOTO 120
         INXDATAREAD=INXDATAREAD-10
      ELSE
         WRITE( *, * )
     &   'WARNING:INXHEADREAD: UNKNOWN RECORD IN IONEX FILE:'
         WRITE( *, * ) '(',LINETEXT(61:80),')'
      ENDIF
C
      GOTO 100
 140  CONTINUE
      INXDATAREAD=4
      RETURN
 130  CONTINUE
      EOF=1
      RETURN
 120  CONTINUE
      IF( INXDATAREAD .EQ. 0 .AND. ( RTEC .NE. NTEC .OR. NTEC .EQ. 0 ) )
     &  INXDATAREAD=5
      RETURN
      END
C
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
      INTEGER*4 FUNCTION GETINXSATBIAS( CONST, PRN, BIAS, RMS )
C
      IMPLICIT NONE
C
      CHARACTER*1 CONST
      INTEGER*4 PRN
      REAL*8 BIAS, RMS
C
C IONEX HEADER COMMON DATA
C
      INTEGER*4 MAXINXCMT, MAXINXDSC, MAXINXMAP,
     &          MAXINXSATDCB, MAXINXSTADCB
      PARAMETER (MAXINXCMT=20)
      PARAMETER (MAXINXDSC=10)
      PARAMETER (MAXINXMAP=288)
      PARAMETER (MAXINXSATDCB=136)
      PARAMETER (MAXINXSTADCB=300)
C
      CHARACTER*1 INXSATBIASSATSYS(MAXINXSATDCB),
     &            INXSTABIASSATSYS(MAXINXSTADCB)
      CHARACTER*4 INXTYPE, INXSTABIASRCV(MAXINXSTADCB), INXMAPFUNCTION
      CHARACTER*20 INXPROGRAM, INXAGENCY, INXDATE
      CHARACTER*60 INXSATSYST, INXOBS_USED, INXDESCRIPTION(MAXINXDSC),
     &             INXCOMMENT(MAXINXCMT)
      INTEGER*4 INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     &          INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     &          INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     &          INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     &          INXSATBIASPRN(MAXINXSATDCB)
     &         ,INXHDPADDING
      REAL*4 INXVERSION, INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASERADIUS
      REAL*8 INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     &       INXLON1, INXLON2, INXDLON, INXMAP_TIME(MAXINXMAP),
     &       INXSATBIASBIAS(MAXINXSATDCB), INXSATBIASRMS(MAXINXSATDCB),
     &       INXSTABIASBIAS(MAXINXSTADCB), INXSTABIASRMS(MAXINXSTADCB)
C
      COMMON /IONEXHD/INXSATBIASSATSYS, INXSTABIASSATSYS, INXTYPE,
     & INXSATSYST, INXSTABIASRCV, INXMAPFUNCTION, INXPROGRAM, INXAGENCY,
     & INXDATE, INXOBS_USED, INXDESCRIPTION, INXCOMMENT,
     & INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     & INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     & INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     & INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     & INXSATBIASPRN, INXVERSION,
     & INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASERADIUS,
     & INXHDPADDING,
     & INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     & INXLON1, INXLON2, INXDLON, INXMAP_TIME,
     & INXSATBIASBIAS, INXSATBIASRMS, INXSTABIASBIAS, INXSTABIASRMS
C
      INTEGER*4 I,K
C
      GETINXSATBIAS=1
      BIAS=0.D0
      RMS=0.D0
      IF( INXNB_SAT_DCB .EQ. 0 ) RETURN
      K=0
      DO I=1,INXNB_SAT_DCB
        IF( INXSATBIASSATSYS(I) .EQ. CONST .AND.
     &      INXSATBIASPRN(I) .EQ. PRN ) K=I
      END DO
      IF( K.EQ.0 ) RETURN
      GETINXSATBIAS=0
      BIAS = INXSATBIASBIAS(K)
      RMS = INXSATBIASRMS(K)
      RETURN
      END
C
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
      INTEGER*4 FUNCTION GETINXSTABIAS( CONST, RCV, BIAS, RMS )
C
      IMPLICIT NONE
C
      CHARACTER*1 CONST
      CHARACTER*4 RCV
      REAL*8 BIAS,RMS
C
C IONEX HEADER COMMON DATA
C
      INTEGER*4 MAXINXCMT, MAXINXDSC, MAXINXMAP,
     &          MAXINXSATDCB, MAXINXSTADCB
      PARAMETER (MAXINXCMT=20)
      PARAMETER (MAXINXDSC=10)
      PARAMETER (MAXINXMAP=288)
      PARAMETER (MAXINXSATDCB=136)
      PARAMETER (MAXINXSTADCB=300)
C
      CHARACTER*1 INXSATBIASSATSYS(MAXINXSATDCB),
     &            INXSTABIASSATSYS(MAXINXSTADCB)
      CHARACTER*4 INXTYPE, INXSTABIASRCV(MAXINXSTADCB), INXMAPFUNCTION
      CHARACTER*20 INXPROGRAM, INXAGENCY, INXDATE
      CHARACTER*60 INXSATSYST, INXOBS_USED, INXDESCRIPTION(MAXINXDSC),
     &             INXCOMMENT(MAXINXCMT)
      INTEGER*4 INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     &          INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     &          INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     &          INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     &          INXSATBIASPRN(MAXINXSATDCB)
     &         ,INXHDPADDING
      REAL*4 INXVERSION, INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASERADIUS
      REAL*8 INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     &       INXLON1, INXLON2, INXDLON, INXMAP_TIME(MAXINXMAP),
     &       INXSATBIASBIAS(MAXINXSATDCB), INXSATBIASRMS(MAXINXSATDCB),
     &       INXSTABIASBIAS(MAXINXSTADCB), INXSTABIASRMS(MAXINXSTADCB)
C
      COMMON /IONEXHD/INXSATBIASSATSYS, INXSTABIASSATSYS, INXTYPE,
     & INXSATSYST, INXSTABIASRCV, INXMAPFUNCTION, INXPROGRAM, INXAGENCY,
     & INXDATE, INXOBS_USED, INXDESCRIPTION, INXCOMMENT,
     & INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     & INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     & INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     & INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     & INXSATBIASPRN, INXVERSION,
     & INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASERADIUS,
     & INXHDPADDING,
     & INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     & INXLON1, INXLON2, INXDLON, INXMAP_TIME,
     & INXSATBIASBIAS, INXSATBIASRMS, INXSTABIASBIAS, INXSTABIASRMS
C
      INTEGER*4 I,K
C
      GETINXSTABIAS=1
      BIAS=0.D0
      RMS=0.D0
      IF( INXNB_STA_DCB .EQ. 0 ) RETURN
      K=0
      DO I=1,INXNB_STA_DCB
        IF( INXSTABIASSATSYS(I) .EQ. CONST .AND.
     &      INXSTABIASRCV(I) .EQ. RCV ) K=I
      END DO
      IF( K.EQ.0 ) RETURN
      GETINXSTABIAS=0
      BIAS = INXSTABIASBIAS(K)
      RETURN
      END
C
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
      INTEGER*4 FUNCTION GETINXDAY( YEAR, MONTH, DAY )
C
      IMPLICIT NONE
C
      INTEGER*4 YEAR, MONTH, DAY
C
C IONEX HEADER COMMON DATA
C
      INTEGER*4 MAXINXCMT, MAXINXDSC, MAXINXMAP,
     &          MAXINXSATDCB, MAXINXSTADCB
      PARAMETER (MAXINXCMT=20)
      PARAMETER (MAXINXDSC=10)
      PARAMETER (MAXINXMAP=288)
      PARAMETER (MAXINXSATDCB=136)
      PARAMETER (MAXINXSTADCB=300)
C
      CHARACTER*1 INXSATBIASSATSYS(MAXINXSATDCB),
     &            INXSTABIASSATSYS(MAXINXSTADCB)
      CHARACTER*4 INXTYPE, INXSTABIASRCV(MAXINXSTADCB), INXMAPFUNCTION
      CHARACTER*20 INXPROGRAM, INXAGENCY, INXDATE
      CHARACTER*60 INXSATSYST, INXOBS_USED, INXDESCRIPTION(MAXINXDSC),
     &             INXCOMMENT(MAXINXCMT)
      INTEGER*4 INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     &          INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     &          INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     &          INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     &          INXSATBIASPRN(MAXINXSATDCB)
     &         ,INXHDPADDING
      REAL*4 INXVERSION, INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASERADIUS
      REAL*8 INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     &       INXLON1, INXLON2, INXDLON, INXMAP_TIME(MAXINXMAP),
     &       INXSATBIASBIAS(MAXINXSATDCB), INXSATBIASRMS(MAXINXSATDCB),
     &       INXSTABIASBIAS(MAXINXSTADCB), INXSTABIASRMS(MAXINXSTADCB)
C
      COMMON /IONEXHD/INXSATBIASSATSYS, INXSTABIASSATSYS, INXTYPE,
     & INXSATSYST, INXSTABIASRCV, INXMAPFUNCTION, INXPROGRAM, INXAGENCY,
     & INXDATE, INXOBS_USED, INXDESCRIPTION, INXCOMMENT,
     & INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     & INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     & INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     & INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     & INXSATBIASPRN, INXVERSION,
     & INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASERADIUS,
     & INXHDPADDING,
     & INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     & INXLON1, INXLON2, INXDLON, INXMAP_TIME,
     & INXSATBIASBIAS, INXSATBIASRMS, INXSTABIASBIAS, INXSTABIASRMS
C
      GETINXDAY=0
      YEAR=INXYEARFIRST
      MONTH=INXMONTHFIRST
      DAY=INXDAYFIRST
      RETURN
      END
C
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
      INTEGER*4 FUNCTION GETINXSPECS( SLAT, ELAT, DLAT, SLON, ELON,
     &                                DLON, ELVCUT, SLMHGT, MAXMAP,
     &                                INTRV )
C
      IMPLICIT NONE
C
      INTEGER*4 MAXMAP, INTRV
      REAL*8 SLAT, ELAT, DLAT, SLON, ELON, DLON, ELVCUT, SLMHGT
C
C IONEX HEADER COMMON DATA
C
      INTEGER*4 MAXINXCMT, MAXINXDSC, MAXINXMAP,
     &          MAXINXSATDCB, MAXINXSTADCB
      PARAMETER (MAXINXCMT=20)
      PARAMETER (MAXINXDSC=10)
      PARAMETER (MAXINXMAP=288)
      PARAMETER (MAXINXSATDCB=136)
      PARAMETER (MAXINXSTADCB=300)
C
      CHARACTER*1 INXSATBIASSATSYS(MAXINXSATDCB),
     &            INXSTABIASSATSYS(MAXINXSTADCB)
      CHARACTER*4 INXTYPE, INXSTABIASRCV(MAXINXSTADCB), INXMAPFUNCTION
      CHARACTER*20 INXPROGRAM, INXAGENCY, INXDATE
      CHARACTER*60 INXSATSYST, INXOBS_USED, INXDESCRIPTION(MAXINXDSC),
     &             INXCOMMENT(MAXINXCMT)
      INTEGER*4 INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     &          INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     &          INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     &          INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     &          INXSATBIASPRN(MAXINXSATDCB)
     &         ,INXHDPADDING
      REAL*4 INXVERSION, INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASERADIUS
      REAL*8 INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     &       INXLON1, INXLON2, INXDLON, INXMAP_TIME(MAXINXMAP),
     &       INXSATBIASBIAS(MAXINXSATDCB), INXSATBIASRMS(MAXINXSATDCB),
     &       INXSTABIASBIAS(MAXINXSTADCB), INXSTABIASRMS(MAXINXSTADCB)
C
      COMMON /IONEXHD/INXSATBIASSATSYS, INXSTABIASSATSYS, INXTYPE,
     & INXSATSYST, INXSTABIASRCV, INXMAPFUNCTION, INXPROGRAM, INXAGENCY,
     & INXDATE, INXOBS_USED, INXDESCRIPTION, INXCOMMENT,
     & INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     & INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     & INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     & INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     & INXSATBIASPRN, INXVERSION,
     & INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASERADIUS,
     & INXHDPADDING,
     & INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     & INXLON1, INXLON2, INXDLON, INXMAP_TIME,
     & INXSATBIASBIAS, INXSATBIASRMS, INXSTABIASBIAS, INXSTABIASRMS
C
      GETINXSPECS=0
      SLAT=INXLAT1
      ELAT=INXLAT2
      DLAT=INXDLAT
      SLON=INXLON1
      ELON=INXLON2
      DLON=INXDLON
      ELVCUT=INXELEV_CUTOFF
      SLMHGT=INXSHELL_HEIGHT
      MAXMAP=INXNB_MAPS
      INTRV=INXINTERVAL
      RETURN
      END
C
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
      INTEGER*4 FUNCTION GETINXMAPID( MAPNO, MAPTYP, MAPTIM )
     &                              
C
      IMPLICIT NONE
C
      INTEGER*4 MAPNO, MAPTYP
      REAL*8    MAPTIM
C
C IONEX HEADER COMMON DATA
C
      INTEGER*4 MAXINXCMT, MAXINXDSC, MAXINXMAP,
     &          MAXINXSATDCB, MAXINXSTADCB
      PARAMETER (MAXINXCMT=20)
      PARAMETER (MAXINXDSC=10)
      PARAMETER (MAXINXMAP=288)
      PARAMETER (MAXINXSATDCB=136)
      PARAMETER (MAXINXSTADCB=300)
C
      CHARACTER*1 INXSATBIASSATSYS(MAXINXSATDCB),
     &            INXSTABIASSATSYS(MAXINXSTADCB)
      CHARACTER*4 INXTYPE, INXSTABIASRCV(MAXINXSTADCB), INXMAPFUNCTION
      CHARACTER*20 INXPROGRAM, INXAGENCY, INXDATE
      CHARACTER*60 INXSATSYST, INXOBS_USED, INXDESCRIPTION(MAXINXDSC),
     &             INXCOMMENT(MAXINXCMT)
      INTEGER*4 INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     &          INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     &          INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     &          INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     &          INXSATBIASPRN(MAXINXSATDCB)
     &         ,INXHDPADDING
      REAL*4 INXVERSION, INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASERADIUS
      REAL*8 INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     &       INXLON1, INXLON2, INXDLON, INXMAP_TIME(MAXINXMAP),
     &       INXSATBIASBIAS(MAXINXSATDCB), INXSATBIASRMS(MAXINXSATDCB),
     &       INXSTABIASBIAS(MAXINXSTADCB), INXSTABIASRMS(MAXINXSTADCB)
C
      COMMON /IONEXHD/INXSATBIASSATSYS, INXSTABIASSATSYS, INXTYPE,
     & INXSATSYST, INXSTABIASRCV, INXMAPFUNCTION, INXPROGRAM, INXAGENCY,
     & INXDATE, INXOBS_USED, INXDESCRIPTION, INXCOMMENT,
     & INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     & INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     & INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     & INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     & INXSATBIASPRN, INXVERSION,
     & INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASERADIUS,
     & INXHDPADDING,
     & INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     & INXLON1, INXLON2, INXDLON, INXMAP_TIME,
     & INXSATBIASBIAS, INXSATBIASRMS, INXSTABIASBIAS, INXSTABIASRMS
C
C
C IONEX MAP COMMON DATA
C
      INTEGER*4 MAXINXCELLS
      PARAMETER (MAXINXCELLS=10585)
      INTEGER*4 INXMAP_NO,INXNBCELLLAT,INXNBCELLLON,INXMAP_TYPE,
     &          INXDTEXPONENT
     &         ,INXDTPADDING,INXTABLE(MAXINXCELLS)
      REAL*8 INXGPSTIME,INXMINLAT,INXLATCELLSIZE,INXMINLON,
     &       INXLONCELLSIZE
      COMMON /IONEXDT/INXMAP_NO,INXNBCELLLAT,INXNBCELLLON,INXMAP_TYPE,
     & INXDTEXPONENT,
     & INXDTPADDING,
     & INXGPSTIME,INXMINLAT,INXLATCELLSIZE,INXMINLON,INXLONCELLSIZE,
     & INXTABLE
C
      GETINXMAPID=0
      MAPNO=INXMAP_NO 
      MAPTYP=INXMAP_TYPE
      MAPTIM=INXGPSTIME
      RETURN
      END
C
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
      INTEGER*4 FUNCTION GETINXMAPTEC( LAT, LON, TEC )
     &                              
C
      IMPLICIT NONE
C
      REAL*8 LAT, LON, TEC
C
C IONEX HEADER COMMON DATA
C
      INTEGER*4 MAXINXCMT, MAXINXDSC, MAXINXMAP,
     &          MAXINXSATDCB, MAXINXSTADCB
      PARAMETER (MAXINXCMT=20)
      PARAMETER (MAXINXDSC=10)
      PARAMETER (MAXINXMAP=288)
      PARAMETER (MAXINXSATDCB=136)
      PARAMETER (MAXINXSTADCB=300)
C
      CHARACTER*1 INXSATBIASSATSYS(MAXINXSATDCB),
     &            INXSTABIASSATSYS(MAXINXSTADCB)
      CHARACTER*4 INXTYPE, INXSTABIASRCV(MAXINXSTADCB), INXMAPFUNCTION
      CHARACTER*20 INXPROGRAM, INXAGENCY, INXDATE
      CHARACTER*60 INXSATSYST, INXOBS_USED, INXDESCRIPTION(MAXINXDSC),
     &             INXCOMMENT(MAXINXCMT)
      INTEGER*4 INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     &          INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     &          INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     &          INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     &          INXSATBIASPRN(MAXINXSATDCB)
     &         ,INXHDPADDING
      REAL*4 INXVERSION, INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASERADIUS
      REAL*8 INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     &       INXLON1, INXLON2, INXDLON, INXMAP_TIME(MAXINXMAP),
     &       INXSATBIASBIAS(MAXINXSATDCB), INXSATBIASRMS(MAXINXSATDCB),
     &       INXSTABIASBIAS(MAXINXSTADCB), INXSTABIASRMS(MAXINXSTADCB)
C
      COMMON /IONEXHD/INXSATBIASSATSYS, INXSTABIASSATSYS, INXTYPE,
     & INXSATSYST, INXSTABIASRCV, INXMAPFUNCTION, INXPROGRAM, INXAGENCY,
     & INXDATE, INXOBS_USED, INXDESCRIPTION, INXCOMMENT,
     & INXYEARFIRST, INXMONTHFIRST, INXDAYFIRST,
     & INXMAPFIRST, INXMAPLAST, INXINTERVAL, INXNB_MAPS,
     & INXNB_STA, INXNB_SAT, INXMAPDIM, INXHDEXPONENT,
     & INXNB_SAT_DCB, INXNB_STA_DCB, INXNB_LAT, INXNB_LON,
     & INXSATBIASPRN, INXVERSION, 
     & INXELEV_CUTOFF, INXSHELL_HEIGHT, INXBASERADIUS,
     & INXHDPADDING,
     & INXHGT1, INXHGT2, INXDHGT, INXLAT1, INXLAT2, INXDLAT,
     & INXLON1, INXLON2, INXDLON, INXMAP_TIME,
     & INXSATBIASBIAS, INXSATBIASRMS, INXSTABIASBIAS, INXSTABIASRMS
C
C
C IONEX MAP COMMON DATA
C
      INTEGER*4 MAXINXCELLS
      PARAMETER (MAXINXCELLS=10585)
      INTEGER*4 INXMAP_NO,INXNBCELLLAT,INXNBCELLLON,INXMAP_TYPE,
     &          INXDTEXPONENT
     &         ,INXDTPADDING,INXTABLE(MAXINXCELLS)
      REAL*8 INXGPSTIME,INXMINLAT,INXLATCELLSIZE,INXMINLON,
     &       INXLONCELLSIZE
      COMMON /IONEXDT/INXMAP_NO,INXNBCELLLAT,INXNBCELLLON,INXMAP_TYPE,
     & INXDTEXPONENT,
     & INXDTPADDING,
     & INXGPSTIME,INXMINLAT,INXLATCELLSIZE,INXMINLON, INXLONCELLSIZE,
     & INXTABLE
C
      INTEGER*4 I,INCLAT,INCLON,IGPIND(4),NIGP,MININD
      REAL*8 ILAT,ILON,PLAT,PLON,WLAT(4),WLON(4),TECVAL(4),MINW
      DATA IGPIND/0,0,0,0/
      DATA WLAT/0.D0,0.D0,0.D0,0.D0 /
      DATA WLON/0.D0,0.D0,0.D0,0.D0 /
      DATA TECVAL/-1.D0,-1.D0,-1.D0,-1.D0 /
      GETINXMAPTEC=1
      NIGP=0
      MINW=1.D20
      TEC=999.D0
C
C MANAGE INPUT LAT,LON WRT GRID DEFINITION
C
      ILON=LON
C LATITUDE
      ILAT=DMOD(LAT,360.D0)
      IF( ILAT .LT. -90.D0 ) THEN
        ILAT=180.D0+ILAT
        ILON=180.D0+ILON
      ENDIF
      IF( ILAT .GT. 90.D0 ) THEN
        ILAT=180.D0-ILAT
        ILON=180.D0+ILON
      ENDIF
      PLAT=INXLATCELLSIZE*INT((ILAT-INXMINLAT)/INXLATCELLSIZE)
      IF( ILAT .LT. INXMINLAT ) PLAT=PLAT-INXLATCELLSIZE
C LONGITUDE
      IF( DABS(ILON) .GT. 360.D0 ) ILON=DMOD(ILON,360.D0)
      IF( INXMINLON .LT. 0 ) THEN
        IF ( ILON .GT. 180.D0 ) ILON=ILON-360.D0
        IF ( ILON .LT. -180.D0 ) ILON=ILON+360.D0
      ELSE IF( INXMINLON+INXLONCELLSIZE*(INXNBCELLLON-1)
     &                                      .GT. 180.D0 ) THEN
        IF ( ILON .LT. 0.D0 ) ILON=ILON+360.D0
      END IF
      PLON=INXLONCELLSIZE*INT((ILON-INXMINLON)/INXLONCELLSIZE)
C
C SCAN POINTS SURROUNDING LAT,LON
C
      DO I=1,4
        IF( I.EQ.2) PLON = PLON+INXLONCELLSIZE
        IF( I.EQ.3) PLAT = PLAT+INXLATCELLSIZE
        IF( I.EQ.4) PLON = PLON-INXLONCELLSIZE
        INCLAT=INT(DMOD(PLAT,180.D0)/INXLATCELLSIZE)
        INCLON=INT(DMOD(PLON,360.D0)/INXLONCELLSIZE)
        IGPIND(I) = 1 + INXNBCELLLON * INCLAT + INCLON
        IF( IGPIND(I) .LE. MAXINXCELLS .AND.
     &      INCLAT .GE. 0 .AND. INCLAT .LT. INXNBCELLLAT .AND.
     &      INCLAT .GE. 0 .AND. INCLAT .LT. INXNBCELLLAT .AND.
     &      INCLON .GE. 0 .AND. INCLON .LT. INXNBCELLLON .AND.
     &      INCLON .GE. 0 .AND. INCLON .LT. INXNBCELLLON ) THEN
          IF( INXTABLE(IGPIND(I)) .NE. 9999 ) THEN
            WLAT(I)=DABS(ILAT-INXMINLAT-PLAT)/INXLATCELLSIZE
            WLON(I)=DABS(ILON-INXMINLON-PLON)/INXLONCELLSIZE
            TECVAL(I)=(10.D0**INXDTEXPONENT)*INXTABLE(IGPIND(I))
            IF( WLAT(I)*WLON(I) .LT. MINW ) THEN
              MINW = WLAT(I)*WLON(I)
              MININD=I
            ENDIF
            NIGP=NIGP+1
          ENDIF
        ENDIF
      ENDDO
C
C COMPUTE WEIGHTS BASED ON AVAILABLE POINTS
C
      IF( NIGP .GT. 0 ) THEN
C
C CLOSE ENOUGH TO A SINGLE POINT
C
        IF( NIGP .EQ. 1 .AND. WLAT(MININD) .LT. 0.01D0 .AND.
     &                        WLON(MININD) .LT. 0.01D0 ) THEN
          WLAT(MININD) = 1.D0
          DO I=1,4
           IF( I .NE. MININD ) THEN
             WLAT(I)=0.D0
             TECVAL(I)=0.D0
           ENDIF
          END DO
          GETINXMAPTEC=0
C
C CLOSE ENOUGH TO TWO POINTS ALONG A LATITUDE OR LONGITUDE
C LINEAR WEIGHTING
C
        ELSE IF( NIGP .EQ. 2 ) THEN
C
C LATITUDE 1 CASE
C
          IF( MININD .LT. 3 .AND.
     &        TECVAL(1) .GE. 0.D0 .AND. TECVAL(2) .GE. 0.D0 .AND.
     &        WLAT(1) .LT. 0.01D0 .AND. WLAT(2) .LT. 0.01D0 ) THEN
            WLAT(1)=1.D0-WLON(1)
            WLAT(2)=1.D0-WLON(2)
            WLAT(3)=0.D0
            WLAT(4)=0.D0
            TECVAL(3)=0.D0
            TECVAL(4)=0.D0
            GETINXMAPTEC=0
C
C LATITUDE 2 CASE
C
          ELSE IF( MININD .GT. 2 .AND.
     &        TECVAL(3) .GE. 0.D0 .AND. TECVAL(4) .GE. 0.D0 .AND.
     &        WLAT(3) .LT. 0.01D0 .AND. WLAT(4) .LT. 0.01D0 ) THEN
            WLAT(3)=1.D0-WLON(3)
            WLAT(4)=1.D0-WLON(4)
            WLAT(1)=0.D0
            WLAT(2)=0.D0
            TECVAL(1)=0.D0
            TECVAL(2)=0.D0
            GETINXMAPTEC=0
C
C LONGITUDE 1 CASE
C
          ELSE IF( (MININD .EQ. 1 .OR. MININD .EQ. 4) .AND.
     &        TECVAL(1) .GE. 0.D0 .AND. TECVAL(4) .GE. 0.D0 .AND.
     &        WLON(1) .LT. 0.01D0 .AND. WLON(4) .LT. 0.01D0 ) THEN
            WLAT(1)=1.D0-WLAT(1)
            WLAT(4)=1.D0-WLAT(4)
            WLAT(2)=0.D0
            WLAT(3)=0.D0
            TECVAL(2)=0.D0
            TECVAL(3)=0.D0
            GETINXMAPTEC=0
C
C LONGITUDE 2 CASE
C
          ELSE IF( (MININD .EQ. 2 .OR. MININD .EQ. 3) .AND.
     &        TECVAL(2) .GE. 0.D0 .AND. TECVAL(3) .GE. 0.D0 .AND.
     &        WLON(3) .LT. 0.01D0 .AND. WLON(3) .LT. 0.01D0 ) THEN
            WLAT(2)=1.D0-WLAT(2)
            WLAT(3)=1.D0-WLAT(3)
            WLAT(1)=0.D0
            WLAT(4)=0.D0
            TECVAL(1)=0.D0
            TECVAL(4)=0.D0
            GETINXMAPTEC=0
          ENDIF
C
C TRIANGULAR WEIGHTING
C
        ELSE IF( NIGP .EQ. 3 ) THEN
C
C LOWER LEFT
C
          IF( MININD .EQ. 1 .AND. TECVAL(3) .LT. 0.D0 ) THEN
            WLAT(1)=1.D0-WLAT(1)-WLON(1)
            WLAT(2)=1.D0-WLON(2)
            WLAT(4)=1.D0-WLAT(4)
            WLAT(3)=0.D0
            TECVAL(3)=0.D0
C
C LOWER RIGHT
C
          ELSE IF( MININD .EQ. 2 .AND. TECVAL(4) .LT. 0.D0 ) THEN
            WLAT(1)=1.D0-WLON(1)
            WLAT(2)=1.D0-WLAT(2)-WLON(2)
            WLAT(3)=1.D0-WLAT(3)
            WLAT(4)=0.D0
            TECVAL(4)=0.D0
C
C UPPER RIGHT
C
          ELSE IF( MININD .EQ. 3 .AND. TECVAL(1) .LT. 0.D0 ) THEN
            WLAT(2)=1.D0-WLAT(2)
            WLAT(3)=1.D0-WLAT(3)-WLON(3)
            WLAT(4)=1.D0-WLON(4)
            WLAT(1)=0.D0
            TECVAL(1)=0.D0
C
C UPPER LEFT
C
          ELSE IF( MININD .EQ. 4 .AND. TECVAL(2) .LT. 0.D0 ) THEN
            WLAT(1)=1.D0-WLAT(1)
            WLAT(3)=1.D0-WLON(3)
            WLAT(4)=1.D0-WLAT(4)-WLON(4)
            WLAT(2)=0.D0
            TECVAL(2)=0.D0
          ENDIF
          GETINXMAPTEC=0
C
C SQUARE WEIGHTING
C
        ELSE IF( NIGP .EQ. 4 ) THEN
          WLAT(1)=(1.D0-WLAT(1))*(1.D0-WLON(1))
          WLAT(2)=(1.D0-WLAT(2))*(1.D0-WLON(2))
          WLAT(3)=(1.D0-WLAT(3))*(1.D0-WLON(3))
          WLAT(4)=(1.D0-WLAT(4))*(1.D0-WLON(4))
          GETINXMAPTEC=0
        END IF
      END IF
C
C PERFORM INTERPOLATION
C
      IF( GETINXMAPTEC .EQ. 0 ) THEN
        TEC=0.D0
        DO I=1,4
          TEC=TEC+TECVAL(I)*WLAT(I)
        END DO
      END IF
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C****************************************************************** IONO
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE IONO( MODEL , OBSTYP , L1OBS , L2OBS ,
     &                 IONCOR )
C
C     PURPOSE: COMPUTE AN IONOSPHERIC CORRECTION VALUE
C
C     PARAMETER SPECIFICATIONS:
C
C     MODEL       -  0 = NO MODEL
C                1 = DUAL FREQ
C                2 = BROADCAST
C     OBSTYP      -  0 = PSEUDORANGE
C                1 = PHASE
C     L1OBS       -  OBSERVATION ON L1
C     L2OBS       -  OBSERVATION ON L2
C
C     DLAY12      - RECEIVER INTER-FREQUENCY HARDWARE DELAY
C
C***********************************************************************
C
      IMPLICIT NONE
C
      REAL*8 L1OBS , L2OBS
      REAL*8 IONCOR
      INTEGER*4 MODEL , OBSTYP
C
C
C
      IF( MODEL.EQ.0) RETURN
C
      IF( OBSTYP .EQ. 0) THEN
         IONCOR =   L2OBS - L1OBS
      ELSE
         IONCOR =  (-.6470D0) * ( L1OBS - 1.2833D0 * L2OBS )
      ENDIF
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C************************************************************** IONO2ND
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE IONO2ND(IYR, JDAY, GEO, XST, XSAT, EL, HION, AE,    
     &                 P1, P2, DP12SAT, DP12ST, P120, VTEC, DL3)
C
C     PURPOSE: COMPUTE 2RD ORDER IONO CORRECTION VALUE BASED ON THE
C              IERS2010 CONVENTIONS (CHAP 9) & INT GEOMAG REF MODEL(IGRF11)
C
C      PARAMETER SPECIFICATIONS:
C INPUT:
C      IYR, JDAY - YEAR & DAY OF YEAR (E.G., 2010 & 355)
C      GEO(3) - STATION EPOCH LAT(RAD), LON(RAD) & H(M)
C      XST(3) - STATION EPOCH X(M), Y(M) & Z(M)
C      XSAT(3)- SATELLITE X(M), Y(M) & Z(M)
C      EL     - STATION-SATELLITE ELEVATION ANGLE (IN DEGREES)
C      HION   - IONO LAYER HEIGHT in KM (EG 450 KM) 
C      AE     - SEMI MAJOR AXIS OF REF ELIPSOID (M)
C      P1, P2-PHASES(M)
C      DP12SAT - SATELLITE  DP1P2 DCB(ns) FROM THE SVB FILE
C      DP12ST  - STATIOTION DP1P2 DCB(M) (FROM FLTDF IN FLTPAR(16))
C      P120   - P2-P1 THE INITIAL PHASE ANBIGUITY
C      VTEC   - EPOCH VTEC IN TECU (IN  0.1 TECU (10E16 ELECTRONS/M2))
C OUTPUT:
C      DL3 -  2ND ORDER IONO CORRECTON(IERS2010) (IN M)
C             TO BE SUBTRACTED(!) FROM L3 PHASE MEASUREMENTS(M)             
C
C***********************************************************************
C
      IMPLICIT NONE
C
      REAL*8 ZEN,AE,HION,PI, EL, P1, P2, DP12SAT, DP12ST, DL3,
     &       COLAT, ELONG, X, Y, Z, BP, C, F1, F2, S, S2, DATE
     &       ,AZ , DIST, P120, VTEC
      REAL*8 XST(3),   XSAT(3), GEO(3)
      REAL*8 XPT(3),   PLZ(3)
      INTEGER*4 IYR, JDAY
C
      PI      = 3.1415926536D0
      C       = 299792458.0D0
      F1      = 1575.42D+06
      F2      = 1227.60D+06
C
      ZEN= PI/2.D0-EL*PI/180.D0
      CALL  IONPT( XST, XSAT, ZEN, AE, HION*1.D3, XPT, PLZ, PI )
      CALL AZELD ( XPT(1),XPT(2),XPT(3),PLZ(1),PLZ(2),XSAT(1),XSAT(2),
     &            XSAT(3),AZ,ZEN,DIST)
      COLAT= (PI/2.D0-PLZ(1))*180.D0/PI
      ELONG= PLZ(2)*180.D0/PI
      DATE = IYR+JDAY/365.25D0
C
      CALL igrf12syn (  0,date,    1,HION,colat,elong,x,y,z,BP)
C FIELD COMPONENTs (nT) x +ve N, y +ve E & Z +ve DOWN /CHANGE UP !           
      Z=-Z
C
C  COMPUTE 3RD IONO CORRECTION (IERS 2010 CONVENTIONS, CHAP. 9, EQS.9-44,9-46
C
      S = 0.D0
C  COMPUTE STEC  S (EQ. 9-48) FROM PR2-PR1 & DCBs DP12SAT,DP12ST 
C  IF DP12ST.NE.0 (I.E. A STATION DP1P2 DCB & P12 PHSE AMB P120 EXIST)
      IF(DP12ST.NE.0.D0.AND.P120.NE.0.D0)
     &   S = (P1*C/F1-P2*C/F2+DP12SAT*C*1.D-9+DP12ST + P120)/1.0507D-17
C ONLY STEC > 0 IS MEANINGFUL, IF NOT, COMPUTE FROM VTEC OR IGNORE STEC = 0
      IF (S.LE.0.D0.OR.S.GT.1200.D16) THEN
          S=0.D0
C VTEC IS IN 0.1 TECU (E16)= 1E15!
        IF(VTEC.GT.0.D0.AND.VTEC.LE.4000.D0)
     &    S = VTEC*1.D15/COS(PLZ(3))
      ENDIF
C
C COMPUTE BpCOS(THETAp) & S2 (ACCORDING TO EQ. 9-46), AND /1.E9 (nT->TESLA)
C !NOTE PIERCE POINT => SAT DIR = - SAT SIGNAL PROPAGATION DIRECTION !
      S2=-1.1284D03*S*(SIN(PLZ(3))*(COS(AZ)*X+SIN(AZ)*Y)+COS(PLZ(3))*Z)
C L3 PHASE 2ND CORRECTION (M) (EQ. 9-44), FOR PR (9-45) NEGLECTED
C    TO BE SUBTRACTED FROM L3(M)
C 
      DL3 =    S2/F1/F2/(F1+F2)
C
C PARTIAL 3RD IONO CORRECTIONS (TERMS POTENTIALLY > 1 MM ONLY)
C
C  DS3 RAY BENDING (DS3/F1^2/F2^2) SEE EQ.9-37 & 9-44 (EQ.9-47 < 1 mm NEGLECTED) 
     &       +2.495D-3*(1.D0/COS(PLZ(3))-1.D0)*S**2/F1/F1/F2/F2
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** IONPT
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE IONPT( XST, XSAT, ZEN, AE, HION, XPT, PLZ, PI )
C
C     NAME       :  IONPT
C
C     PURPOSE    :  COMPUTE GEOCENTRIC LONGITUDE, LATITUDE AND 
C                   ZENITH DISTANCE OF THE INTERSECTION OF THE LINE
C                   RECEIVER-SATELLITE WITH THE IONOSPHERE LAYER.
C
C    PARAMETERS         DESCRIPTION
C
C      XST              EARTH FIXED RECEIVER COORDINATES
C      XSAT             EARTH FIXED SATELLITE COORDINATES 
C      ZEN              ZENITH DISTANCE OF SATELLITE FROM RECEIVER
C      HION             HEIGHT OF IONOSPHERE LAYER (M)     
C
C      XPT              CARTESIAN COORDINATES OF RECEIVER-SATELLITE
C                       LINE INTERSECTION WITH IONOSPHERIC LAYER
C      PLZ              LATITUDE, LONGITUDE AND ZENITH ANGLE
C                       OF INTERSECTION BETWEEN SATELLITE-RECEIVER
C                       LINE AND IONOSPHERIC LAYER    
C
      IMPLICIT NONE
C
      REAL*8 ZEN,AE,HION,PI
      REAL*8 XST(3),   XSAT(3)
      REAL*8 XPT(3),   PLZ(3)
C
      INTEGER*4 I
      REAL*8    R,RPH,SINZP,XXX,DIST
C
C     RADIUS VECTOR OF RECEIVER
C
      R=DSQRT(XST(1)**2+XST(2)**2+XST(3)**2)
C
C     GEOCENTRIC DISTANCE OF IONOSPHERE LAYER
C
      RPH=AE+HION
C      RPH=R+HION
       PLZ(3)= ZEN
       XPT(1)=XST(1)*RPH /R
       XPT(2)=XST(2)*RPH /R
       XPT(3)=XST(3)*RPH /R
       PLZ(2)= DATAN2(XPT(2),XPT(1))
       PLZ(1)= DATAN(XPT(3)/DSQRT(XPT(1)**2+XPT(2)**2))
C
C     ZENITH DISTANCE OF SATELLITE FROM INTERSECTION WITH IONOSPHERE
C
      SINZP=(R/RPH)*DSIN(ZEN)
c!    WRITE(*,*) 'IN IONPT',R,SINZP
      IF (DSQRT(1.D0-SINZP**2) .GT. .01D0 ) THEN
        PLZ(3)=DATAN(SINZP/DSQRT(1.D0-SINZP**2))
      ELSE
        PLZ(3) = PI/2.D0-1.D02
      END IF
c!    WRITE(*,*) 'IN IONPT,zen,sinzp,plz3',
c!   &               ZEN*180.D0/PI,SINZP,PLZ(3)*180.D0/PI
C
C     COORDINATES OF INTERSECTION OF LINE RECEIVER-SATELLITE
C     WITH IONOSPHERE-LAYER
C
      IF(R.LT.RPH) THEN
      XXX=DSQRT(RPH**2+R**2-2*RPH*R*DCOS(ZEN-PLZ(3)))
      DIST=0.D0
      DO 5 I=1,3
      DIST=DIST+(XSAT(I)-XST(I))**2
 5    CONTINUE
      DIST=DSQRT(DIST)
      DO 10 I=1,3
        XPT(I)=XST(I)+XXX*(XSAT(I)-XST(I))/DIST
 10   CONTINUE
      PLZ(2)= DATAN2(XPT(2),XPT(1))
      PLZ(1)= DATAN(XPT(3)/DSQRT(XPT(1)**2+XPT(2)**2))
      ENDIF
c!    WRITE(*,*) 'IN IONPT,plz12',PLZ(1),PLZ(2)
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C ************************************************************** JACONV
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE        JACONV  (A, E, PHI, LAM, H, M, N, JACB )
C
C     NAME              JACONV
C
C     PURPOSE   COMPUTE JACOBIAN FOR CONVERSION OF 
C                       VARIANCE-COVARIANCE FROM CARTESIAN 
C                       TO ELLIPSOIDAL
C
C     PARAMETERS        DESCRIPTION
C
C            A          ELLIPSOID SEMI-MAJOR AXIS
C            E          ELLIPSOID ECCENTRICITY
C            PHI        LATITUDE
C            LAM        LONGITUDE
C            H          HEIGHT
C            JACB       JACOBIAN
C
      IMPLICIT  NONE
C
      REAL*8            A
        REAL*8          E
      REAL*8            PHI
      REAL*8            LAM
      REAL*8            H
      REAL*8            M
      REAL*8            N
      REAL*8            JACB(3,3)
C
      REAL*8            E2
      REAL*8            SIN_P
      REAL*8            COS_P
      REAL*8            SIN_L
      REAL*8            COS_L
C-------------------------------------------------------------------------------
      E2        = E*E
      SIN_P     = SIN ( PHI )
      COS_P     = COS ( PHI )
      SIN_L     = SIN ( LAM )
      COS_L     = COS ( LAM )
C
      JACB( 1 , 1 ) = (-1.0D0) * SIN_P * COS_L / ( M + H )
      JACB( 1 , 2 ) = (-1.0D0) * SIN_P * SIN_L / ( M + H )
      JACB( 1 , 3 ) =          COS_P         / ( M + H )
      JACB( 2 , 1 ) = (-1.0D0) / COS_P * SIN_L / ( N + H )
      JACB( 2 , 2 ) = COS_L  / COS_P         / ( N + H )
      JACB( 2 , 3 ) = 0.0D0
      JACB( 3 , 1 ) =          COS_P * COS_L
      JACB( 3 , 2 ) =          COS_P * SIN_L
      JACB( 3 , 3 ) =                  SIN_P
c!    write(*,*) ((jacb(i,j),j=1,3),i=1,3)
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C************************************************************* JLIAN
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
        SUBROUTINE JLIAN ( MJD, IYEAR, MONTH, IDAY)
C
C       NAME            JULIAN
C
C       PURPOSE         TO CALCULATE THE JULIAN DAY    
C                       GIVEN YEAR, MONTH, DAY
C
C     PARAMETERS        DESCRIPTION
C
C          MJD          MODIFIED JULIAN DATE
C          IYEAR        YEAR
C          MONTH        MONTH OF YEAR
C          IDAY         DAY OF MONTH
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4 MJD, IYEAR, MONTH, IDAY
C
      INTEGER*4 NYRM1,IC,LEAP,M1,M3,M2
      INTEGER*4 N2(12)
      DATA N2/0,31,59,90,120,151,181,212,243,273,304,334/
      NYRM1=IYEAR-1
      IC=NYRM1/100
      MJD=-678576+365*NYRM1+NYRM1/4-IC+IC/4
      LEAP=0
      IF(MONTH.LT.3) GO TO 100
      M1=MOD(IYEAR,4)
      IF(M1.NE.0)GO TO 100
      LEAP=1
      M3=MOD(IYEAR,100)
      IF(M3.NE.0)GO TO 100
      M2=MOD(IYEAR,400)
      IF(M2.NE.0)LEAP=0
  100 MJD=MJD+N2(MONTH)+IDAY+LEAP
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** JULDM
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE JULDM ( JULD, IYEAR, IMTH, IDAY, IWAY )
C
C     NAME              JULDM
C
C     PURPOSE   CONVERT JULIAN DAY TO
C               MONTH AND DAY OR VICE VERSA
C
C     PARAMETERS        DESCRIPTION
C
C        JULD   JULIAN DAY
C        IYEAR  YEAR
C        IMTH   MONTH
C        IDAY   DAY OF MONTH
C        IWAY   DIRECTION OF CONVERSION
C               0 = JULIAN DAY ==> MONTH, DAY OF MONTH
C               1 = MONTH, DAY OF MONTH ==> JULIAN DAY
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4 JULD, IYEAR, IMTH, IDAY, IWAY
C
      INTEGER*4 JULDAY,ILEAP,IM
      INTEGER*4 NDAYM(12,2)
C
      DATA NDAYM /  31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,
     &              31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 /
C
C
C     SEE IF THIS IS A LEAP YEAR
C
      ILEAP = 1
      IF ( MOD(IYEAR,4) .EQ. 0 .AND. MOD(IYEAR,100) .NE. 0
     &         .OR. MOD(IYEAR,400) .EQ. 0 ) ILEAP = 2
C
C     JULIAN DAY ==> MONTH AND DAY
C
      IF ( IWAY .EQ. 0 ) THEN
C
        JULDAY = JULD
      DO 100 IM=1,12
         IF (JULDAY .LE. NDAYM(IM,ILEAP)) GO TO 200
         JULDAY  = JULDAY - NDAYM(IM,ILEAP)
  100 CONTINUE
C
  200 CONTINUE
      IMTH = IM
      IDAY = JULDAY
      END IF
C
C     MONTH AND DAY ==> JULIAN DAY
C
      IF ( IWAY .EQ. 1 ) THEN
        JULDAY = 0
      DO 300 IM=1,IMTH-1
         JULDAY  = JULDAY + NDAYM(IM,ILEAP)
  300 CONTINUE
      JULDAY = JULDAY + IDAY
        JULD = JULDAY
      END IF
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** KLCLK
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE KLCLK (EPH,DTM,TIM,DELTAT,DLTR)
C
C     PURPOSE:   COMPUTE BROADCAST SATELLITE CLOCK
C
C
      IMPLICIT NONE
C
      REAL*8    EPH(30), DTM(7),TIM,DELTAT,DLTR
C
      INTEGER*4 IFLAG
      REAL*8    PI,A,ANYM,AMYE,AMYT,RK
C
      PI = 4.D0*DATAN(1.D0)
      A  = EPH(19)**2
      ANYM = EPH(15) + (DSQRT(DTM(6)/A**3)+EPH(14))*TIM
      CALL ANML2(ANYM,EPH(17),AMYE,AMYT,IFLAG,PI)
c!    WRITE(*,'(A3,I2.2,F15.2,F20.10)') 'RLY',EPH(1),TIM,ANYM
C
      RK     = (-4.443D-10)*EPH(17)*EPH(19)
      DLTR   = RK*DSIN(AMYE)
      DELTAT = EPH(11) + EPH(10)*TIM + EPH(9)*TIM*TIM +DLTR
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C***************************************************************** KLORB
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE KLORB(LUO,EPH,XSV,XSVD,C,XRV,DTM,TIM,ITIM,IPR,IVEL)
C
C  NAME: KLORB
C
C     PURPOSE:   COMPUTE SATELLITE COORDINATES AND VELOCITIES
C              FROM BROADCAST EPHEMERIS ELEMENTS .
C
C  CALLING PARAMETERS:
C
C     INPUT:
C
C     EPH    - EPHEMERIS DATA:
C            ---------------------- SUBFRAME 1 -----------------------
C            EPH( 1) - SV NUMBER
C            EPH( 2) - GPS WEEK NUMBER
C            EPH( 3) - MODE (0 = C/A & P, 1=P ONLY, 2=C/A ONLY)
C            EPH( 4) - SV ACCURACY
C            EPH( 5) - SV HEALTH
C            EPH( 6) - TG (GROUP DELAY DIFFERENTIAL)
C            EPH( 7) - AODC (AGE OF DATA, CLOCK)
C            EPH( 8) - TO (REFERENCE TIME FOR CLOCK PARAMETERS)
C            EPH( 9) - AF2 (POLYNOMIAL COEFFICIENT FOR CLOCK)
C            EPH(10) - AF1 (POLYNOMIAL COEFFICIENT FOR CLOCK)
C            EPH(11) - AF0 (POLYNOMIAL COEFFICIENT FOR CLOCK)
C            --------------------- SUBFRAME 2 -----------------------
C            EPH(12) - AODE (AGE OF DATA, EPHEMERIS)
C            EPH(13) - CRS (AMPLITUDE OF SINE HARMONIC CORRECTION
C                TERM TO ORBIT RADIUS)
C            EPH(14) - DN (MEAN MOTION DIFFERENCE FROM COMPUTED VALUE)
C            EPH(15) - MO (MEAN ANOMOLY AT REFERENCE TIME)
C            EPH(16) - CUC (AMPLITUDE OF COSINE HARMONIC CORRECTION
C                TERM TO ARGUMENT OF LATITUDE)
C            EPH(17) - E (ECCENTRICITY)
C            EPH(18) - CUS (AMPLITUDE OF SINE HARMONIC CORRECTION
C                TERM TO ARGUMENT OF LATITUDE)
C            EPH(19) - A**.5 (SQUARE ROOT OF MAJOR SEMI-AXIS)
C            EPH(20) - TOE (REFERENCE TIME OF EPHEMERIS)
C            EPH(21) - CURVE FIT INTERVAL (4 HRS OR 6 HRS)
C            ---------------------- SUBFRAME 3 -----------------------
C            EPH(22) - CIC (AMPLITUDE OF COSINE HARMONIC CORRECTION
C                TERM TO ANGLE OF INCLINATION)
C            EPH(23) - OMEGAO (RIGHT ASCENSION AT REFERENCE TIME)
C            EPH(24) - CIS (AMPLITUDE OF SINE HARMONIC CORRECTION
C                TERM TO ANGLE OF INCLINATION)
C            EPH(25) - IO  (INCLINATION ANGLE AT REFERENCE TIME)
C            EPH(26) - CRC (AMPLITUDE OF COSINE HARMONIC CORRECTION
C                TERM TO ORBIT RADIUS)
C            EPH(27) - W (ARGUMENT OF PERIGEE)
C            EPH(28) - OMEGADOT (RATE OF RIGHT ASCENSION)
C            EPH(29) - AODE (AGE OF DATA, EPHEMERIS)
C            EPH(30) - IDOT (RATE OF INCLINATION ANGLE)
C
C            XSV(3)       SATELLITE COORDINATES (M)
C            XSVD(3)      SATELLITE VELOCITIES (M/SEC)
C            C    SPEED OF LIGHT (M/SEC)
C            XRV(3)       STATION COORDINATES (M)
C            DTM(7)       DATUM PARAMETERS
C            TIM          TIME (SINCE EPH REF.TIME)
C            ITIM         TIME FLAG = 0:TIME SIGNAL TRANSM.
C                           > 0:TIME SIGNAL RECEPT.
C            IPR          PRINTER LU
C            IVEL         = 0: COMPUTE COORDINATES
C                 > 0: COMPUTE COORDINATES + VELOCITIES
C            COMPMM -   COMPUTED MEAN MOTION
C            CORRMM -   CORRECTED MEAN MOTION
C
C    CALLED  SUBROUTINES: ANOMLY , RVECT
C
      IMPLICIT NONE
C
      INTEGER*4 LUO,ITIM,IPR,IVEL
      REAL*8    C,TIM
      REAL*8    EPH(*),   XSVD(3),   XSV(3),    DTM(7),   XRV(3)
C
      INTEGER*4 ITER,IFLAG
      REAL*8    A,ECC,RINC,COMPMM,CORRMM,AMYM,AMYE,AMYT,PHIK0,XR(3)
      REAL*8    RADIUS,RDOT,VDOT,CPK,SPK,DUK,DRK,DIK,PROP,PHIK,COSU
      REAL*8    SINU,COSI,SINI,RLNG,COSW,SINW,X,Y,DR,SINDR,COSDR
      REAL*8    RNG,TPROP,DUDOT,DRDOT,DIDOT,OMDOT,XDOT,YDOT,FAC1,FAC2
C INITIALIZE VARIABLES
      A    = EPH(19)**2
      ECC  = EPH(17)
      RINC = EPH(25)
C COMPUTE COMPUTED AND CORRECTED  MEAN MOTION
      COMPMM = DSQRT(DTM(6)/A**3)
      CORRMM = COMPMM + EPH(14)
C COMPUTE ORBIT ANOMOLIES
      CALL ANOMLY(EPH,TIM,IPR,AMYM,AMYE,AMYT,
     #                        PHIK0,IFLAG,CORRMM)
C COMPUTE ORBIT RADIUS
      RADIUS = A * (1.0D0 - ECC *DCOS(AMYE))
C COMPUTE TIME DERIVATIVE OF RADIUS AND TRUE ANOMOLY
      RDOT = A*ECC*DSIN(AMYE)*CORRMM/(1.0D0-ECC*DCOS(AMYE))
      VDOT = DSQRT(1.0D0-ECC*ECC)*CORRMM/(1.0D0-ECC*DCOS(AMYE))**2
C COMPUTE PERTURBATIONS FROM EPHEMERIS CORRECTION PARAMETERS
      CPK = DCOS(2.0D0 * PHIK0)
      SPK = DSIN(2.0D0 * PHIK0)
      DUK = EPH(16) * CPK + EPH(18) * SPK
      DRK = EPH(26) * CPK + EPH(13) * SPK
      DIK = EPH(22) * CPK + EPH(24) * SPK
C CORRECT ARGUMENT OF LATITUDE,RADIUS AND INCLINATION
      RADIUS = RADIUS + DRK
      RINC = RINC + DIK + EPH(30) * TIM
      ITER = 0
      PROP = 0.0D0
C START OF RECEIVE TIME LOOP
10    CONTINUE
      PHIK = PHIK0 + DUK - PROP*VDOT
      COSU = DCOS(PHIK)
      SINU = DSIN(PHIK)
      COSI = DCOS(RINC)
      SINI = DSIN(RINC)
      RLNG = EPH(23) + ( EPH(28) - DTM(7) ) * (TIM - PROP)
     #                  - DTM(7) * EPH(20)
      COSW = DCOS(RLNG)
      SINW = DSIN(RLNG)
C COMPUTE COORDINATES IN THE ORBITAL PLANE
      X = RADIUS*COSU
      Y = RADIUS*SINU
C COMPUTE COORDINATES IN EARTH FIXED SYSTEM
      XSV(1) = X*COSW - Y*COSI*SINW
      XSV(2) = X*SINW + Y*COSI*COSW
      XSV(3) = Y*SINI
C IF TRANSMISSION TIME OPTION IS CHOSEN JUMP OUT OF LOOP
      IF(ITIM .EQ. 0) GO TO 30
      DR = PROP*DTM(7)
      SINDR = DSIN(DR)
      COSDR = DCOS(DR)
      XR(1) = XRV(1)*COSDR + XRV(2)*SINDR
      XR(2) = XRV(2)*COSDR - XRV(1)*SINDR
      XR(3) = XRV(3)
      CALL RVECT(XSV,XR,RNG)
      TPROP = RNG / C
      IF(DABS(PROP-TPROP) .LT. 1.D-12) GO TO 30
      IF(ITER .GE. 10) GO TO 20
      PROP = TPROP
      ITER = ITER + 1
      GO TO 10
   20 CONTINUE
      WRITE(LUO,1001) DABS(PROP-TPROP),ITER
 1001 FORMAT(' /KLORB: ABS(PROP-TPROP)=',G20.8,' AFTER ',I4,
     #       ' ITERATIONS')
   30 CONTINUE
C  IF NO VELOCITIES REQUIRED JUMP OUT OF ROUTINE
      IF(IVEL .EQ. 0) RETURN
C COMPUTE THE TIME DERIVATIVE OF THE ORBITAL ELEMENTS
      DUDOT = 2.0D0*VDOT*(-(EPH(16)*SPK) + EPH(18) *CPK)
      DRDOT = 2.0D0*VDOT*(-(EPH(26)*SPK) + EPH(13) *CPK)
      DIDOT = 2.0D0*VDOT*(-(EPH(22)*SPK) + EPH(24)*CPK)
      DUDOT = DUDOT + VDOT
      DRDOT = DRDOT + RDOT
      DIDOT = DIDOT + EPH(30)
      OMDOT = EPH(28) -DTM(7)
C COMPUTE THE TIME DERIVATIVES IN THE ORBITAL PLANE
      XDOT = DRDOT*COSU - RADIUS*SINU*DUDOT
      YDOT = DRDOT*SINU + RADIUS*COSU*DUDOT
C COMPUTE VELOCITIES IN THE EARTH FIXED SYSTEM
      FAC1 = XDOT - Y*COSI*OMDOT
      FAC2 = -(X*OMDOT) - (YDOT*COSI) + (Y*SINI*DIDOT)
      XSVD(1) = COSW*FAC1 + SINW*FAC2
      XSVD(2) = SINW*FAC1 - COSW*FAC2
      XSVD(3) = YDOT*SINI + Y*COSI*DIDOT
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** L1CODE
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      LOGICAL*4 FUNCTION L1CODE ( IP1OB, IC1OB, P1, C1, ICUSE, IDCBUSE,
     &                            DP1C1, C )
C
C     NAME              L1CODE 
C
C     PURPOSE         SELECT L1 CODE FOR PROCESSING (P1 OR C1) 
C                       AND APPLY DCB IF REQUIRED
C
C     PARAMETERS        DESCRIPTION
C
C          IP1OB       P-CODE OBSERVED (TRUE/FALSE)
C          IC1OB       CA-CODE OBSERVED (TRUE/FALSE)
C          P1          P-CODE PSEUDORANGE
C          C1          CA-CODE PSEUDORANGE
C          ICUSE       CODE TO USE (0=P1,1=C1,2=P1 or C1)
C          IDCBUSE     IDCBUSE (0=NO,1=YES)
C
C                        L1 CODE SELECTION TABLE
C                        (if IDCBUSE=0 then DCB=0)
C
C                  |          L1 CODE TO USE
C                  |     P1         C1       P1 | C1
C     -------------------------------------------------------
C       OBSERVED   |
C                  |
C       P1 (YES)   |     P1        -           P1
C       P1 (NO)    |     0         -            0
C       C1 (YES)   |     -         C1+DCB      C1+DCB if P1=0
C       C1 (NO)    |     -         0           0 if P1=0 and C1=0
C               
C
C *********************************************************************
C
      IMPLICIT NONE
C
      LOGICAL   IP1OB, IC1OB
      INTEGER*4 ICUSE, IDCBUSE
      REAL*8    P1,    C1, DP1C1, C
      L1CODE=.TRUE.
C
C     C1 CODE OBSERVED
C
      IF ( IC1OB ) THEN      
        IF ( ICUSE .EQ. 1 ) THEN
          P1=C1
          IF ( IDCBUSE .NE. 0 ) P1=P1+DP1C1/1.D9
          L1CODE=.FALSE.
        END IF
C
C       USE P1 OR C1 CODE, DEPENDING ON AVAILABILITY
C
        IF ( ICUSE .EQ. 2 .AND. .NOT. IP1OB ) THEN
          P1=C1
          IF ( IDCBUSE .NE. 0 ) P1=P1+DP1C1/1.D9
          L1CODE=.FALSE.
        END IF
C
C     NO C1 CODE OBSERVED
C
      ELSE
        IF ( ICUSE .EQ. 1 .OR.
     &      (ICUSE .EQ. 2 .AND. .NOT. IP1OB) ) P1=0.D0
      END IF
C
c!    write(*,*) icuse,idcbuse,ip1ob,ic1ob,p1*c,c1*c
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C **************************************************************** L2CODE
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      LOGICAL*4 FUNCTION L2CODE ( IP2OB, IC2OB, P2, C2, ICUSE, IDCBUSE,
     &                            DP2C2, C )
C
C     NAME              L1CODE 
C
C     PURPOSE         SELECT L2 CODE FOR PROCESSING (P2 OR C2) 
C                       AND APPLY DCB IF REQUIRED
C
C     PARAMETERS        DESCRIPTION
C
C          IP2OB       P-CODE OBSERVED (TRUE/FALSE)
C          IC2OB       CA-CODE OBSERVED (TRUE/FALSE)
C          P2          P-CODE PSEUDORANGE
C          C2          CA-CODE PSEUDORANGE
C          ICUSE       CODE TO USE (0=P2,1=C2,2=P2 or C2)
C          IDCBUSE     IDCBUSE (0=NO,1=YES)
C
C                        L2 CODE SELECTION TABLE
C                        (if IDCBUSE=0 then DCB=0)
C
C                  |          L2 CODE TO USE
C                  |     P2         C2       P2 | C2
C     -------------------------------------------------------
C       OBSERVED   |
C                  |
C       P2 (YES)   |     P2        -           P2
C       P2 (NO)    |     0         -            0
C       C2 (YES)   |     -         C2+DCB      C2+DCB if P2=0
C       C2 (NO)    |     -         0           0 if P2=0 and C2=0
C               
C
C *********************************************************************
C
      IMPLICIT NONE
C
      LOGICAL   IP2OB, IC2OB
      INTEGER*4 ICUSE, IDCBUSE
      REAL*8    P2,    C2, DP2C2, C
      L2CODE=.TRUE.
C
C     C2 CODE OBSERVED
C
      IF ( IC2OB ) THEN      
        IF ( ICUSE .EQ. 1 ) THEN
          P2=C2
          IF ( IDCBUSE .NE. 0 ) P2=P2+DP2C2/1.D9
          L2CODE=.FALSE.
        END IF
C
C       USE P2 OR C2 CODE, DEPENDING ON AVAILABILITY
C
        IF ( ICUSE .EQ. 2 .AND. .NOT. IP2OB ) THEN
          P2=C2
          IF ( IDCBUSE .NE. 0 ) P2=P2+DP2C2/1.D9
          L2CODE=.FALSE.
        END IF
C
C     NO C2 CODE OBSERVED
C
      ELSE
        IF ( ICUSE .EQ. 1 .OR.
     &      (ICUSE .EQ. 2 .AND. .NOT. IP2OB) ) P2=0.D0
      END IF
C
c!    write(*,*) icuse,idcbuse,ip1ob,ic1ob,p1*c,c1*c
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** LASTSV
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE LASTSV ( NSV, ISV, NSVL, ISVL )
C
C     NAME              LASTSV
C
C     PURPOSE   SAVE LAST EPOCH SATELLITE PRN LIST
C
C     PARAMETERS        DESCRIPTION
C
C        NSV            NUMBER OF SATELLITES OBSERVED AT THIS EPOCH
C        ISV            ARAAY OF EPOCH SATELLITE PRN NUMBERS
C        NSVL           NUMBER OF SATELLITES OBSERVED AT THIS EPOCH
C        ISVL           ARAAY OF EPOCH SATELLITE PRN NUMBERS
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4    NSV,         ISV(*)
      INTEGER*4    NSVL,        ISVL(*)
C
      INTEGER*4    I
C
C-------------------------------------------------------------------------
C     SEE SATELLITE LIST 'ISV(I)' INTO LIST 'ISVL(I)'
C-------------------------------------------------------------------------
C
      NSVL = NSV
      DO 150 I=1,NSV
         ISVL(I) = ISV(I)
  150 CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** LOWE
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C LOWE, P.R. 'An Approximating Polynomial for the Computation of
C Saturation Vapor Pressure',J. Applied Meteorology, Vol 16, No 1,
C January, 1977, pp. 100-103
C
       REAL*8 FUNCTION LOWE (TEMP)
C
       IMPLICIT NONE
       INTEGER*4 I
       REAL*8 TEMP
       REAL*8 LOWECOEF(7)
C                    a0               a1              a2
       DATA LOWECOEF/  6984.505294D0, -188.9039310D0,   2.133357675D0,
C                    a3               a4              a5
     &               -1.288580973D-2, 4.393587233D-5, -8.023923082D-8,
C                    a6
     &               6.136820929D-11/
       LOWE=LOWECOEF(1)+
     &      TEMP*(LOWECOEF(2)+TEMP*(LOWECOEF(3)+TEMP*(LOWECOEF(4)+
     &      TEMP*(LOWECOEF(5)+TEMP*(LOWECOEF(6)+TEMP*LOWECOEF(7))))))
       RETURN
       END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** MATMPY
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE MATMPY(M1,M2,M3,L,M,N,JL,JM,JN,ICODE)
C
C     NAME:       MATMPY
C
C     PURPOSE:    TO COMPUTE THE PRODUCT OF TWO MATRICES IN ANY
C             ALLOWABLE TRANSPOSE COMBINATION AS FOLLOWS:
C
C               OPTION ICODE          PRODUCT M3
C
C                    1                   M1*M2
C                    2                 (M1)T*M2
C                    3                 M1*(M2)T
C                    4                (M1)T*(M2)T
C
C
C               (L,M),(M,N),(L,N) ARE THE DIMENSIONS OF THE
C                   PRE- , POST- AND PRODUCT-MATRICES
C                        RESPECTIVELY
C                     JL,JM,JN ARE CORRESPONDING DECLARED ROW
C                DIMENSIONS AT THE CALLING PROGRAM
C
C
      IMPLICIT NONE
C
      INTEGER*4 L,M,N,JL,JM,JN,ICODE
      REAL*8    M1(JL,*) , M2(JM,*) , M3(JN,*)
C 
      INTEGER*4 I,J,K
C
       DO 11 I = 1,L
       DO 11 J = 1,N
        M3(I,J) = 0.
          DO 11 K = 1,M
         GO TO(1,2,3,4),ICODE
   1     CONTINUE
C     M3 = M1 * M2
          M3(I,J) = M3(I,J) + M1(I,K)*M2(K,J)
            GO TO 11
   2     CONTINUE
C   M3 = M1 TRANSPOSE * M2
          M3(I,J) = M3(I,J) + M1(K,I)*M2(K,J)
          GO TO 11
   3       CONTINUE
C   M3 = M1 * M2 TRANSPOSE
          M3(I,J) = M3(I,J) + M1(I,K)*M2(J,K)
           GO TO 11
   4        CONTINUE
C   M3 = M1 TRANSPOSE * M2 TRANSPOSE
             M3(I,J) = M3(I,J) + M1(K,I)*M2(J,K)
   11 CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C************************************************************** MOONXYZ
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE MOONXYZ(DMJ, SIDT, XMOON, YMOON, ZMOON)
C  based on program developed by J. Vondrak of Astronomical Inst. Prague cca 1970
C  elliptical lat & long are accurate within 20 sec of arc
C
C PROGRAM FOR COMPUTATION OF MOON COORDINATES WHERE TERMS LESS
C THAN 5 SEC IN ANGULAR POSITION AND 0.1 SEC IN SIN PARALLAX ARE NEGLECTED
C Input: Modified Julian Day (DMJ), output: ecliptic longitude DL, latitude DB (both
C in radians) and sin of equatorial parallax DSP  in mean elliptical coordinates of the
C input date
C
C
      IMPLICIT NONE
C
      REAL*8 DMJ, SIDT, XMOON, YMOON, ZMOON
C
      INTEGER*4 IAR(49),I,IARG,I1,I2,I3,I4
      REAL*8    DT,T,T2,DL,A1,ALM,AL1,AF,AD,DB,DSP,SF,CF,ARG
      REAL*8    SAR,CAR,B1,C1,C3,C4,A2,A3,A4,C90,C91,C9,RM,E0
      REAL*8    XMOONO,YMOONE,ZMOONE,YMOONO
      REAL*8    AL(49),ASP(49),AB(49),ROD,DROS
C
      DATA IAR/5553,5554,5555,5556,5557,5559,5573,5575,5577,5633,
     &    5635,5637,5653,5655,5656,5657,5753,5755,6435,6453,
     &    6455,6457,6533,6535,6537,6551,6553,6554,6555,6556,
     &    6557,6573,6575,6633,6635,6651,6653,6655,6753,7455,
     &    7535,7551,7553,7555,7557,7653,7655,8553,8555/
      DATA AL/3*0.D0,-125.D0,2370.D0,14.D0,-55.D0,-412.D0,-6.D0,2*0.D0,
     &    -1.D0,-165.D0,-668.D0,18.D0,-24.D0,-8.D0,-7.D0,0.D0,28.D0,
     &    148.D0,15.D0,9.D0,40.D0,-6.D0,-38.D0,-4586.D0,19.D0,
     &    22640.D0,-8.D0,192.D0,0.D0,-45.D0,0.D0,0.D0,-4.D0,-206.D0,
     &    -110.D0,7.D0,10.D0,-1.D0,-31.D0,-212.D0,769.D0,14.D0,-9.D0,
     &    -8.D0,-13.D0,36.D0/
      DATA ASP/2*0.D0,3422.5D0,-1.0D0,28.2D0,0.3D0,-0.1D0,5*0.D0,1.9D0,
     &    -0.4D0,0.1D0,-0.3D0,0.1D0,2*0.D0,-0.2D0,1.2D0,0.2D0,0.D0,
     &    -0.7D0,0.D0,0.6D0,34.3D0,0.D0,186.5D0,-0.1D0,3.1D0,-0.1D0,
     &    3*0.D0,0.1D0,1.4D0,-0.9D0,0.D0,0.1D0,0.D0,0.4D0,-0.3D0,
     &    10.2D0,0.3D0,0.D0,2*-0.1D0,0.6D0/
      DATA AB/-624.D0,5.D0,18461.D0,-5.D0,117.D0,1.D0,-2.D0,-6.D0,0.D0,
     &    -8.D0,-5.D0,-12.D0,-30.D0,-6.D0,1.D0,-1.D0,-1.D0,0.D0,6.D0,
     &    1.D0,7.D0,1.D0,-199.D0,1000.D0,33.D0,-7.D0,-167.D0,0.D0,
     &    1010.D0,-1.D0,15.D0,0.D0,-1.D0,-9.D0,-5.D0,-1.D0,-7.D0,-5.D0,
     &    0.D0,1.D0,32.D0,-1.D0,-16.D0,62.D0,2.D0,2*-1.D0,-2.D0,4.D0/
      DATA ROD,DROS/57.2958D0,206264.8062470963D0/
C
      DT=(DMJ-15019.5D0)/36525.D0
      T=DT
      T2=T*T
      DL=973563.D0+1732564379D0*DT-4.D0*T2+14.D0*SIN(3.376D0-2.319D0*T)
      A1=DMOD(DL,1296D3)/DROS
      ALM=DMOD(296.1047D0+477198.8492D0*DT+92D-4*T2,36D1)/ROD
      AL1=DMOD(358.4758D0+ 35999.0497D0*DT- 1D-4*T2,36D1)/ROD
      AF =DMOD( 11.2508D0+483202.0253D0*DT-32D-4*T2,36D1)/ROD
      AD =DMOD(350.7375D0+445267.1142D0*DT-14D-4*T2,36D1)/ROD
      DL=DL+7.D0*SIN(A1-AF)
      DB=(-8.D0)*SIN(A1)
      DSP=0D0
      SF=SIN(AF)
      CF=COS(AF)
      DO 1 I=1,49
      IARG=IAR(I)
      I1=IARG/1000-5
      I2=MOD(IARG/100,10)-5
      I3=MOD(IARG/10,10)-5
      I4=MOD(IARG,10)-5
      ARG=I1*ALM+I2*AL1+I3*AF+I4*AD
      SAR=SIN(ARG)
      CAR=COS(ARG)
      DL=DL+AL(I)*SAR
      DB=DB+AB(I)*(SAR*CF+CAR*SF)
    1 DSP=DSP+ASP(I)*CAR
      DL=DMOD(DL,1296D3)/DROS
      DB=DB/DROS
      DSP=DSP/DROS
C  TEMP. MODIFICATION ADDED TO VONDRAK'S ORIGINAL SUBROUTINE
C      COMPUTE RMOON
      B1= DMJ-15019.5D0
      C1=(279.6966788D0+0.9856473354D0*B1 +0.000303D0*T2)/ROD
      C3=(270.434358D0+13.1763965268D0*B1  -0.001133D0*T2 +
     *   0.0000019D0*DT*T2)/ROD
      C4=(334.329653D0+0.1114040803D0*B1 -0.010325D0*T2-
     *   0.000012D0*DT*T2)/ROD
C
      A2=  (C3-C4)
      A3=  (C3-2*C1+C4)
      A4=  (C3-C1)
      C90=1+0.0545D0*COS(A2)+0.01002D0*COS(A3)
      C91=0.00825D0*COS(2D0*A4)+0.00297D0*COS(2D0*A2)
      C9=C90+C91
      RM=     384401.D03/C9
C 
      E0=(23.452294D0-0.0130125D0*DT-0.00000164D0*T2+
     *   0.000000503D0*DT*T2)/ROD
C COMPUTE GEOCENTRIC MOON COORDINATES FROM ECL. LAT & LONG (DB, DL)
      XMOONO= RM*COS(DB)*COS(DL)
      YMOONE= RM*COS(DB)*SIN(DL)
      ZMOONE= RM*SIN(DB)
      YMOONO= YMOONE*COS(E0)-ZMOONE*SIN(E0)
      ZMOON= ZMOONE*COS(E0)+YMOONE*SIN(E0)
      XMOON= XMOONO*COS(SIDT)+YMOONO*SIN(SIDT)
      YMOON= YMOONO*COS(SIDT)-XMOONO*SIN(SIDT)

      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** OPCREJ
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE OPCREJ ( LPR, IRJCT, NSV, ISV, TTAG, 
     &                    PR1, PR2, P1, P2, FPR, PRDC, DORBC, IODC,
     &                    FCP, ICSLIP,
     &                    ISPR1, ISPR2,
     &                    MSOFF, MSJMP,
     &                    NRJCT, IARC, IPRINT, IREASON )
C
C     NAME              OPCREJ
C
C     PURPOSE   REJECT OBSERVATION, COMPRESS ARRAYS
C               DECREMENT COUNTER
C
C     PARAMETERS        DESCRIPTION
C
C          IRJCT        OBSERVATION NUMBER TO REJECT
C        NSV            NUMBER OF SATELLITES IN RECORD
C        ISV            LIST OF SATELLITE I.D.'S
C        TTAG   OBSERVATION TIME TAG
C        PR1            PSEUDO-RANGE ON L1
C        PR2            PSEUDO-RANGE ON L2
C        P1             CARRIER PHASE ON L1
C        P2             CARRIER PHASE ON L2
C          FPR          FILTERED PSEUDO-RANGE
C          PRDC         PSEUDO-RANGE DIFFERENTIAL CORRECTION
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      LOGICAL*4    ISPR1(*), ISPR2(*)
      INTEGER*4    LPR,         IRJCT
      INTEGER*4    ICSLIP(*),   MSOFF(*),    MSJMP(*)
      INTEGER*4    NSV,         ISV(*)
      INTEGER*4    NRJCT(MAXSAT,MAXARC,*)
      INTEGER*4    IARC
      INTEGER*4    IPRINT,        IREASON
      REAL*8       TTAG(*)
      REAL*8       PR1(*),      PR2(*)
      REAL*8       P1(*),       P2(*)
      REAL*8       FPR(*),     PRDC(10,*)
      REAL*8       FCP(*)
      INTEGER*4    IODC(*)
      REAL*8       DORBC(12,*)
C
      INTEGER*4    J, IR
      CHARACTER*10  REASON(MAXREJ)
      CHARACTER*10  ACTION(2)
      DATA (ACTION(IR),IR=1,2) /'REJECTED  ','DEWEIGHTED'/
      INTEGER*4 IACTION, JREASON
C     REASONS: TRK  SLP  CLK  EPH  IGP  RES  ELV
      DATA (REASON(IR),IR=1,7) /'TRACKING  ','CYCLE SLIP',' CLOCK',
     &                       'EPHEMERIS' ,'IONO GRID ',' OUTLIER  ',
     &                       'ELEVATION'/       
C
      JREASON=IREASON
      IF( IREASON/10 .EQ. 0 ) THEN
        IACTION=1
      ELSE
        IACTION=2
      ENDIF
      IREASON=MOD(JREASON,10)
       IF (IARC.GT.0) NRJCT(ISV(IRJCT),IARC,IREASON) =
     &         NRJCT(ISV(IRJCT),IARC,IREASON) + 1
c!    write(*,*) 'OPCREJ ',ISV(IRJCT),TTAG(IRJCT),REASON(IREASON),
c!   &         IRJCT,IARC,NRJCT(ISV(IRJCT),IARC,IREASON)
       IF ( IPRINT .GE. 2 ) 
     &     WRITE(LPR,*) ACTION(IACTION),' PRN ',ISV(IRJCT),' ON ',
     &               REASON(IREASON), ' CHECK'
       IF ( IPRINT .GE. 1 ) 
     &     WRITE(*,*) ACTION(IACTION),' PRN ',ISV(IRJCT),' ON ',
     &               REASON(IREASON), ' CHECK',
     &               NRJCT(ISV(IRJCT),IARC,IREASON),
     &               'SATELLITES LEFT', NSV -1
C
      IF ( IACTION .EQ. 1 ) THEN
       NSV = NSV - 1
       DO J=IRJCT,NSV
         ISV(J)  = ISV(J+1)
         ICSLIP(J) = ICSLIP(J+1)
         MSOFF(J) = MSOFF(J+1)
         MSJMP(J) = MSJMP(J+1)
         TTAG(J) = TTAG(J+1)
         ISPR1(J) = ISPR1(J+1)
         ISPR2(J) = ISPR2(J+1)
         PR1(J)  = PR1(J+1)
         PR2(J)  = PR2(J+1)
         P1(J)   = P1(J+1)
         P2(J)   = P2(J+1)
         FPR(J)  = FPR(J+1)
         PRDC(1,J) = PRDC(1,J+1)
         PRDC(2,J) = PRDC(2,J+1)
         PRDC(3,J) = PRDC(3,J+1)
         PRDC(4,J) = PRDC(4,J+1)
         PRDC(6,J) = PRDC(6,J+1)
         PRDC(5,J) = PRDC(5,J+1)
         PRDC(7,J) = PRDC(7,J+1)
         IODC(J) = IODC(J+1)
         DORBC(1,J) = DORBC(1,J+1)
         DORBC(2,J) = DORBC(2,J+1)
         DORBC(3,J) = DORBC(3,J+1)
         DORBC(4,J) = DORBC(4,J+1)
         DORBC(5,J) = DORBC(5,J+1)
         DORBC(6,J) = DORBC(6,J+1)
         DORBC(7,J) = DORBC(7,J+1)
         DORBC(8,J) = DORBC(8,J+1)
         DORBC(9,J) = DORBC(9,J+1)
         DORBC(10,J) = DORBC(10,J+1)
         DORBC(11,J) = DORBC(11,J+1)
         DORBC(12,J) = DORBC(12,J+1)
         FCP(J)  = FCP(J+1)
       END DO
      END IF
C
      IREASON=JREASON
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** PEPXYZ
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE PEPXYZ ( LPR, LUPEP, NAMEP, NDAY, NPEPSV, IPEPSV, 
     &                    IPEPACC, IPEPINT, IARC, NEPREAD, IARCTE, 
     &         NEPARC, T, X, Y, Z, DT, ENDTTAG, BAS1, BAS2, SSVX, ISSVX)
C
C     PURPOSE:   READ SATELLITE COORDINATES AND CLOCKS 
C                FOR ARC BETWEEN EPOCHS TB AND TE
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     LPR               LOGICAL UNIT OF PRINTER
C     LUPEP             LOGICAL UNIT OF PRECISE EPHEMERIS FILE
C     NPEPSV            NUMBER OF SATELLITES WITH PRECISE EPHEMERIS
C     IPEPSV            ARRAY OF PRN'S WITH PRECISE EPHEMERIS
C       IPEPINT         PRECISE EPHEMERIS INTERVAL (SECONDS)
C       IARC            SATELLITE ARC NUMBER
C     IARCTB            ARC START TIME
C     IARCTE            ARC END TIME
C     NEPARC            NUMBER OF EPOCHS IN ARC
C     T         ARRAY OF SATELLITE TIMES
C     X         ARRAY OF SATELLITE X COORDINATES
C     Y         ARRAY OF SATELLITE Y COORDINATES
C     Z         ARRAY OF SATELLITE Z COORDINATES
C     DT                ARRAY OF SATELLITE CLOCKS
C     C         SPEED OF LIGHT
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE  'MAXDIM'
C
      INTEGER*4 LPR, LUPEP, NDAY, NPEPSV,IPEPINT
      INTEGER*4 IARC, NEPREAD, IARCTE,NEPARC
      INTEGER*4 IPEPSV(*),IPEPACC(*)
      REAL*8    T(*),X(MAXPFIT,*),Y(MAXPFIT,*),Z(MAXPFIT,*)
      REAL*8    DT(MAXPFIT,*)
      REAL*8    ENDTTAG          
      REAL*8 BAS1, BAS2, SSVX(1440,4,MAXSAT)
      INTEGER*4 ISSVX
      CHARACTER*80   NAMEP(*)
C
      INTEGER*4 IE,IEND,IS,IPRN,IOS,IGPSWK,NPEPEPO,ITT
     &         ,IMINACC
      REAL*8    SECOW,SVXYZ(MAXSAT,3),SVCLK(MAXSAT)
      LOGICAL NEWPEP, NEWTT
C
C     READ SATELLITE COORDINATES AND CLOCKS AT SELECTED
C     EPOCHS WITHIN ARC TIME LIMITS
C
      DO IE=1,NEPREAD
        CALL RDSP3E ( LPR, LUPEP, NPEPSV, IPEPSV, ITT, 
     &                SVXYZ, SVCLK, SSVX, BAS1, BAS2, ISSVX, IEND)
C 
C
C       STORE IN SATELLITE ARC ARRAYS FOR FIT
C
        IF ( IEND .NE. 1 ) THEN
          NEPARC        = NEPARC + 1
        T(NEPARC)     = ITT
          ENDTTAG= ITT
          DO IS=1,NPEPSV
          IPRN=IPEPSV(IS)
          IF( IPRN.GT.0 .AND. IPRN.LE.MAXSAT ) THEN
          X(NEPARC,IPRN)  = SVXYZ(IS,1)*1.D3
          Y(NEPARC,IPRN)  = SVXYZ(IS,2)*1.D3
          Z(NEPARC,IPRN)  = SVXYZ(IS,3)*1.D3
          DT(NEPARC,IPRN) = SVCLK(IS)/1.D6
c!        WRITE(*,'(2I4,F10.1,3F12.1,F20.9)') NEPARC, IPRN,
c!   &             DMOD(T(NEPARC),604800.D0), 
c!   &             SVXYZ(IS,1), SVXYZ(IS,2), SVXYZ(IS,3), SVCLK(IS)
          END IF
          END DO
        ELSE
        IEND=0
        CLOSE(LUPEP)
          OPEN  ( LUPEP, FILE=NAMEP(NDAY+1), STATUS='OLD',IOSTAT=IOS, 
     &            ERR=600 )
        CALL HDSP3 ( LUPEP, NEWPEP, NEWTT, NPEPSV, IPEPSV,
     &                 IGPSWK, SECOW, IEND, IPEPACC, NPEPEPO,
     &                 IMINACC,
     &                 IPEPINT, BAS1, BAS2)
          CALL RDSP3E ( LPR, LUPEP, NPEPSV, IPEPSV, ITT, 
     &                  SVXYZ, SVCLK, SSVX, BAS1, BAS2, ISSVX, IEND )
          IF ( IEND .NE. 1 ) THEN
            NEPARC        = NEPARC + 1
          T(NEPARC)     = ITT
            DO IS=1,NPEPSV
             IF(IPEPSV(IS).GT.0.AND.IPEPSV(IS).LE.MAXSAT) THEN
            IPRN=IPEPSV(IS)
            X(NEPARC,IPRN)  = SVXYZ(IS,1)*1.D3
            Y(NEPARC,IPRN)  = SVXYZ(IS,2)*1.D3
            Z(NEPARC,IPRN)  = SVXYZ(IS,3)*1.D3
            DT(NEPARC,IPRN) = SVCLK(IS)/1.D6
             END IF
c!        WRITE(*,'(I4,F10.1,3F12.1,F20.9)') NEPARC,DMOD(TT,604800.D0) 
c!    &            SVXYZ(IS,1),SVXYZ(IS,2), SVXYZ(IS,3), SVCLK(IS)
            END DO
          END IF
      END IF
      END DO
C
C
C
  600 CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** PGMLBL
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE PGMLBL( LUO, IVERSION, IRLEASE, NAMORG, NLNORG, LNG )
C
C     NAME:      PGMLBL
C
C     PURPOSE:   WRITE PROGRAM LABEL TO OUTPUT FILE
C
C     PARAMETERS        DESCRIPTION
C
C        LUO            LOGICAL UNIT OF OUTPUT
C          IVERSION     VERSION NUMBER
C          IRLEASE      COMPILATION NUMBER
C          NAMORG       NAME OF ORGANIZATION
C          NLNORG       LINES IN ORGANIZATION NAME
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4 LUO, IVERSION, IRLEASE, NLNORG, LNG
      CHARACTER*80 NAMORG(*)
      CHARACTER*80 NAMVER
C
      INTEGER*4 I, IDOY, IYEAR, IMTH, IDAY
      CHARACTER*50 PGMNAM(2)
      CHARACTER*10 DATE
C
      IDOY=IRLEASE/100
      IYEAR=MOD(IRLEASE,100)+2000
      CALL JULDM ( IDOY, IYEAR, IMTH, IDAY, 0 )
      WRITE(DATE,'(I4,A1,I2.2,A1,I2.2)') IYEAR,'-',IMTH,'-',IDAY
C
      DATA (PGMNAM(I),I=1,2) 
     &  /"GPSPACE   Precise Point Positioning      (Version ",
     &   "GPSPACE   Positionnement Ponctuel Precis (version "/
      WRITE(NAMVER,700) PGMNAM(LNG),IVERSION/100.D0,IRLEASE,DATE
      WRITE(LUO,1000)
      WRITE(LUO,'(A80)')  NAMVER, (NAMORG(I),I=1,NLNORG)
      WRITE(LUO,1000)
C
C-----------------------------------------------------------------------
C               FORMAT STATEMENTS
C-----------------------------------------------------------------------
C
  700 FORMAT(A50,F6.2,'/',I5.5,'/',A10,')' )
 1000 FORMAT( '------------------------------------------------',
     &        '-------------------------------')
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** PLXYZ1
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE PLXYZ1(XO,YO,ZO,A,E,X)
C
C       PURPOSE         COMPUTE CARTESIAN COORDINATES X , Y , Z
C                     GIVEN ELLIPSOIDAL COORDINATES PHI , RLAM , H.
C
C       PARAMETERS
C
C             I  X        LATITUDE (RAD),EAST LONGITUDE (RAD),HEIGHT (M)
C           I  XO,YO,ZO DATUM TRANSLATION COMPONENTS (M)
C           I  A,E        ELLIPSOID SEMIMAJOR AXIS AND ECCENTRICITY (M)
C           O  X          CARTESIAN COORDINATES (M)
C
      IMPLICIT NONE
C
      REAL*8    XO,YO,ZO,A,E,X(3)
C
      REAL*8    E2,PHI,RLAM,H,SP,CP,XN
C
      E2   = E*E
      PHI  = X(1)
      RLAM = X(2)
      H    = X(3)
      SP   = DSIN(PHI)
      CP   = DCOS(PHI)
      XN   = A / DSQRT(1.D0 - E2 * SP*SP)
C
      X(1) = XO + ( XN + H ) * CP * DCOS(RLAM)
      X(2) = YO + ( XN + H ) * CP * DSIN(RLAM)
      X(3) = ZO + ( XN * (1.D0 - E2) + H ) * SP
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** POSSIG
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE POSSIG ( XCOR, XMEAN, SXRMS, XRMS, NFIX )
C
C     PURPOSE:   TO COMPUTE MEAN POSITION CORRECTIONS IN X, Y, Z
C            AND THEIR RESPECTIVE RMS USING A SEQUENTIAL
C            FORMULATION
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C       XCOR            X,Y,Z CORRECTIONS TO INITIAL POSITION
C       XMEAN   MEAN CORRECTIONS TO X,Y,Z
C       SXRMS   SUM OF RMS CORRECTIONS TO INITIAL X,Y,Z
C       XRMS            RMS OF CORRECTIONS TO INITIAL X,Y,Z
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4 NFIX
      REAL*8         XCOR(3),   XMEAN(3)
      REAL*8         XRMS(3),   SXRMS(3)
C
      INTEGER*4 I
C
      DO 100 I=1,3
      XMEAN(I) = XMEAN(I) + ( XCOR(I) - XMEAN(I) ) / NFIX
      SXRMS(I) = SXRMS(I) + ( XCOR(I) - XMEAN(I) )**2 
      XRMS(I)  = DSQRT(SXRMS(I) / NFIX)
  100 CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** POWER2
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      REAL*8 FUNCTION POWER2( IEXP )
      IMPLICIT NONE
      INTEGER*4 IEXP
      REAL*8    POW2(46)
      DATA POW2/1.D0,2.D0,4.D0,8.D0,16.D0,32.D0,64.D0,128.D0,
     +  256.D0,512.D0,1024.D0,2048.D0,4096.D0,8192.D0,16384.D0,
     +  32768.D0,65536.D0,131072.D0,262144.D0,524288.D0,1048576.D0,
     +  2097152.D0,4194304.D0,8388608.D0,16777216.D0,33554432.D0,
     +  67108864.D0,134217728.D0,268435456.D0,536870912.D0,
     +  1073741824.D0,2147483648.D0,4294967296.D0,8589934592.D0,
     +  17179869184.D0,34359738368.D0,68719476736.D0,137438953472.D0,
     +  274877906944.D0,549755813888.D0,1099511627776.D0,
     +  2199023255552.D0,4398046511104.D0,8796093022208.D0,
     +  17592186044416.D0,35184372088832.D0/
      IF( IEXP .GE. 0 .AND. IEXP .LE. 45 ) THEN
       POWER2=POW2(IEXP+1)
      ELSE
       POWER2=2.D0**IEXP
      END IF
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RADMS
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RADMS (RAD,ID,IM,S)
C
C       PURPOSE         CONVERTS RADIANS TO DEG, MIN, SEC
C
      IMPLICIT NONE
C
      INTEGER*4 ID,IM
      REAL*8    RAD,S
C
      REAL*8    RHO,RA
C
      RHO  = 45.D0/DATAN(1.D0)
      RA   = RAD*RHO
      ID   = INT(RA)
      RA   = ABS(RA-DBLE(ID))*60.D0
      IM   = INT(RA)
      S    = (RA - DBLE(IM))*60.D0
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RCVUV
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
      SUBROUTINE RCVUV( XRV, DTM, URVX, URVY, URVZ )
C
C FUNCTION: RCVUV: COMPUTE UNIT VECTORS IN RECEIVER LOCAL SYSTEM
C
C INPUT:    XRV   = RECEIVER COORDINATES
C
C OUTPUT:   URVX   = UNIT VECTOR IN RECEIVER NORTH DIRECTION
C           URVY   = UNIT VECTOR IN RECEIVER EAST DIRECTION 
C           URVZ   = UNIT VECTOR IN RECEIVER UP DIRECTION
C
      IMPLICIT NONE
C
      REAL*8    XRV(*), DTM(*)
      REAL*8    URVX(*),        URVY(*),        URVZ(*)
C
      INTEGER*4 I
      REAL*8    F,R,RXY,GEOLAT,SINLAT,COSLAT,SINLON,COSLON
C
C     COMPUTE UNIT VECTORS ALONG NORTH, EAST AND UP DIRECTIONS
C
C      F = = 1/1-e**2
C 
      F = 1.D0/(1.D0-DTM(2)*DTM(2))
      R = 0.D0
      DO I=1,3
        R = R + XRV(I)*XRV(I)
      END DO
      RXY = R - XRV(3)*XRV(3)
      R   = DSQRT(R)
      RXY = DSQRT(RXY)
      GEOLAT = DATAN(F*XRV(3)/RXY)
      SINLAT = DSIN(GEOLAT)
      COSLAT = DSQRT(1.D0-SINLAT*SINLAT)
      SINLON = XRV(2)/RXY
      COSLON = XRV(1)/RXY
C      
      URVX(1) =  -(SINLAT*COSLON)
      URVX(2) =  -(SINLAT*SINLON)
      URVX(3) =   COSLAT
C
      URVY(1) =   SINLON
      URVY(2) = - COSLON
      URVY(3) =   0.0D0
C
      URVZ(1) =   COSLON*COSLAT
      URVZ(2) =   SINLON*COSLAT
      URVZ(3) =   SINLAT
C
       RETURN
       END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDBLQ
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDBLQ(LUPR, LUOLD, UG, DTM, DMJDOL, TW,
     &                 NOCOF, AMPL, PHAS, IOLD)
C
C     NAME:      RDBLQ
C
C     PURPOSE:   READS OCEAN LOADING  COEFFICIENTS FROM BLQ FORMAT
C                FILE (IF EXISTS) 
C                AND USES THE STATION WITHIN 10KM RADIUS (IF FOUND), 
C                OTHERWISE USES 0 AMPLITUDES (I.E. NO O LOADING)
C
C     PARAMETERS        DESCRIPTION
C
C       LUPR          PRINTOUT (SUM) FILE LU
C         LUOLD         HARPOS FORMAT OCEAN LOADING FILE
C         UG(3)         STATION XYZ GEOCENTRIC POSITION (M)    
C         DTM(7)        DATUM PARAMETERS (A, F, XYZ DATM SHIFT/OFFSET)
C         DMJDOL        REFERENCE TIME
C         TW            HARMONIC COMPONENTS READ
C         NOCOF         NO. OF OLOAD COEFFICIENTS
C         AMPL          INPUT AMPLITUDES + UP,  N , E (MM)
C         PHAS          INPUT PHASES (DEG) 
C         IOLD          OLOAD FLAG (=0 NO OLOAD COEF FOUND, 
C                                   =1 OLOAD COEF FOUND!
C                                   =-1 NOT BLQ format try another)
C
      IMPLICIT NONE
      INCLUDE 'MAXDIM'
C
      INTEGER*4 LUPR, LUOLD, NOCOF, IOLD
      REAL*8    AMPL(4,*), PHAS(4,*), UG(*), DTM(*), DMJDOL
      CHARACTER*3 TW(*)
C
      INTEGER*4 I,J
      REAL*8    DRAD,TSTDIS,XT(3)
      REAL*8    V(11),OMEGA(11)
      CHARACTER*3  IW(11)
      CHARACTER*80 STR
      DATA IW/'M2 ','S2 ','N2 ','K2 ','K1 ','O1 ','P1 ',
     &        'Q1 ','MF ','MM ','SSA'/
      DATA OMEGA/0.505868049736D0,
     &           0.523598775598D0,
     &           0.496366918746D0,
     &           0.525032341570D0,
     &           0.262516170785D0,
     &           0.243351878951D0,
     &           0.261082604813D0,
     &           0.233850747961D0,
     &           0.019164291834D0,
     &           0.009501130990D0,
     &           0.001433565972D0/
      DATA V/ 124.299584D0,
     &        359.999982D0,
     &        349.336207D0,
     &        200.932918D0,
     &        190.466469D0,
     &        293.833155D0,
     &        169.533571D0,
     &        158.869737D0,
     &        256.633297D0,
     &        314.963380D0,
     &         20.932898D0/
C
C Test BLQ format
C
      READ(LUOLD,'(A80)',END=3000,ERR=3000) STR
      IF( STR(1:29) .NE. '$$ Ocean loading displacement' ) GOTO 4000
C
C Zero amplitudes and phases arrays
C
      DRAD = 0.0174532925D0 
      IOLD=0
      NOCOF=11
      IF ( NOCOF .GT. MAXOTLC )  NOCOF=MAXOTLC
      DO I=1,4
      DO J=1,MAXOTLC
         AMPL(I,J)=0.D0
       PHAS(I,J)=0.D0
      END DO
      END DO
C
C Look for Site definition records (S) until within 10Km of station
C
1600  CONTINUE
      READ(LUOLD,'(A80)',END=3000,ERR=3000) STR


       IF (index(STR,'lon/lat:') .ne. 0 ) THEN
         READ(STR(index(STR,'lon/lat:')+8:),*,ERR=3000) 
     +                                               XT(2),XT(1)
      ELSE
         GOTO 1600
        ENDIF

      XT(1)=XT(1)*DRAD
      XT(2)=XT(2)*DRAD
      XT(3)=0.D0
      CALL PLXYZ1(DTM(3), DTM(4), DTM(5), DTM(1), DTM(2), XT)
      TSTDIS=SQRT((UG(1)-XT(1))**2+(UG(2)-XT(2))**2+(UG(3)-XT(3))**2)
      IF(TSTDIS.GT.1.D4) GOTO 1600
C
C Read amplitude terms
C
      READ(LUOLD,'(1X,11F7.5)',END=3000,ERR=3000) (AMPL(1,J),J=1,NOCOF)
      READ(LUOLD,'(1X,11F7.5)',END=3000,ERR=3000) (AMPL(2,J),J=1,NOCOF)
      READ(LUOLD,'(1X,11F7.5)',END=3000,ERR=3000) (AMPL(3,J),J=1,NOCOF)
      DO J=1,NOCOF
        DO I=1,3
        AMPL(I,J)=AMPL(I,J)*1000.D0
        END DO
      END DO
C
C Read phase terms
C
      READ(LUOLD,'(1X,11F7.1)',END=3000,ERR=3000) (PHAS(1,J),J=1,NOCOF)
      READ(LUOLD,'(1X,11F7.1)',END=3000,ERR=3000) (PHAS(2,J),J=1,NOCOF)
      READ(LUOLD,'(1X,11F7.1)',END=3000,ERR=3000) (PHAS(3,J),J=1,NOCOF)
      DO J=1,NOCOF
        DO I=1,3
        IF ( I .GT. 1 ) PHAS(I,J)=PHAS(I,J)+180.D0
        IF ( PHAS(I,J) .LT. 0 ) PHAS(I,J)=PHAS(I,J)+360.D0
        END DO
      END DO
C
C Found Model. Clear remaining array
C
      IOLD=1
      DMJDOL=51544.5D0
      DO J=1,NOCOF
      TW(J)=IW(J)
      AMPL(4,J)=OMEGA(J)
      PHAS(4,J)=V(J)
      END DO
      DO J=NOCOF+1,MAXOTLC
      TW(J)='   '
      DO I=1,4
         AMPL(I,J)=0.D0
       PHAS(I,J)=0.D0
      END DO
      END DO
      RETURN
C
C Format problems or premature end of file
C
3000  CONTINUE
      REWIND(LUOLD)
      IOLD=0
      RETURN
C
C Not BLQ format
C
4000  CONTINUE
      REWIND(LUOLD)
      IOLD=-1
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDCMD
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
      SUBROUTINE RDCMD( LU, LUO, LUCMD, FNAM, NFREQ, IFMTM, IFMTE, 
     &                  MISCFACTR, MISCFACTP,
     &                  SDP, XRVMRK,XRVVEL,IXRVRNX,ANTH, ICLKSOL,CUTOFF, 
     &                  IDC, IERR, NUCMD, IUCMD, DOPMAX, HDXYZH, DTM, 
     &                  PI, SDCP, SDTROP, CMDLST, ICMD, SMTHCLK, LNG )
C
C     NAME              RDCMD
C
C     PURPOSE   READ COMMAND FILE
C
C     PARAMETERS        DESCRIPTION
C
C        LU             LOGICAL UNIT OF INPUT
C        LUO            LOGICAL UNIT OF OUTPUT
C        LUCMD  LOGICAL UNIT OF COMMAND FILE
C        INAM   NAME OF MEASUREMENT FILE
C        FNAM   NAME OF COMMAND FILE
C          IFREQ        FREQUENCY TO PROCESS FLAG (1=L1,2=L3)
C        IFMTM  FORMAT OF MEASUREMENT FILE
C        IFMTE  FORMAT OF EPHEMERIS FILE
C          ISVEPH       SATELLITE EPHEMERIS (1=BRD, 2=SP3)
C          ISVCLK       SATELLITE CLOCK (1=BRD, 2=CLX, 3=SP3)
C          IPOSSOL      POSITION SOLUTION (1=YES  , 2=FIXED)
C        SDP            STANDARD DEVIATION OF OBSERVATIONS
C        XRVMRK         MARKER COORDINATES
C          ANTH         ANTENNA HEIGHT
C        ICLKSOL        RECEIVER CLOCK SOLUTION (1=YES  , 2=FIXED)
C        IDC            APPLY DIFFERENTIAL CORRECTIONS (1=NO, 2=YES)
C        IERR   FILE OPEN ERROR FLAG
C          IFLTR        RANGE FILTERING FLAG
C          ISLM         SINGLE LAYER IONOSPHERIC MODEL FLAG
C          IREFOUT      OUTPUT REFERENCE SYSTEM 
C          ICOROUT      OUTPUT COORDINATE SYSTEM (1=ELLIPSOIDAL, 2=CAARTESIAN)
C          DOPMAX       MAXIMUM DOPPLER ACCEPTED
C          ITRPSOL      RECEIVER TROPO ZPD SOLUTION (1=FIXED, 1=YES  )
C          CMDLST       LIST OF SELECTED OPTIONS
C
C *********************************************************************
C
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      CHARACTER*80  FNAM,  CMDLST(*)
      LOGICAL*4 SMTHCLK
      INTEGER*4 ICMD(*)
      INTEGER*4 LU, LUO,LUCMD,NFREQ,IFMTM,IFMTE
      INTEGER*4 ICLKSOL,IDC,NUCMD,IUCMD(*)
      INTEGER*4 LNG,IERR
      REAL*8    SDP,ANTH,CUTOFF,DOPMAX,PI,SDCP,SDTROP
      REAL*8    HDXYZH(*),XRVMRK(*),DTM(*)
      REAL*8    XRVVEL(*),XRNV, XREV, XRHV
      REAL*8    MISCFACTR, MISCFACTP
C
      INTEGER*4     IOPTER(MAXCMD),I,IOP,IOPT,NMOD,NOPTERR,IL,IXRV
     &             ,IR
      INTEGER*4     IOPTCF,IOS
      INTEGER*4             ICART, IXRVRNX
      REAL*8        OPT(MAXCMD),XRVVEC,XRVELV,UPOPT
      REAL*8        OPTMIN(MAXCMD)
      REAL*8        OPTMAX(MAXCMD)
      REAL*8    MISCR_FACT, MISCP_FACT
C
      CHARACTER*80      COMMENT
      CHARACTER*6       CMDI(13,5)
      CHARACTER*6       CMDIEN(13,5)
      CHARACTER*6       CMDIFR(13,5)
      CHARACTER*45      CMDP(MAXCMD)
      CHARACTER*45      CMDPFR(MAXCMD)
      CHARACTER*45      CMDPEN(MAXCMD)
      CHARACTER*1       ANSWR
C
      DATA (CMDIEN(1,IOP),IOP=1,5)
     &                    /' 1    ',' 2    ',' 3    ',' 4    ',' 5    '/
      DATA (CMDIEN(2,IOP),IOP=1,5)
     &                    /'STA   ','KIN   ','SKI   ','      ','      '/
      DATA (CMDIEN(3,IOP),IOP=1,5)
     &                    /'COD   ','C&P   ','      ','      ','      '/
      DATA (CMDIEN(4,IOP),IOP=1,5)
     &                    /'L1    ','L2    ','L3    ','      ','      '/
      DATA (CMDIEN(5,IOP),IOP=1,5)
     &                    /'BRD   ','SP3   ','      ','      ','      '/
      DATA (CMDIEN(6,IOP),IOP=1,5)
     &                    /'NO    ','CLKRNX','MRTCA ','RTCM  ','NO    '/
      DATA (CMDIEN(7,IOP),IOP=1,5)
     &                    /'NO    ','YES   ','      ','      ','      '/
      DATA (CMDIEN(8,IOP),IOP=1,5)
     &                    /'NO    ','YES   ','INIT  ','      ','      '/
      DATA (CMDIEN(9,IOP),IOP=1,5)
     &                    /'NO    ','YES   ','      ','      ','      '/
      DATA (CMDIEN(10,IOP),IOP=1,5)
     &                    /'NO    ','2MM/HR','3MM/HR','4MM/HR','5MM/HR'/
      DATA (CMDIEN(11,IOP),IOP=1,5)
     &                    /'NO    ','YES   ','!CLK  ','      ','      '/
      DATA (CMDIEN(12,IOP),IOP=1,5)
     &                    /'NAD   ','TRF   ','      ','      ','      '/
      DATA (CMDIEN(13,IOP),IOP=1,5)
     &                    /'ELL   ','CAR   ','      ','      ','      '/
C
      DATA (CMDIFR(1,IOP),IOP=1,5)
     &                    /' 1    ',' 2    ',' 3    ',' 4    ',' 5    '/
      DATA (CMDIFR(2,IOP),IOP=1,5)
     &                    /'STA   ','KIN   ','SKI   ','      ','      '/
      DATA (CMDIFR(3,IOP),IOP=1,5)
     &                    /'COD   ','C&P   ','      ','      ','      '/
      DATA (CMDIFR(4,IOP),IOP=1,5)
     &                    /'L1    ','L2    ','L3    ','      ','      '/
      DATA (CMDIFR(5,IOP),IOP=1,5)
     &                    /'BRD   ','SP3   ','      ','      ','      '/
      DATA (CMDIFR(6,IOP),IOP=1,5)
     &                    /'NON   ','CLKRNX','MRTCA ','RTCM  ','NON   '/
      DATA (CMDIFR(7,IOP),IOP=1,5)
     &                    /'NON   ','OUI   ','      ','      ','      '/
      DATA (CMDIFR(8,IOP),IOP=1,5)
     &                    /'NON   ','OUI   ','INIT  ','      ','      '/
      DATA (CMDIFR(9,IOP),IOP=1,5)
     &                    /'NON   ','OUI   ','      ','      ','      '/
      DATA (CMDIFR(10,IOP),IOP=1,5)
     &                    /'NON   ','2MM/HR','3MM/HR','4MM/HR','5MM/HR'/
      DATA (CMDIFR(11,IOP),IOP=1,5)
     &                    /'NON   ','OUI   ','!HRLG ','      ','      '/
      DATA (CMDIFR(12,IOP),IOP=1,5)
     &                    /'NAD   ','TRF   ','      ','      ','      '/
      DATA (CMDIFR(13,IOP),IOP=1,5)
     &                    /'ELL   ','CAR   ','      ','      ','      '/
C
      DATA OPT     / 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 1, 2, 1, 
     &                1.D0, 1.D-2, 0.D0, 0.D0, 0.D0, 0.D0,10.D0, 20.D0 /
      DATA OPTMIN  / 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
     &    0.1D-1, 1.D-3, -6390000.D0, -6390000.D0, -6390000.D0,-10.D0, 
     &  -90.D0, 0.D0 /
      DATA OPTMAX  /MAXDAYS, 3, 2, 8, 2, 5, 2, 3, 2, 5, 3, 2, 3,
     &     1.D3, 3.D-1, 6390000.D0,  6390000.D0, 6390000.D0,50.D0, 
     &     90.D0, 1.D3 /
      DATA IOPTER  / 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 / 
      DATA IOPTCF /0/
C
      DATA CMDPEN     /'UT DAYS OBSERVED                       (1-7):',
     &                 'USER DYNAMICS         (1=STATIC,2=KINEMATIC):',
     &                 'OBSERVATION TO PROCESS         (1=COD,2=C&P):',
     &                 'FREQUENCY TO PROCESS        (1=L1,2=L2,3=L3):',
     &                 'SATELLITE EPHEMERIS INPUT     (1=BRD ,2=SP3):',
     &                 'SAT CLOCKS(1=NO,2=Prc,3=RTCA,4=RTCM,+10=!AR):',
     &                 'SATELLITE CLOCK INTERPOLATION   (1=NO,2=YES):',
     &                 'IONOSPHERIC GRID (1=NO,2=YES,3=INIT,+10*MFi):',
     &                 'SOLVE STATION COORDINATES       (1=NO,2=YES):',
     &                 'SOLVE TROP. (1=NO,2-5=RW MM/HR) (+100=grad) :',
     &                 'BACKWARD SUBSTITUTION    (1=NO,2=YES,3=!CLK):',
     &                 'REFERENCE SYSTEM            (1=NAD83,2=ITRF):',
     &                 'COORDINATE SYSTEM(1=ELLIPSOIDAL,2=CARTESIAN):',
     &                 'A-PRIORI PSEUDORANGE SIGMA(m)    [&MISC TOL]:',
     &                 'A-PRIORI CARRIER PHASE SIGMA(m)  [&MISC TOL]:',
     &                 'LAT(ddmmss.sss,+N) | ECEF X(m) [&VEL(mm/yr)]:',
     &                 'LON(ddmmss.sss,+E) | ECEF Y(m) [&VEL(mm/yr)]:',
     &                 'HGHT (m)           | ECEF Z(m) [&VEL(mm/yr)]:',
     &                 'ANTENNA HEIGHT                           (m):',
     &                 'CUTOFF ELEVATION                       (deg):',
     &                 'GDOP CUTOFF                                 :'/
C
      DATA CMDPFR     /'NOMBRE DE JOURS OBSERVES               (1-7):',
     &                 "DYNAMIQUE DE L'UTILISATEUR     (1=STA,2=KIN):",
     &                 'OBSERVATION A TRAITER          (1=COD,2=C&P):',
     &                 'FREQUENCE A TRAITER         (1=L1,2=L2,3=L3):',
     &                 'EPHEMERIDE DE SATELLITE       (1=BRD ,2=SP3):',
     &                 'HRLG SAT (1=NON,2=Prc,3=RTCA,4=RTCM,+10=!RA):',
     &                 'INTERPOLATION DES HORLOGES     (1=NON,2=OUI):',
     &                 'GRILLE IONOSPH. (1=NON,2=OUI,3=INIT,+10*FMi):',
     &                 'SOLUTION DES COORDONNEES       (1=NON,2=OUI):',
     &                 'SOLUTION TROPO(1=NO,2-5=RW MM/HR)(+100=grad):',
     &                 'LISSAGE DES PARAMETRES (1=NON,2=OUI,3=!HRLG):',
     &                 'SYSTEME DE REFERENCE        (1=NAD83,2=ITRF):',
     &                 'SYSTEME DE COORDONNEES         (1=ELL,2=CAR):',
     &                 'INCERTITUDE PSEUDODISTANCES(m)   [&TOL MISC]:',
     &                 'INCERTITUDE PORTEUSES(m)         [&TOL MISC]:',
     &                 'LAT(ddmmss.sss,+N) | ECEF X(m) [&VEL(mm/yr)]:',
     &                 'LON(ddmmss.sss,+E) | ECEF Y(m) [&VEL(mm/yr)]:',
     &                 'ALT (m)            | ECEF Z(m) [&VEL(mm/yr)]:',
     &                 'HAUTEUR ANTENNE                          (m):',
     &                 'ELEVATION MINIMUM                      (deg):',
     &                 'GDOP MAXIMUM                                :'/
C
C-----------------------------------------------------------------------
C     SELECT USER PROMPTS IN SPECIFIED LANGUAGE 
C-----------------------------------------------------------------------
C
      IF  ( OPTMAX(1) .LT. 10 ) THEN
        WRITE(CMDPEN(1)(40:45),30000) IDINT(OPTMAX(1))
        WRITE(CMDPFR(1)(40:45),30000) IDINT(OPTMAX(1))
      ELSE 
        WRITE(CMDPEN(1)(39:45),30001) IDINT(OPTMAX(1))
        WRITE(CMDPFR(1)(39:45),30001) IDINT(OPTMAX(1))
      END IF
      IERR=0
      DO I=1,NUCMD-8
        DO IOPT=1,5
          IF (LNG .EQ. 1) CMDI(IUCMD(I),IOPT)=CMDIEN(IUCMD(I),IOPT)
          IF (LNG .EQ. 2) CMDI(IUCMD(I),IOPT)=CMDIFR(IUCMD(I),IOPT)
        END DO  
        IOPT=MOD(IDINT(OPT(IUCMD(I))),10)
        IF (LNG .EQ. 1) CMDI(IUCMD(I),IOPT)=CMDIEN(IUCMD(I),IOPT)
        IF (LNG .EQ. 2) CMDI(IUCMD(I),IOPT)=CMDIFR(IUCMD(I),IOPT)
      END DO
C
      DO I=1,NUCMD
        IF (LNG .EQ. 1) CMDP(I)=CMDPEN(I)
        IF (LNG .EQ. 2) CMDP(I)=CMDPFR(I)
      END DO
C-----------------------------------------------------------------------
C     RESET OPTION 4 IF SINGLE FREQUENCY DATA
C-----------------------------------------------------------------------
C
      IF ( NFREQ .EQ. 1 ) THEN
         OPTMAX(4)  = 1
      END IF
C
C-----------------------------------------------------------------------
C     ENTER COMMAND FILE NAME AND OPEN FILE
C-----------------------------------------------------------------------
C
      NMOD=0
      NOPTERR=0
      I = 99
  100 CONTINUE
      WRITE(LUO,10010)
      READ(LU,10020) FNAM
      CALL STRLIM(FNAM,IL,IR)
      IF (IL-IR.EQ.0) THEN 
         WRITE(FNAM,'(A)') 'gpsppp.cmd'
         OPEN ( LUCMD, FILE=FNAM, STATUS='UNKNOWN' )
      END IF
  120 CONTINUE
      OPEN ( LUCMD, FILE=FNAM, STATUS='UNKNOWN',ERR=150 )
C
      READ(LUCMD,*,END=150,ERR=150) (COMMENT, OPT(IUCMD(I)), I=1,13)
      READ(LUCMD,'(52x,2f15.4)',END=125,ERR=125) OPT(IUCMD(14)),
     &                                                    MISCR_FACT
  125 CONTINUE
      IF( MISCR_FACT .LT. 0.D0 .OR.
     &    (MISCFACTR.GT.0.D0 .AND. MISCR_FACT .GT. MISCFACTR) .OR.
     &    (MISCFACTR.LE.0.D0 .AND. MISCR_FACT .GT. 9.D0) )
     &   MISCFACTR=MISCR_FACT
      READ(LUCMD,'(52x,2f15.4)',END=126,ERR=126) OPT(IUCMD(15)),
     &                                                    MISCP_FACT
  126 CONTINUE
      IF( MISCP_FACT .LT. 0.D0 .OR.
     &    (MISCFACTP.GT.0.D0 .AND. MISCP_FACT .GT. MISCFACTP) .OR.
     &    (MISCFACTP.LE.0.D0 .AND. MISCP_FACT .GT. 9.D0) )
     &   MISCFACTP=MISCP_FACT
      DO 130 I=1,3
      XRVVEL(I)= 0.0D0              
      READ(LUCMD,'(52x,2f15.4)',END=140,ERR=140) OPT(IUCMD(I+15)),
     &  XRVVEL(I)
140   CONTINUE                        
C sta vel from m/year to m/sec
      XRVVEL(I)= XRVVEL(I)/86400.D0/365.25D0
130   CONTINUE
      READ(LUCMD,*,END=150,ERR=150) (COMMENT, OPT(IUCMD(I)), I=19,NUCMD)
C
C     CHECK THAT INPUT OPTION IS ACCEPTABLE
C
 150  CONTINUE
      DO I=1,NUCMD
       IF ( I .NE. 6 .AND. I .NE. 8 .AND. I .NE. 9 .AND.
     &      I .NE.10 .AND.
     & ( I .LT. 16 .OR. I .GT. 18 ) ) THEN
        IF ( OPT(IUCMD(I)) .LT. OPTMIN(IUCMD(I)) .OR.
     &          OPT(IUCMD(I)) .GT. OPTMAX(IUCMD(I)) ) 
     &            OPT(IUCMD(I))=OPTMIN(IUCMD(I))
       ELSE IF(( I .LE. 10 .AND. I .GE. 8 ).OR. I .EQ. 6) THEN
        IF ( DMOD(OPT(IUCMD(I)),10.D0) .LT. OPTMIN(IUCMD(I)) .OR.
     &       DMOD(OPT(IUCMD(I)),10.D0) .GT. OPTMAX(IUCMD(I)) ) 
     &            OPT(IUCMD(I))=OPTMIN(IUCMD(I))
     &                          +10*DINT(OPT(IUCMD(I))/10.D0)
       ENDIF
      END DO
C
C-----------------------------------------------------------------------
C      COMPUTE VECTOR TO MARKER FROM COMMAND FILE COORDINATES
C-----------------------------------------------------------------------
C
      IXRVRNX=-1
      IXRV = IUCMD(NUCMD-6)
      ICART=1
      XRVVEC=0.D0
      DO I=1,3
        XRVVEC=XRVVEC+OPT(IXRV+I)*OPT(IXRV+I)
      END DO
C
C     IF VECTOR IS NON-ZERO, DETERMINE COORDINATE INPUT SYSTEM 
C     ELSE REPLACE MARKER COORDINATES WITH RINEX FILE INPUT
C
      IF (XRVVEC .GT. 1.D0) THEN
        XRVVEC=DSQRT(XRVVEC)
      XRVELV=XRVVEC-DTM(1)
        IF ( DABS(XRVELV) .GT. 2.D5 ) ICART=0
        IXRVRNX=0
      ELSE
        IXRVRNX=1
        DO I=1,4
         OPT(IXRV+I)=HDXYZH(I)
        END DO
        DO I=1,3
          XRVVEC=XRVVEC+OPT(IXRV+I)*OPT(IXRV+I)
        END DO
C
C       IF RINEX FILE COORDINATES ARE ZERO, SET TO 100.D0
C
        XRVVEC=SQRT(XRVVEC)
        IF (DABS(XRVVEC) .LT. 1.D0 .OR.
     &      DABS(XRVVEC) .GT. OPTMAX(16) ) THEN
          DO I=1,3
            OPT(IXRV+I)=100.D0
          END DO
      END IF
      END IF
 200  CONTINUE
C
C-----------------------------------------------------------------------
C     DISPLAY SELECTED OPTIONS TO SCREEN IF NOT ACP STATION
C-----------------------------------------------------------------------
C
      IF ( I .EQ. 0 ) GO TO 400
  250 CONTINUE
      IF ( LNG .EQ. 1 ) WRITE(LUO,19000) FNAM
      IF ( LNG .EQ. 2 ) WRITE(LUO,19001) FNAM
      WRITE(LUO,20010)  (I, CMDP(IUCMD(I)),
     &                   OPT(IUCMD(I)), I=1,1)
      WRITE(LUO,20000) (I, CMDP(IUCMD(I)), 
     &       CMDI(IUCMD(I),MOD(IDINT(OPT(IUCMD(I))),10)), I=2,NUCMD-8)
       WRITE(LUO,20010) (I, CMDP(IUCMD(I)),
     &                   OPT(IUCMD(I)), I=NUCMD-7,NUCMD)
C
C-----------------------------------------------------------------------
C     MAKE DESIRED MODIFICATIONS
C-----------------------------------------------------------------------
C
c!    WRITE(*,*) (IDINT(OPT(IUCMD(I))), I=1,NUCMD-8)
c!    WRITE(*,*) (CMDI(IUCMD(I),IDINT(OPT(IUCMD(I)))), I=1,NUCMD-8)
      IF ( LNG .EQ. 1 ) WRITE(LUO,20200)
      IF ( LNG .EQ. 2 ) WRITE(LUO,20201)
      READ(LU,*) I, UPOPT
      IF ( I .NE. 0 .AND. I .LE. NUCMD ) THEN
        NMOD = NMOD + 1
        OPT(IUCMD(I)) = UPOPT
c!    write(*,*) i,upopt,opt(iucmd(i))
        GO TO 200
      END IF
C
C-----------------------------------------------------------------------
C     CHECK SELECTED OPTIONS AND ASSIGN TO OUTPUT VARIABLES
C-----------------------------------------------------------------------
C
      IOPTER(1)=0
      IOPTER(2)=0
C
C     BROADCAST EPHEMERIS - NO PHASE SOLUTION (OPT(3))
C                           NO PRECISE CLOCKS (OPT(6))
C                           NO IONOSPHERIC GRID (OPT(8))
C                           NO TZD ESTIMATION (OPT(10))
C                           NO BACKWARD SUBSTITUTION (OPT(11))
C
      IF ( OPT(5) .EQ. 1 ) THEN
        IOPTER(1)=5
        IOPTCF=1
        IF( DMOD(OPT(6),10.D0) .NE. 3 .AND.
     &      DMOD(OPT(6),10.D0) .NE. 4 ) THEN
         OPT(6)=1+OPT(6)-DMOD(OPT(6),10.D0)
         IF (OPT(3) .EQ. 2)  IOPTER(2)=3
         IF (OPT(10) .GT. 1) IOPTER(2)=10
         IF (OPT(11) .GE. 2) IOPTER(2)=11
        END IF
      ELSE
C
C     PRECISE EPHEMERIS
C
C
C       CODE OBSERVATION -> NO TZD ESTIMATION (OPT(10)) 
C                        -> NO BACKWARD SUBSTITUTION (OPT(11))
C
        IF ( OPT(3) .EQ. 1 ) THEN
          IOPTER(1)=3
          IOPTCF=1
          IF (OPT(10) .GT. 1) IOPTER(2)=10
          IF (OPT(11) .GE. 2) IOPTER(2)=11
        END IF
C
C       SP3 SATELLITE CLOCKS - NO CLOCK INTERPOLATION (OPT(10)) 
C
        IF ( DMOD(OPT(6),10.D0) .EQ. 1 .AND. OPT(7) .EQ. 2 ) THEN
          IOPTER(1)=6
          IOPTCF=3
          IOPTER(2)=7
        END IF
      END IF
C
C
C     IONOSPHERIC FREE OBSERVATION - NO IONOSPHERE MODEL (OPT(8)) 
C
C     
      DO 350 I=1,NUCMD
        IF ( ( I .NE. 6 .AND. I .NE. 8 .AND. I .NE. 9 .AND.
     &         I .NE.10 .AND.
     &        (OPT(IUCMD(I)) .LT. OPTMIN(IUCMD(I)) .OR.
     &          OPT(IUCMD(I)) .GT. OPTMAX(IUCMD(I)) ) ) .OR.
     &       (((I .LE. 10 .AND. I .GE. 8).OR. I .EQ. 6 ) .AND.
     &        (DMOD(OPT(IUCMD(I)),10.D0) .LT. OPTMIN(IUCMD(I)) .OR.
     &         DMOD(OPT(IUCMD(I)),10.D0) .GT. OPTMAX(IUCMD(I)) ) ) .OR.
     &             IOPTER(2) .EQ. IUCMD(I) ) THEN
          IF (IOPTER(2) .EQ. IUCMD(I)) THEN       
            IF ( LNG .EQ. 1 ) WRITE(LUO,20210)
            IF ( LNG .EQ. 2 ) WRITE(LUO,20211)
            WRITE(LUO,20000) INT(IOPTER(1)), CMDP(IOPTER(1)), 
     &                 CMDI(IOPTER(1),IDINT(DMOD(OPT(IOPTCF),10.D0)))          
            WRITE(LUO,20000) INT(IOPTER(2)), CMDP(IOPTER(2)), 
     &                 CMDI(IOPTER(2),IDINT(DMOD(OPT(IUCMD(I)),10.D0)))          
          ELSE
            IF ( LNG .EQ. 1 ) WRITE(LUO,20220)
            IF ( LNG .EQ. 2 ) WRITE(LUO,20221)
            IF ( IUCMD(I) .EQ. 1 .OR. IUCMD(I) .GT. NUCMD-8 ) THEN
            WRITE(LUO,20010) I, CMDP(IUCMD(I)),OPT(IUCMD(I))
            ELSE
            WRITE(LUO,20000) I, CMDP(IUCMD(I)), 
     &               CMDI(IUCMD(I),IDINT(OPT(IUCMD(I))))
            END IF
          END IF
C
          IF ( LNG .EQ. 1 ) WRITE(LUO,20200)
          IF ( LNG .EQ. 2 ) WRITE(LUO,20201)
          READ(LU,*,ERR=300) IOPT, UPOPT
          OPT(IUCMD(IOPT)) = UPOPT
c!        WRITE(*,*) OPT(IUCMD(I)),UPOPT
  300     CONTINUE        
          NOPTERR = NOPTERR + 1
          IF (NOPTERR .LT. 3 .AND. UPOPT .NE. 0) THEN
          GO TO 200
        ELSE
          IERR=1
          GO TO 400
        END IF
        END IF
  350 CONTINUE   
C
  400 CONTINUE
C
C     WRITE OUT FINAL OPTION LIST TO CMDLST 
C
      DO I=1,NUCMD
c      IF( (I .GT. 1 .AND. I .LT. 8) .OR.
c    &     I .EQ. 9 .OR. I .EQ. 11 .OR. I .EQ. 12 ) THEN
       IF( I .GT. 1 .AND. I .LT. 14 ) THEN
        WRITE(CMDLST(I),20000) I,CMDP(IUCMD(I)), 
     &      CMDI(IUCMD(I),IDINT(DMOD(OPT(IUCMD(I)),10D0)))
       ELSE
        WRITE(CMDLST(I),20010)  I, CMDP(IUCMD(I)), OPT(IUCMD(I))
       END IF
      END DO
C
      ICMD(1)  = IDINT(OPT(1))
      ICMD(2)  = IDINT(OPT(2))
      ICMD(3)  = IDINT(OPT(3))
      ICMD(4)  = IDINT(OPT(4))
      ICMD(5)  = IDINT(OPT(5))
      ICMD(6)  = IDINT(OPT(6))
      ICMD(7)  = IDINT(OPT(7))
      ICMD(8)  = IDINT(OPT(8))
      ICMD(9)  = IDINT(OPT(9))
      ICMD(10) = IDINT(OPT(10))
      ICMD(11) = IDINT(OPT(11))
      ICMD(12) = IDINT(OPT(12))
      ICMD(13) = IDINT(OPT(13))
      SDP      = OPT(14)
      SDCP     = OPT(15)
C
C     THESE OPTIONS NOT SUPPORTED ANYMORE (READ CLK&TRP AND FIX)
C
      ICLKSOL = 1
C
      SMTHCLK=ICMD(11).EQ.2
      IF (ICMD(11) .GE. 2) ICMD(11)=-1
      IFMTM=1
      IFMTE=IFMTM
      IF ( ICMD(10) .NE. 1 ) SDTROP=MOD(ICMD(10),10)*1.D-3
C
C     CONVERT ELLIPSOIDAL COORDINATES TO CARTESIAN
C
      IF ( ICART .EQ. 0 ) THEN
        CALL DMSR (PI, XRVMRK(1),OPT(16),2)
        CALL DMSR (PI, XRVMRK(2),OPT(17),2)
        XRVMRK(3) = OPT(18)
C convert PLH sta velocity to XYX ONES
        XRNV = XRVVEL(1)
        XREV = XRVVEL(2)
        XRHV = XRVVEL(3)
       XRVVEL(1)=-SIN(XRVMRK(1))*COS(XRVMRK(2))*XRNV-SIN(XRVMRK(2))*XREV
     &           +COS(XRVMRK(1))*COS(XRVMRK(2))*XRHV
       XRVVEL(2)=-SIN(XRVMRK(1))*SIN(XRVMRK(2))*XRNV+COS(XRVMRK(2))*XREV
     &           +COS(XRVMRK(1))*SIN(XRVMRK(2))*XRHV
       XRVVEL(3)= COS(XRVMRK(1))*XRNV + SIN(XRVMRK(1))*XRHV
        CALL PLXYZ1(DTM(3),DTM(4),DTM(5),DTM(1),DTM(2),XRVMRK)
      ELSE
        XRVMRK(1)=OPT(16)
        XRVMRK(2)=OPT(17)
        XRVMRK(3)=OPT(18)
      END IF
c!    WRITE(*,*) 'XRVMRK',XRVMRK(1),XRVMRK(2),XRVMRK(3)
      ANTH    = OPT(19)
      CUTOFF  = OPT(20)
      DOPMAX  = OPT(21)
C
C     IF SP3 ORBIT SELECTED AND NO SATELLITE CLOCKS APPLIED,
C     USE SP3 15 MINUTE SATELLITE CLOCKS
C
      IF ( NMOD .NE. 0 .AND. NOPTERR .LT. 3 ) THEN
        IF ( LNG .EQ. 1 ) THEN 
        WRITE(LUO,20230)
          READ (LU,'(A)') ANSWR
          IF ( ANSWR .EQ. 'Y' .OR. ANSWR .EQ. 'y' ) ANSWR='Y'
      END IF
        IF ( LNG .EQ. 2 ) THEN
        WRITE(LUO,20231)
          READ (LU,'(A)') ANSWR
          IF ( ANSWR .EQ. 'O' .OR. ANSWR .EQ. 'o' ) ANSWR='Y'
      END IF
        IF ( ANSWR .EQ. 'Y' ) THEN
          CLOSE ( LUCMD, STATUS='DELETE' )
          OPEN ( LUCMD, FILE=FNAM, STATUS='NEW', IOSTAT=IOS, ERR=500 )
          WRITE(LUCMD,20001) (CMDP(IUCMD(I)), IDINT(OPT(IUCMD(I))),
     &                             I=1,NUCMD-8)
          WRITE(LUCMD,20011) (CMDP(IUCMD(I)), OPT(IUCMD(I)),
     &                             I=NUCMD-7,NUCMD)
          CLOSE ( LUCMD )
          GO TO 550
C
  500     CONTINUE
          WRITE(LUO,10100) IOS, FNAM
          IERR = 1
  550     CONTINUE
        END IF
      END IF
C
  600 CONTINUE
C
C-----------------------------------------------------------------------
C               FORMAT STATEMENTS
C-----------------------------------------------------------------------
C
10010 FORMAT( '+','Enter COMMAND file name    :')
10020 FORMAT( A80 )
10100 FORMAT( ' ERROR ',I9,'trying to open FILE ',  A15 )
19000 FORMAT(/,' THE FOLLOWING OPTIONS WERE READ FROM FILE     ',A80,/)
19001 FORMAT(/,' LES OPTIONS SUIVANTES ONT ETE LUES DU FICHIER ',A80,/)
20000 FORMAT( 1X,I2,". ",A45,10X, A6 )
20001 FORMAT( "'", A45,"'",10X, I6 )
20010 FORMAT( 1X,I2,". ",A45,1X,F15.3 )
20011 FORMAT( "'", A45,"'",1X,F15.3 )
20200 FORMAT( ' ENTER OPTION AND NEW VALUE ',
     &            '(0,0 TO CONTINUE)' )
20201 FORMAT( "ENTREZ L'OPTION ET SA NOUVELLE VALEUR ",
     &            '(0,0 POUR CONTINUER)' )
20210 FORMAT(' THE FOLLOWING OPTIONS CONFLICT')
20211 FORMAT(' LES OPTIONS SUIVANTES NE PEUVENT ETRE COMBINEES')
20220 FORMAT(' THIS OPTION IS NOT VALID')
20221 FORMAT(" CETTE OPTION N'EST PAS VALIDE")
20230 FORMAT(' UPDATE COMMAND FILE (Y/N)?')
20231 FORMAT(" MISE A JOUR DU FICHIER D'OPTIONS (O/N)?")
30000 FORMAT('(1-',I1,'):')
30001 FORMAT('(1-',I2,'):')
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDDEF
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDDEF(   LUI, LUO, LUDEF, IYEARS, IMTHS, IDAYS,
     &           IFLT, NAMFLT, FLTPAR, IFLTON, IPC, VSCALE,
     &           IC1USE, IC2USE, IDCBUSE, SDPR, SDCLK,
     &           ISVB, NAMSVB, IGNSS, ISVN, ISVBLK, 
     &           DSVX, DSVY, DSVZ, DP1P2, DP1C1, DP2C2, AVCLK,
     &           IOLC, NAMOLC, XRVMRK, DTM, NOCOF, AMPL, PHAS, 
     &           DMJDOL, TW,
     &           IPCV, NAMPCV, ANTNAM, PCVNEU, PCVELV, PCVSAT,
     &           ITRF, NAMTRF, IREFIN, RFRAME, RFREAL, TRFPAR,
     &            ICLKAP,NAMSTC,CLKY0,CLKD0,UCLKY0,UCLKD0,CLKSD0,
     &            ICLKFIT,
     &           IMET, NAMMET, STNHGT, TEMP, PRES, RH, TROSC ,
     &           IGF, FOUND22, IFREQ)
C
C     PURPOSE:   READ DEFAULT FILES AND ASSIGN MODEL PARAMETERS
C
C     PARAMETERS        DESCRIPTION
C
C        LUI            LOGICAL UNIT OF SCREEN INPUT
C        LUO            LOGICAL UNIT OF SCREEN OUTPUT
C        LUDEF        LOGICAL UNIT OF DEFAULT FILE
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      CHARACTER*80 NAMSTC
      INTEGER*4   ICLKAP
     &            ,ICLKFIT
      REAL*8      CLKY0,CLKD0,UCLKY0,UCLKD0,CLKSD0
      LOGICAL*4  FOUND22
      CHARACTER*80 NAMFLT,NAMSVB,NAMOLC,NAMPCV,NAMTRF,NAMMET
      CHARACTER*1  IGNSS(*)
      CHARACTER*20 ANTNAM
      CHARACTER*5  RFRAME
      CHARACTER*5  RFREAL
      CHARACTER*3  TW(*)
      REAL*8       DMJDOL
      INTEGER*4 LUI,LUO,LUDEF,IYEARS,IMTHS,IDAYS,IFLT,IFLTON,IPC
      INTEGER*4 ISVB,ISVN(*),ISVBLK(*),NOCOF,IOLC,IPCV,ITRF,IREFIN
      INTEGER*4 IMET, IC1USE, IC2USE, IDCBUSE
      REAL*8    FLTPAR(*),VSCALE,DSVX(*),DSVY(*),DSVZ(*)
      REAL*8    DP1P2(*),DP1C1(*), DP2C2(*), AVCLK(*)
C AMPL(4,J) PHAS(4,j) contains frequency/phase of tidal term
      REAL*8    XRVMRK(*), DTM(*), AMPL(4,*), PHAS(4,*)
      REAL*8  PCVNEU(6,*), PCVELV(361,182,*),TRFPAR(*), PCVSAT(MAXSAT,*)
      REAL*8    STNHGT, TEMP, PRES, RH, TROSC, SDPR
      REAL*8    SDCLK
C
      INTEGER*4 I, IGF(*)
      INTEGER*4 IFREQ
C
C     READ FILTER PARAMETERS
C   
      OPEN ( LUDEF, FILE=NAMFLT, STATUS='UNKNOWN')

      CALL RDFLT( LUDEF, FLTPAR, IPC, IFLTON, IC1USE, IC2USE, IDCBUSE, 
     &            VSCALE, SDPR, SDCLK )
      CLOSE (LUDEF)        
C
C     READ SV BIASES 
C      
      OPEN ( LUDEF, FILE=NAMSVB, STATUS='UNKNOWN')
c!    WRITE(*,*) 'CALLING RDSAT',LUDEF,NAMSVB
      DO I=1,MAXSAT
       DSVX(I)=0.D0
       DSVY(I)=0.D0
       DSVZ(I)=0.D0
       DP1P2(I)=0.D0
       DP1C1(I)=0.D0
       DP2C2(I)=0.D0
       AVCLK(I)=0.D0
      END DO   
      CALL RDSAT( LUDEF, IYEARS, IMTHS, IDAYS, IGNSS, 
     &            ISVN, ISVBLK, DSVX, DSVY, DSVZ, 
     &            DP1P2, DP1C1, DP2C2, AVCLK, ISVB, IGF)
      CLOSE (LUDEF)
C
C     READ OCEAN LOADING COEFFICIENTS
C
      OPEN ( LUDEF, FILE=NAMOLC, STATUS='UNKNOWN')
c!    WRITE(*,*) 'CALLING RDOLC', LUDEF, NAMOLC
      CALL RDOLC(LUO, LUDEF, XRVMRK, DTM,
     &             DMJDOL, TW, NOCOF, AMPL, PHAS, IOLC)
      CLOSE (LUDEF)
C
C     READ USER ANTENNA PHASE CENTER VARIATIONS
C      
      OPEN ( LUDEF, FILE=NAMPCV, STATUS='UNKNOWN')
c!    WRITE(*,*) 'CALLING RDPCV',NAMPCV
      CALL RDPCV( LUDEF, ANTNAM, PCVNEU, PCVELV, PCVSAT, 
     &     DSVX, DSVY, DSVZ, MAXSAT, IPCV, IYEARS, IMTHS, IDAYS, ISVBLK,
     &     FOUND22, IFREQ)
      CLOSE (LUDEF)
      IF(IPCV.EQ.0) THEN
C RESET DSVXYZ IN CASE OVERWRITTEN IN RDPCV (SINCE RX PCV N/A)
        OPEN ( LUDEF, FILE=NAMSVB, STATUS='UNKNOWN')
        DO I=1,MAXSAT    
          DSVX(I)=0.D0
          DSVY(I)=0.D0
          DSVZ(I)=0.D0
          DP1P2(I)=0.D0
          DP1C1(I)=0.D0
          DP2C2(I)=0.D0
          AVCLK(I)=0.D0
        END DO
        CALL RDSAT( LUDEF, IYEARS, IMTHS, IDAYS, IGNSS,
     &            ISVN, ISVBLK, DSVX, DSVY, DSVZ,
     &            DP1P2, DP1C1, DP2C2, AVCLK, ISVB, IGF)
        CLOSE (LUDEF)
      ENDIF
C
C     READ REFERENCE FRAME TRANSFORMATION PARAMETERS
C        
      OPEN ( LUDEF, FILE=NAMTRF, STATUS='UNKNOWN')
c!    WRITE(*,*) 'CALLING RDTRF',NAMTRF, RFRAME, RFREAL
      CALL RDTRF( LUDEF, RFRAME, RFREAL, TRFPAR, ITRF )
      CLOSE(LUDEF)
C      
C
C     READ STATION APRIORI CLOCK PARAMETERS
C
      OPEN ( LUDEF, FILE=NAMSTC, STATUS='UNKNOWN')
      ICLKFIT=1
      CALL RDSTC( LUDEF, ICLKAP, CLKY0, CLKD0, UCLKY0, UCLKD0, CLKSD0
     &            , ICLKFIT )
      CLOSE(LUDEF)
      RETURN
      END      
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C***************************************************************** RDEPH
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDEPH (LPR,LUEPH,IFMT,NEPSV,IEPSV,NEPTIM,EPHTIM,EPHTBL,
     &                  AIONBRD, BIONBRD, ISRCH)
C
C     PURPOSE:   TO READ THE EPHEMERIS DATA
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4      LPR, LUEPH, IFMT, NEPSV, ISRCH
      INTEGER*4      IEPSV(MAXSAT), NEPTIM(MAXSAT)
      REAL*8         EPHTIM(MAXSAT,MAXEPH)
      REAL*8         EPHTBL(MAXKEP,MAXSAT,MAXEPH)
      REAL*8         AIONBRD(*), BIONBRD(*)
C-----------------------------------------------------------------------
C
      IF (IFMT .EQ. 1) CALL RNXEP (LPR, LUEPH, NEPSV, IEPSV,
     &                             NEPTIM, EPHTIM, EPHTBL, AIONBRD,
     &                             BIONBRD, ISRCH)
      IF (IFMT .EQ. 2) CALL RTCAEPH(LPR, LUEPH, NEPSV, IEPSV,
     &                              NEPTIM, EPHTIM, EPHTBL, ISRCH)
      IF (IFMT .EQ. 3) CALL RTCMEPH(LPR, LUEPH, NEPSV, IEPSV,
     &                              NEPTIM, EPHTIM, EPHTBL, ISRCH)
c
c!    DO IS=1,NEPSV+1
c!    WRITE(*,*)
c!   &'RDEPH --------------------------------------------------'
c!    WRITE(*,*) 'RDEPH IS,PRN,NEPTIM',IS,IEPSV(IS),NEPTIM(IS)
c!    DO IEP=1,NEPTIM(IS)+1
c!        WRITE(*,*) 'RDEPH IEP,EPHTIM',IEP,EPHTIM(IS,IEP)
c!        WRITE(*,*) 'RDEPH SAT,WK,REFE,REFC',EPHTBL(1,IS,IEP),
c!   &  EPHTBL(2,IS,IEP),EPHTBL(20,IS,IEP),EPHTBL(8,IS,IEP)
c!        WRITE(*,*) 'RDEPH IODC,IODE,IODE',EPHTBL(7,IS,IEP),
c!   &                   EPHTBL(12,IS,IEP),EPHTBL(29,IS,IEP)
c!        WRITE(*,*) 'RDEPH HLTH,FIT',EPHTBL(5,IS,IEP),
c!   &                                     EPHTBL(21,IS,IEP)
c!    END DO
c!    END DO
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDEPO
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDEPO ( LUMEA, LPR, FIRSTM, RECORD, NOBTYP, IOBPOS,
     &                   OBSINT, IGPSWK, PTTAG, TTAG, 
     &                   NSV, ISV, IGF, DP1C1,DP2C2,
     &           PR1, PR2, P1, P2, CR1, CR2,RIFRATE, C, AL1, AL2, IDIR,
     &                   ISVRJCT, NSVRJCT, IERR, IEND, 
     &                   ISPR1, ISPR2,
     &                   IC1USE, IC2USE, IDCBUSE, IFREQ)
C
C     NAME:      RDEPO
C
C     PURPOSE:   READ EPOCH RECORDS FROM MEASUREMENT FILE
C
C     PARAMETERS        DESCRIPTION
C
C        LUMEA          LOGICAL UNIT OF MEASUREMENT FILE
C        LPR            LOGICAL UNIT OF PRINT FILE
C        FIRSTM         FIRST MEASUREMENT FLAG
C        RECORD         LAST RECORD READ
C        EPOCH          EPOCH OF MEASUREMENTS RECORDS
C        EPOBLK         BLOCK OF RECORDS
C        NRECBLK        NUMBER OF RECORDS IN EPOCH BLOCK
C        NOBTYP         NUMBER OF OBSERVATION TYPES (RNX ONLY)
C        IOBPOS         POSITION OF L1, L2, P1 & P2 OBSERVATIONS
C        IGPSWK         GPS WEEK OF OBSERVATION 
C        TTAG           TIME TAG OF OBSERVATION (SECONDS OF WEEK)
C        NSV            NUMBER OF SATELLITES IN RECORD
C        ISV            LIST OF SATELLITE I.D.'S
C        IGF            SATELLITE CONSTELLATION FLAG (0=GPS,1=GLONASS)
C        PR1            P-CODE PSEUDORANGE ON L1
C        PR2            P-CODE PSEUDORANGE ON L2
C        P1             CARRIER PHASE ON L1
C        P2             CARRIER PHASE ON L2
C        CR1            C/A CODE PSEUDORANGE ON L1
C        CR2            C/A CODE PSEUDORANGE ON L2
C        C              SPEED OF LIGHT
C        AL1            L1 WAVELENGTH
C        AL2            L2 WAVELENGTH
C        IDIR           DIRECTION OF READ (1=FORWARD, -1=REVERSE)
C        IERR           READ ERROR FLAG
C        IEND           END OF FILE FLAG
C        MAXOBS         MAXIMUM NUMBER OF OBSERVED SATELLITES
C        MAXREC         MAXIMUM NUMBER OF RECORDS IN BLOCK
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      CHARACTER*80  RECORD
      INTEGER*4 LUMEA,LPR,NOBTYP,IGPSWK,NSV,IDIR,NSVRJCT

      LOGICAL*4 ISPR1(*), ISPR2(*)
      INTEGER*4 IERR,IEND,               IC1USE, IC2USE, IDCBUSE
      INTEGER*4 ISV(*),IGF(*),ISVRJCT(*),IOBPOS(*)
      REAL*8    OBSINT,PTTAG,TTAG(*),DP1C1(*),DP2C2(*),PR1(*),PR2(*)
      REAL*8    CR1(*),CR2(*),HDXYZH(4),P1(*),P2(*),C,AL1,AL2
      REAL*8    DUMMY, RIFRATE                                        
      LOGICAL   FIRSTM
C
      CHARACTER*80  EPOBLK(MAXREC),RECBUF(MAXREC)
      CHARACTER*14  EOHDR
      CHARACTER*40  STNA
      CHARACTER*20  ANTNAM,RECNAM
      INTEGER*4 I,J,NRECBLK,IYEAR,IMTH,IDAYM,IHR,IMN,IEP,NRSV
      INTEGER*4 NFREQ,IEOF,JULD,IWKDAY,NRECBUF
      INTEGER*4 IRECBUF, IFREQ
      REAL*8    SEC,EPOCH,UEPOCH
C
C------------------------------------------------------------------------
C     READ MEASUREMENT FILE FORWARD
C------------------------------------------------------------------------
C
      IF ( IDIR .EQ. 1 ) THEN
        NRECBLK=0
  100   CONTINUE
        IF ( FIRSTM ) THEN
          READ(LUMEA,'(A80)',ERR=100, END=500) RECORD
          FIRSTM = .FALSE.
        GOTO 300
        END IF
  200   CONTINUE
        READ(LUMEA,'(A80)',ERR=200, END=500) RECORD
  300   CONTINUE      
c!       WRITE(*,*) RECORD
        READ(RECORD,2000,ERR=200,END=500) IYEAR, IMTH, IDAYM,
     &                            IHR, IMN, SEC, IEP, NRSV
C        WRITE(*,*) 'IYEAR, IMTH, IDAYM,IHR,IMN,SEC,IEP,NRSV'
C        WRITE(*,*) IYEAR, IMTH, IDAYM,IHR,IMN,SEC,IEP,NRSV
        NRECBLK=NRECBLK+1
      EPOBLK(NRECBLK)=RECORD
C
C       MORE THAN 12 SATELLITES TRACKED
C
      IF ( IEP .LE. 1 .OR. IEP .EQ. 6 ) THEN
       DO I=1,(NRSV-1)/12
          READ(LUMEA,'(A80)',ERR=200, END=500) RECORD
        NRECBLK=NRECBLK+1
        EPOBLK(NRECBLK)=RECORD
       END DO
      END IF
C
        IF ( IYEAR .GE. 0 .AND. IYEAR .LT. 80 ) THEN
          IYEAR = IYEAR + 2000
        ELSE
          IYEAR = IYEAR + 1900
        END IF
C
        DO I=1,MIN(MAXREC-NRECBLK,NRSV)
         READ(LUMEA,'(A80)',ERR=200,END=500) RECORD
       IF(NRECBLK .LT. MAXREC ) THEN
          NRECBLK=NRECBLK+1
          EPOBLK(NRECBLK)=RECORD
       END IF
         IF ( IEP .LE. 1 .OR. IEP .EQ. 6 ) THEN
        DO J=1,(NOBTYP-1)/5
           READ(LUMEA,'(A80)',ERR=200,END=500) RECORD
         IF( NRECBLK .LT. MAXREC ) THEN
            NRECBLK=NRECBLK+1
            EPOBLK(NRECBLK)=RECORD
c!          WRITE(*,*) EPOBLK(NRECBLK)
         END IF
        END DO
       END IF
        END DO
        DO I=MIN(MAXREC-NRECBLK,NRSV)+1,NRSV
          READ(LUMEA,'(A80)',ERR=200,END=500) RECORD
      END DO
C        WRITE(*,*) IYEAR, IMTH, IDAYM
C
C------------------------------------------------------------------------
C        READ CONTENT OF EPOCH BLOCK
C------------------------------------------------------------------------
C
c!        WRITE(*,*) 'CALLING RDRNX,IDIR',IDIR
         CALL RDRNX ( LPR, EPOBLK, NRECBLK, NOBTYP, IOBPOS, OBSINT,
     &                   IGPSWK, TTAG, NSV, ISV, IGF, 
     &                   DP1C1, DP2C2, PR1, PR2, P1, P2, CR1, CR2,
     &                   ISPR1, ISPR2,
     &  RIFRATE, C, AL1, AL2, IERR, IC1USE, IC2USE, IDCBUSE, MAXOBS )
C        
C------------------------------------------------------------------------
C        THIS CHECK ADDED BECAUSE DUPLICATE SAT FOR SAME EPOCH
C------------------------------------------------------------------------
C      
         NSVRJCT = 0
         DO I=2,NSV
           DO J=1,I-1
             IF ( ISV(I) .EQ. ISV(J) ) THEN 
               NSVRJCT = NSVRJCT + 1
               ISVRJCT(NSVRJCT) = ISV(I)
             END IF
           END DO
         END DO  
         RETURN
C
C------------------------------------------------------------------------
C        END OF FILE REACHED READING FORWARDS 
C        IF   FORWARD RUN (NDIR=1) THEN RETURN 
C        ELSE REWIND FILE AND POSITION AT LAST EPOCH 
C------------------------------------------------------------------------
C
 500    CONTINUE
        IEND=1
      RETURN
      END IF
C------------------------------------------------------------------------
C     READ MEASUREMENT FILE IN REVERSE
C------------------------------------------------------------------------
C
      IF ( IDIR .EQ. -1 ) THEN
        IF ( IEND .EQ. 1 ) THEN
c!         WRITE(*,*) 'REWINDING LUMEA'
        REWIND(LUMEA)
          CALL HDRNX (LUMEA, IYEAR, IMTH, IDAYM, STNA,
     &                DUMMY , NOBTYP, IOBPOS, NFREQ, HDXYZH, 
     &                ANTNAM, RECNAM, IFREQ, IEOF )
 550     CONTINUE
            READ(LUMEA,'(A80)',ERR=550, END=900) RECORD
c!        WRITE(*,*) RECORD
            READ(RECORD,2000,ERR=550,END=900) IYEAR, IMTH, IDAYM,
     &                                        IHR, IMN, SEC, IEP, NRSV
            IF ( IYEAR .GE. 0 .AND. IYEAR .LT. 80 ) THEN
              IYEAR = IYEAR + 2000
            ELSE
              IYEAR = IYEAR + 1900
            END IF
            CALL GPSDC ( JULD,IYEAR,IMTH,IDAYM,IGPSWK,IWKDAY,2 )
            EPOCH = (IWKDAY-1)*86400.D0 + IHR*3600.D0 + IMN*60.D0 
     &              + SEC 
            UEPOCH = IGPSWK*604800.D0 + EPOCH
c!        WRITE(*,*) 'EPOCH,PTTAG',EPOCH,PTTAG
        IF ( IEP .GT. 1 .OR. ABS(UEPOCH- PTTAG).GT.3.D-3 ) THEN
          IF( IEP .LE. 1 .OR. IEP .EQ. 6 ) THEN
           DO I=1,(NRSV-1)/12
              READ(LUMEA,'(A80)',ERR=550, END=900) RECORD
           END DO
          END IF
          DO I=1,NRSV
             READ(LUMEA,'(A80)',ERR=550, END=900) RECORD
           IF( IEP .LE. 1 .OR. IEP .EQ. 6 ) THEN
            DO J=1,(NOBTYP-1)/5
               READ(LUMEA,'(A80)',ERR=550, END=900) RECORD
            END DO
           END IF
          END DO
            GO TO 550
          ELSE
          DO I=1,(NRSV-1)/12
              READ(LUMEA,'(A80)',ERR=550, END=900) RECORD
          END DO
            DO I=1,NRSV
              READ(LUMEA,'(A80)',ERR=550, END=900) RECORD
              IF ( IEP .LE. 1 .OR. IEP .EQ. 6 ) THEN 
             DO J=1,(NOBTYP-1)/5
                READ(LUMEA,'(A80)',ERR=550, END=900) RECORD
             END DO
              END IF
            END DO
          END IF
      END IF
C
        NRECBLK=0
        NRECBUF=0
  600   CONTINUE
        IF ( IEND .EQ. 1 ) THEN
          IEND=0
        ELSE
          BACKSPACE(LUMEA)
        END IF
        BACKSPACE(LUMEA)
      NRECBUF=NRECBUF+1
        READ(LUMEA,'(A80)',ERR=600) RECORD
c!    write(*,*) record
        EOHDR = RECORD(61:74)
c!    WRITE(*,*) '----',EOHDR,'----'
        IRECBUF=MOD(NRECBUF-1,MAXREC)+1
      RECBUF(IRECBUF)=RECORD
C
C       END OF HEADER IS END OF FILE
C
      IF ( EOHDR .EQ. 'END OF HEADER') GO TO 900
c!    WRITE(*,'(I2,1X,A80)') NRECBUF, RECBUF(NRECBUF)
        READ(RECBUF(IRECBUF),2000,ERR=600) IYEAR, IMTH, IDAYM,
     &                            IHR, IMN, SEC, IEP, NRSV
        IF ( IMTH .EQ. 0 .OR. IDAYM .EQ. 0 .OR. NRSV .EQ. 0 ) GO TO 600
        IF ( IYEAR .GE. 0 .AND. IYEAR .LT. 80 ) THEN
          IYEAR = IYEAR + 2000
        ELSE
          IYEAR = IYEAR + 1900
        END IF
        NRECBLK=NRECBLK+1
      EPOBLK(NRECBLK)=RECORD
        NRECBUF=NRECBUF-1
      DO I=1,(NRSV-1)/12
       IF( NRECBLK .LT. MAXREC ) THEN
          NRECBLK=NRECBLK+1
          IRECBUF=MOD(NRECBUF-1,MAXREC)+1
          EPOBLK(NRECBLK)=RECBUF(IRECBUF)
        NRECBUF=NRECBUF-1
       END IF
      END DO
C
        DO I=1,NRSV
        IF ( NRECBUF .GT. 0 .AND. NRECBLK .LT. MAXREC ) THEN
            NRECBLK=NRECBLK+1
            IRECBUF=MOD(NRECBUF-1,MAXREC)+1
            EPOBLK(NRECBLK)=RECBUF(IRECBUF)
c!          WRITE(*,'(I2,1X,I2,1X,A80)') I,NRECBUF,EPOBLK(NRECBLK)
          NRECBUF=NRECBUF-1
            DO J=1,(NOBTYP-1)/5
          IF( NRECBUF .GT. 0 .AND. NRECBLK .LT. MAXREC ) THEN
              NRECBLK=NRECBLK+1
c!            WRITE(*,'(I2,1X,I2,1X,A80)') I,NRECBUF
              IRECBUF=MOD(NRECBUF-1,MAXREC)+1
              EPOBLK(NRECBLK)=RECBUF(IRECBUF)
c!            WRITE(*,'(I2,1X,I2,1X,A80)') I,NRECBUF,EPOBLK(NRECBLK)
            NRECBUF=NRECBUF-1
          END IF
          END DO
        END IF
        END DO
C
C------------------------------------------------------------------------
C        READ CONTENT OF EPOCH BLOCK
C------------------------------------------------------------------------
C
         CALL RDRNX ( LPR, EPOBLK, NRECBLK, NOBTYP, IOBPOS, OBSINT,
     &                   IGPSWK, TTAG, NSV, ISV, IGF,  
     &                   DP1C1, DP2C2, PR1, PR2, P1, P2, CR1, CR2,
     &                   ISPR1, ISPR2,
     &  RIFRATE, C, AL1, AL2, IERR, IC1USE, IC2USE, IDCBUSE, MAXOBS )
     
C        
C------------------------------------------------------------------------
C        THIS CHECK ADDED BECAUSE DUPLICATE SAT FOR SAME EPOCH
C------------------------------------------------------------------------
C 
         IF ( NSV .GT. 0 ) THEN
           NSVRJCT = 0
           DO I=2,NSV
             DO J=1,I-1
               IF ( ISV(I) .EQ. ISV(J) ) THEN 
                 NSVRJCT = NSVRJCT + 1
                 ISVRJCT(NSVRJCT) = ISV(I)
               END IF
             END DO
           END DO
       END IF
         RETURN
      END IF
C        
C------------------------------------------------------------------------
C        END OF FILE (WHEN READING BACKWARDS)
C------------------------------------------------------------------------
C      
  900 CONTINUE
      IEND=1
C
 2000 FORMAT (5I3,F11.7,2(1X,I2))
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDERP
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDERP( LU, LUO, LUERP, IYOBS, IMOBS, IDOBS,  
     &                  FMJDMP,XMPDIF, YMPDIF, XMPDRT, YMPDRT, IERP )
C
C     NAME              RDERP
C
C     PURPOSE   READ ERP FILE VERSION 2 TO RETURN DIFFERENCE W. MEAN POLE
C
C     PARAMETERS        DESCRIPTION
C
C        LU             LOGICAL UNIT OF INPUT
C        LUO            LOGICAL UNIT OF OUTPUT
C        LUMET          LOGICAL UNIT OF ERP FILE
C        FMJDMP         REFERENCE DATE OF MEAN POLE DIFFFERENCE
C        XMPDIF         XP DIFFERENCE W. MEAN POLE (arcsec)
C        YMPDIF         YP DIFFERENCE W. MEAN POLE (arcsec)
C        XMPDRT         XP DIFFERENCE W. MEAN POLE RATE(arcsec/d)
C        YMPDRT         YP DIFFERENCE W. MEAN POLE RATE (arcsec/d)
C        IERP           INDICATOR FOR POLAR TIDE
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4 LU, LUO, LUERP, IYOBS, IMOBS, IDOBS, IERP
      REAL*8    FMJDMP, XMPDIF, YMPDIF, XMPDRT, YMPDRT
C
      CHARACTER*160   RECORD
      INTEGER*4       I,J,MJD,MJDS
      INTEGER*4       IX,IY,UT1UTC,LOD,XS,YS,UTS,LODS,NR,NF,NT,IXRT,IYRT
      REAL*8          FMJD,DT,DTP
      INTEGER*4       POLECONV,IERR
      REAL*8          EPOCH,XMEAN,YMEAN,XRATE,YRATE
C!!
C!! CHOOSE (UNCOMMENT) ONE OF THE FOLLOWING
C!!
C!! Code Beg =============================================================
C!!   DATA POLECONV/2003/
C!!   DATA POLECONV/2010/
      DATA POLECONV/2015/
C!! Code End =============================================================
C
C
      IERP=0
      XMPDIF=0.D0
      YMPDIF=0.D0
      XMPDRT=0.D0
      YMPDRT=0.D0
      CALL JLIAN ( MJDS, IYOBS, IMOBS, IDOBS )
C
C-----------------------------------------------------------------------
C     READ ERP FILE 
C     MUST START WITH 'VERSION 2'
C-----------------------------------------------------------------------
C
      READ(LUERP,10000,END=250) RECORD 
      IF( RECORD(1:9) .NE. 'VERSION 2' .AND.
     &    RECORD(1:9) .NE. 'Version 2' .AND.
     &    RECORD(1:9) .NE. 'version 2' ) GOTO 250
C
C-----------------------------------------------------------------------
C     LOCATE MJDS IF ANY
C-----------------------------------------------------------------------
C
210   CONTINUE
      READ(LUERP,10000,END=250,ERR=250) RECORD
      READ(RECORD,*,END=210,ERR=210) FMJD,IX,IY,UT1UTC,LOD,XS,YS,UTS,
     &                       LODS,NR,NF,NT,IXRT,IYRT
      MJD= INT(FMJD+1.d-3) 
      IF(MJDS.LT.MJD) GO TO 250
      MJD= INT(FMJD+1.d-3) - MJDS
      IF(MJD.GE.0.AND.MJD.LE.1) THEN
        FMJDMP=FMJD
C COMPUTE MEAN POLE AT INTEGER FMJD AFTER
        EPOCH=(INT(FMJDMP)+1-51544)/365.25D0+2000.0D0
        CALL IERS_CMP_2015( POLECONV, EPOCH, XRATE, YRATE, IERR )
        IF( IERR .LT. 0 ) GOTO 250
C COMPUTE MEAN POLE AT INTEGER FMJD BEFORE
        EPOCH=(INT(FMJDMP)+0-51544)/365.25D0+2000.0D0
        CALL IERS_CMP_2015( POLECONV, EPOCH, XMEAN, YMEAN, IERR )
        IF( IERR .LT. 0 ) GOTO 250
        XRATE=(XRATE-XMEAN)
        YRATE=(YRATE-YMEAN)
C COMPUTE MEAN POLE AT FMJD
        EPOCH=(FMJDMP-51544)/365.25D0+2000.0D0
        CALL IERS_CMP_2015( POLECONV, EPOCH, XMEAN, YMEAN, IERR )
        IF( IERR .LT. 0 ) GOTO 250
        IF( IERR .NE. 0 )
     &    WRITE(LUO,*) 'RDERP WARNING: MEAN POLE EXTENSION :',POLECONV
        XMPDIF=IX*1.D-6
        YMPDIF=IY*1.D-6
        XMPDRT=IXRT*1.D-6
        YMPDRT=IYRT*1.D-6
        XMPDIF=XMPDIF-XMEAN
        YMPDIF=YMPDIF-YMEAN
        XMPDRT=XMPDRT-XRATE
        YMPDRT=YMPDRT-YRATE
        IERP=1
      ENDIF
      GO TO 210
  250 CONTINUE
      RETURN
C
C-----------------------------------------------------------------------
C               FORMAT STATEMENTS
C-----------------------------------------------------------------------
C
10000 FORMAT(A160)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDFLT
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDFLT( LUFLT, FLTPAR, IPC, IFLTON, IC1USE, IC2USE, 
     &                  IDCBUSE,
     &                  VSCALE, SDPR, SDCLK )
C
C     NAME              RDFLT
C
C     PURPOSE   READ OBSERVATION FILTER PARAMETERS
C
C     PARAMETERS        DESCRIPTION
C
C        LUFLT        LOGICAL UNIT OF FILE WITH FILTER PARAMETERS 
C          FLTPAR(1)    FILTER DELTA NARROWLANE TRESHOLD 
C          FLTPAR(2)    FILTER DELTA WIDELANE TRESHOLD
C          FLTPAR(3)    FILTER INITIAL AMBIGUITY TRESHOLD 
C          FLTPAR(4)    FILTER DELTA CODE-PHASE TRESHOLD 
C          FLTPAR(5)    FILTER DELTA TIME TRESHOLD
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4 LUFLT, IPC, IFLTON, IC1USE, IC2USE, IDCBUSE
      REAL*8    FLTPAR(*), VSCALE, SDPR
      REAL*8    SDCLK
C
      CHARACTER*160 RECORD
      CHARACTER*3 HDR
      INTEGER*4 I
C
        IPC=1
      IFLTON=1
      VSCALE=1.D0
        FLTPAR(1)=20.D0
        FLTPAR(2)=500.D0
      FLTPAR(3)=300.D0
        FLTPAR(4)=200.D0
        FLTPAR(5)=300.D0
  100 CONTINUE
      READ(LUFLT,'(A)',END=500) RECORD
      READ(RECORD,'(A3)',ERR=400) HDR
      IF ( HDR .EQ. 'FLT' ) THEN 
c!      WRITE(*,*) RECORD
        READ(RECORD(4:),*, END=400) (FLTPAR(I), I=1,5), IPC, IFLTON,
     &                       IC1USE, IDCBUSE, VSCALE, SDCLK, IC2USE
      END IF
      GO TO 100
  400 CONTINUE
      WRITE(*,*) 'ERROR ENCOUNTERED READING ', RECORD
      GO TO 100      
  500 CONTINUE
      DO I=1,4
        FLTPAR(I)=FLTPAR(I)/1.D2
      END DO
C
C     IF LESS THAN 3*STANDARD DEVIATION ON PSEUDORANGE (SDPR) 
C     SET WIDELANE AND AMBIGUITY TRESHOLDS TO 3*SDPR
C 
      IF ( SDCLK .GT. 0 ) SDCLK=SDCLK/1.D15
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDFMT
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
        SUBROUTINE RDFMT (LUIN, IFMT, IEND)
C
C       NAME            RDFMT
C
C       PURPOSE         READ RECORD AND DETERMINE FILE FORMAT
C
C       PARAMETERS      DESCRIPTION
C
C          LUIN         LOGICAL UNIT OF INPUT FILE
C          IFMT         FORMAT OF INPUT DATA
C                       1 = RINEX
C                       2 = ROGUE
C          IEND         END OF FILE FLAG
C
C
C       VERSION/DATE    1.0 /P. HEROUX / FEBRUARY 1991
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4 LUIN, IFMT, IEND
C
      CHARACTER  IREC*80
      CHARACTER  ITYP*2
      INTEGER*4 IOS
C
      IEND=0
C
      READ(LUIN,20000,IOSTAT=IOS,END=500) IREC
      ITYP = IREC(1:2)
C
C     IF FIRST RECORD, DETERMINE FILE FORMAT
C
      IF ( ITYP .EQ. '  ' ) IFMT = 1
      IF ( ITYP .EQ. '--' ) IFMT = 2
      IF ( IFMT .EQ. 0 ) GO TO 500
      RETURN
C
C     UNKNOWN FORMAT
C
  500 CONTINUE
      WRITE(*,*) ' UNKNOWN FILE FORMAT, PROGRAM END '
      IEND = 1
      RETURN
C
20000 FORMAT ( A80 )
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDHDR
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDHDR ( IFMT, LUMEA, IYEAR, IMTH, IDAYM, STNA,
     &                   OBSINT, NOBTYP, IOBPOS, DLAY12, NFREQ, IFREQ, 
     &                   HDXYZH, ANTNAM, RECNAM, RIFRATE, IEOF )
C
C     NAME:      RDHDR
C
C     PURPOSE:   READ HEADER INFORMATION
C
C     PARAMETERS        DESCRIPTION
C
C        IFMT   FORMAT OF INPUT DATA
C        LUMEA  LOGICAL UNIT OF MEASUREMENT FILE
C        IYEAR  YEAR OF DATA COLLECTION
C        IMTH   MONTH OF DATA COLLECTION
C        IDAYM  DAY OF MONTH OF DATA COLLECTION
C        STNA   NAME OF STATION OBSERVED
C        OBSINT DATA RATE
C        NOBTYP NUMBER OF OBSERVATION TYPES (RNX ONLY)
C        IOBPOS POSITION OF L1, L2, P1 & P2 OBSERVATIONS
C        DLAY12 RECEIVER INTER FREQUENCY DELAY (SEC.)
C        NFREQ  NUMBER OF OBSERVED FREQUENCIES
C          HDXYZH       APPROXIMATE RECEIVER COORDINATES & ANTENNA HEIGHT
C          ANTNAM       ANTENNA NAME
C        IEOF   END OF FILE FLAG
C
C *********************************************************************
C
      IMPLICIT NONE
C
      CHARACTER    STNA*40
      CHARACTER    ANTNAM*20
      CHARACTER    RECNAM*20
      INTEGER*4    IFMT,LUMEA,IYEAR,IMTH,IDAYM,IEOF
      INTEGER*4    IOBPOS(*),NOBTYP,NFREQ, IFREQ
      REAL*8       DLAY12,HDXYZH(*),OBSINT
C
      CHARACTER    RECORD*80
      INTEGER*4 IEP,NRSV,NINTVL,INTVL,INTLAST
      INTEGER*4 NEPO,IYEPO,IMEPO,IDEPO,IHREPO,IMNEPO,I,J
      REAL*8    SECEPO,EPO,EPOLAST,EPODT
C GLONASS INTER FREQ DCB RATE ARRAY - RIFDCB (ns/ch)
      CHARACTER IFDCB*20
      REAL*8 RIFDCB, RIFRATE
      DIMENSION  IFDCB(40), RIFDCB(40)
C TABLE 4, From THE 2013 GLNS INER FQCY BIAS REPORT       
      DATA    IFDCB( 1)/'AOAD/M_T        NONE'/, RIFDCB( 1)/ -1.43/,
     &  IFDCB( 2)/'AOAD/M_T        AUST'/, RIFDCB( 2)/ -1.23/,
     &  IFDCB( 3)/'AOAD/M_B        OSOD'/, RIFDCB( 3)/  1.06/,
     &  IFDCB( 4)/'AOAD/M_TA_NGS   NONE'/, RIFDCB( 4)/ -0.63/,
     &  IFDCB( 5)/'ASH700936E_C    SNOW'/, RIFDCB( 5)/  0.56/,
     &  IFDCB( 6)/'ASH700936D_M    NONE'/, RIFDCB( 6)/  0.60/,
     &  IFDCB( 7)/'ASH700936A_M    SNOW'/, RIFDCB( 7)/  0.20/,
     &  IFDCB( 8)/'ASH701073.1     SCIS'/, RIFDCB( 8)/ -1.39/,
     &  IFDCB( 9)/'ASH701941.B     SNOW'/, RIFDCB( 9)/  0.26/,
     &  IFDCB(10)/'ASH701946.2     SCIS'/, RIFDCB(10)/  1.29/,
     &  IFDCB(11)/'ASH701945B_M    SNOW'/, RIFDCB(11)/ -0.10/,
     &  IFDCB(12)/'ASH701945C_M    NONE'/, RIFDCB(12)/  0.95/,
     &  IFDCB(13)/'ASH701945E_M    NONE'/, RIFDCB(13)/ -0.27/,
     &  IFDCB(14)/'ASH701945G_M    NONE'/, RIFDCB(14)/  0.74/,
     &  IFDCB(15)/'JAVRINGANT_DM   NONE'/, RIFDCB(15)/ -1.35/,
     &  IFDCB(16)/'JAVRINGANT_DM   JVDM'/, RIFDCB(16)/  0.11/,
     &  IFDCB(17)/'JAV_RINGANT_G3T NONE'/, RIFDCB(17)/ -0.39/,
     &  IFDCB(18)/'JAV_RINGANT_G3T JVDM'/, RIFDCB(18)/ -0.49/,     
     &  IFDCB(19)/'JPSREGANT_DD_E1 NONE'/, RIFDCB(19)/ -0.82/,
     &  IFDCB(20)/'JPSREGANT_SD_E1 NONE'/, RIFDCB(20)/  0.50/,
     &  IFDCB(21)/'LEIAR25.R3      NONE'/, RIFDCB(21)/ -1.25/,
     &  IFDCB(22)/'LEIAR25.R3      LEIS'/, RIFDCB(22)/ -1.25/,
     &  IFDCB(23)/'LEIAR25.R3      LEIT'/, RIFDCB(23)/ -1.25/,
     &  IFDCB(24)/'LEIAX1202GG     NONE'/, RIFDCB(24)/ -1.25/,
     &  IFDCB(25)/'LEIAX1202GG     LEIS'/, RIFDCB(25)/ -1.25/,
     &  IFDCB(26)/'LEIAT504GG      NONE'/, RIFDCB(26)/ -1.25/,
     &  IFDCB(27)/'TPSCR3_GGD      CONE'/, RIFDCB(27)/  0.44/,
     &  IFDCB(28)/'TPSCR3_GGD      NONE'/, RIFDCB(28)/  0.20/,
     &  IFDCB(29)/'TRM55971.00     NONE'/, RIFDCB(29)/  0.89/,
     &  IFDCB(30)/'TRM29659.00     NONE'/, RIFDCB(30)/  1.35/,
     &  IFDCB(31)/'TRM59800.00     NONE'/, RIFDCB(31)/  0.97/,
     &  IFDCB(32)/'TRM59800.00     SCIS'/, RIFDCB(32)/  0.92/,
     &  IFDCB(33)/'NOV750.R4       NONE'/, RIFDCB(33)/  0.60/,
     &  IFDCB(34)/'NOV702GG        NONE'/, RIFDCB(34)/ -1.70/,
     &  IFDCB(35)/'                    '/, RIFDCB(35)/  0.00/,
     &  IFDCB(36)/'                    '/, RIFDCB(36)/  0.00/,
     &  IFDCB(37)/'                    '/, RIFDCB(37)/  0.00/,
     &  IFDCB(38)/'                    '/, RIFDCB(38)/  0.00/,
     &  IFDCB(39)/'                    '/, RIFDCB(39)/  0.00/,
     &  IFDCB(40)/'                    '/, RIFDCB(40)/  0.00/
        RIFRATE = 0.D0 
C
      STNA='XXXX'
      NEPO=0
      NINTVL=0
      INTLAST=0
      EPOLAST=0.D0
      OBSINT=0.D0
      IYEAR=0
      IMTH=0
      IDAYM=0
      IF ( IFMT .EQ. 1 ) THEN
        CALL HDRNX (LUMEA, IYEAR, IMTH, IDAYM, STNA,
     &              OBSINT, NOBTYP, IOBPOS, NFREQ, HDXYZH, ANTNAM,
     &              RECNAM, IFREQ, IEOF )
C       determine GLONASS inter channel rate (RIFRATE)
        DO I=1,40
         IF (ANTNAM.EQ. IFDCB(I)) RIFRATE= RIFDCB(I)
        ENDDO 
        write (*,*) "RIFRATE =", RIFRATE
C
C       DETERMINE INTERVAL IF NOT FOUND IN HEADER
C
        IF ( IEOF .NE. 0 )  GOTO 200
        IF ( OBSINT .EQ. 0.D0 )  THEN
  100       CONTINUE
            READ(LUMEA,'(A80)',ERR=100,END=200) RECORD
            READ(RECORD,1000,ERR=100,END=200) IYEPO, IMEPO, IDEPO,
     &                                   IHREPO, IMNEPO, SECEPO, 
     &                                   IEP, NRSV
            DO I=1,(NRSV-1)/12
           READ(LUMEA,'(A80)',ERR=100,END=200) RECORD
          ENDDO
            DO I=1,NRSV
              READ(LUMEA,'(A80)',ERR=100,END=200) RECORD
            IF( IEP .LE. 1 ) THEN
            DO J=1,(NOBTYP-1)/5
             READ(LUMEA,'(A80)',ERR=100,END=200) RECORD
            END DO
            ENDIF
            END DO
            EPO=IHREPO*3600.D0+IMNEPO*60.D0+SECEPO
          NEPO=NEPO+1
C
C           
            IF ( NEPO .EQ. 1 ) THEN
              EPOLAST=EPO
            GO TO 100
            ELSE
            NINTVL=NINTVL+1
              EPODT=EPO-EPOLAST
              IF (EPODT .LT. 0.D0) EPODT=EPODT+86400.D0
              INTVL = INT(EPODT*1000+.5)
            IF (NINTVL .EQ. 1) THEN
              INTLAST = INTVL
            EPOLAST = EPO
            GO TO 100
            ELSE
c!            WRITE(*,*) INTVL,INTLAST
              IF ( INTVL .EQ. INTLAST ) THEN
                  REWIND(LUMEA)
                  CALL HDRNX (LUMEA, IYEAR, IMTH, IDAYM, STNA,
     &              OBSINT, NOBTYP, IOBPOS, NFREQ, HDXYZH, ANTNAM,
     &              RECNAM, IFREQ, IEOF )
                  IF (INTVL .NE. 0) OBSINT=INTVL/1000.D0
                ELSE
              INTLAST=INTVL
              EPOLAST=EPO
              NINTVL=1
              GO TO 100
              END IF
              END IF
          END IF
        END IF
      END IF       
C
      RETURN
  200 CONTINUE
      IEOF=1
      RETURN
 1000 FORMAT(5I3,F11.7,2(1X,I2))
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDHRPS
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDHRPS(LUPR, LUOLD, UG, DTM, DMJDOL, TW,
     &                  NOCOF, AMPL, PHAS, IOLD)
C
C     NAME:      RDHRPS
C
C     PURPOSE:   READS OCEAN LOADING  COEFFICIENTS FROM HARPOS FORMAT
C                FILE (IF EXISTS) 
C                AND USES THE STATION WITHIN 10KM RADIUS (IF FOUND), 
C                OTHERWISE USES 0 AMPLITUDES (I.E. NO O LOADING)
C
C     PARAMETERS        DESCRIPTION
C
C       LUPR          PRINTOUT (SUM) FILE LU
C         LUOLD         HARPOS FORMAT OCEAN LOADING FILE
C         UG(3)         STATION XYZ GEOCENTRIC POSITION (M)    
C         DTM(7)        DATUM PARAMETERS (A, F, XYZ DATM SHIFT/OFFSET)
C         DMJDOL        REFERENCE TIME
C         TW            HARMONIC COMPONENTS READ
C         NOCOF         NO. OF OLOAD COEFFICIENTS
C         AMPL          INPUT AMPLITUDES + UP,  N , E (MM)
C         PHAS          INPUT PHASES (DEG) 
C         IOLD          OLOAD FLAG (=0 NO OLOAD COEF FOUND, 
C                                   =1 OLOAD COEF FOUND!
C                                   =-1 NOT HARPOS format try another)
C
      IMPLICIT NONE
      INCLUDE 'MAXDIM'
C
      INTEGER*4 LUPR, LUOLD, NOCOF, IOLD
      REAL*8    AMPL(4,*), PHAS(4,*), UG(*), DTM(*), DMJDOL
      CHARACTER*3 TW(*)
C
      INTEGER*4 I,J
      REAL*8    DRAD,TSTDIS,XT(3),COSU,COSN,COSE,SINU,SINN,SINE
      CHARACTER*80 STR
C
C Test HARPOS format
C
      READ(LUOLD,'(A80)',END=1000,ERR=1000) STR
      IF( STR(1:13) .NE. 'HARPOS Format' ) GOTO 2000
C
C Zero amplitudes and phases arrays
C
      DRAD = 0.0174532925D0 
      IOLD=0
      NOCOF=0
      DO I=1,4
      DO J=1,MAXOTLC
         AMPL(I,J)=0.D0
       PHAS(I,J)=0.D0
      END DO
      END DO
C
C Look for Harmonic definition records (H)
C
500   CONTINUE
      READ(LUOLD,'(A80)',END=1000,ERR=1000) STR
      IF (STR(1:2) .NE. 'H ' ) GOTO 500
C
C Load Harmonic definition
C
      NOCOF=0
510   CONTINUE
      IF ( NOCOF .LT. MAXOTLC ) THEN
        NOCOF=NOCOF+1
        READ(STR,'(3X,A3,7X,D13.6,2X,D19.12)',ERR=1000)
     &      TW(NOCOF),PHAS(4,NOCOF),AMPL(4,NOCOF)
      PHAS(4,NOCOF)=PHAS(4,NOCOF)/DRAD
      AMPL(4,NOCOF)=AMPL(4,NOCOF)*3600.D0
      END IF
520   CONTINUE
      READ(LUOLD,'(A80)',END=1000,ERR=1000) STR
      IF (STR(1:2) .EQ. 'H ' ) GOTO 510
C
C Look for Site definition records (S) until within 10Km of station
C
600   CONTINUE
      READ(LUOLD,'(A80)',END=1000,ERR=1000) STR
      IF (STR(1:2) .NE. 'S ' ) GOTO 600
      READ(STR,'(12X,3(1X,F13.4))',ERR=1000) (XT(I),I=1,3)
      TSTDIS=SQRT((UG(1)-XT(1))**2+(UG(2)-XT(2))**2+(UG(3)-XT(3))**2)
      IF(TSTDIS.GT.1.D4) GOTO 600
C
C Look for Displacement definition records (D)
C
700   CONTINUE
      READ(LUOLD,'(A80)',END=1000,ERR=1000) STR
      IF ( STR(1:1) .EQ. '#' ) GOTO 700
      IF ( STR(1:2) .NE. 'D ' ) GOTO 600
C
C Load Displacement definition
C
      DO I=1,3
      DO J=1,MAXOTLC
         AMPL(I,J)=0.D0
       PHAS(I,J)=0.D0
      END DO
      END DO
      J=0
710   CONTINUE
      READ(STR,'(21X,2(2X,3(1X,F8.5)))',ERR=1000)
     &                 COSU,COSE,COSN,SINU,SINE,SINN
      IF ( J .LT. MAXOTLC ) THEN
        J=J+1
        AMPL(1,J)=SQRT(COSU*COSU+SINU*SINU)*1.D3
        AMPL(2,J)=SQRT(COSE*COSE+SINE*SINE)*1.D3
        AMPL(3,J)=SQRT(COSN*COSN+SINN*SINN)*1.D3
        IF( AMPL(1,J).NE.0.D0 ) PHAS(1,J)=ATAN2(SINU,COSU)/DRAD
        IF( AMPL(2,J).NE.0.D0 ) PHAS(2,J)=ATAN2(SINE,COSE)/DRAD
        IF( AMPL(3,J).NE.0.D0 ) PHAS(3,J)=ATAN2(SINN,COSN)/DRAD
      IF( PHAS(1,J).LT.0.D0 ) PHAS(1,J)=PHAS(1,J)+360.D0
      IF( PHAS(2,J).LT.0.D0 ) PHAS(2,J)=PHAS(2,J)+360.D0
      IF( PHAS(3,J).LT.0.D0 ) PHAS(3,J)=PHAS(3,J)+360.D0
      END IF
720   CONTINUE
      READ(LUOLD,'(A80)',END=1000,ERR=1000) STR
      IF (STR(1:2) .EQ. 'D ' ) GOTO 710
C
C If data incomplete look for another site
C
      IF ( J .LT. NOCOF ) GOTO 600
C
C Found Model. Clear remaining array
C
      IOLD=1
      DMJDOL=51544.5D0
      DO J=NOCOF+1,MAXOTLC
      DO I=1,4
         AMPL(I,J)=0.D0
       PHAS(I,J)=0.D0
      END DO
      END DO
      RETURN
C
C Format problems or premature end of file
C
1000  CONTINUE
      REWIND(LUOLD)
      IOLD=0
      RETURN
C
C Not HARPOS format
C
2000  CONTINUE
      REWIND(LUOLD)
      IOLD=-1
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDIPX
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDIPX( LUIPX, IPXR, UTTAG, NFPAR, XRVEPO, NSVAMB, 
     &                  ISVAMB, CPAMB, PX, NSVO, ISVO, FLTSUM,
     &                  TWUPCOR, PWUPCOR, NCSLIP15, ICSLIP15, PL,
     &                  EL, HORDION, FLTPAR,
     &                  LFIXNL, LFIXWL, DMXNLSAV, DMXWLSAV,
     &                  IRLEASE )
C
C     NAME              RDIPX
C
C     PURPOSE   READ INITIAL PARAMETER AND VARIANCE ESTIMATES
C
C     PARAMETERS        DESCRIPTION
C
C        LUIPX  LOGICAL UNIT OF INITIAL ESTIMATES
C          UTTAG        EPOCH OF ESTIMATES
C          NSVO         NUMBER OF SATELLITES
C          ISVO         SATELLITE PRN NUMBERS
C          XRVEPO       EPOCH STATION PARAMETERS
C          CPAMB        SATELLITE PHASE AMBIGUITIES
C          PX           EPOCH WEIGHTS
C          NSVO         LAST OBSERVED SATELLITES NUMBER
C          ISVO         LAST OBSERVED SATELLITE LIST
C          FLTSUM       OBSERVATION FILTER INFO
C          TWUPCOR      PHASE WINDUP INFO
C          PWUPCOR      PHASE WINDUP INFO
C          NCSLIP15     CYCLE SLIP FLAG OVERALL
C          ICSLIP15     CYCLE SLIP FLAG PER SATELLITE
C          PL           OBSERVATION WEIGHTS MATRIX
C          HORDION      2ND ORDER IONO CORRECTION STATE
C          IRLEASE      RELEASE NUMBER IDENTIFICATION
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4     LUIPX
      INTEGER*4     NPAR, NFPAR, NSVO, ISVO(*), IPXR, I, J
      INTEGER*4     NSVAMB, ISVAMB(*), IOBTYP
      INTEGER*4     NCSLIP15, ICSLIP15(*)
      REAL*8    FLTSUM(MAXFLT,MAXSAT)
      REAL*8    UTTAG, XRVEPO(*), CPAMB(*)
      REAL*8    PX(MAXPAR2,MAXPAR2) 
      REAL*8    PL(MAXOBS2,MAXOBS2) 
      REAL*8    TWUPCOR(*), PWUPCOR(*)
      LOGICAL*4 LFIXNL, LFIXWL
      REAL*8    DMXNLSAV, DMXWLSAV, FLTPAR(*)
      REAL*8    EL(*),HORDION(*) 
      INTEGER*4 IRLEASE
      REAL*8    SDPR, SDCP
      INTEGER*4 ID
     &         ,NSVO2
C
      IPXR=0
C
  100 CONTINUE
c!    WRITE(*,*) 'READING LUIPX'
C CHECK RELEASE OF INPUT
      READ(LUIPX,ERR=400,END=500) ID
      IF( ID .NE. IRLEASE ) THEN
        WRITE(*,*) 'ERROR MISMATCH ID OF IPX FILE ',
     &             ID, ' WITH ',IRLEASE,' EXPECTED'
        RETURN
      ENDIF
      READ(LUIPX,ERR=400,END=500) UTTAG, NFPAR, NSVAMB,NSVO2
      NPAR=NFPAR+NSVAMB
      READ(LUIPX,ERR=400,END=500) (XRVEPO(I),I=1,NFPAR)
      READ(LUIPX,ERR=400,END=500) (ISVAMB(I),EL(I),CPAMB(ISVAMB(I)),
     &                               I=1,NSVAMB)
      READ(LUIPX,ERR=400,END=500) ((PX(I,J),J=I,NPAR),I=1,NPAR)
      DO I=1,NPAR
        DO J=I,NPAR
        PX(J,I)=PX(I,J)
        END DO
      END DO
      READ(LUIPX,ERR=400,END=500) ((PL(I,J),J=I,NSVO2),I=1,NSVO2)
      DO I=1,NSVO2
        DO J=I,NSVO2
        PL(J,I)=PL(I,J)
        END DO
      END DO
      READ(LUIPX,ERR=400,END=500) IOBTYP, SDPR, SDCP
C
C     INITIALIZE OBSERVATION WEIGHTS
C 
      DO I = NSVO2+1,MAXOBS2
        DO J = 1,MAXOBS2
        PL(J,I) = 0.0D0
        PL(I,J) = 0.0D0
        END DO
        PL(I,I) = 1.0D0/SDPR**2
C   
C       CODE & CARRIER PROCESSING - INITIALIZE CARRIER WEIGHTS 
C
        IF (IOBTYP .EQ. 2 .AND. MOD(I,2) .EQ. 0) THEN
          PL(I,I) = 1.0D0/(SDCP    )**2
        END IF
      END DO
      READ(LUIPX,ERR=400,END=500) 
     &           ((FLTSUM(J,I),J=1,MAXFLT),I=1,MAXSAT)
      READ(LUIPX,ERR=400,END=500) 
     &           (TWUPCOR(I), PWUPCOR(I),I=1,MAXSAT)
      READ(LUIPX,ERR=400,END=500) NCSLIP15,(ICSLIP15(I), I=1,MAXSAT)
      READ(LUIPX,ERR=400,END=500) LFIXNL, LFIXWL, DMXNLSAV, DMXWLSAV,
     &               (FLTPAR(I),I=1,MAXFLT)
      READ(LUIPX,ERR=400,END=500) (HORDION(I), I=1,MAXHOION)
      IPXR=1
c!    WRITE(*,*) UTTAG, NFPAR, NSVO
c!    WRITE(*,*) (XRVEPO(I),I=1,NFPAR)
c!    WRITE(*,*) (ISVAMB(I),CPAMB(ISVAMB(I)),I=1,NSVAMB)
c!    WRITE(*,*) ' PX AND FLTSUM IN RDIPX', IPXR
c!    WRITE(*,'(15F5.3)') (PX(I,I),I=1,NPAR)  
c!    WRITE(*,*) NSVO
c!    WRITE(*,*) (ISVO(I),(FLTSUM(J,ISVO(I)),J=1,MAXFLT),I=1,NSVO)
c!    WRITE(*,*) (TWUPCOR(I), PWUPCOR(I), I=1,MAXSAT)
      RETURN
  400 CONTINUE
      WRITE(*,*) 'ERROR ENCOUNTERED READING IPX FILE'
      RETURN
  500 CONTINUE
      WRITE(*,*) 'EOF ENCOUNTERED'       
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDMET
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDMET( LU, LUO, LUMET, IYOBS, IMOBS, IDOBS,  
     &       METSRC,
     &       TEMP, PRES, RH, TROSCL, PH, COEFMF, STNA, LNG )
C
C     NAME              RDMET
C
C     PURPOSE   READ MET FILE
C
C     PARAMETERS        DESCRIPTION
C
C        LU             LOGICAL UNIT OF INPUT
C        LUO            LOGICAL UNIT OF OUTPUT
C        LUMET  LOGICAL UNIT OF MET FILE
C          TEMP         TEMPERATURE (Deg. C)
C          PRES         PRESSURE (Millibar)
C          RH           RELATIVE HUMIDITY (%)
C          TROSCL       TROPOSPHERIC SCALE FACTOR
C          PH           ELLIPSOIAL HEIGHT (m)
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4 LU, LUO, LUMET, IYOBS, IMOBS, IDOBS, LNG
     &       ,METSRC(*)
      REAL*8    TEMP, PRES, RH, TROSCL, PH(3), UNDU, DMJD
C
      CHARACTER*15    SRCMET(6),SRCMETE(6),SRCMETF(6)
      REAL*8 DTEMP         
      CHARACTER*45    METHD(4)
      CHARACTER*45    METHDE(4)
      CHARACTER*45    METHDF(4)
      INTEGER*4       NMET,MAGEMET,I,IDOY,IWKOBS,IDWKOBS,IDATEO
      INTEGER*4       IYMET,IMMET,IDMET,IWKMET,IDWKMET,IDATEM
      INTEGER*4       IAGEMET, MJDS, MJD, J
      CHARACTER*40    STNA, STNAIN
C    ARRAY FOR VMF1 & IMF MAPPING FUNCTIONS (UP TO 5 6-hour epochs I)
C     vmf1  - COEFMF(I,MJD,   Ah,     Aw,     ZPDry,     ZPDw, KTemp) 
C     imf   - COEFMF(I,MJD, H200, Wratio, GradAlpfa, GradIncl, Ktemp)
      REAL*8          COEFMF(5,6), FMJD, ARG
      REAL*8          UPMET, DEFMET(4), USRMET(4)
      REAL*8 POS(3,1),VAL(7,1)
C
      DATA    SRCMETE/'Default        ',
     &                'GPT            ',
     &                'VMF1           ',
     $                'GPT2           ',
     $                'Local/File     ',
     $                'Local/Keyed-in '/
      DATA    SRCMETF/'Defaut         ',
     &                'GPT            ',
     &                'VMF1           ',
     $                'GPT2           ',
     $                'Local/Fichier  ',
     $                'Local/Entree   '/
      DATA METHDE /'1. Temperature        (deg C)',
     &             '2. Pressure           (Mb)',
     &             '3. Relative humidity  (%)  ',
     &             '4. Tropospheric scale '/
      DATA METHDF /'1. Temperature        (deg C)',
     &             '2. Pression           (Mb)',
     &             '3. Humidite relative  (%)  ',
     &             '4. Echelle tropospherique  '/
      DATA NMET /4/
      DO I=1,5
       METSRC(I)=1
      END DO
C
      MAGEMET=0
      IF( LNG .GT. 0 ) THEN
      DO I=1,NMET
        IF (LNG .EQ. 1) METHD(I)=METHDE(I)
        IF (LNG .EQ. 2) METHD(I)=METHDF(I)
      END DO
      END IF
C
C-----------------------------------------------------------------------
C     OPEN AND READ MET FILE 
C-----------------------------------------------------------------------
C
      CALL JLIAN ( MJDS, IYOBS, IMOBS, IDOBS)
      CALL GPSDC ( IDOY, IYOBS, IMOBS, IDOBS, IWKOBS, IDWKOBS, 2)
      IDATEO=IWKOBS*7+IDWKOBS
      DMJD= MJDS 
      IF ( PH(3) .GT. -30.D0 .AND. PH(3).LT.100000.0) THEN
      CALL GPT(DMJD, PH(1), PH(2), PH(3), PRES, TEMP, UNDU)
      DEFMET(1) = TEMP 
      DEFMET(2) = PRES
      METSRC(1)=2
      METSRC(2)=2
      ELSE
      DEFMET(1) = 20.D0
      DEFMET(2) = 1000.D0
      ENDIF
      DEFMET(3) = 50.D0
      DEFMET(4) = 1.D0
C 
  110 CONTINUE
      READ(LUMET,*,END=250,ERR=200) 
     &   (IYMET,IMMET,IDMET, USRMET(I), I=1,NMET)
      CALL GPSDC ( IDOY, IYMET, IMMET, IDMET, IWKMET, IDWKMET, 2)
      IDATEM=IWKMET*7+IDWKMET   
      IAGEMET=IABS(IDATEO-IDATEM)
      IF (IAGEMET .LT. MAGEMET) THEN
        MAGEMET=IAGEMET
        DEFMET(1) = USRMET(1)
        DEFMET(2) = USRMET(2)
        DEFMET(3) = USRMET(3)
        DEFMET(4) = USRMET(4)
        METSRC(1)=5
        METSRC(2)=5
        METSRC(3)=5
      END IF
      GO TO 110
C
C-----------------------------------------------------------------------
C     DISPLAY MET VALUES TO SCREEN
C-----------------------------------------------------------------------
C
  200 CONTINUE
      I=0
C     TRY vmf1/imf input format 
      BACKSPACE(LUMET)
210   READ(LUMET,*,END=250,ERR=250) STNAIN 
      IF (STNAIN(1:4).EQ.STNA(1:4)) THEN
C      imf   - COEFMF(I,MJD, H200, Wratio, GradAlpfa, GradIncl, Ktemp)
          BACKSPACE(LUMET)
          READ(LUMET,*,END=250,ERR=250) 
     &    STNAIN, FMJD, (USRMET(J), J=1,NMET),UPMET  
          MJD= INT(FMJD+1.d-3) 
          IF(I.EQ.0.AND.MJDS.LT.MJD) GO TO 250
          MJD= INT(FMJD+1.d-3) - MJDS
          IF(MJD.GE.0.AND.MJD.LE.1.AND.I.LE.4) THEN
            IF(USRMET(1).LT.1.d0) THEN
C      vmf1 format!
C      vmf1  - COEFMF(I,MJD,   Ah,     Aw,     ZPDry,     ZPDw, KTemp) 
              BACKSPACE(LUMET) 
              READ(LUMET,*,END=250,ERR=250) 
     &         STNAIN, FMJD, (USRMET(J), J=1,NMET),UPMET, PRES, TEMP, RH
              IF(I.EQ.0) THEN
C set default met to the first vmf1 iput temp,pres & ew
                IF(PRES.NE.0.d0) THEN
             DEFMET(2) = PRES 
                 METSRC(2)=3
            ENDIF
                IF(UPMET.EQ.0.d0) THEN
             TEMP= DEFMET(1)
            ELSE
                 METSRC(1)=3
            ENDIF
                DEFMET(1) = TEMP 
                TEMP = TEMP + 273.0D0
C compute Rel hum 
                 ARG = -37.2465D0 +.213166D0*TEMP-.256908D-3*TEMP**2
                 IF(RH.GT.0.d0) THEN
              DEFMET(3) = 100.D0*RH/EXP(ARG) 
                  METSRC(3)=3
                 ENDIF
              ENDIF
              METSRC(5)=4
              IF(UPMET.EQ.0.D0) METSRC(5)=3
            ELSE
              METSRC(5)=2
          ENDIF
            I=I+1
            COEFMF(I,1)= FMJD
            DO J=1,4
              COEFMF(I,J+1)= USRMET(J)
            ENDDO
            COEFMF(I,6)= UPMET
            IF(I.GE.5) GO TO 250
          ENDIF
       END IF
C
C TRY THE GPT2 GRID
       IF (STNAIN(1:1).EQ.'%') THEN
C gpt2 grid found!!! call gpt2
        backspace(LUMET)
        POS(1,1) = PH(1)
        POS(2,1) = PH(2)
        POS(3,1) = PH(3)
        call gpt2 (dmjd,pos(1,1),pos(2,1),pos(3,1),1,0,
     &          val(1,1),val(2,1),val(3,1),val(4,1),
     &          val(5,1),val(6,1),val(7,1))
        pres=val(1,1)
        Temp=val(2,1)
        dTemp=val(3,1)
        rh=val(4,1)
        coefmf(1,2)=val(5,1)
        coefmf(1,3)=val(6,1)
        undu=val(7,1)
        DEFMET(1) = TEMP
        DEFMET(2) = PRES
        TEMP = TEMP + 273.0D0
C COMPUTE DRY & WET ZPD, SEE TROPO SUBROUTINE MODEL 2
        COEFMF(1,4) = 2.2768D-3*PRES/
     &                    (1.D0 - 2.66D-3*DCOS(2.D0*PH(1))-.28D-6*PH(3))
        ARG=  62.00D0*(TEMP -88.259D0)
        COEFMF(1,5) = 7.46512D-02*RH /TEMP **2* ARG
C compute Rel hum 
        ARG = -37.2465D0 +.213166D0*TEMP-.256908D-3*TEMP**2
        IF(RH.GT.0.d0) THEN
           DEFMET(3) = 100.D0*RH/EXP(ARG)
           METSRC(3)=4
        ENDIF
        METSRC(1)=4
        METSRC(2)=4
        METSRC(5)=5
C SIMULATE GRIDDED VMF1 (COEFMF(*,6)=0 (INVOKES THE AH HEIGHT CORR!) 
        FMJD= DMJD
        DO i=1,5
          COEFMF(I,1)= FMJD
          DO J=2,5
            COEFMF(I,J)= COEFMF(1,J)
          END DO
          COEFMF(I,6)= 0.D0       
          FMJD= FMJD+ 0.25D0 
        ENDDO
        GOTO 250
       ENDIF
      GOTO 210
  250 CONTINUE
      DO I=1,4
        IF (LNG .EQ. 1) SRCMET(I)=SRCMETE(METSRC(I))
        IF (LNG .EQ. 2) SRCMET(I)=SRCMETF(METSRC(I))
      END DO
  260 CONTINUE
      IF( LNG .GT. 0 ) THEN
      WRITE(LUO,20000)  METHD(1), DEFMET(1),SRCMET(1)
      WRITE(LUO,20000)  METHD(2), DEFMET(2),SRCMET(2)
      WRITE(LUO,20000)  METHD(3), DEFMET(3),SRCMET(3)
      WRITE(LUO,20000)  METHD(4), DEFMET(4),SRCMET(4)
      END IF
C
C-----------------------------------------------------------------------
C     MAKE DESIRED MODIFICATIONS
C-----------------------------------------------------------------------
C
      IF( LNG .GT. 0 ) THEN
       IF (LNG .EQ. 1) WRITE(LUO,20200)
       IF (LNG .EQ. 2) WRITE(LUO,20201)
       READ(LU,*) I, UPMET
       IF( I .GT. 0 .AND. I .LT. 5 ) THEN
      IF( METSRC(5) .LT. 3 ) THEN
         METSRC(I)=6
         IF (LNG .EQ. 1) SRCMET(I)=SRCMETE(METSRC(I))
         IF (LNG .EQ. 2) SRCMET(I)=SRCMETF(METSRC(I))
         DEFMET(I) = UPMET
        ELSE
       WRITE(LUO,*)
     &      ' *** WARNING *** '
       WRITE(LUO,*)
     &      ' *** WARNING *** Changes to item ',I,' not allowed. ***'
       WRITE(LUO,*)
     &      ' *** WARNING *** '
      END IF
        GO TO 260
       END IF
      END IF
C
C-----------------------------------------------------------------------
C     ASSIGN SELECTED OPTIONS TO OUTPUT VARIABLES
C-----------------------------------------------------------------------
C
  400 CONTINUE
      TEMP = DEFMET(1)
      PRES = DEFMET(2)
      RH   = DEFMET(3)
      TROSCL= DEFMET(4)
      IF(COEFMF(5,1).EQ.0.d0) THEN
C     Extrapolate the last (5th) epoch
        DO J=1,6
        COEFMF(5,J)= COEFMF(4,J) + COEFMF(4,J)-COEFMF(3,J)
        ENDDO
      ENDIF         
c!     write(*,*) stna, stnain, I, DEFMET
c!     write(*,*) MJDS, MJD, COEFMF
C
C-----------------------------------------------------------------------
C               FORMAT STATEMENTS
C-----------------------------------------------------------------------
C
19000 FORMAT(/,' THE FOLLOWING SURFACE METS WERE READ FROM FILE ',A80,/)
19001 FORMAT(/,' LES DONNEES METEO SUIVANTES ONT ETE LUES DU FICHIER ',
     &           A80,/)
20000 FORMAT( 1X,A45,F12.3,' ',A15 )
20200 FORMAT( ' ENTER OPTION AND NEW VALUE ',
     &            '(0,0 TO CONTINUE)' )
20201 FORMAT( "ENTREZ L'OPTION ET SA NOUVELLE VALEUR ",
     &            '(0,0 POUR CONTINUER)' )
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDOLC
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDOLC(LUPR, LUOLD, UG, DTM, DMJDOL, TW,
     &                 NOCOF, AMPL, PHAS, IOLD)
C
C     NAME:      RDOLC
C
C     PURPOSE:   READS OCEAN LOADING  COEFFICIENTS FROM FILE (IF EXISTS) 
C                AND USES THE STATION WITHIN 10KM RADIUS (IF FOUND), 
C                OTHERWISE USES 0 AMPLITUDES (I.E. NO O LOADING)
C
C     PARAMETERS        DESCRIPTION
C
C       LUPR          PRINTOUT (SUM) FILE LU
C         DMJD76        MJD of JAN 1, 1976 (EPOCH OF OLOAD COEFFICIENTS)
C         AMPL          INPUT AMPLITUDES + UP,  E , N (MM)
C         PHAS          IMPUT PHASES (DEG) 
C         UG(3)         STATION XYZ (M)    
C         DTM(7)        DATUM PARAMETERS (A, F, XYZ DATM SHIFT/OFFSET)
C         NOCOF         NO. OF OLOAD COEFFICIENTS
C         IOLD          OLOAD FLAG (=0 NO OLOAD COEF FOUND, 
C                                   =1 OLOAD COEF FOUND!
C                                   =-1 NOT HARPOS format)
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4 LUPR, LUOLD, NOCOF, IOLD
C
C AMPL(4,J) PHAS(4,j) contains frequency/phase of tidal term
C
      REAL*8    DMJDOL,AMPL(4,*), PHAS(4,*), UG(*), DTM(*)
      CHARACTER*3 TW(*)
C
      CHARACTER*8 TEST1, TEST2
      CHARACTER*3 IW(11)
      REAL*8      V(11),OMEGA(11)
      INTEGER*4 I,J,                    II,IGD,IGM,LDG,LMN
      REAL*8     DRAD,GSEC,SEL,TSTDIS,DM1,DM2,XT(3)
C
C Hard coded OTL components frequencies and phases
C
      DATA IW/'M2 ','S2 ','K1 ','O1 ','N2 ','P1 ',
     &        'K2 ','Q1 ','MF ','MM ','SSA'/
      DATA OMEGA/0.505868049736D0,
     &           0.523598775598D0,
     &           0.262516170785D0,
     &           0.243351878951D0,
     &           0.496366918746D0,
     &           0.261082604813D0,
     &           0.525032341570D0,
     &           0.233850747961D0,
     &           0.019164291834D0,
     &           0.009501130990D0,
     &           0.001433565972D0/
      DATA V/ 124.299584D0,
     &        359.999982D0,
     &        190.466469D0,
     &        293.833155D0,
     &        349.336207D0,
     &        169.533571D0,
     &        200.932918D0,
     &        158.869737D0,
     &        256.633297D0,
     &        314.963380D0,
     &         20.932898D0/
      DRAD = 0.0174532925D0 
      IOLD=0
C
C     SET AMPLITUDES & PHASES TO 0's
C
      DO I=1,4
      DO J=1,MAXOTLC
        AMPL(I,J)=0.d0
      PHAS(I,J)=0.d0
      END DO
      END DO
C
C Try HARPOS format (preferred since it is self contained)
C
      CALL RDHRPS(LUPR, LUOLD, UG, DTM,
     &            DMJDOL, TW, NOCOF, AMPL, PHAS, IOLD)
      IF ( IOLD .GE. 0 ) RETURN
      IOLD=0
C
C Try BLQ format
C
      CALL RDBLQ(LUPR, LUOLD, UG, DTM, 
     &           DMJDOL, TW, NOCOF, AMPL, PHAS, IOLD)
      IF ( IOLD .GE. 0 ) RETURN
      IOLD=0
C
C     FIND A STATION WITHIN 10KM OTHERWISE NO OCEN LOADING APOPLIED
C
      DO 122 II=1,1000
        READ(LUOLD ,'(61X,2I3,F7.3)',ERR=121,END=121)IGD,IGM,GSEC
        READ(LUOLD,'(I3,58X,2I3,F7.3)',ERR=121,END=121)
     &                                    NOCOF,LDG,LMN, SEL
      IF ( NOCOF .EQ. 0 )  NOCOF=9
        IF ( IGD .LT. 0 ) IGM=-IGM 
        IF ( IGD .LT. 0 ) GSEC=-GSEC 
        IF ( LDG .LT. 0 ) LMN=-LMN 
        IF ( LDG .LT. 0 ) SEL=-SEL 
        XT(1)=(DBLE(IGD)+ DBLE(IGM)/60.D0 +GSEC/3600.D0)* DRAD
        XT(2)=(DBLE(LDG)+ DBLE(LMN)/60.D0 + SEL/3600.D0)* DRAD
        XT(3)=0.d0
C       CONVERT ELLIPSOIDAL -> CARTESIAN, COMPUTE DISTANCE
        CALL PLXYZ1(DTM(3), DTM(4), DTM(5), DTM(1), DTM(2), XT)
        TSTDIS=SQRT((UG(1)-XT(1))**2+(UG(2)-XT(2))**2+(UG(3)-XT(3))**2)
C       FIND COEFFICIENRS (SPIROS LODSDP OUTPUT FORMAT)
        DO J=1,10
        READ(LUOLD,*,ERR=121,END=121) TEST1, TEST2
        IF(TEST1(1:5).EQ.'AMPL.'.AND. TEST2(1:5).EQ.'PHASE') GO TO 100
        END DO
C       READ OLOAD STATION COEF's
100     CONTINUE
        DO J=1,NOCOF
       IF ( J .LE. MAXOTLC ) 
     &    READ(LUOLD ,*,ERR=121,END=121) TW(J), DM1, DM2,
     &                                 AMPL(1,J),PHAS(1,J),
     &                                 AMPL(3,J),PHAS(3,J),
     &                                 AMPL(2,J),PHAS(2,J)
        END DO
        DMJDOL=51544.5D0
        DO J=1,NOCOF
        DO I=1,11
         IF ( TW(J) .EQ. IW(I) ) THEN
           AMPL(4,J)=OMEGA(I)
           PHAS(4,J)=V(I)
         END IF
        END DO
      END DO
C
C Clear unused components
C
        DO J=NOCOF,MAXOTLC
       DO I=1,4
           AMPL(I,J)=0.D0
         PHAS(I,J)=0.D0
       END DO
        END DO
C       STATION/COEFFICIENTS FOUND (<10 KM!) (IOLD=1)
        IF(TSTDIS.LE.1.D4) THEN    
          IOLD=1
          RETURN
        END IF
122   CONTINUE
121   CONTINUE
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDPCV
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
C
      SUBROUTINE RDPCV(LUPCV, ANTNAM, PCVNEU, PCVELV, PCVSAT,
     &   DSVX, DSVY, DSVZ, MAXSAT, IPCV, IYEARS, IMTHS, IDAYS, ISVBLK,
     &   FOUND22 , IFREQ)
C
C     NAME              RDPCV
C
C     PURPOSE   READ ANTENNA PHASE CENTER VARIATION (PCV) FILE
C
C     PARAMETERS        DESCRIPTION
C
C        LUPCV  LOGICAL UNIT OF PCV FILE
C          ANTNAM       ANTENNA NAME
C          PCVNEU       PHASE CENTER NORTH, EAST AND UP ECCENTRICITIES
C          PCVEL        ANTENNA PHASE CENTER ELEVATION TABLE
C                       ( 1-19) L1 PCV, 90->0 DEG, 5 DEG INTERVAL
C                       (20-38) L2 PCV, 90->0 DEG, 5 DEG INTERVAL
C          PCVSAT       SATELLITE ANT PHASE CENTRE NADIR TABLE
C                       (IPRN, 1 -21) L1 PCV, 0->20 DEG, 1 DEG INTERVAL
C                       (IPRN, 92-42) L2 PCV, 0->20 DEG, 1 DEG INTERVAL
C                       (IPRN, 43) MAX NADIR ANGLE ENCODED
C          DSVX-Z       SAT ANT OFFSETs IN BODY FIXED X,Y,Z, ALREDY READ
C                       IN RDSAT (GPSPPP.SVB), IF AVAILABLE OVERRIDES
C          MAXSAT       (SEE MAXDIM)
C          IPCV         ANTENNA PCV TABLE FOUND (0=NO, >1=YES), =1+INT(10*DAZIM)
C          IYEARS, IMTHS, IDAYS - STARTING DATE
C          ISVBLK       SV BLOCK 0-N/A, 1=I, 2=II, 3=IIA, 4=IIR, 5=IIRM, 6=IIF
C
C *********************************************************************
C
      IMPLICIT NONE
C
      CHARACTER    ANTNAM*20
      LOGICAL*4  FOUND22
      INTEGER*4 LUPCV, IPCV
      INTEGER*4 IFREQ
      REAL*8    PCVNEU(6,*)
      INTEGER*4 IYEARS, IMTHS, IDAYS, IR, IPRN , IY, IM, ID, ISVBLK(*)
      INTEGER   MAXSAT, IBLK
      REAL*8 PCVELV(361,182,*),PCVSAT(MAXSAT,*), DSVX(*),DSVY(*),DSVZ(*)
     &         , DAZI, ZEN1, ZEN2, DZEN, DANTS(6)
      REAL*8  F1, F2, F1S, F2S, F12S, F1ION, F2ION, AL1, AL2, AL3, AL4
      CHARACTER    VERSION*3
      CHARACTER    RECORD*80
      CHARACTER    VENDOR*15
      CHARACTER    MODEL*22
      CHARACTER    DESC*45
      LOGICAL*4  FOUND16
      INTEGER*4 IMODEL,LANTNAM,       I,LMODEL, J, K
     &         ,ICL,ICR
      INTEGER*4    IF, IL, IRL
C
C     INITIALIZE ANTENNA PHASE CENTER VARIATION TABLE
C
      FOUND16=.FALSE.
      FOUND22=.FALSE.
      IMODEL=0
      IPCV=0
      CALL STRLIM(ANTNAM,ICL,ICR)
      LANTNAM=ICR-ICL+1
      IF (LANTNAM .EQ. 0) THEN
        ANTNAM='N/A IN RINEX HEADER'
      RETURN
      END IF
      IF( LANTNAM .LT. 16 ) LANTNAM=16
      DO J=1, MAXSAT
       DO I=1,43
        PCVSAT(J,I)=0.D0
       END DO
      END DO
      DO I=1,6
        PCVNEU(I,1)=0.D0
      END DO
      DO I=1,182
        DO J=1, 361
        PCVELV(J,I,1)=0.D0
        ENDDO
      END DO
C
C 
C
      READ(LUPCV,'(A80)',END=500, ERR=501) RECORD
      CALL STRLIM(RECORD,ICL,ICR)
      IF (ICR-ICL+1.EQ. 0) GO TO 501
      READ(RECORD,'(5x,A3)',END=500) VERSION
      if(VERSION.EQ."1.3" .OR. VERSION.EQ."1.4") then
C ANTX- VER 1.3 FILE READ HEADER
190     READ(LUPCV,'(A80)',END=500, ERR=600) RECORD
        READ(RECORD,'(60x,A15)',END=500) VENDOR  
        IF(VENDOR.NE."START OF ANTENN") GO TO 190
C READ ATX
        READ(LUPCV,'(A80)',END=500, ERR=600) RECORD
        READ(RECORD,'(60x,A15)',END=500) VENDOR
          IF(VENDOR.EQ."TYPE / SERIAL N") THEN
             READ(RECORD,'(A22)') MODEL  
C ONLY SELECT ANTENNA WITHOUT DOME OR WITH PROPER DOME
             IF ( .NOT. FOUND22 .AND.
     &            ANTNAM(1:16) .EQ. MODEL(1:16) ) THEN
             FOUND16= MODEL(17:20) .EQ. 'NONE' .OR. 
     &                  MODEL(17:20) .EQ. '    '
               FOUND22= LANTNAM .GE. 20 .AND. 
     &             ANTNAM(1:LANTNAM) .EQ. MODEL(1:LANTNAM) 
             IF( .NOT. FOUND16 .AND. .NOT. FOUND22 ) GOTO 190
200            READ(LUPCV,'(A80)',END=501, ERR=600) RECORD
               IF(RECORD(61:74).EQ."END OF ANTENNA") GOTO 190
               IF(RECORD(61:64).EQ."DAZI") THEN
                  READ(RECORD,'(2x,f5.1)') DAZI   
                  GOTO 200
               ENDIF
               IF(RECORD(61:64).EQ."ZEN1") THEN
                  READ(RECORD,'(2x,3f6.1)') ZEN1, ZEN2, DZEN
C
C DZEN must be 5.0
C
                    IF(DZEN.LT.1.d0) THEN 
C DZEN TOO SMALL FOR DIMENSIONING PCVELV, CHNG COL DIMENSION 
                     WRITE(*,*) "DZEN.LT. 1 DEG, ANT PCV IGNORED"
                 FOUND22=.FALSE.
                     GOTO 190
                    ENDIF
                  IL= INT(ZEN2/DZEN+1.1)
                  IF= INT(ZEN1/DZEN+1.1)
              IF( IL-IF .GT. 90 ) THEN
                    WRITE(*,*) "TOO MANY VALUES, ANT PCV IGNORED"
                 FOUND22=.FALSE.
                    GOTO 190
              END IF
                  GOTO 200
               ENDIF
               IF(RECORD(61:78).EQ."START OF FREQUENCY") THEN
                  IF(RECORD(4:4).EQ."G") K=1
                  IF(RECORD(4:4).EQ."R") K=2
                  IF(RECORD(4:4).EQ."E") K=3
                  IF(RECORD(4:4).EQ."C") K=4
                  READ(RECORD,'(4x,I2)') I               
                  IF(I.GE.1.AND.I.LE.2) THEN
                   READ(LUPCV,'(A80)',END=500) RECORD
                   READ(RECORD,'(3F10.2)',ERR=600) (PCVNEU(J,K),
     &                                       J=(i-1)*3+1,(i-1)*3+3) 
                   IF(K.EQ.1) THEN
                    DO J=(i-1)*3+1,(i-1)*3+3
C      SET GLN & GAL PCVNEU TO THE GPS ONE FOR NOW
                     PCVNEU(J,2)= PCVNEU(J,1)
                     PCVNEU(J,3)= PCVNEU(J,1)
                     PCVNEU(J,4)= PCVNEU(J,1)
C FILL L2 WITH GPS L1 (IN CASE L2 NOT FOUND)
                     IF(I.EQ.1) THEN
                      PCVNEU(J+3,1)= PCVNEU(J,1)
                      PCVNEU(J+3,2)= PCVNEU(J,1)
                      PCVNEU(J+3,3)= PCVNEU(J,1)
                      PCVNEU(J+3,4)= PCVNEU(J,1)
                     ENDIF
                    END DO
                   ENDIF
C NOAZIM PCV
                   READ(LUPCV,'(8x,91f8.2)',ERR=600)
     &                                  (PCVELV(1,(i-1)*91+J,K),J=IF,IL)
                   IF(K.EQ.1) THEN
                    DO J=IF, IL
                     PCVELV(1,(i-1)*91+J,2)= PCVELV(1,(i-1)*91+J,1)
                     PCVELV(1,(i-1)*91+J,3)= PCVELV(1,(i-1)*91+J,1)
                     PCVELV(1,(i-1)*91+J,4)= PCVELV(1,(i-1)*91+J,1)
C FILL L2 WITH GPS L1 (IN CASE L2 NOT FOUND)
                     IF(I.EQ.1) THEN
                      PCVELV(1,91+J,1)= PCVELV(1,(i-1)*91+J,1)
                      PCVELV(1,91+J,2)= PCVELV(1,(i-1)*91+J,1)
                      PCVELV(1,91+J,3)= PCVELV(1,(i-1)*91+J,1)
                      PCVELV(1,91+J,4)= PCVELV(1,(i-1)*91+J,1)
                     ENDIF
                    END DO
                   ENDIF
                   IF(DAZI.GE.1.D0) THEN
C AZIM PCV (0->360 deg; 73 rows)
                    IRL= INT(360.d0/DAZI + 1.1)
c!                  write(*,*) IRL, IF, IL
                    DO IR= 1,IRL                 
                      READ(LUPCV,'(8x,91f8.2)', ERR=600)
     &                                 (PCVELV(IR,(i-1)*91+J,K),J=IF,IL)
                     IF(K.EQ.1) THEN
                      DO J=IF,IL
                       PCVELV(IR,(i-1)*91+J,2)=PCVELV(IR,(i-1)*91+J,1)
                       PCVELV(IR,(i-1)*91+J,3)=PCVELV(IR,(i-1)*91+J,1)
                       PCVELV(IR,(i-1)*91+J,4)=PCVELV(IR,(i-1)*91+J,1)
C FILL L2 WITH GPS L1 (IN CASE L2 NOT FOUND)
                       IF(I.EQ.1) THEN
                        PCVELV(IR,91+J,1)=PCVELV(IR,(i-1)*91+J,1)
                        PCVELV(IR,91+J,2)=PCVELV(IR,(i-1)*91+J,1)
                        PCVELV(IR,91+J,3)=PCVELV(IR,(i-1)*91+J,1)
                        PCVELV(IR,91+J,4)=PCVELV(IR,(i-1)*91+J,1)
                       ENDIF
                      END DO
                     END IF
                    ENDDO
                   ENDIF
                  ENDIF
C RX ANT PCV FOUND FOR L1/2
                         IPCV=1+INT(DAZI*1.d2+.5d0)+INT(DZEN*1.d1+.5d0)
c!             write(*,*) IPCV
               READ(LUPCV,'(A80)',END=500) RECORD
               READ(LUPCV,'(A80)',END=500) RECORD
               IF(RECORD(61:74).EQ."END OF ANTENNA") GOTO 190
               BACKSPACE(LUPCV)
               GOTO 200
               ENDIF
               GOTO 200
             ELSE
C
C READ SV PCV
C
               IF(RECORD(1:7).NE."BLOCK I".AND. RECORD(1:7).NE.
     &         "GLONASS".AND.RECORD(1:7).NE."GALILEO"
     &                  .AND.RECORD(1:6).NE."BEIDOU") GO TO 190
C INITILIZE FRQ Ant OFFSETS
               DO I=1,6
               DANTS(i)= 0.D0
               ENDDO 
               IPRN=0
               IF(RECORD(21:21).EQ."G") READ(RECORD,'(21x,I2)') IPRN
               IF(RECORD(1:9).EQ."BLOCK I  ") IBLK=1
               IF(RECORD(1:9).EQ."BLOCK II ") IBLK=2
               IF(RECORD(1:9).EQ."BLOCK IIA") IBLK=3
               IF(RECORD(1:11).EQ."BLOCK IIR-A") IBLK=4
               IF(RECORD(1:11).EQ."BLOCK IIR-B") IBLK=5
               IF(RECORD(1:11).EQ."BLOCK IIR-M") IBLK=5
               IF(RECORD(1:11).EQ."BLOCK IIF") IBLK=6
C
                IF(RECORD(21:21).EQ."R") THEN 
                 IF(RECORD(1:11).EQ."GLONASS    ") IBLK=7
                 IF(RECORD(1:11).EQ."GLONASS-M  ") IBLK=8
                 IF(RECORD(1:11).EQ."GLONASS-K  ") IBLK=9
                 READ(RECORD,'(21x,I2)') IPRN
                 IF(IPRN.GT.0.AND.IPRN.LE.32) IPRN=IPRN+32
                ENDIF
               IF(IPRN.LE.0.AND.IPRN.GT.MAXSAT) GO TO 190
                IF(RECORD(21:21).EQ."E") THEN
C GALILEO BLKS > 10
                 IF(RECORD(1:9).EQ."GALILEO-1") IBLK=11
                 IF(RECORD(1:9).EQ."GALILEO-2") IBLK=12
                 READ(RECORD,'(21x,I2)') IPRN
                 IF(IPRN.GT.0.AND.IPRN.LE.36) THEN
                  IPRN=IPRN+64
                 ELSE
                  GO TO 190
                 END IF
                END IF
C start :BEIDOUO
                IF(RECORD(21:21).EQ."C") THEN
C GALILEO BLKS > 20 M-MEDIUM, I-INCLINED, G-GEOSTAT ORBITS
                 IF(RECORD(1:9).EQ."BEIDOU-2M") IBLK=21
                 IF(RECORD(1:9).EQ."BEIDOU-2I") IBLK=22
                 IF(RECORD(1:9).EQ."BEIDOU-2G") IBLK=23
                 IF(RECORD(1:9).EQ."BEIDOU-3M") IBLK=25
                 IF(RECORD(1:9).EQ."BEIDOU-3I") IBLK=26
                 IF(RECORD(1:9).EQ."BEIDOU-3G") IBLK=27
                 READ(RECORD,'(21x,I2)') IPRN
                 IF(IPRN.GT.0.AND.IPRN.LE.36) THEN
                  IPRN=IPRN+100
                 ELSE
                  GO TO 190
                 END IF
                END IF
C
201            READ(LUPCV,'(A80)',END=501, ERR=600) RECORD
               IF(RECORD(61:64).EQ."DAZI") THEN
                  READ(RECORD,'(2x,f6.1)') DAZI   
                  GOTO 201
               ENDIF
               IF(RECORD(61:64).EQ."ZEN1") THEN
                  READ(RECORD,'(2x,3f6.1)') ZEN1, ZEN2, DZEN
C 
C DZEN must be 1deg
C
                    IF(DZEN.NE.1.d0) THEN 
C DZEN TOO SMALL FOR DIMENSIONING PCVSAT, CHNG COL DIMENSION 
                     WRITE(*,*) "DZEN.LT. 1 DEG, SAT PCV IGNORED"
                     GOTO 190
                    ENDIF
                  IL= INT(ZEN2/DZEN+1.1)
                  IF= INT(ZEN1/DZEN+1.1)
                  PCVSAT(IPRN,43) = ZEN2
              IF( IL-IF .GT. 20 ) THEN
                     WRITE(*,*) "TOO MANY VALUES, SAT PCV IGNORED"
                     GOTO 190
              END IF
                  GOTO 201
               ENDIF
               IF(RECORD(61:70).EQ."VALID FROM") THEN
                  READ(RECORD,'(3I6)') IY,IM,ID
                  IF(IY.GT.IYEARS) GO TO 190
                  IF(IY.EQ. IYEARS) THEN
                    IF(IM.GT.IMTHS) GO TO 190
                    IF(IM.EQ.IMTHS) THEN 
                     IF(ID.GT.IDAYS) GO TO 190
                    ENDIF
                  ENDIF
                  GOTO 201
               ENDIF
               IF(RECORD(61:71).EQ."VALID UNTIL") THEN
                  READ(RECORD,'(3I6)') IY,IM,ID
                  IF(IY.LT.IYEARS) GO TO 190
                  IF(IY.EQ. IYEARS) THEN
                    IF(IM.LT.IMTHS) GO TO 190
                    IF(IM.EQ.IMTHS) THEN 
                     IF(ID.LT.IDAYS) GO TO 190
                    ENDIF
                  ENDIF
                  GOTO 201
               ENDIF
               IF(RECORD(61:78).EQ."START OF FREQUENCY".AND.
     &              (RECORD(4:4).EQ."G".OR.RECORD(4:4).EQ."R"
     &               .OR.RECORD(4:4).EQ."E".OR.RECORD(4:4).EQ."C")) THEN
                  READ(RECORD,'(4x,I2)') I               
C USE E5/L5 IN PLACE of L2
C USE L5, OR L7, OR L8 AS L2 DEPENDING ON INPUT IFREQ
                  IF(RECORD(4:4).EQ."E".AND.I.EQ.5.AND.IFREQ.LE.5) I=2
                  IF(RECORD(4:4).EQ."E".AND.I.EQ.7.AND.IFREQ.EQ.7) I=2
                  IF(RECORD(4:4).EQ."E".AND.I.EQ.8.AND.IFREQ.EQ.8) I=2
C USE BEIDOU B2 (RNX3 CODE = 7) FOR L2 
                  IF(RECORD(4:4).EQ."C".AND.I.EQ.7) I=2
                  IF(I.GE.1.AND.I.LE.2) THEN
                   READ(LUPCV,'(A80)',END=500) RECORD
                   READ(RECORD,'(3F10.2)',ERR=600) (DANTS(J),
     &                                       J=(i-1)*3+1,(i-1)*3+3) 
C NOAZIM PCV only
                   READ(LUPCV,'(8x,19f8.2)',ERR=600)
     &                                (PCVSAT(IPRN,(i-1)*21+J) ,J=IF,IL)
                  ENDIF
                IF(I.EQ.1. AND.(DANTS(4)+DANTS(5)+DANTS(6)).EQ.0.D0) 
     &             GO TO 201
C SAT ANT PCV FOUND FOR L1/2
                IF((DANTS(1)+DANTS(2)+DANTS(3)).NE.0.D0.AND.
     &             (DANTS(4)+DANTS(5)+DANTS(6)).NE.0.D0) THEN
C allow GAL eclips switch by BEI SVB BLK!
                  IF(ISVBLK(IPRN).NE.25.AND.ISVBLK(IPRN).NE.26)
     &             ISVBLK(IPRN)= IBLK
                 CALL FREQ12( IPRN, F1, F2, F1S, F2S, F12S, F1ION,
     &            F2ION, AL1, AL2, AL3, AL4 , IFREQ)
                  DSVX(IPRN)= (F2ION  *DANTS(1)-F1ION  *DANTS(4))*1.D-3
                  DSVY(IPRN)= (F2ION  *DANTS(2)-F1ION  *DANTS(5))*1.D-3
                  DSVZ(IPRN)= (F2ION  *DANTS(3)-F1ION  *DANTS(6))*1.D-3
                  GOTO 190
                ENDIF
               ENDIF
               GOTO 201
             ENDIF
          ENDIF
       GO TO 190
  600  CONTINUE
       FOUND22=.FALSE.
       WRITE(*,*) 'ERROR ENCOUNTERED READING ', RECORD
       GO TO 190
      else
C
C     READ HEADER OF ANTENNA PHASE CENTER FILE PCV- FORMAT
C
   90 CONTINUE
c!    write(*,*) 'after 90'
      READ(LUPCV,'(A80)',END=500,ERR=90) RECORD
c!    write(*,*) record, length(record)
      CALL STRLIM(RECORD,ICL,ICR)
      IF (ICR-ICL+1.NE. 0) GO TO 90
C
C     READ ANTENNA PHASE CENTER VARIATION TABLE
C     FOR SCPECIFIED ANTENNA
C
  100 CONTINUE
c!    write(*,*) 'after 100'
      READ(LUPCV,'(A80)',END=500) RECORD
      READ(RECORD,'(A15,A22,A45)',ERR=400) 
     &             VENDOR,MODEL,DESC
C ONLY SELECT ANTENNA WITHOUT DOME OR WITH PROPER DOME
      FOUND16= ANTNAM(1:16) .EQ. MODEL(1:16) .AND.
     &         ( MODEL(17:20) .EQ. 'NONE' .OR.
     &           MODEL(17:20) .EQ. '    ' )
      FOUND22= LANTNAM .GE. 20 .AND. 
     &         ANTNAM(1:LANTNAM) .EQ. MODEL(1:LANTNAM)
      IF( .NOT. FOUND16 .AND. .NOT. FOUND22 ) GOTO 100
      IPCV=1+INT(DZEN*1.d1+.5d0)
      READ(LUPCV,'(A80)',END=500) RECORD
      READ(RECORD,'(3(F10.1))',ERR=400)PCVNEU(1,1),PCVNEU(2,1),
     & PCVNEU(3,1)
      READ(LUPCV,'(A80)',END=500) RECORD
      READ(RECORD,'(10(F6.1))',ERR=400) 
     &      PCVELV(1,1,1),PCVELV(1,2,1),PCVELV(1,3,1),PCVELV(1,4,1),
     &      PCVELV(1,5,1),PCVELV(1,6,1),PCVELV(1,7,1),PCVELV(1,8,1),
     &      PCVELV(1,9,1),PCVELV(1,10,1)
      READ(LUPCV,'(A80)',END=500) RECORD
      READ(RECORD,'(9(F6.1))',ERR=400) 
     &      PCVELV(1,11,1),PCVELV(1,12,1),PCVELV(1,13,1),PCVELV(1,14,1),
     &      PCVELV(1,15,1),PCVELV(1,16,1),PCVELV(1,17,1),PCVELV(1,18,1),
     &      PCVELV(1,19,1)
      READ(LUPCV,'(A80)',END=500) RECORD
      READ(RECORD,'(3(F10.1))',ERR=400) PCVNEU(4,1), PCVNEU(5,1),
     &     PCVNEU(6,1)
      READ(LUPCV,'(A80)',END=500) RECORD
      READ(RECORD,'(10(F6.1))',ERR=400) 
     &      PCVELV(1,20,1),PCVELV(1,21,1),PCVELV(1,22,1),PCVELV(1,23,1),
     &      PCVELV(1,24,1),PCVELV(1,25,1),PCVELV(1,26,1),PCVELV(1,27,1),
     &      PCVELV(1,28,1), PCVELV(1,29,1)
      READ(LUPCV,'(A80)',END=500) RECORD
      READ(RECORD,'(9(F6.1))',ERR=400) 
     &      PCVELV(1,30,1),PCVELV(1,31,1),PCVELV(1,32,1),PCVELV(1,33,1),
     &      PCVELV(1,34,1),PCVELV(1,35,1),PCVELV(1,36,1),PCVELV(1,37,1),
     &      PCVELV(1,38,1)
      IMODEL=IMODEL+1
      CALL STRLIM(MODEL,ICL,ICR)
      LMODEL=ICR-ICL+1
c!    WRITE(*,*) IMODEL, MODEL(1:20), ANTNAM(1:20), LMODEL, LANTNAM
C
C     IF ANTNAM INCLUDING RADOME MATCHES MODEL - RETURN
C
       IF( FOUND22 ) RETURN
       GO TO 100
  400  CONTINUE
       WRITE(*,*) 'ERROR ENCOUNTERED READING ', RECORD
       GO TO 100
      end if
  501 WRITE(*,*) 'EOF ENCOUNTERED OR NO PCVs'       
      FOUND22=.FALSE.
      IPCV=0
  500 CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDRNX
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDRNX ( LPR, EPOBLK, NRECBLK, NOBTYP, IOBPOS,
     &                   OBSINT, IGPSWK, TTAG, NSV, ISV,
     &                   IGF, DP1C1, DP2C2, PR1, PR2, P1, P2, CA1,CA2,
     &                   ISPR1, ISPR2,
     &  RIFRATE, C, AL1, AL2, IERR, IC1USE, IC2USE, IDCBUSE, MAXOBS )
C
C     NAME              RDRNX
C
C     PURPOSE   READ MEASUREMENT RECORD IN RINEX DATA FORMAT
C
C     PARAMETERS        DESCRIPTION
C
C        LPR            LOGICAL UNIT OF PRINT FILE
C        EPOBLK         BLOCK OF RECORDS
C        NRECBLK        NUMBER OF RECORDS IN EPOCH BLOCK
C        NOBTYP         NUMBER OF OBSERVATION TYPES (RNX ONLY)
C        IOBPOS         POSITION OF L1, L2, P1 & P2 OBSERVATIONS
C        IGPSWK         GPS WEEK OF OBSERVATION 
C        TTAG           TIME TAG OF OBSERVATION (SECONDS OF WEEK)
C        NSV            NUMBER OF SATELLITES IN RECORD
C        ISV            LIST OF SATELLITE I.D.'S
C        PR1            P-CODE PSEUDORANGE ON L1
C        PR2            P-CODE PSEUDORANGE ON L2
C        P1             CARRIER PHASE ON L1
C        P2             CARRIER PHASE ON L2
C        CA1            C/A CODE PSEUDORANGE ON L1
C        CA2            C/A CODE PSEUDORANGE ON L2
C        C              SPEED OF LIGHT
C        AL1            L1 WAVELENGTH
C        AL2            L2 WAVELENGTH
C        IERR           ERROR FLAG
C        MAXOBS         MAXIMUM EPOCH OBSERVED SATELLITES
C
C *********************************************************************
      IMPLICIT NONE
C
      CHARACTER*80 EPOBLK(*)
      INTEGER*4 LPR,NRECBLK,NOBTYP,IGPSWK,NSV,IERR,MAXOBS
      LOGICAL*4          ISPR1(*), ISPR2(*)
      INTEGER*4 ISV(*),IGF(*),IOBPOS(*), IC1USE, IC2USE, IDCBUSE
      REAL*8    OBSINT,C,AL1,AL2
      REAL*8    TTAG(*),DP1C1(*),DP2C2(*),PR1(*),PR2(*),P1(*),P2(*),
     &          CA1(*),CA2(*)
C
      INTEGER*4 INPSV,MAXSV,IRECBLK,IYEAR,IMTH,IDAYM,IHR,IMN,IEP
      INTEGER*4 IRSV(96),NRSV,IS,IPSV,          IO,IP,IDP,K
      INTEGER*4 JULD,IWKDAY
      INTEGER*4 IPRN
      REAL*8    EPOCH,SEC,AL1G,AL2G,OBS(30,96), RIFRATE
      INTEGER*4 JRECBLK
C
      CHARACTER*80 RECORD
      CHARACTER*40 STNA
      CHARACTER*16 OBSVAL
      CHARACTER*20 COMMENT
      CHARACTER*1  IMODE(30,96)
      CHARACTER*1  ISN(30,96)
      CHARACTER*1  IGGSV(96)
C

      LOGICAL      IPR1OB,  IPR2OB, ICA1OB, ICA2OB
      LOGICAL*4 L1CODE, L2CODE
C
C------------------------------------------------------------------------
C     READ MEASUREMENT RECORD FROM RINEX FORMAT
C------------------------------------------------------------------------
C
      NSV = 0
      INPSV = 0
      MAXSV = MAXOBS
      EPOCH = 9999.99D0
      IRECBLK=1
      READ(EPOBLK(IRECBLK),2000,ERR=500) IYEAR, IMTH, IDAYM, 
     &                                   IHR, IMN, SEC, IEP, NRSV
      IF ( IYEAR .GE. 0 .AND. IYEAR .LT. 80 ) THEN
        IYEAR = IYEAR + 2000
      ELSE
        IYEAR = IYEAR + 1900
      END IF
C
C     IF EVENT FLAG, SEE IF NEW MARKER NAME IS DEFINED
C
      IF ( IEP .GT. 1 ) THEN
        IF ( NRECBLK .NE. 0 ) THEN
          DO IS=1,NRECBLK
         IRECBLK=IRECBLK+1
           READ (EPOBLK(IRECBLK),'(A80)',ERR=500) RECORD
           COMMENT = RECORD(61:80)
           IF ( COMMENT .EQ. 'MARKER NAME         ' )
     &             READ(RECORD,'(A40)') STNA
          END DO
        END IF
      NSV=0
      RETURN
      END IF
C
      READ(EPOBLK(IRECBLK),2050,ERR=500) 
     &               (IGGSV(IS),IRSV(IS), IS=1,MIN(NRSV,12))
      DO K=1,(NRSV-1)/12
       IF( IRECBLK .LT. NRECBLK ) THEN
        IRECBLK=IRECBLK+1
      READ (EPOBLK(IRECBLK),'(A80)',ERR=500) RECORD
        READ(RECORD,2050,ERR=500)
     &  (IGGSV(IS),IRSV(IS),IS=K*12+1,MIN(96,MIN((K+1)*12,NRSV)))
       END IF
      END DO
      DO 250 IS=1,NRSV
        IPSV=INPSV+1
C UNKNOWN CONSTELLATION
        IPRN=0
C GPS
        IF((IGGSV(IS) .EQ. 'G' .OR.
     &      IGGSV(IS) .EQ. ' ').AND.
     &     IRSV(IS) .GE. 1 .AND.
     &     IRSV(IS) .LE. 32 ) IPRN=IRSV(IS)
C GLONASS
      IF(IGGSV(IS) .EQ. 'R' .AND.
     &     IRSV(IS) .GE. 1 .AND.
     &     IRSV(IS) .LE. 24 ) IPRN=IRSV(IS)+32
C GEOSTATIONARY : disabled
      IF(IGGSV(IS) .EQ. 'S' ) IPRN=0
C GALILEO : enabled
      IF(IGGSV(IS)   .EQ. 'E'.AND.
     &      IRSV(IS) .GE. 1  .AND.
     &      IRSV(IS) .LE. 36 ) IPRN=IRSV(IS)+64
C COMPASS : enabledd
      IF(IGGSV(IS)   .EQ. 'C'.AND.
     &      IRSV(IS) .GE. 1  .AND.
     &      IRSV(IS) .LE. 36 ) IPRN=IRSV(IS)+100
C SKIP INDICATOR : ISLT in SVB file
        IF( IPRN .NE. 0 ) THEN
          IF( IGF(IPRN) .EQ. 99 ) IPRN=0
      END IF
        IF ( IPSV .LE. MAXSV .AND. 
     &       IPRN .GT. 0 ) THEN
          ISV(IPSV)=IPRN
        INPSV=INPSV+1
          PR1(IPSV)=0.D0
          PR2(IPSV)=0.D0
          CA1(IPSV)=0.D0
          CA2(IPSV)=0.D0
          P1(IPSV)=0.D0
          P2(IPSV)=0.D0
C
          DO 240 IO=1,NOBTYP
            OBS(IO,IPSV) = 0.D0
            IMODE(IO,IPSV) = ' '
            ISN(IO,IPSV) = ' '
            JRECBLK=IRECBLK+(IO-1)/5+1
          IP  = MOD(IO-1,5)*16+1
            IDP = IP+10
            IF ( JRECBLK .LE. NRECBLK .AND.
     &           EPOBLK(JRECBLK)(IDP:IDP) .EQ. '.' ) THEN
              OBSVAL = EPOBLK(JRECBLK)(IP:IP+15)
              READ(OBSVAL,'(F14.3,A1,A1)',ERR=500)
     &                    OBS(IO,IPSV), IMODE(IO,IPSV), ISN(IO,IPSV)
            END IF
 240      CONTINUE
C
C------------------------------------------------------------------------
C     SELECT OBSERVATIONS USING POSITION SEQUENCE DEFINED IN HEADER
C------------------------------------------------------------------------
C
        IF(IOBPOS(1) .NE. 0 ) THEN
          IF( OBS(IOBPOS(1),IPSV) .NE. 0.D0 )
     &       P1(IPSV) = OBS(IOBPOS(1),IPSV)
        END IF
        IF(IOBPOS(2) .NE. 0 ) THEN
          IF( OBS(IOBPOS(2),IPSV) .NE. 0.D0 )
     &       P2(IPSV) = OBS(IOBPOS(2),IPSV)
        END IF
        IF (ISV(IPSV) .GT. 32.AND.ISV(IPSV).LE.64) THEN
          AL1 = C/1575.42D+06
          AL2 = C/1227.60D+06
          K=IGF(ISV(IPSV))
          AL1G=C/(1602.D6+K*9.D0/16.D0*1.D6)/AL1
          AL2G=C/(1246.D6+K*7.D0/16.D0*1.D6)/AL2
          IF(IOBPOS(1) .NE. 0 ) THEN
            IF( OBS(IOBPOS(1),IPSV) .NE. 0.D0 )
     &        P1(IPSV) = (OBS(IOBPOS(1),IPSV))*AL1G
          END IF
          IF(IOBPOS(2) .NE. 0 ) THEN
            IF( OBS(IOBPOS(2),IPSV) .NE. 0.D0 )
     &        P2(IPSV) = (OBS(IOBPOS(2),IPSV))*AL2G
          END IF
        END IF
        IPR1OB=.FALSE.
        IF(IOBPOS(3) .NE. 0 ) THEN
         IF( OBS(IOBPOS(3),IPSV) .NE. 0.D0 ) THEN
          IPR1OB=.TRUE.
          PR1(IPSV) = OBS(IOBPOS(3),IPSV) / C
          IF (ISV(IPSV) .GT. 32.AND.ISV(IPSV).LE.64)
     &     PR1(IPSV)= PR1(IPSV)+RIFRATE*IGF(ISV(IPSV))*1.D-9
         END IF
        END IF
        IPR2OB=.FALSE.
        IF(IOBPOS(4) .NE. 0 ) THEN
         IF( OBS(IOBPOS(4),IPSV) .NE. 0.D0 ) THEN 
            IPR2OB=.TRUE.
            PR2(IPSV) = OBS(IOBPOS(4),IPSV) / C
            IF (ISV(IPSV) .GT. 32.AND.ISV(IPSV).LE.64)
     &       PR2(IPSV)= PR2(IPSV)+RIFRATE*IGF(ISV(IPSV))*1.D-9
         END IF
        END IF
        ICA1OB=.FALSE.
        IF(IOBPOS(5) .NE. 0 ) THEN
         IF( OBS(IOBPOS(5),IPSV) .NE. 0.D0 ) THEN
          ICA1OB=.TRUE.
          CA1(IPSV) = OBS(IOBPOS(5),IPSV) / C
          IF (ISV(IPSV) .GT. 32.AND.ISV(IPSV).LE.64)
     &     CA1(IPSV)= CA1(IPSV)+RIFRATE*IGF(ISV(IPSV))*1.D-9
         END IF
        END IF

        ICA2OB=.FALSE.
        IF(IOBPOS(6) .NE. 0 ) THEN
         IF( OBS(IOBPOS(6),IPSV) .NE. 0.D0 ) THEN
            ICA2OB=.TRUE.
            CA2(IPSV) = OBS(IOBPOS(6),IPSV) / C
            IF (ISV(IPSV) .GT. 32.AND.ISV(IPSV).LE.64)
     &       CA2(IPSV)= CA2(IPSV)+RIFRATE*IGF(ISV(IPSV))*1.D-9
         END IF
        END IF
C Allow GALILEO L5 & C5 in P2(L2) & PR2  
       IF(IPRN.GT.64.AND.IPRN.LE.100) THEN
C fill PR1 with CA1 (no P available)
        IPR1OB=.TRUE.
        PR1(IPSV)= CA1(IPSV)
        IF(IOBPOS(7) .NE. 0 ) THEN
          IF( OBS(IOBPOS(7),IPSV) .NE. 0.D0 )
     &       P2(IPSV) = OBS(IOBPOS(7),IPSV)
        END IF
        IF(IOBPOS(8) .NE. 0 ) THEN
         IF( OBS(IOBPOS(8),IPSV) .NE. 0.D0 ) THEN
            IPR2OB=.TRUE.
            PR2(IPSV) = OBS(IOBPOS(8),IPSV) / C
         END IF
        END IF
       ENDIF
C Allow BEIDOU  B2 (RNX3 L7, C7)  in P2(L2) & PR2  
       IF(IPRN.GT.100.AND.IPRN.LE.136) THEN
C fill PR1 with CA1 (no P available)
        IPR1OB=.TRUE.
        PR1(IPSV)= CA1(IPSV)
C RNX 3 BDS B1 L1/L2 CONFUSION TRY L2 IF PRESENT FOR BDS!
        IF(IOBPOS(2) .NE. 0 ) THEN
          IF( OBS(IOBPOS(2),IPSV) .NE. 0.D0 )
     &       P1(IPSV) = OBS(IOBPOS(2),IPSV)
        END IF
         IF( OBS(IOBPOS( 6),IPSV) .NE. 0.D0 ) THEN
            IPR1OB=.TRUE.
            PR1(IPSV) = OBS(IOBPOS( 6),IPSV) / C
C fill CA1 with PR1 
        ICA1OB=.TRUE.
        CA1(IPSV)= PR1(IPSV)
         END IF
        IF(IOBPOS(9) .NE. 0 ) THEN
          IF( OBS(IOBPOS(9),IPSV) .NE. 0.D0 )
     &       P2(IPSV) = OBS(IOBPOS(9),IPSV)
        END IF
         IF( OBS(IOBPOS(10),IPSV) .NE. 0.D0 ) THEN
            IPR2OB=.TRUE.
            PR2(IPSV) = OBS(IOBPOS(10),IPSV) / C
         END IF
       ENDIF
C          
C
C       SELECT L1 CODE (P1 OR C1) AND APPLY DCB AS REQUIRED
C
          ISPR1(IPSV) =
     &         L1CODE ( IPR1OB, ICA1OB, PR1(IPSV), CA1(IPSV), 
     &                  IC1USE, IDCBUSE, DP1C1(ISV(IPSV)), C )

C       SELECT L2 CODE (P2 OR C2) AND APPLY DCB AS REQUIRED
          ISPR2(IPSV) = 
     &         L2CODE ( IPR2OB, ICA2OB, PR2(IPSV), CA2(IPSV), 
     &                  IC2USE, IDCBUSE, DP2C2(ISV(IPSV)), C )
C
          CALL GPSDC ( JULD,IYEAR,IMTH,IDAYM,IGPSWK,IWKDAY,2 )
          EPOCH =(IWKDAY-1)*86400.D0 + IHR*3600.D0 + IMN*60.D0 + 
     &            SEC 
        TTAG(IPSV) = EPOCH
c!         IF(ISV(IPSV).EQ.18)
c!   & write(18,111) ttag(ipsv), ca1(ipsv)*c, p1(ipsv),pr2(ipsv)*c
c!   & ,p2(ipsv), isv(ipsv)
c!111  format(5f15.3, I5)
        END IF
      IRECBLK=IRECBLK+((NOBTYP-1)/5+1)
  250 CONTINUE
      NSV = NSV + INPSV
      NSV = MIN(NSV,MAXSV)
      IERR=0
      RETURN
C
  500 CONTINUE
      IERR = 1
      RETURN
C
C------------------------------------------------------------------------
C     FORMAT STATEMENTS
C------------------------------------------------------------------------
C
 1000 FORMAT (I6,9(4X,A2))
 1010 FORMAT(5I6,F12.6)
 2000 FORMAT (5I3,F11.7,2(1X,I2))
 2050 FORMAT (32X,24(1A,I2))
 2100 FORMAT (5(F14.3,1X,I1))
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDSAT
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDSAT( LUSAT, IYEAR, IMTH, IDAY, IGNSS, ISVN, 
     &                  ISVBLK, DSVX, DSVY, DSVZ, DP1P2, DP1C1, DP2C2, 
     &                  AVCLK, IRDSAT, IGF )
C
C     NAME              RDSAT
C
C     PURPOSE   READ SATELLITE PARAMETERS
C
C     PARAMETERS        DESCRIPTION
C
C        LUSAT        LOGICAL UNIT OF FILE WITH SATELLITE PARAMETERS 
C          IGNSS        GNSS CONSTELLATION (GPS,GLONASS,...)
C          ISVN         SPACE VEHICULE NUMBER 
C          IBLK         SATELLITE BLOCK NUMBER 
C          DSVXYZ       SATELLITE XYZ ANTENNA PHASE CENTER OFFSETS
C          DP1P2        SATELLITE P1-P2 DIFFERENTIAL CODE BIAS
C          DP1C1        SATELLITE P1-C1 DIFFERENTIAL CODE BIAS
C          DP2C2        SATELLITE P2-C2 DIFFERENTIAL CODE BIAS
C          IRDSAT       SATELLITE PARAMETERS FOUND (0=NO,1=YES)
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      CHARACTER*1 IGNSS(*)
      INTEGER*4 LUSAT,IYEAR,IMTH,IDAY,IRDSAT,ISVN(*),ISVBLK(*), IGF(*)
      REAL*8    DSVX(*),DSVY(*),DSVZ(*),DP1P2(*),DP1C1(*),DP2C2(*),
     &          AVCLK(*)
C
      CHARACTER*80 RECORD
      CHARACTER*3 HDR
      INTEGER*4 IPRN,IBLK,IYUP,IMUP,IDUP,IYEND,IMEND,IDEND
      INTEGER*4 MJD,MJDUP,MJDEND,IPLN,ISLT,ISVCLK
      REAL*8    XBIAS,YBIAS,ZBIAS,DSVBLK(MAXBLK,3)
      LOGICAL IPRNUP
      INTEGER*4 IGFBUF(MAXSAT)
C
      IRDSAT=0
      DO IPRN=1,MAXSAT
        ISVBLK(IPRN)=1
C SET ALL SATELLITES TO UNOBSERVABLE
        IGFBUF(IPRN)=99
      END DO
  100 CONTINUE
      READ(LUSAT,'(A)',END=500) RECORD
      READ(RECORD,'(A3)',ERR=400) HDR
      IF ( HDR .EQ. 'BLK' ) THEN
c!      write(*,*) record(10:)
        READ(RECORD(10:),*,ERR=400)  IBLK,XBIAS,YBIAS,ZBIAS
c!      WRITE(*,*) IBLK,XBIAS,YBIAS,ZBIAS
      IF (IBLK .GE. 1 .AND. IBLK .LE. MAXBLK ) THEN
        DSVBLK(IBLK,1)=XBIAS
        DSVBLK(IBLK,2)=YBIAS
        DSVBLK(IBLK,3)=ZBIAS
        END IF
      END IF
C
      IF ( HDR .EQ. 'GPS' .OR.HDR.EQ.'GLN'.OR.HDR.EQ.'GAL'.OR.
     &     HDR .EQ. 'BEI') THEN
        IPRNUP=.FALSE.
        READ(RECORD(4:),'(2(I5,2I3),I4)',ERR=400)
     &              IYUP,IMUP,IDUP,IYEND,IMEND,IDEND,IPRN
        CALL JLIAN ( MJD, IYEAR, IMTH, IDAY)
        CALL JLIAN ( MJDUP, IYUP, IMUP, IDUP)
        CALL JLIAN ( MJDEND, IYEND, IMEND, IDEND)
        IF ( MJD .GE. MJDUP .AND. MJD .LE. MJDEND ) IPRNUP=.TRUE.
        IF ( IPRNUP .AND. IPRN .GT. 0 .AND. IPRN .LE. MAXSAT ) THEN
          IRDSAT=IRDSAT+1
          IF ( HDR .EQ. 'GPS' ) IGNSS(IPRN)='G'
          IF ( HDR.EQ.'GLN' ) IGNSS(IPRN)='R'
          IF ( HDR.EQ.'GAL' ) IGNSS(IPRN)='E'
          IF ( HDR .EQ. 'BEI') IGNSS(IPRN)='C'
          READ(RECORD(30:),*,ERR=400) ISVN(IPRN),ISVBLK(IPRN),IPLN,
     &                             ISLT,ISVCLK,
     &               DP1P2(IPRN), DP1C1(IPRN), AVCLK(IPRN), DP2C2(IPRN)
C
C READ GLONASS FREQ CHANNEL IGF
C
          IGFBUF(IPRN)= ISLT
          DSVX(IPRN)=DSVBLK(ISVBLK(IPRN),1)
          DSVY(IPRN)=DSVBLK(ISVBLK(IPRN),2)
          DSVZ(IPRN)=DSVBLK(ISVBLK(IPRN),3)
        END IF
      END IF
      GO TO 100
  400 CONTINUE
      WRITE(*,*) 'ERROR ENCOUNTERED READING ', RECORD
      GO TO 100      
  500 CONTINUE
C IF SATELLITES WERE READ, SET IGF TO THOSE INITIALIZED AND/OR READ
      IF( IRDSAT .NE. 0 ) THEN
       DO IPRN=1,MAXSAT
        IGF(IPRN)=IGFBUF(IPRN)
       END DO
      END IF
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** RDSINX
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDSINX ( LUGRD, LUO, STNLAT, IYEAR, IMTH, IDAY,
     &                    STNA,
     &                   SLAT, ELAT, DLAT, SLON, ELON, DLON, 
     &                   TIMMAP, AION, RION, 
     &                   NRX, IRXDCB, RXDCB, RXDCBS, 
     &                   NSV, ISVDCB, SVDCB, SVDCBS,
     &                   MININC, SLMHGT, MAPNB, MAXMAP,
     &                   IONBAND, IONGRD, REFLAT, PI, 
     &                   IEXP,
     &                   MAPINT, MAPTYP, IDIR )
C
C     NAME       :  RDSINX
C
C     PURPOSE    :  READ IONEX IONOSPHERIC GRID AND SATELLITE 
C                   CALIBRATION DELAYS
C
C     PARAMETERS       DESCRIPTION
C
C     LUGRD            LOGICAL UNIT OF SINGLE LAYER GRID
C     LUO              LOGICAL UNIT OF OUTPUT
C     STNLAT           STATION LATITUDE (RADIANS)
C     SLAT             START LATITUDE OF GRID (DEGREES)
C     ELAT             END LATITUDE OF GRID (DEGREES)
C     DLAT             LATITUDE INCREMENT OF GRID (DEGREES)
C     SLON             START LONGITUDE OF GRID (DEGREES)
C     ELON             END LONGITUDE OF GRID (DEGREES)
C     DLON             LONGITUDE INCREMENT OF GRID (DEGREES)
C     TIMMAP           TIME OF IONOSPHERIC GRID (SECONDS OF DAY)
C     AION             AVERAGE ION VERTICAL DELAY IN CELL (CM)
C     RION             RMS OF ION VERTICAL DELAY IN CELL (CM)
C     NRX             NUMBER OF STATIONS USED IN GRID ESTIMATION
C     NSV             NUMBER OF SATELLITES CALIBRATED
C     SVDCB            SATELLITE L1/L2 CALIBRATION DELAYS (M)
C     MININC           MINIMUM .1 DEGREE INCREMENTS IN CELL SIZE
C     SLMHGT           SINGLE LAYER MODEL HEIGHT
C     MAPNB            MAP NUMBER TO READ
C     IONBAND          SIZE OF IONOSPHERIC BAND (DEGREES)
C     IONGRD           IONOSPHERIC GRID FOUND (1=YES,0=NO)
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      CHARACTER*4   IRXDCB(*)
      CHARACTER*40   STNA
      INTEGER*4 LUGRD,LUO,IYEAR,IMTH,IDAY,NRX,NSV,       MININC
      INTEGER*4 MAPNB,MAXMAP,IONBAND,IONGRD,MAPTYP,IDIR,IEXP
      INTEGER*4 ISVDCB(*)
      REAL*8    STNLAT,SLAT,ELAT,DLAT,SLON,ELON,DLON,TIMMAP,SLMHGT
      REAL*8    REFLAT,PI,AION(MAXLAT,*),RION(MAXLAT,*)
      REAL*8    SVDCB(*),SVDCBS(*),RXDCB(*),RXDCBS(*)
      INTEGER*4 MAPINT
C
      CHARACTER*80  ADTLST(MAXADT)
      CHARACTER*60  ADTLBL,  OBSTXT
      CHARACTER*20  SATSTR,  PGMSTR,  AGESTR,  DATSTR
      CHARACTER*4   MAPSTR,ISTN
      CHARACTER*1   IGNSS
      INTEGER*4 NSTNSAT(3),IGRD,NBLON,NBLAT,I,IPRN,J,JULD
      INTEGER*4 IGPSWK,IWKDAY,ILON,ILAT,IDXLON,IDXLAT,IERROR,IRC
     &         ,NDAT
      REAL*8    TECMAP(MAXLON,MAXLAT),XINT,ELVCUT,DCB,DCBS
      REAL*8    ENDLAT,TODMAP,PPLON,PPLAT
      CHARACTER*1   CONST
      INTEGER*4 EOF,MAPNO,INTRV
      INTEGER*4 InxHeadRead, InxDataRead, GetInxSpecs, GetInxMap,
     &          GetInxSatBias, GetInxStaBias, GetInxMapId, GetInxMapTec
C
      IGRD=1
      NBLON=0
      NBLAT=0
      ENDLAT=-90.D0
C
C-----------------------------------------------------------------------
C     READ IONEX FILE HEADER
C-----------------------------------------------------------------------
C
      IF ( IDIR .EQ. -1 .OR. MAPNB .EQ. 1 ) THEN
        IF ( IDIR .EQ. -1 ) REWIND(LUGRD)
        IRC = InxHeadRead( LUGRD, EOF )
        IF( IRC .NE. 0 .OR. EOF .NE. 0 ) THEN
          IONGRD=0
          RETURN
        END IF
        IRC = GetInxSpecs( SLAT, ELAT, DLAT, SLON, ELON, DLON, ELVCUT,
     &                     SLMHGT, MAXMAP, MAPINT )
        MAPINT=MAPINT/2
        IF( IRC .NE. 0 ) THEN
          IONGRD=0
          RETURN
        END IF
C
C-----------------------------------------------------------------------
C       READ SATELLITE AND STATION DCB'S FROM AUXILIARY DATA LIST
C-----------------------------------------------------------------------
C
        NSV=0
        DO I=1,MAXSAT
          IF( I .LE. 32 ) THEN
            IPRN=I
            CONST="G"
          ELSE
            IPRN=I-32
            CONST='R'
          END IF
          IRC=GetInxSatBias( CONST, IPRN, DCB, DCBS )
          IF( IRC .EQ. 0 ) THEN
             NSV=NSV+1
             ISVDCB(NSV)=I
             SVDCB(NSV)=DCB*.299792458D0
             SVDCBS(NSV)=DCBS*.299792458D0
          ENDIF
        END DO
        NRX=0
        IRC=GetInxStaBias( ' ', STNA(1:4), DCB, DCBS )
        IF( IRC .NE. 0 ) IRC=GetInxStaBias( 'G', STNA(1:4), DCB, DCBS )
        IF( IRC .EQ. 0 ) THEN
          NRX=NRX+1
          IRXDCB(NRX)=STNA(1:4)
          RXDCB(NRX)=DCB*.299792458D0
          RXDCBS(NRX)=DCBS*.299792458D0
        ENDIF
C
C-----------------------------------------------------------------------
C     COMPUTE LIMITS OF LATITUDE BAND (+/- IBAND)
C-----------------------------------------------------------------------
C
        REFLAT=INT(STNLAT*180.D0/PI/DLAT)*DLAT+IONBAND
        IF ( REFLAT .GT. SLAT ) REFLAT=SLAT
C
        ENDLAT=REFLAT-2.D0*IONBAND
        IF ( ENDLAT .LT. ELAT ) ENDLAT=ELAT
C
C       IONOSPHERIC GRID IS NOT 90% FULL AROUND THE STATION
C       SET IONGRD TO 0 (NOT FOUND) AND RETURN 
C  
c!      WRITE(*,*) 'IN RDSINX',REFLAT-ENDLAT,IONBAND*1.8
        IF ( REFLAT-ENDLAT .LT. 1.8*IONBAND .AND. 
     &           REFLAT .NE. SLAT .AND. ENDLAT .NE. ELAT  ) THEN
          IONGRD=0
          RETURN
        END IF
      END IF
C
C-----------------------------------------------------------------------
C     BACKWARD RUN, READ UP TO SPECIFIED MAP NUMBER
C-----------------------------------------------------------------------
C
      IF ( IDIR .EQ. -1 ) THEN
        DO I=1,MAPNB-1
 150    CONTINUE
        IRC = InxDataRead( LUGRD, EOF )
        IF( IRC .NE. 0 .OR. EOF .NE. 0 ) GOTO 1000
        IRC = GetInxMapId( MAPNO, MAPTYP, TIMMAP )
        IF( IRC .NE. 0 ) GOTO 1000
        IF( MAPTYP .NE. 0 ) GOTO 150
        END DO
      END IF
C
C-----------------------------------------------------------------------
C     READ NEXT IONEX TEC MAP 
C-----------------------------------------------------------------------
C
      IF (MAPNB .LE. MAXMAP) THEN
C
c!      WRITE(*,*) 'IN RDSINX,MAP NB ANT TIME',MAPNB,MAXMAP,TIMMAP,IRC
 250    CONTINUE
        IRC = InxDataRead( LUGRD, EOF )
        IF( IRC .NE. 0 .OR. EOF .NE. 0 ) GOTO 1000
        IRC = GetInxMapId( MAPNO, MAPTYP, TIMMAP )
        IF( IRC .NE. 0 ) GOTO 1000
        IF( MAPTYP .NE. 0 ) GOTO 250
        IF( MAPNO .GT. MAPNB ) GO TO 1000
C
C-----------------------------------------------------------------------
C       STORE TEC MAP FOR THIS EPOCH
C-----------------------------------------------------------------------
C
        NBLON = IDNINT((ELON-SLON)/DLON)
        NBLAT = IDNINT((ELAT-SLAT)/DLAT)+1
        DO ILON=1,NBLON
          PPLON = SLON+(ILON-1)*DLON
          DO ILAT=1,NBLAT
            PPLAT = SLAT+(ILAT-1)*DLAT
            IRC = GetInxMapTec( PPLAT, PPLON, TECMAP(ILON,ILAT) )
            IF ( IRC .EQ. 0 .AND.
     &           PPLAT .LE. REFLAT .AND. PPLAT .GE. ENDLAT ) THEN
              CALL IDXPP(MININC,REFLAT,SLON,DLAT,DLON,1,
     &                     PPLAT,PPLON,IDXLAT,IDXLON,IERROR)
              AION(IDXLAT,IDXLON)=TECMAP(ILON,ILAT)*10.1D0
c!            WRITE(*,'(I4,2F8.1,2I10,2F10.2)')
c!    &              MAPNB,PPLAT,PPLON,IDXLAT,IDXLON,
c!    &              AION(IDXLAT,IDXLON),RION(IDXLAT,IDXLON)
            END IF
          END DO
        END DO
      END IF
C
 1000 CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDSP3E
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDSP3E ( LPR, LUPEP, NPEPSV, IPEPSV, ITT, 
     &                    XSV, DT, SSVX, BAS1, BAS2, ISSVX, IEND )
C
C     NAME:      RDSP3E
C
C     PURPOSE:   READ EPOCH COORDINATES AND CLOCK OFFSETS
C                FOR ALL SATELLITES
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     LPR               LOGICAL UNIT OF PRINTER
C     LUPEP             LOGICAL UNIT OF PRECISE EPHEMERIS FILE
C     NPEPSV            NUMBER OF SATELLITES WITH PRECISE EPHEMERIS
C     IPEPSV            ARRAY OF PRN'S WITH PRECISE EPHEMERIS
C     ISV               PRN OF SELECTED  SATELLITE
C     ITT               TIME TAG
C     XSV               PRECISE SATELLITE COORDINATES
C     DT                PRECISE SATELLITE CLOCK OFFSET
C     IEND              END OF FILE FLAG
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4 LPR,LUPEP,NPEPSV,IPEPSV(*),ITT,IEND 
      REAL*8    DT(*),XSV(MAXSAT,3)
C
      CHARACTER*2   IDLIN
      INTEGER*4 IYEAR,IMONTH,IDAY,IHOUR,IMIN,IWAY,JULD,IGPSWK,IWKDAY
      INTEGER*4 IPRN,IS
      REAL*8    SEC,SECOW
      REAL*8    SSVX(1440, 4, MAXSAT), BAS1, BAS2
      INTEGER*4 ISSVX, IX(4), I
C
C     READ EPOCH SATELLITE COORDINATES AND CLOCK OFFSETS
C
500   CONTINUE
      READ(LUPEP,1800,ERR=600,END=600) IDLIN,IYEAR,IMONTH,IDAY,
     &                                   IHOUR,IMIN,SEC
      IF( IDLIN .NE. '* ' ) GO TO 500
c!    WRITE(*,*) IDLIN,IYEAR,IMONTH,IDAY,IHOUR,IMIN,SEC
      IWAY = 2
      CALL GPSDC ( JULD,IYEAR,IMONTH,IDAY,IGPSWK,IWKDAY,IWAY )
      IWAY = 1
      CALL TOWHMS( IWKDAY, SECOW, IHOUR, IMIN, SEC, IWAY )
      ITT=IGPSWK*604800+SECOW
      ISSVX = ISSVX +1
      DO IS=1,NPEPSV
        IF( IS .LE. MAXSAT ) THEN
      READ(LUPEP,1900,ERR=600,END=600) IDLIN, IPRN, 
     &       XSV(IS,1), XSV(IS,2), XSV(IS,3), DT(IS), IX
      IF( IDLIN .NE. 'P ' .AND. IDLIN .NE. 'p ' )
     &    READ(LUPEP,1900,ERR=600,END=600) IDLIN, IPRN, 
     &       XSV(IS,1), XSV(IS,2), XSV(IS,3), DT(IS)
        ELSE
      READ(LUPEP,1901,ERR=600,END=600) IDLIN
      IF( IDLIN .NE. 'P ' .AND. IDLIN .NE. 'p ' )
     &     READ(LUPEP,1901,ERR=600,END=600) IDLIN
      END IF
      IF( IPEPSV(IS) .NE. 0 ) THEN
       DO I= 1,3
        SSVX(ISSVX, I, IPEPSV(IS)) = 0.D0
        IF(IX(I).GT.0) SSVX(ISSVX,I,IPEPSV(IS))= BAS1**IX(I)
       END DO
       SSVX(ISSVX,4, IPEPSV(IS)) = 0.D0
       IF(IX(4).GT.0) SSVX(ISSVX, 4,IPEPSV(IS)) = BAS2**IX(4)
      END IF
      END DO
      IEND = 0
      RETURN
C
C     REACHED END OF FILE OR NO COORDINATES FOUND
C
  600 CONTINUE
      IEND = 1
      RETURN
C
C  FORMAT STATEMENTS
C  -----------------
C
 1000 FORMAT ( A2,1X,I4,1X,4(I2,1X),F11.8,1X,I7,1X,2(A5,1X),A3,1X,A4 )
 1100 FORMAT ( A2,1X,I4,1X,F15.8,1X,F14.8,1X,I5,1X,F15.13 )
 1200 FORMAT ( A2,2X,I2, 3X, 17I3 )
 1300 FORMAT ( 9X, 17I3 )
 1400 FORMAT ( A2,2(1X,A2), 2(1X,A3),4(1X,A4),4(1X,A5) )
 1500 FORMAT ( A2,1X,F10.7,1X,F12.9,1X,F14.11,1X,F18.15 )
 1600 FORMAT ( A2,4(1X,I4),4(1X,I6),1X,I9 )
 1700 FORMAT ( A2,1X,A57 )
 1800 FORMAT ( A2,1X,I4,4(1X,I2),1X,F11.8 )
 1900 FORMAT ( A1,1X,I2,4F14.6, 3(1x,I2),1X, I3 )
 1901 FORMAT ( A1 )
 2000 FORMAT ( I4,4I3,F11.7,3F13.5,3F12.8 )
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** RDSSLM
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDSSLM ( LUGRD, LUO, STNLAT, IYGRD, IMGRD, IDGRD,
     &                   STNA,
     &                   SLAT, ELAT, DLAT, SLON, ELON, DLON, 
     &                   TION, AION, RION, 
     &                   NRX, IRXDCB, RXDCB, RXDCBS, 
     &                   NSV, ISVDCB, SVDCB, SVDCBS,
     &                   MININC, SLMHGT, IONREF, IONFMT,
     &                   PI, MAPNB, MAXMAP, MAPINT, IONBAND, REFLAT, 
     &                   IEXP,
     &                          IRC, IDIR )
C
C     NAME       :  RDSSLM
C
C     PURPOSE    :  READ IONOSPHERIC GRID AND SATELLITE 
C                   CALIBRATION DELAYS
C
C     PARAMETERS       DESCRIPTION
C
C     LUGRD            LOGICAL UNIT OF SINGLE LAYER GRID
C     LUO              LOGICAL UNIT OF OUTPUT
C     IYGRD            YEAR OF ION GRID
C     IMGRD            MONTH OF ION GRID
C     IDGRD            DAY OF MONTH OF ION GRID
C     STNLAT           STATION LATITUDE (RADIANS)
C     SLAT             START LATITUDE OF GRID (DEGREES)
C     ELAT             END LATITUDE OF GRID (DEGREES)
C     DLAT             LATITUDE INCREMENT OF GRID (DEGREES)
C     SLON             START LONGITUDE OF GRID (DEGREES)
C     ELON             END LONGITUDE OF GRID (DEGREES)
C     DLON             LONGITUDE INCREMENT OF GRID (DEGREES)
C     TION             TIME OF IONOSPHERIC GRID (SECONDS OF DAY)
C     AION             VERTICAL IONOSPHERIC DELAY IN CELL (M)
C     DION             VERTICAL IONOSPHERIC DELAY RATE IN CELL (M/S)    
C     RION             RMS OF VERTICAL IONOSPHERIC DELAY IN CELL (M)
C     NSV              NUMBER OF SATELLITES CALIBRATED
C     SVDCB            SATELLITE L1/L2 DCB 
C     SVDCBS           SATELLITE L1/L2 DCB SIGMA
C     NRX             NUMBER OF STATIONS USED IN GRID ESTIMATION
C     IRXDCB           STATION NAME
C     RXDCB            STATION L1/L2 DCB 
C     RXDCBS           STATION L1/L2 DCB SIGMA
C     MININC           MINIMUM .1 DEGREE INCREMENTS IN CELL SIZE
C     SLMHGT           SINGLE LAYER MODEL HEIGHT
C     ELVCUT           ELEVATION CUTOFF
C     IONREF           ION GRID REFERENCE (0=EARTH-FIXED/GEOGRAPHIC)
C                                         (1=SUN-FIXED/GEOMAGNETIC)
C     IONFMT           ION GRID FORMAT (1=GRD,2=INX)
C     IRC              RETURN CODE (0=ERROR OCCURRED, 1=OK)
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      CHARACTER*4      IRXDCB(*)
      CHARACTER*40      STNA
      INTEGER*4 LUGRD,LUO,IYGRD,IMGRD,IDGRD,NRX,NSV,MININC,IONREF
      INTEGER*4 IONFMT,MAPNB,MAXMAP,MAPINT,IONBAND,IRC,IDIR,IEXP
      INTEGER*4 ISVDCB(*)
      REAL*8    STNLAT,SLAT,ELAT,DLAT,SLON,ELON,DLON,TION,SLMHGT
      REAL*8    REFLAT,PI,SVDCB(*),SVDCBS(*),RXDCB(*),RXDCBS(*)
      REAL*8             AION(MAXLAT,*),RION(MAXLAT,*)
C
      INTEGER*4 MAPTYP
C
C     READ FIRST RECORD OF FILE AND DETERMINE FORMAT
C
c!    WRITE(*,*) "IONFMT BEFORE GRDFMT",IONFMT
      IF ( IONFMT .EQ. 0 ) CALL GRDFMT(LUGRD,LUO,IONFMT)
c!    WRITE(*,*) "IONFMT AFTER GRDFMT",IONFMT
      IF ( IONFMT .NE. 1 ) THEN
        IRC=0
        RETURN
      END IF
      MAPTYP=1  
C
C     READ IONEX FILE
C
        IONREF=0
        CALL RDSINX ( LUGRD, LUO, STNLAT, IYGRD, IMGRD, IDGRD,
     &                STNA,
     &                SLAT, ELAT, DLAT, SLON, ELON, DLON, 
     &                TION, AION, RION, 
     &                NRX, IRXDCB, RXDCB, RXDCBS, 
     &                NSV, ISVDCB, SVDCB, SVDCBS,
     &                MININC, SLMHGT, MAPNB,
     &                MAXMAP, IONBAND, IRC, REFLAT, PI, 
     &                IEXP,
     &                MAPINT, MAPTYP, IDIR )
C
      IF ( MAXMAP .EQ. 1 ) MAPINT=86400
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDSTC
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDSTC( LUSTC, ICLKAP, CLKY0, CLKD0 ,
     &                                 UCLKY0, UCLKD0, CLKSD0,
     &                                 ICLKFIT )
C
C     NAME              RDSTC
C
C     PURPOSE   READ STATION CLOCK APRIORI INFO
C
C     PARAMETERS        DESCRIPTION
C
C        LUSTC        LOGICAL UNIT OF FILE WITH CLOCK PARAMETERS 
C          ICLKAP       APRIORI CLOCK SWITCH
C          CLKY0        APRIORI CLOCK FREQUENCY OFFSET (unitless)
C          CLKD0        APRIORI CLOCK FREQUENCY DRIFT (1/seconds)
C          UCLKY0       APRIORI CLOCK FREQUENCY OFFSET UNCERT. (unitless)
C          UCLKD0       APRIORI CLOCK FREQUENCY DRIFT UNCERT. (1/seconds)
C          CLKSD0       APRIORI CLOCK ADEV(1second)    (unitless)
C        ICLKFIT      POLYNOMIAL DEGREE TO BE FITTED (1 or 2)
C
C       NOTE: THESE PARAMETERS WILL OVERRIDE ADEV(1s) OBTAINED IN RDFLT
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4 LUSTC, ICLKAP
     &         , ICLKFIT
      REAL*8    CLKY0, CLKD0, UCLKY0, UCLKD0, CLKSD0
C
      CHARACTER*80 RECORD
      CHARACTER*3 HDR
C
      ICLKAP=0
      CLKY0 = 0.D0
      CLKD0 = 0.D0
      UCLKY0 = 0.D0
      UCLKD0 = 0.D0
      CLKSD0 = 0.D0
  100 CONTINUE
      READ(LUSTC,'(A)',END=500) RECORD
      READ(RECORD,'(A3)',ERR=400) HDR
      IF ( HDR .EQ. 'DEG' ) THEN 
c!    WRITE(*,*) RECORD
        READ(RECORD(4:),*) ICLKFIT
      IF( ICLKFIT .LT. 1 ) ICLKFIT=1
      IF( ICLKFIT .GT. 2 ) ICLKFIT=2
      END IF
      IF ( HDR .EQ. 'STC' ) THEN 
c!      WRITE(*,*) RECORD
        READ(RECORD(4:),*) CLKY0, CLKD0 , CLKSD0
      IF( CLKY0 .NE. 0.D0 .OR. CLKD0 .NE. 0.D0 .OR. CLKSD0 .NE. 0.D0 )
     &    ICLKAP = 1
      END IF
      IF ( ICLKAP .EQ. 1 .AND. HDR .EQ. 'STD' ) THEN 
c!      WRITE(*,*) RECORD
        READ(RECORD(4:),*) UCLKY0, UCLKD0 
      IF( UCLKY0 .NE. 0.D0 .OR. UCLKD0 .NE. 0.D0 )
     &    ICLKAP = 2
      END IF
      GO TO 100
  400 CONTINUE
      WRITE(*,*) 'ERROR ENCOUNTERED READING ', RECORD
      GO TO 100      
  500 CONTINUE
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RDTRF
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RDTRF( LUTRF, RFRAME, RFREAL, TRFPAR, ITRFPAR )
C
C     NAME              RDTRF
C
C     PURPOSE   READ REFERENCE FRAME TRANSFORMATION PARAMETERS
C
C     PARAMETERS        DESCRIPTION
C
C        LUTRF  LOGICAL UNIT OF TRANSFORMATION PARAMETERS
C          IFRSP3       REFERENCE FRAME REALISATION FROM  SP3 ORBIT
C          TRFPAR       TRANSFORMATION PARAMETERS (NAD83<->TRFxx)
C          ITRFPAR      TRANSFORMATION PARAMETERS USED (0=DEFAULT,1=FILE)
C
C *********************************************************************
C
      IMPLICIT NONE
C
      CHARACTER*5   RFRAME
      CHARACTER*5   RFREAL
      INTEGER*4 LUTRF,ITRFPAR
      REAL*8    TRFPAR(*)
C
      CHARACTER*130 RECORD
      CHARACTER*3   HEADER
      CHARACTER*2   ITREAL
      INTEGER*4 ITRFYR,I
C
      TRFPAR(1)=2008.D0
      TRFPAR(2)=1997.0D0
      TRFPAR(3)=99.34D0
      TRFPAR(4)=-190.33D0
      TRFPAR(5)=-52.66D0
      TRFPAR(6)=1.72D0
      TRFPAR(7)=-25.915D0
      TRFPAR(8)=-9.426D0
      TRFPAR(9)=-11.599D0
      TRFPAR(10)=0.08D0
      TRFPAR(11)=-0.06D0
      TRFPAR(12)=-0.13D0
      TRFPAR(13)=-0.100D0
      TRFPAR(14)=-0.0670D0
      TRFPAR(15)=0.7570D0
      TRFPAR(16)=0.0510D0
      ITRFPAR=0
C
  100 CONTINUE
      READ(LUTRF,'(A)',END=500) RECORD
      READ(RECORD,'(A3)',ERR=400) HEADER
      IF ( HEADER .EQ. 'TRF' .OR. HEADER .EQ. 'NAD' 
     &                                .OR. HEADER .EQ. 'WGS') THEN
        READ(RECORD(5:),*,ERR=400) (TRFPAR(I),I=1,16)
      ITRFYR=INT(TRFPAR(1))
        ITRFYR=MOD(ITRFYR,100)
        WRITE(ITREAL,'(I2.2)') ITRFYR 
        IF ( RFREAL(4:5) .EQ. ITREAL ) RETURN
        IF ( RFRAME(4:5) .EQ. ITREAL ) RETURN
      END IF
      GO TO 100
  400 CONTINUE
      WRITE(*,*) 'ERROR ENCOUNTERED READING ', RECORD
      GO TO 100
  501 WRITE(*,*) 'EOF ENCOUNTERED'       
  500 CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C************************************************************* RELATE
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RELATE ( IPRN, XRV, XSV, VSV, MJD, FMJDDT, GHADOT, C,
     &                    PRE, PREIN )
C
C       NAME            RELATE
C
C       PURPOSE         TRANSFORMS THE RECTANGULAR EARTH-FIXED     
C                       SATELLITE CO-ORDINATES TO INERTIAL AND
C                       THEN COMPUTES THE PERIODIC RELATIVITY 
C                       EFFECT AS GIVEN BY RALPH GIBSON:       
C                       "A DERIVATION OF RELATIVISTIC EFFECTS 
C                        IN SATELLITE TRACKING", NSWC, FORMULA 
C                        TAKEN FROM PAGES 6 AND 7.                   
C
C     PARAMETERS        DESCRIPTION
C
C         IPRN          SATELLITE PRN NUMBER
C         XRV           STATION TERRESTRIAL COORDINATES
C         XSV           SATELLITE TERRESTRIAL COORDINATES
C         VSV           SATELLITE TERRESTRIAL VELOCITIES
C         MJD           MODIFIED JULIAN DATE
C         FMJDDT        FRACTIONAL PART OF DAY
C         PRE           EFFECT OF RELATIVITY
C
      IMPLICIT NONE
      INTEGER*4 IPRN, MJD
      REAL*8 XRV(*), XSV(*),VSV(*), FMJDDT, GHADOT, C, PRE, PREIN
C
C      INTEGER*4 MJD
C
      REAL*8 AT,T,T2,BT,CT,DT,GHAAPP,COSTH,SINTH,RDOTV,RHO,R1,R2
      REAL*8 XSVIN(3),VSVIN(3)
      REAL*8 XRVIN(3)
      DATA AT/6.646065661D0/
      T=(MJD-15019.5D0)/36525.D0
      T2=T*T
      BT=2400.051286D0 * T
      BT=DMOD(BT,24.D0)
      CT=0.000025806D0 * T2
      DT=FMJDDT*86400.D0*GHADOT
      DT=DT*3.81971863D0
      GHAAPP=AT + BT + CT + DT
      GHAAPP=GHAAPP/3.81971863D0
      COSTH=DCOS(GHAAPP)
      SINTH=DSIN(GHAAPP)
C
C  CONVERT TO INERTIAL COORDIANTES
C
      XSVIN(1)=XSV(1)*COSTH - XSV(2)*SINTH
      XSVIN(2)=XSV(1)*SINTH + XSV(2)*COSTH
      XSVIN(3)=XSV(3)
C
      XRVIN(1)=XRV(1)*COSTH - XRV(2)*SINTH
      XRVIN(2)=XRV(1)*SINTH + XRV(2)*COSTH
      XRVIN(3)=XRV(3)
C  
      VSVIN(1)=VSV(1)*COSTH - VSV(2)*SINTH - XSVIN(2)*GHADOT
      VSVIN(2)=VSV(1)*SINTH + VSV(2)*COSTH + XSVIN(1)*GHADOT
      VSVIN(3)=VSV(3)
C  PRE = 2*R.V/C
      RDOTV=XSVIN(1)*VSVIN(1)+XSVIN(2)*VSVIN(2)+XSVIN(3)*VSVIN(3)
C  PERIODIC EFFECT IN RANGE (M)
c!    PREIN=(RDOTV+RDOTV)/C
      PRE  =(RDOTV+RDOTV)/C
C  TEST IN ECEF
      RDOTV=XSV(1)*VSV(1)+XSV(2)*VSV(2)+XSV(3)*VSV(3)
c!    WRITE(*,'(A18,I2.2,3X,I2.2,3F12.2,3F10.2)') 
c!   &           'SPECIAL RELATIVITY',IPRN,IPRN,
c!   &            XSVIN(1),XSVIN(2),XSVIN(3),VSVIN(1),VSVIN(2),VSVIN(3) 
c!    WRITE(*,'(A18,I2.2,3X,I2.2,3F12.2,3F10.2)') 
c!   &           'SPECIAL RELATIVITY',IPRN,IPRN,
c!   &            XSV(1),XSV(2),XSV(3),VSV(1),VSV(2),VSV(3) 
c!    WRITE(*,'(A18,I2.2,3X,I2.2,3F10.2)') 
c!   &           'SPECIAL RELATIVITY',IPRN,IPRN,
c!   &            PRE, PREIN,PRE-PREIN 
C!!
C!! General relativity correction: IERS96 Conventions, p. 92 Eqn. 17
C!! NOTE: ln(10)=2.3025850930d0
C!! APPLY OR NOT
C!! Code Beg ==================================================================
      RHO  = SQRT( (XSV(1)-XRV(1))**2+(XSV(2)-XRV(2))**2
     &+(XSV(3)-XRV(3))**2)
      R1   = SQRT( XRV(1)**2+XRV(2)**2+XRV(3)**2)
      R2   = SQRT( XSV(1)**2+XSV(2)**2+XSV(3)**2)
      PRE = PRE + 2.d0* 3.986004418D14*log((R1+R2+RHO)/(R1+R2-RHO))
     & *2.302585093D0/C/C
C!! Code End ==================================================================
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RNGCOR
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RNGCOR ( ISV,NOBS,IARC,RCOR,NRC,RCAVG,RCSIG,RCRMS
     &                   ,SD,PL,IOBTYP,IOB )
C
C     PURPOSE:   TO COMPUTE MEAN RANGE CORRECTIONS
C            AND THEIR RESPECTIVE RMS FOR EACH OBSERVED
C            SATELLITE
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C       ISV             SATELLITE ID LIST
C       NOBS            NUMBER OF RANGES OBSERVED AT THIS EPOCH
C       IARC            ARC NUMBER
C       RCOR            RANGE CORRECTIONS OR RESIDUALS AT THIS EPOCH
C       NRC             NUMBER OF RANGE CORRECTIONS OR RESIDUALS
C       RCAVG   AVERAGE RANGE CORRECTION OR RESIDUAL
C       RCSQR   SUM OF SQUARED RANGE CORRECTIONS OR RESIDUALS
C       RCRMS   RANGE CORRECTIONS OR RESIDUALS RMS
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4      NOBS,          ISV(MAXOBS)
      INTEGER*4      IARC(MAXSAT)
      INTEGER*4      NRC(MAXSAT,MAXARC)
      REAL*8         RCOR(MAXOBS,1)
      INTEGER*4      IOBTYP,IOB
      REAL*8         SD,PL(MAXOBS2,*)
      REAL*8         RCAVG(MAXSAT,MAXARC), RCSIG(MAXSAT,MAXARC)
      REAL*8         RCRMS(MAXSAT,MAXARC)
C
      INTEGER*4      I, IS, IA
      INTEGER*4      IDX
C
      DO 100 I=1,NOBS
      IS = ISV(I)
      IA = IARC(IS)
      IDX=IOBTYP*(I-1)+IOB
      NRC(IS,IA) = NRC(IS,IA) + 1
      RCAVG(IS,IA) = RCAVG(IS,IA) +
     &   ( RCOR(I,1) *SD*PL(IDX,IDX)**0.5 - RCAVG(IS,IA) )
     &                  /  NRC(IS,IA)
      RCRMS(IS,IA) = DSQRT(RCRMS(IS,IA)**2*(1.D0-1.D0/NRC(IS,IA)) 
     &                 + RCOR(I,1)**2 *SD*SD*PL(IDX,IDX) /NRC(IS,IA))
      IF( NRC(IS,IA) .GT. 1)
     &   RCSIG(IS,IA) = DSQRT(RCRMS(IS,IA)**2 - RCAVG(IS,IA)**2)
  100 CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C************************************************************* RNGRT
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RNGRT ( XRV, XSV, VSV, C, RNG, RRATE, DIRC )
C
C       NAME            RNGRT
C
C       PURPOSE         Compute station-satellite range rate
C
C     PARAMETERS        DESCRIPTION
C
C         XRV           RECEIVER ECEF COORDINATES (m)
C         XSV           SATELLITE ECEF COORDINATES (m)
C         VSV           SATELLITE ECEF VELOCITIES (m/s)
C         C             SPEED OF LIGHT (m/s)
C         RNG           RANGE (m)
C         RRATE         RANGE RATE (m/s)
C         DIRC          DIRECTION COSINES (unitless)
C
      IMPLICIT NONE
C
      REAL*8    XRV(*), XSV(*), VSV(*), DIRC(*), C, RNG, RRATE
C
      INTEGER*4 I
      REAL*8    RELCOR,DX(3)
C
      RNG = 0.0D0
      DO I= 1,3
        DX(I) = XRV(I) - XSV(I)
        RNG   = RNG + DX(I) * DX(I)
      END DO
      RNG = DSQRT(RNG)
C
      RELCOR = 1.0D0
      DO I= 1,3
         RELCOR = RELCOR - ((DX(I)/RNG)*(VSV(I)/C))
      END DO
C
      RELCOR=1.D0/RELCOR
      DO I= 1,3
        DX(I)=DX(I)/RNG*RELCOR
      END DO
      RRATE=DX(1)*VSV(1)+DX(2)*VSV(2)+DX(3)*VSV(3)
      DIRC(1)=-DX(1)
      DIRC(2)=-DX(2)
      DIRC(3)=-DX(3)
c!    WRITE(*,*) 'RANGE RATE',RRATE
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C***************************************************************** RNXEP
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RNXEP (LPR,LUEPH,NEPSV,IEPSV,NEPTIM,EPHTIM,EPHTBL,
     &                  AIONBRD, BIONBRD, ISRCH)
C
C     PURPOSE:   TO READ THE EPHEMERIS DATA IN RINEX FORMAT
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     LPR               LOGICAL UNIT OF PRINTER
C     LUEPH             LOGICAL UNIT OF EPHEMERIS FILE
C     NEPSV             NUMBER OF SATELLITES WITH EPHEMERIS
C     IEPSV             SATELLITE ID'S
C     NEPTIM            NUMBER OF EPHEMERIS DOWNLOADED PER SATELLITE
C     EPHTIM            ARRAY OF EPHEMERIS SORTING TIMES
C     EPHTBL            TABLE OF EPHEMERIDES
C       ISRCH           SORT OPTION: 0) RECEIVE TIME
C                                    1) REFERENCE TIME
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
      INTEGER*4      LPR, LUEPH, NEPSV, ISRCH
      INTEGER*4      IEPSV(MAXSAT), NEPTIM(MAXSAT)
      REAL*8         EPHTIM(MAXSAT,MAXEPH)
      REAL*8         EPHTBL(MAXKEP,MAXSAT,MAXEPH)
      REAL*8         AIONBRD(*), BIONBRD(*)
C
      INTEGER*4      ISV,IVERS,IPRN
      INTEGER        IYR,IMTH,IDAY,IHR,IMN
      CHARACTER*80   RECORD
      CHARACTER*20   COMMENT
      REAL*8         EPH(30), CODL2, FLAGL2, TXTIME,SC
C
C------------------------------------------------------------------------
C     STRIP HEADER RECORDS FROM RINEX FORMAT
C------------------------------------------------------------------------
C
   50 CONTINUE
      READ(LUEPH,'(A80)',END=500) RECORD
c!    WRITE(*,*) RECORD
      COMMENT = RECORD(61:80)
C
C     GET RINEX VERSION NUMBER
C
      IF ( COMMENT .EQ. 'RINEX VERSION / TYPE' )
     &              READ(RECORD,'(I6)') IVERS
C
C     GET IONOSPHERE ALPHA COEFFICIENTS
C
      IF ( COMMENT .EQ. 'ION ALPHA           ' )
     &   READ(RECORD,'(2X,4D12.4)') AIONBRD(1), AIONBRD(2),
     &                              AIONBRD(3), AIONBRD(4)
C
C     GET IONOSPHERE BETA COEFFICIENTS
C
      IF ( COMMENT .EQ. 'ION BETA            ' )
     &   READ(RECORD,'(2X,4D12.4)') BIONBRD(1), BIONBRD(2),
     &                              BIONBRD(3), BIONBRD(4)
C
C BLANK LINE IS END OF HEADER
C
      IF ( COMMENT .EQ. '                    ' .OR.
     &            COMMENT .EQ. 'END OF HEADER       ') GO TO 100
      GO TO 50
C
  100 CONTINUE
C
      READ(LUEPH,1000,ERR=50,END=500) IPRN,IYR,IMTH,IDAY,IHR,IMN,SC,
     &                                EPH(11), EPH(10), EPH(9)
      EPH(1)=IPRN
c!    write(*,*) EPH(1),IYR,IMTH,IDAY,IHR,IMN,SC
      READ(LUEPH,1100,ERR=50,END=500) EPH(12), EPH(13), EPH(14),
     &                                EPH(15)
      READ(LUEPH,1100,ERR=50,END=500) EPH(16), EPH(17), EPH(18),
     &                                EPH(19)
      READ(LUEPH,1100,ERR=50,END=500) EPH(20), EPH(22), EPH(23),
     &                                EPH(24)
      READ(LUEPH,1100,ERR=50,END=500) EPH(25), EPH(26), EPH(27),
     &                                EPH(28)
      READ(LUEPH,1100,ERR=50,END=500) EPH(30), CODL2  , EPH(2),
     &                                FLAGL2
      READ(LUEPH,1100,ERR=50,END=500) EPH(4) , EPH(5) , EPH(6),
     &                                EPH(7)
      IF ( IVERS .EQ. 2 ) THEN
               READ(LUEPH,1200,ERR=50,END=500) TXTIME
           TXTIME=TXTIME+EPH(2)*604800.D0
      ELSE
           TXTIME = 0.0
      END IF
      EPH(3) = CODL2 + FLAGL2 * 256
C
      EPH(8)  = EPH(20)
      EPH(29) = EPH(12)
C CURVE FIT INTERVAL FLAG FROM RINEX CAN NOT BE DETERMINED WITHOUT AMBIGUITY
C 6hrs INTERVAL WILL BE MISTAKEN FOR 4hrs INTERVAL
      IF (EPH(12) .LT. 240.D0) THEN
         EPH(21)=4.D0 
      ELSE IF (EPH(7) .LT. 248.D0) THEN
         EPH(21)=8.D0 
      ELSE IF (EPH(7) .LT. 497.D0) THEN
         EPH(21)=14.D0 
      ELSE IF (EPH(7) .LT. 504.D0) THEN
         EPH(21)=26.D0 
      ELSE IF (EPH(7) .LT. 511.D0) THEN
         EPH(21)=50.D0 
      ELSE IF (EPH(7) .LT. 757.D0) THEN
         EPH(21)=74.D0 
      ELSE IF (EPH(7) .LT. 764.D0) THEN
         EPH(21)=98.D0 
      ELSE IF (EPH(7) .LT. 1011.D0) THEN
         EPH(21)=122.D0 
      ELSE IF (EPH(7) .LT. 1021.D0) THEN
         EPH(21)=146.D0
      END IF
      ISV = EPH(1)
c!    WRITE(*,9999) (EPH(I), I=1,30)
c9999 FORMAT (4D20.12)
C
C--------------------------------------------------------------------------
C     UPDATE NUMBER OF SATELLITES (NEPSV),
C     SATELLITE I.D. LIST (IEPSV)
C     NUMBER OF EPHEMERIS RECORDS PER SATELLITE (NEPTIM)
C     AND REFERENCE TIME OF EPHEMERIS (EPHTIM)
C--------------------------------------------------------------------------
C
      CALL UPTBL(ISV,TXTIME,EPH,NEPSV,IEPSV,NEPTIM,EPHTIM,EPHTBL,ISRCH)
      GO TO 100
C
C--------------------------------------------------------------------------
C        REACHED END OF FILE
C--------------------------------------------------------------------------
C
500   CONTINUE
      WRITE(*,*) 'REACHED END OF EPHEMERIS FILE', NEPSV
      RETURN
C
C--------------------------------------------------------------------------
C        FORMAT STATEMENTS
C--------------------------------------------------------------------------
C
 1000 FORMAT(I2,5I3,F5.1,3D19.12)
 1100 FORMAT(3X,4D19.12)
 1200 FORMAT(3X,D19.12)
C
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** RSETPX
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RSETPX ( NFPAR, NSVO, NSVOL, ISVO, 
     &                    XRVEPO, XRVAPR, CPAMB, OCPAMB, PX, OPX )
C
C     NAME              RSETPX
C
C     PURPOSE         RESET PARAMETERS AND VARIANCE-COVARIANCE  
C
C     PARAMETERS        DESCRIPTION
C
C          LPR          LOGICAL UNIT OF PRINT FILE
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4 NFPAR,NSVO,NSVOL,ISVO(*)
      REAL*8    XRVEPO(*),XRVAPR(*),CPAMB(*),OCPAMB(*)
      REAL*8    PX(MAXPAR2,MAXPAR2),OPX(MAXPAR2,MAXPAR2)
C
      INTEGER*4 I,J
C
          DO I=1, NFPAR
            XRVEPO(I) = XRVAPR(I)
          END DO
C
          DO I=1,NSVO
          CPAMB(ISVO(I)) = OCPAMB(ISVO(I))
          END DO
C
          DO I=1,NFPAR+NSVOL
            DO J=1,NFPAR+NSVOL
              PX(I,J)=OPX(I,J)
            END DO
          END DO
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C****************************************************************** RTCA
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RTCADLAY( LPR, PHI, LAM, AZ, EL, RTCAVERT, RTCAGIVE,
     &                     VERT, SLANT, PI )
      IMPLICIT NONE
C ARGUMENT VARIABLES
      INTEGER*4 LPR
      REAL*8    PHI,LAM,EL,AZ,VERT,SLANT,PI
      REAL*8    RTCAVERT(1808),RTCAGIVE(1808)
C LOCAL VARIABLES
      INTEGER*4 I,J,II,JJ,ILAT(2),ILON(4),IDX(2,4),INTLAT,INTLON
      INTEGER*4 NLAT,NLON,NP,NPP,SN,ID,IDD
      REAL*8 PSI,LATPP,LONPP,LIM,VIONO(2,4),XPP,YPP
      REAL*8 ERAD,HEIGHT,SL,W(2,4)
C FUNCTIONS
      INTEGER*4 GEO2IGP
      DATA INTLAT,INTLON,ERAD,HEIGHT/5,5,6378136.3D0,350000.D0/
      DATA IDX/8*-1/
      DATA VIONO/8*-1.D0/
C COMPUTE PIERCE POINT LOCATION
      PSI=0.D0
      IF( (90.D0 - EL) .GT. 1.D-6 )
     & PSI=(90.D0-EL)*PI/180D0-
     &           DASIN(ERAD*DCOS(EL*PI/180D0)/(ERAD+HEIGHT))
      LATPP=DASIN(DSIN(PHI)*DCOS(PSI)+
     &            DCOS(PHI)*DSIN(PSI)*DCOS(AZ*PI/180D0))
      LONPP=LAM+DASIN(DSIN(PSI)*DSIN(AZ*PI/180.D0)/DCOS(LATPP))
      LATPP=180.D0*LATPP/PI
      LONPP=180.D0*LONPP/PI
      IF( LONPP .LT. 0.D0 ) LONPP=LONPP+360.D0
C SPECIAL CASE ABOVE/BELOW +/- 85DEG LAT
      IF( DABS(LATPP) .GE. 85.D0 ) THEN
       NLAT=1
       NLON=4
       INTLAT=10
       INTLON=90
       ILAT(1)=DSIGN(85.D0,LATPP)
       IF( LATPP .GT. 0.D0 ) THEN
        ILON(1)=IDINT(LONPP/90)*90
       ELSE IF( LONPP .LT. 40.D0 ) THEN
        ILON(1)=IDINT((LONPP+320)/90)*90+40
       ELSE
        ILON(1)=IDINT((LONPP-40)/90)*90+40
       END IF
       DO I=2,4
      ILON(I)=ILON(I-1)+90
       END DO
C SPECIAL CASE ABOVE/BELOW +/- 75DEG LAT
      ELSE IF( DABS(LATPP) .GE. 75.D0 ) THEN
       NLAT=2
       NLON=2
       INTLAT=10
       INTLON=10
       IF( LATPP .GT. 0.D0 ) THEN
        ILAT(1)=75
        ILAT(2)=85
        ILON(1)=IDINT(LONPP/90)*90
        ILON(2)=ILON(1)+90
        ILON(3)=IDINT(LONPP/INTLON)*INTLON
        ILON(4)=ILON(2)+INTLON
       ELSE
        ILAT(1)=-85
        ILAT(2)=-75
        IF( LONPP .GE. 40.D0 ) THEN
         ILON(1)=IDINT((LONPP-40)/90)*90+40
        ELSE
         ILON(1)=IDINT((LONPP+320)/90)*90+40
        END IF
        ILON(2)=ILON(1)+90
        ILON(3)=IDINT(LONPP/INTLON)*INTLON
        ILON(4)=ILON(3)+INTLON
       END IF
C SPECIAL CASE ABOVE/BELOW +/- 55DEG LAT
      ELSE IF( DABS(LATPP) .GT. 55.D0 ) THEN
       NLAT=2
       NLON=2
       INTLON=10
       INTLAT=10
       IF( LATPP .LT. 0.D0 ) THEN
        ILAT(2)=-(5+IDINT((DABS(LATPP)-5)/INTLAT)*INTLAT)
        ILAT(1)=ILAT(2)-INTLAT
       ELSE
        ILAT(1)=5+IDINT(DABS(LATPP-5)/INTLAT)*INTLAT
        ILAT(2)=ILAT(1)+INTLAT
       END IF
       ILON(1)=IDINT((LONPP)/INTLON)*INTLON
       ILON(2)=ILON(1)+INTLON
C IN 5X5 GRID SELECT 5X5 SURROUNDING GRID POINTS
      ELSE
       NLAT=2
       NLON=2
       INTLON=5
       INTLAT=5
       IF( LATPP .LT. 0.D0 ) THEN
        ILAT(2)=-IDINT(DABS(LATPP)/INTLAT)*INTLAT
      IF( ILAT(2) .EQ. -55 ) THEN
       ILAT(1)=-55
       ILAT(2)=-50
      ELSE
         ILAT(1)=ILAT(2)-INTLAT
      END IF
       ELSE
        ILAT(1)=IDINT(DABS(LATPP)/INTLAT)*INTLAT
      IF( ILAT(1) .EQ. 55 ) THEN
       ILAT(1)=50
       ILAT(2)=55
      ELSE
         ILAT(2)=ILAT(1)+INTLAT
      END IF
       END IF
       ILON(1)=IDINT((LONPP)/INTLON)*INTLON
       ILON(2)=ILON(1)+INTLON
      END IF
C CHECK AVAILABILITY: NEGATIVE VERTICAL DELAY IMPLIES MASK NOT SET
C LOAD 5X5 TRIANGLE/SQUARE SURROUNDING PIERCE POINT
      NP=0
      DO I=1,NLAT
       DO J=1,NLON
      IDX(I,J)=GEO2IGP( ILAT(I), ILON(J) )
      IF( IDX(I,J) .NE. -1 .AND.
     &      RTCAVERT(IDX(I,J)) .LT. 0 ) IDX(I,J)=-1
        IF( IDX(I,J) .GT. 0 ) THEN
       NP=NP+1
       VIONO(I,J)=RTCAVERT(IDX(I,J))
        ELSE IF ( DABS(LATPP) .LT. 75.D0 ) THEN
       ID=(I-1)*NLAT+J
         LIM=LONPP-ILON(1)+ILAT(1)
       SN=1
         IF( I .EQ. 1) SN=-1
        END IF
       END DO
      END DO
C TRY EXPAND IN 10X10 SQUARE/TRIANGLE IF REQUIRED
      IF( INTLON .EQ. 5 .AND.
     &    ( ( NP .GT. 0 .AND. NP .LT. 3 ) .OR.
     &      ( NP .LT. 4 .AND.
     &         SN*LATPP .GT. SN*LIM ) ) ) THEN
       NP=0
       IDD=0
       INTLON=10
       INTLAT=10
       DO I=1,NLAT
       DO J=1,NLON
      IF( NP .LT. 4 .AND. IDX(I,J) .GT. 0 ) THEN
         NPP=0
       ILAT(MOD(I,2)+1)=ILAT(I)+(MOD(I,2)+1-I)*INTLAT
       ILON(MOD(J,2)+1)=ILON(J)+(MOD(J,2)+1-J)*INTLON
       DO II=1,NLAT
       DO JJ=1,NLON
        ID=GEO2IGP( ILAT(II), ILON(JJ) )
        IF( ID .NE. -1 .AND. RTCAVERT(ID) .NE. -1 ) THEN
           NPP=NPP+1
          ELSE IF( DABS(LATPP) .LT. 75.D0 ) THEN
           LIM=LONPP-ILON(1)+ILAT(1)
         SN=1
           IF( II .EQ. 1 ) SN=-1
        END IF
       END DO
       END DO
       IF( NPP .GT. NP .AND.
     &       ( NPP .EQ. 4 .OR.
     &        ( NPP .EQ. 3 .AND. SN*LATPP .LE. SN*LIM ) ) ) THEN
        NP=NPP
        IDD=(I-1)*NLAT+J
       END IF
       ILAT(MOD(I,2)+1)=ILAT(I)+(MOD(I,2)+1-I)*INTLAT/2
       ILON(MOD(J,2)+1)=ILON(J)+(MOD(J,2)+1-J)*INTLON/2
      END IF
       END DO
       END DO
       IF( NP .GE. 3 ) THEN
      I=(IDD-1)/NLAT+1
      J=IDD-(I-1)*NLAT
      ILAT(MOD(I,2)+1)=ILAT(I)+(MOD(I,2)+1-I)*INTLAT
      ILON(MOD(J,2)+1)=ILON(J)+(MOD(J,2)+1-J)*INTLON
      DO II=1,NLAT
      DO JJ=1,NLON
       IDX(II,JJ)=GEO2IGP( ILAT(II), ILON(JJ) )
       IF( IDX(II,JJ) .GT. 0 .AND.
     &       RTCAVERT(IDX(II,JJ)) .LT. 0 ) IDX(II,JJ)=-1
         IF( IDX(II,JJ) .GT. 0 ) THEN
        VIONO(II,JJ)=RTCAVERT(IDX(II,JJ))
         ELSE
        ID=(II-1)*NLAT+JJ
          LIM=LONPP-ILON(1)+ILAT(1)
        SN=1
          IF( II .EQ. 1 ) SN=-1
         END IF
      END DO
      END DO
       END IF
      END IF
C IF NOT ENOUGH POINTS SELECTED OR THERE IS A DO NOT USE: BRANCH OUT
      IF( NP .LT. 3 .OR.
     &    ( NP .LT. 4 .AND. SN*LATPP .GT. SN*LIM ) .OR.
     &    ( DABS(LATPP) .GE. 75.D0 .AND. NP .LT. 4 ) ) THEN
       VERT=999.D0
       SLANT=0.D0
       RETURN
      END IF
C BRANCH OUT IF THERE IS A DO NOT USE IN THE SELECTED POINTS
      DO I=1,NLAT
       DO J=1,NLON
        IF( IDX(I,J) .GT. 0 .AND.
     &      VIONO(I,J) .GT. 63.750D0 ) THEN
         VERT=999.D0
         SLANT=0.D0
         RETURN
        END IF
       END DO
      END DO
C INTERPOLATE THE +-85 LAT VALUES TO THE LONGITUDES
      IF( DABS(LATPP) .GE. 75.D0 .AND.
     &    DABS(LATPP) .LT. 85.D0 ) THEN
       I=2
       IF( LATPP .LT. 0.D0 ) I=1
       SL=(VIONO(I,2)-VIONO(I,1))/(ILON(2)-ILON(1))
       VIONO(I,1)=VIONO(I,1)+SL*(ILON(3)-ILON(1))
       ILON(1)=ILON(3)
       VIONO(I,2)=VIONO(I,2)+SL*(ILON(4)-ILON(2))
       ILON(2)=ILON(4)
      END IF
C COMPUTE WEIGHTS
      IF( NP .EQ. 4 ) THEN
       IF( DABS(LATPP) .GE. 85.D0 ) THEN
      YPP=(DABS(LATPP)-85.D0)/INTLAT
      XPP=YPP+(LONPP-ILON(1))/INTLON*(1.D0-2.D0*YPP)
      W(1,1)=(1.D0-XPP)*(1.D0-YPP)
      W(1,2)=XPP*(1.D0-YPP)
      W(1,3)=XPP*YPP
      W(1,4)=(1.D0-XPP)*YPP
       ELSE
      XPP=(LONPP-ILON(1))/INTLON
      YPP=(LATPP-ILAT(1))/INTLAT
      W(1,1)=(1.D0-XPP)*(1.D0-YPP)
      W(1,2)=XPP*(1.D0-YPP)
      W(2,1)=(1.D0-XPP)*YPP
      W(2,2)=XPP*YPP
       END IF
      ELSE
       IF( ID .EQ. 1 ) THEN
      W(1,1)=0.D0
      W(1,2)=DABS(LATPP-ILAT(2))/INTLAT
      W(2,1)=DABS(LONPP-ILON(2))/INTLON
      W(2,2)=1.D0-DABS(LATPP-ILAT(2))/INTLAT
     &             -DABS(LONPP-ILON(2))/INTLON
       ELSE IF( ID .EQ. 2 ) THEN
      W(1,2)=0.D0
      W(1,1)=DABS(LATPP-ILAT(2))/INTLAT
      W(2,2)=DABS(LONPP-ILON(1))/INTLON
      W(2,1)=1.D0-DABS(LATPP-ILAT(2))/INTLAT
     &             -DABS(LONPP-ILON(1))/INTLON
       ELSE IF( ID .EQ. 3 ) THEN
      W(2,1)=0.D0
      W(2,2)=DABS(LATPP-ILAT(1))/INTLAT
      W(1,1)=DABS(LONPP-ILON(2))/INTLON
      W(1,2)=1.D0-DABS(LATPP-ILAT(1))/INTLAT
     &             -DABS(LONPP-ILON(2))/INTLON
       ELSE IF( ID .EQ. 4 ) THEN
      W(2,2)=0.D0
      W(2,1)=DABS(LATPP-ILAT(1))/INTLAT
      W(1,2)=DABS(LONPP-ILON(1))/INTLON
      W(1,1)=1.D0-DABS(LATPP-ILAT(1))/INTLAT
     &             -DABS(LONPP-ILON(1))/INTLON
       ELSE 
      W(1,2)=0.D0
      W(1,1)=0.D0
      W(2,2)=0.D0
      W(2,1)=0.D0
       END IF
      END IF
C COMPUTE VERTICAL IONO WITH NP POINTS
      VERT=0.D0
      DO I=1,NLAT
      DO J=1,NLON
       VERT=VERT+W(I,J)*VIONO(I,J)
      END DO
      END DO
C COMPUTE SLANT DELAY
      SLANT=VERT/DSQRT(1.D0-
     &            (ERAD*DCOS(EL*PI/180D0)/(ERAD+HEIGHT))**2)
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      SUBROUTINE RTCAIONRD( LUION, IDIR, TTAG, TION, TIONX,
     &                      TIONINIT, RTCAVERT, RTCAGIVE, IRC )
      IMPLICIT NONE
C ARGUMENT VARIABLES
      INTEGER*4 LUION, IDIR,                              IRC
      REAL*8    RTCAVERT(1808),RTCAGIVE(1808)
     &          ,TTAG,TION,TIONX,TIONINIT
C READING VARIABLES
      CHARACTER HEX*64,DIST*6
      INTEGER*4 TIME,PREAMBLE,TYPE,FLG
      INTEGER*4 T18NBND,T18BNDN,T18IODI,T18MSK(201)
      INTEGER*4 T26IODI,T26BNDN,T26BLKN,GIVE(15)
      REAL*8    VERT(15)
C MRTCA STORAGE VARIABLES
      LOGICAL*4 GRDMSK(1809)
      INTEGER*4 IODI(2),SLOT2GRD(2,9,201),NGRDBND(2,9)
      INTEGER*4 IGPI(1808)
      REAL*8    IGPV(1808),IGPS(1808)
      REAL*8    SIG26(16)
C PROCESSING VARIABLES
      INTEGER*4 I,J
      INTEGER*4 MSK
      INTEGER*4 LAT,LON
      REAL*8    TVAL,TGRD
C FUNCTIONS
      INTEGER*4 DECODE_T18,DECODE_T26,IGP2GEO
C INITIALIZATION
      DATA GRDMSK/ 1809 * .FALSE. /
      DATA NGRDBND,IODI /18*0,-1,-1/
      DATA SLOT2GRD/ 3618*0 /
      DATA SIG26/0.30D0,0.60D0,0.90D0,1.20D0,1.50D0,1.80D0,2.10D0,
     +  2.40D0,2.70D0,3.00D0,3.60D0,4.50D0,6.00D0,1.50D1,4.5D1,1.D6/
      DATA IGPI/1808*15/
      DATA IGPV/1808*63.750/
      DATA IGPS/1808*1.D6/
C SAVED INFORMATION
      SAVE GRDMSK,IODI,SLOT2GRD,NGRDBND,IGPI,IGPV,IGPS,SIG26
C LOCATE BEGINING OF PREVIOUS/NEXT IONO BLOCK: FILE IS POSITIONED AT LAST READ
      TGRD=TION
 500  CONTINUE
      IF( IDIR .EQ. -1 ) BACKSPACE(LUION)
      READ(LUION,'(I10,1X,A64)',END=800,ERR=9999) TIME, HEX
      GOTO 850
 800  CONTINUE
      WRITE(*,*) 'RTCAIONRD - REACHED END OF FILE WHILE LOOKING'
      GOTO 9000
 850  CONTINUE
      IF( IDIR .EQ. -1 ) BACKSPACE(LUION)
      CALL EXTRACT_TIMETYPE( HEX, PREAMBLE, TYPE )
      TVAL=(TIME/604800)*604800+MOD(TIME,604800)-
     &      MOD(MOD(TIME,604800),256)+PREAMBLE
      IF( TVAL .GT. TIME ) TVAL=TVAL-256
      IF( IDIR .EQ. 1 ) THEN
       IF( TIONINIT .LT. 0 ) TIONINIT=TVAL*100.D0+TYPE
       IF( TYPE .NE. 18 .AND. TYPE .NE. 26 ) GOTO 500
       TGRD=TVAL
       BACKSPACE(LUION,ERR=9999)
      ELSE
       IF( TVAL*100.D0+TYPE .EQ. TIONINIT ) THEN
        WRITE(*,*) 'RTCAIONRD - REACHED START OF FILE'
        TGRD=-1
        GOTO 900
       END IF
       IF( TVAL .GE. TION ) GOTO 500
       IF( TGRD .EQ. TION .AND. 
     &     TYPE .NE. 18 .AND. TYPE .NE. 26 ) GOTO 500
       IF( TYPE .EQ. 18 .OR. TYPE .EQ. 26 ) TGRD=TVAL
      END IF
C IS LAST BLOCK READ THE ONE WE NEED?
 900  CONTINUE
      IF( ( IDIR .EQ. 1 .AND.
     &      TGRD .GT. TTAG .AND. TION .LE. TTAG ) .OR.
     &    ( IDIR .EQ. -1 .AND.
     &      TGRD .LT. TTAG .AND. TION .LE. TTAG ) ) THEN
       DO I=1,1808
      RTCAVERT(I)=IGPV(I)
      IF( .NOT. GRDMSK(I) ) RTCAVERT(I)=-1.D0
      RTCAGIVE(I)=IGPS(I)
       END DO
       TIONX=TGRD
       RETURN
      END IF
C PROCESS IONO BLOCK: HERE TVAL==TION AND FILE IS POSITIONED @ BLOCK START
      TION=TGRD
1000  CONTINUE
      READ(LUION,'(I10,1X,A64)',END=2000,ERR=9999) TIME, HEX
      CALL EXTRACT_TIMETYPE( HEX, PREAMBLE, TYPE )
      TVAL=(TIME/604800)*604800+MOD(TIME,604800)-
     &     MOD(MOD(TIME,604800),256)+PREAMBLE
      IF( TVAL .GT. TIME ) TVAL=TVAL-256
      GOTO 3000
2000  CONTINUE
      WRITE(*,*) 'RTCAIONRD - REACHED END OF FILE WHILE PROCESSING'
      TVAL=-1
3000  CONTINUE
C FINISHED PROCESSING BLOCK: LOAD ARRAYS AND RETURN
      IF( TVAL .NE. TGRD ) THEN
       IF( TVAL .EQ. -1 ) GOTO 9000
       IF( IDIR .EQ. 1 ) BACKSPACE(LUION)
       GOTO 500
      END IF
C PROCESS MESSAGE TYPE 18 OR 26
      FLG=-1
      IF( TYPE .EQ. 18 ) THEN
       FLG=DECODE_T18( HEX,PREAMBLE,TYPE,
     +                 T18NBND,T18BNDN,T18IODI,T18MSK,DIST )
       IF( FLG .EQ. 0 .AND.
     +     T18NBND .GT. 0 .AND. T18NBND .LE. 9 .AND.
     +     T18BNDN .GE. 0 .AND. T18BNDN .LT. T18NBND ) THEN
      IF( IODI(1) .NE. T18IODI ) THEN
       DO I=1,9
          NGRDBND(2,I)=NGRDBND(1,I)
        DO J=1,201
         SLOT2GRD(2,I,J)=SLOT2GRD(1,I,J)
         GRDMSK(J+(I-1)*201)=.FALSE.
        END DO
        NGRDBND(1,I)=0
       END DO
       IODI(2)=IODI(1)
       IODI(1)=T18IODI
      END IF
      IF( NGRDBND(1,1+T18BNDN) .EQ. 0 ) THEN
       DO I=1,201
        GRDMSK(I+T18BNDN*201)=T18MSK(I) .EQ. 1 .AND.
     +        IGP2GEO(I+T18BNDN*201,LAT,LON) .EQ. 0
        IF( GRDMSK(I+T18BNDN*201) ) THEN
         NGRDBND(1,1+T18BNDN)=NGRDBND(1,1+T18BNDN)+1
         SLOT2GRD(1,1+T18BNDN,NGRDBND(1,1+T18BNDN))=I+T18BNDN*201
        END IF
       END DO
      END IF
       END IF
      ELSE IF( TYPE .EQ. 26 ) THEN
       FLG=DECODE_T26( HEX,PREAMBLE,TYPE,
     +                 T26BNDN,T26BLKN,VERT,GIVE,T26IODI,DIST )
       IF( FLG .EQ. 0 .AND.
     +     T26BNDN .GE. 0 .AND. T26BNDN .LT. 9 .AND.
     +     T26BLKN .GE. 0 .AND. T26BLKN .LT. 14 .AND.
     +     ( T26IODI .EQ. IODI(1) .OR. T26IODI .EQ. IODI(2) ) ) THEN
      TGRD=TVAL
        DO I=1,2
       IF( T26IODI .EQ. IODI(I) ) MSK=I
      END DO
      DO I=1,15
       IF( GIVE(I) .LT. 15 .AND. GIVE(I) .GE. 0 .AND.
     +       GRDMSK(SLOT2GRD(MSK,1+T26BNDN,I+T26BLKN*15)) ) THEN
        IGPV(SLOT2GRD(MSK,1+T26BNDN,I+T26BLKN*15))=VERT(I)
        IGPI(SLOT2GRD(MSK,1+T26BNDN,I+T26BLKN*15))=GIVE(I)
        IGPS(SLOT2GRD(MSK,1+T26BNDN,I+T26BLKN*15))=SIG26(GIVE(I)+1)
       END IF
      END DO
       END IF
      END IF
      GOTO 1000
9000  CONTINUE
      BACKSPACE(LUION)
      RETURN
9999  CONTINUE
      STOP
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      SUBROUTINE RTCAEPH( LPR, LUEPH, NEPSV, IEPSV,
     &                    NEPTIM, EPHTIM, EPHTBL, ISRCH)
      IMPLICIT NONE
      INCLUDE 'MAXDIM'
C ARGUMENTS
      INTEGER*4      LPR, LUEPH, NEPSV, ISRCH
      INTEGER*4      IEPSV(MAXSAT), NEPTIM(MAXSAT)
      REAL*8         EPHTIM(MAXSAT,MAXEPH)
      REAL*8         EPHTBL(MAXKEP,MAXSAT,MAXEPH)
C READING VARIABLES
      CHARACTER HEX*64,DIST*6
      CHARACTER*48 SUBF,NAV(32,3)
      INTEGER*4 NAVIODE(32,3)
      INTEGER*4 TIME,PREAMBLE,TYPE,FLG,FFLG
      INTEGER*4 T1IODP,T1MSK(32)
      INTEGER*4 T28IODP,T28SLOT,T28IODE
      REAL*8    EPH(30)
      LOGICAL*4 NAVNSUBF(32,3)
C MRTCA STORAGE VARIABLES
      LOGICAL*4 PRNMSK(32)
      INTEGER*4 IODP(2),SLOT2PRN(2,32),NSLOT(2)
C PROCESSING VARIABLES
      INTEGER*4 I
      INTEGER*4 SUBFN,MSK
      INTEGER*4 TVAL
C FUNCTIONS
      INTEGER*4 DECODE_T1,DECODE_T28,NAV_TO_EPH
C INITIALIZATION
      DATA PRNMSK/ 32 * .FALSE. /
      DATA NSLOT,IODP /0,0,-1,-1/
      DATA SLOT2PRN/ 64*0 /
      DATA NAVIODE/96*0/
      DATA NAVNSUBF/96*.FALSE./
1000  CONTINUE
      READ(LUEPH,'(I10,1X,A64)',END=9000,ERR=9999) TIME,HEX
      CALL EXTRACT_TIMETYPE( HEX, PREAMBLE, TYPE )
      TVAL=(TIME/604800)*604800+MOD(TIME,604800)-
     +        MOD(MOD(TIME,604800),256)+PREAMBLE
      IF( TVAL .GT. TIME ) TVAL=TVAL-256
      FLG=-1
      IF( TYPE .EQ. 1 ) THEN
       FLG=DECODE_T1( HEX,PREAMBLE,TYPE,
     +                T1MSK,T1IODP,DIST )
       IF( FLG .EQ. 0 .AND. IODP(1) .NE. T1IODP ) THEN
        NSLOT(2)=NSLOT(1)
      NSLOT(1)=0
      DO I=1,32
       SLOT2PRN(2,I)=SLOT2PRN(1,I)
       PRNMSK(I)= T1MSK(I) .EQ. 1
       IF( PRNMSK(I) ) THEN
        NSLOT(1)=NSLOT(1)+1
        SLOT2PRN(1,NSLOT(1))=I
       END IF
      END DO
      IODP(2)=IODP(1)
      IODP(1)=T1IODP
       END IF
      ELSE IF( TYPE .EQ. 28 ) THEN
       FLG=DECODE_T28( HEX,PREAMBLE,TYPE,
     +                 T28IODP,T28SLOT,T28IODE,SUBFN,SUBF,DIST )
       IF( FLG .EQ. 0 .AND.
     +    ( T28IODP .EQ. IODP(1) .OR. T28IODP .EQ. IODP(2) ) ) THEN
        DO I=1,2
       IF( T28IODP .EQ. IODP(I) ) MSK=I
      END DO
      IF( SUBFN .GT. 0 .AND. SUBFN .LE. 3 .AND.
     +      T28SLOT .GT. 0 .AND. T28SLOT .LE. NSLOT(MSK) .AND.
     +      PRNMSK(SLOT2PRN(MSK,T28SLOT)) ) THEN
       NAV(SLOT2PRN(MSK,T28SLOT),SUBFN)=SUBF
       NAVIODE(SLOT2PRN(MSK,T28SLOT),SUBFN)=T28IODE
       NAVNSUBF(SLOT2PRN(MSK,T28SLOT),SUBFN)=.TRUE.
       IF( NAVNSUBF(SLOT2PRN(MSK,T28SLOT),1) .AND.
     +       NAVNSUBF(SLOT2PRN(MSK,T28SLOT),2) .AND.
     +       NAVNSUBF(SLOT2PRN(MSK,T28SLOT),3) .AND.
     +       NAVIODE(SLOT2PRN(MSK,T28SLOT),1) .EQ.
     +                   NAVIODE(SLOT2PRN(MSK,T28SLOT),2) .AND.
     +       NAVIODE(SLOT2PRN(MSK,T28SLOT),2) .EQ.
     +                   NAVIODE(SLOT2PRN(MSK,T28SLOT),3) ) THEN
        FFLG = NAV_TO_EPH( TIME, SLOT2PRN(MSK,T28SLOT),
     +                       NAVIODE(SLOT2PRN(MSK,T28SLOT),1),
     +                       NAV(SLOT2PRN(MSK,T28SLOT),1),
     +                       NAV(SLOT2PRN(MSK,T28SLOT),2),
     +                       NAV(SLOT2PRN(MSK,T28SLOT),3), EPH )
        DO I=1,3
         NAVNSUBF(SLOT2PRN(MSK,T28SLOT),I)=.FALSE.
c!       write(*,'(A48)') NAV(SLOT2PRN(MSK,T28SLOT),I)
        END DO
c!      write(*,*) (EPH(J),J=1,30)
        IF( FFLG .EQ. 0 )
     +     CALL UPTBL(SLOT2PRN(MSK,T28SLOT),DBLE(TVAL),EPH,
     +            NEPSV,IEPSV,NEPTIM,EPHTIM,EPHTBL,ISRCH)
       END IF
      ENDIF
       ENDIF
      END IF
      GOTO 1000
9000  CONTINUE
      RETURN
9999  CONTINUE
      STOP
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      SUBROUTINE RTCASLCT( LPR, NSVCLK, ISVCLK, LSVCLK, IEOFCLK,
     &                     FRSVCLK, LTSVCLK,
     &                     RTCATBUF, RTCABUF, RTCAIBUF,
     &                     NOSV, IOSV, IGPSWK, TTAG,
     &                     PRDC, DORBC, IODC, NSVRJCT, ISVRJCT,
     &                     C, IDIR, INTCLK, IFITCLK )
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C ARGUMENTS
      INTEGER*4 LPR, LTSVCLK(*), FRSVCLK(*)
      INTEGER*4 NSVCLK, LSVCLK(*), ISVCLK(*), IEOFCLK(*)
      INTEGER*4 NOSV, IOSV(*), IODC(*)
      INTEGER*4 NSVRJCT, ISVRJCT(*)
      INTEGER*4 INTCLK, IFITCLK,  IDIR, IGPSWK
      REAL*8    C, TTAG(*), PRDC(10,*), DORBC(12,*)
      INTEGER*4 RTCATBUF(*), RTCAIBUF(*)
      REAL*8    RTCABUF(8,*)
C LOCAL VARIABLES
      INTEGER*4 I,ISO,ISC,ITTAG
      NSVRJCT=0
      DO ISO=1,NOSV
       IODC(ISO) = -1
       ITTAG = IDNINT(TTAG(ISO)+IGPSWK*604800.D0)
       DO ISC=1,NSVCLK
      IF( IOSV(ISO) .EQ. ISVCLK(ISC) ) THEN
       DO WHILE ( RTCATBUF(ISC) .EQ. -1 .OR.
     &              (IDIR .EQ. 1 .AND.
     &               RTCATBUF(ISC) .LE. ITTAG - INTCLK .AND.
     &                RTCATBUF(ISC) .LT. LTSVCLK(ISC)) .OR. 
     &              (IDIR .EQ. -1 .AND.
     &               RTCATBUF(ISC) .GT. ITTAG .AND.
     &                RTCATBUF(ISC) .GT. FRSVCLK(ISC)) ) 
        IF( IDIR .EQ. -1 .AND. ( RTCATBUF(ISC) .EQ. -1 .OR.
     &        RTCATBUF(ISC) .GT. FRSVCLK(ISC) )) 
     &       BACKSPACE(LSVCLK(ISC))
        READ(LSVCLK(ISC))
     &       RTCATBUF(ISC),(RTCABUF(I,ISC),I=1,8),RTCAIBUF(ISC)
c!      WRITE(*,*) 'READ',IOSV(ISO),ITTAG,RTCATBUF(ISC),
c!   &    FRSVCLK(ISC),LTSVCLK(ISC),ITTAG - RTCATBUF(ISC)
        IF( IDIR .EQ. -1 ) BACKSPACE(LSVCLK(ISC))
       END DO
       IF( ITTAG .GE. RTCATBUF(ISC) .AND.
     &       ITTAG - RTCATBUF(ISC) .LT. INTCLK ) THEN
        DO I=1,6
         DORBC(I,ISO) = RTCABUF(I,ISC)
        END DO
        DO I=1,2
         PRDC(I,ISO) = RTCABUF(I+6,ISC)
        END DO
        IODC(ISO) = RTCAIBUF(ISC)
       END IF
      END IF
       END DO
       IF( IODC(ISO) .EQ. -1 ) THEN
      NSVRJCT = NSVRJCT+1
      ISVRJCT(NSVRJCT) = IOSV(ISO)
       END IF
      END DO
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      SUBROUTINE RTCASORT( LUCLK, CLKFILE, ILUCLK, LLUCLK, NSVCLK,
     &                     ISVCLK, LTRTCA, FRRTCA,
     &                     RTCATBUF, RTCABUF, RTCAIOBUF,
     &                     ENDTTAG,

     &                     IERR, IEND, INTCLK, NBDAY, C, IPC  )
      IMPLICIT NONE
C ARGUMENTS
      CHARACTER*80  CLKFILE(*)
      INTEGER*4 LUCLK,ILUCLK,NSVCLK,IERR,IEND,INTCLK,NBDAY,IPC
      INTEGER*4 LLUCLK(*), ISVCLK(*)
      INTEGER*4 LTRTCA(*), FRRTCA(*), RTCATBUF(*), RTCAIOBUF(*)
      REAL*8    RTCABUF(8,*),C
      REAL*8 ENDTTAG
C READING VARIABLES
      CHARACTER HEX*64,DIST*6
      INTEGER*4 TIME,PREAMBLE,TYPE,FLG
      INTEGER*4 T1IODP,T1MSK(32)
      INTEGER*4 UDRE(13),T2IODP,T32IODP,T2IODF
      INTEGER*4 T25V(2),T25IODP(2),T45IODP
      INTEGER*4 SLOT(4),IODE(4),REFT(4)
      REAL*8    FAST(13),DX(4,4),DXDOT(4,4)
C MRTCA STORAGE VARIABLES
      LOGICAL*4 PRNMSK(32)
      INTEGER*4 IODP(2),SLOT2PRN(2,32),NSLOT(2)
      INTEGER*4 TCLK(32),THCLK(32)
      INTEGER*4 TORB(32),THORB(32)
      INTEGER*4 OID(32),HOID(32)
      INTEGER*4 CSIGI(32),HCSIGI(32)
      INTEGER*4 TREF(32),HTREF(32)
      REAL*8    CLK(32),HCLK(32),CSIG(32),HCSIG(32)
      REAL*8    ORB(32,4),ORBD(32,4)
      REAL*8    HORB(32,4),HORBD(32,4)
      REAL*8    SIG2(16),SIG32(16)
C PROCESSING VARIABLES
      CHARACTER FNAM*12
      INTEGER*4 I,J,K,IDAY,NINTRV
      INTEGER*4 MSK
      INTEGER*4 TVAL,TVALP,TFSTP,TFSTPP
C FUNCTIONS
      INTEGER*4 DECODE_T1,DECODE_T45,DECODE_T25,DECODE_T2
      INTEGER*4 DECODE_T32
C INITIALIZATION
      DATA PRNMSK/ 32 * .FALSE. /
      DATA NSLOT,IODP /0,0,-1,-1/
      DATA SLOT2PRN/ 64*0 /
      DATA SIG2/0.75D0,1.00D0,1.25D0,1.75D0,2.25D0,3.00D0,3.75D0,
     +  4.50D0,5.25D0,6.00D0,7.50D0,15.0D0,50.0D0,150.D0,1.D3,1.D6/
      DATA SIG32/0.01D0,0.02D0,0.03D0,0.05D0,0.10D0,0.15D0,0.20D0,
     +  0.25D0,0.30D0,0.35D0,0.40D0,0.45D0,0.50D0,0.60D0,1.D3,1.D6/
      DATA CSIGI,HCSIGI/64*15/
      DATA CLK,HCLK/64*0D0/
      DATA CSIG,HCSIG/64*1.D6/
      DATA ORB,ORBD/256*0.D0/
      DATA HORB,HORBD/256*0.D0/
      DATA OID,HOID/64*-1/
      DATA TORB,THORB/64*-1/
      DATA TCLK,THCLK/64*-1/
      DATA TVALP,TFSTP,TFSTPP/-1,-1,-1/
      NSVCLK=0
      IEND=0
      IERR=0
      IDAY=0
      INTCLK=0
      NINTRV=0
500   CONTINUE
      IDAY=IDAY+1
      IF( IDAY .GT. NBDAY ) GOTO 9000
      WRITE(*,*) IDAY,CLKFILE(IDAY)
      OPEN(LUCLK,FILE=CLKFILE(IDAY),STATUS='OLD',FORM='FORMATTED')
1000  CONTINUE
      READ(LUCLK,'(I10,1X,A64)',END=2000,ERR=9999) TIME, HEX
      CALL EXTRACT_TIMETYPE( HEX, PREAMBLE, TYPE )
      TVAL=(TIME/604800)*604800+MOD(TIME,604800)-
     +                   MOD(MOD(TIME,604800),256)+PREAMBLE
      IF( TVAL .GT. TIME ) TVAL=TVAL-256
      GOTO 3000
2000  CONTINUE
      WRITE(*,*) 'REACHED END OF FILE',TVALP
      CLOSE(LUCLK)
      TVAL=-1
3000  CONTINUE
      IF( TVAL .NE. TVALP ) THEN
       IF( TVALP .NE. -1 ) THEN
      IF( TFSTP .EQ. TVALP ) THEN
       IF( TFSTPP .NE. -1 ) THEN
        IF( NINTRV .EQ. 0 .OR.
     &       (TFSTP-TFSTPP .LT. INTCLK .AND. TFSTP-TFSTPP .GT. 0) )
     &     INTCLK=TFSTP-TFSTPP
        NINTRV=NINTRV+1
       END IF
       TFSTPP=TFSTP
      END IF
      DO I=1,32
         IF( PRNMSK(I) .AND.
     +      ((TVALP .EQ. THCLK(I) .AND.
     +        TVALP-THORB(I) .LT. 240 ) .OR.
     +       (TVALP .EQ. TCLK(I) .AND.
     +        TVALP-TORB(I) .LT. 240 )) ) THEN
          DO K=1,NSVCLK
         IF( I .EQ. ISVCLK(K) ) GOTO 3100
        END DO
        NSVCLK=NSVCLK+1
        LLUCLK(NSVCLK) = ILUCLK + NSVCLK
        ISVCLK(NSVCLK) = I
        WRITE(FNAM,'(A5,I3.3,A1,I3.3)') 'MRTCA',NSVCLK,'.',I
        OPEN(LLUCLK(NSVCLK),FILE=FNAM,STATUS='OLD',ERR=3050)
        CLOSE(LLUCLK(NSVCLK),STATUS='DELETE')
3050      CONTINUE
        OPEN(LLUCLK(NSVCLK),FILE=FNAM,FORM='UNFORMATTED',
     +         STATUS='NEW')
          FRRTCA(K)=TVALP
3100      CONTINUE
          LTRTCA(K)=TVALP
          ENDTTAG = TVALP
        IF( TVALP .EQ. THCLK(I) .AND.
     +        TVALP-THORB(I) .LT. 240 ) THEN
         WRITE(LLUCLK(K)) TVALP,
     +            (HORB(I,J)+(TVALP-HTREF(I))*HORBD(I,J),J=1,3),
     +            (HORBD(I,J),J=1,3),
     +            HCLK(I)+HORB(I,4),
     +            HCSIG(I)/C, HOID(I), 'H'
        ELSE IF( TVALP .EQ. TCLK(I) .AND.
     +        TVALP-TORB(I) .LT. 240 ) THEN
         WRITE(LLUCLK(K)) TVALP,
     +            (ORB(I,J)+(TVALP-TREF(I))*ORBD(I,J),J=1,3),
     +            (ORBD(I,J),J=1,3),
     +            CLK(I)+ORB(I,4)+(TVALP-TREF(I))*ORBD(I,4),
     +            CSIG(I)/C, OID(I), 'S'
        END IF
       END IF
      END DO
C     IF( K .EQ. 0 ) WRITE(*,*) TVALP,' - NO VALID DATA'
       END IF
       TVALP=TVAL
      END IF
100   FORMAT(I11,3D20.12,D24.16,D10.2,I5.3,1X,A1,2I20)
      IF( TVAL .EQ. -1 ) GOTO 500
      FLG=-1
      IF( TYPE .EQ. 1 ) THEN
       FLG=DECODE_T1( HEX,PREAMBLE,TYPE,
     +                T1MSK,T1IODP,DIST )
       IF( FLG .EQ. 0 .AND. IODP(1) .NE. T1IODP ) THEN
        NSLOT(2)=NSLOT(1)
      NSLOT(1)=0
      DO I=1,32
       SLOT2PRN(2,I)=SLOT2PRN(1,I)
       PRNMSK(I)= T1MSK(I) .EQ. 1
       IF( PRNMSK(I) ) THEN
        NSLOT(1)=NSLOT(1)+1
        SLOT2PRN(1,NSLOT(1))=I
       END IF
      END DO
      IODP(2)=IODP(1)
      IODP(1)=T1IODP
       END IF
      ELSE IF( TYPE .GE. 2 .AND. TYPE .LE. 5 ) THEN
       FLG=DECODE_T2( HEX,PREAMBLE,TYPE,
     +                T2IODF,T2IODP,FAST,UDRE,DIST )
       IF( FLG .EQ. 0 .AND.
     +     ( T2IODP .EQ. IODP(1) .OR. T2IODP .EQ. IODP(2) ) ) THEN
      DO I=1,2
       IF( T2IODP .EQ. IODP(I) ) MSK=I
      END DO
      DO I=1,13
       IF( I+(TYPE-2)*13 .LT. 32 ) THEN
       IF( UDRE(I) .LT. 14 .AND. UDRE(I) .GE. 0 .AND.
     +       PRNMSK(SLOT2PRN(MSK,I+(TYPE-2)*13)) ) THEN
        TCLK(SLOT2PRN(MSK,I+(TYPE-2)*13))=TVAL
        CLK(SLOT2PRN(MSK,I+(TYPE-2)*13))=FAST(I)
        CSIGI(SLOT2PRN(MSK,I+(TYPE-2)*13))=UDRE(I)
        CSIG(SLOT2PRN(MSK,I+(TYPE-2)*13))=SIG2(UDRE(I)+1)
       END IF
       END IF
      END DO
      TFSTP=TVAL
       END IF
      ELSE IF( TYPE .GE. 32 .AND. TYPE .LE. 35 ) THEN
       FLG=DECODE_T32( HEX,PREAMBLE,TYPE,
     +                 T32IODP,FAST,UDRE,DIST )
       IF( FLG .EQ. 0 .AND.
     +     ( T32IODP .EQ. IODP(1) .OR. T32IODP .EQ. IODP(2) ) ) THEN
        DO I=1,2
       IF( T32IODP .EQ. IODP(I) ) MSK=I
      END DO
      DO I=1,11
       IF( I+(TYPE-32)*11 .LT. 32 ) THEN
       IF( UDRE(I) .LT. 14 .AND. UDRE(I) .GE. 0 .AND.
     +       PRNMSK(SLOT2PRN(MSK,I+(TYPE-32)*11)) ) THEN
        THCLK(SLOT2PRN(MSK,I+(TYPE-32)*11))=TVAL
        HCLK(SLOT2PRN(MSK,I+(TYPE-32)*11))=FAST(I)
        HCSIGI(SLOT2PRN(MSK,I+(TYPE-32)*11))=UDRE(I)
        HCSIG(SLOT2PRN(MSK,I+(TYPE-32)*11))=SIG32(UDRE(I)+1)
       END IF
       END IF
      END DO
      TFSTP=TVAL
       END IF
      ELSE IF( TYPE .EQ. 25 ) THEN
       FLG=DECODE_T25( HEX,PREAMBLE,TYPE,
     +          T25V,SLOT,IODE,DX,DXDOT,REFT,T25IODP,DIST )
       IF( FLG .EQ. 0 ) THEN
      DO J=1,2
       MSK=0
       DO I=1,2
          IF( T25IODP(J) .EQ. IODP(I) ) MSK=I
       END DO
       IF( MSK .GT. 0 ) THEN
        DO I=1,2
         IF( SLOT((J-1)*2+I) .GT. 0 .AND.
     +         SLOT((J-1)*2+I) .LE. NSLOT(MSK) .AND.
     +         PRNMSK(SLOT2PRN(MSK,SLOT((J-1)*2+I))) ) THEN
          TORB(SLOT2PRN(MSK,SLOT((J-1)*2+I))) = TVAL
          OID(SLOT2PRN(MSK,SLOT((J-1)*2+I))) = IODE((J-1)*2+I)
          TREF(SLOT2PRN(MSK,SLOT((J-1)*2+I))) = REFT((J-1)*2+I)+
     +                                   (TVAL-MOD(TVAL,86400))
          IF( REFT((J-1)*2+I) - MOD(TVAL,86400) .LT. -43200 )
     +       TREF(SLOT2PRN(MSK,SLOT((J-1)*2+I))) =
     +                   TREF(SLOT2PRN(MSK,SLOT((J-1)*2+I))) + 86400
          DO K=1,4
           ORB(SLOT2PRN(MSK,SLOT((J-1)*2+I)),K) = DX((J-1)*2+I,K)
           ORBD(SLOT2PRN(MSK,SLOT((J-1)*2+I)),K) = DXDOT((J-1)*2+I,K)
          END DO
         END IF
        END DO
       END IF
      END DO
       END IF
      ELSE IF( TYPE .EQ. 45 ) THEN
       FLG=DECODE_T45( HEX,PREAMBLE,TYPE,
     +                  SLOT,IODE,DX,DXDOT,REFT,T45IODP,DIST )
       IF( FLG .EQ. 0 ) THEN
      MSK=0
      DO I=1,2
         IF( T45IODP .EQ. IODP(I) ) MSK=I
      END DO
      IF( MSK .GT. 0 ) THEN
       DO J=1,2
        IF( SLOT(J) .GT. 0 .AND.
     +        SLOT(J) .LE. NSLOT(MSK) .AND.
     +        PRNMSK(SLOT2PRN(MSK,SLOT(J))) ) THEN
         THORB(SLOT2PRN(MSK,SLOT(J))) = TVAL
         HOID(SLOT2PRN(MSK,SLOT(J))) = IODE(J)
         HTREF(SLOT2PRN(MSK,SLOT(J))) = REFT(J)+
     +                                   (TVAL-MOD(TVAL,86400))
         IF( REFT(J) - MOD(TVAL,86400) .LT. -43200 )
     +      HTREF(SLOT2PRN(MSK,SLOT(J))) =
     +              HTREF(SLOT2PRN(MSK,SLOT(J))) + 86400
         DO K=1,4
          HORB(SLOT2PRN(MSK,SLOT(J)),K) = DX(J,K)
          HORBD(SLOT2PRN(MSK,SLOT(J)),K) = DXDOT(J,K)
         END DO
        END IF
       END DO
      END IF
       END IF
      END IF
      GOTO 1000
9000  CONTINUE
      DO I=1,NSVCLK
       REWIND(LLUCLK(I))
       RTCATBUF(I)=-1
      END DO
      IEND=1
      RETURN
9999  CONTINUE
      STOP
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      SUBROUTINE HEXTOBIT( HEX, BIN )
      IMPLICIT NONE
      CHARACTER HEX*(*),BIN*(*)
      CHARACTER*4 UNIT
      INTEGER*4 I,NUM
      BIN=''
      NUM=0
      DO I=1,LEN(HEX)
      UNIT=''
      IF( HEX(I:I) .EQ. 'F' .OR. HEX(I:I) .EQ. 'f' ) UNIT='1111'
      IF( HEX(I:I) .EQ. 'E' .OR. HEX(I:I) .EQ. 'e' ) UNIT='1110'
      IF( HEX(I:I) .EQ. 'D' .OR. HEX(I:I) .EQ. 'd' ) UNIT='1101'
      IF( HEX(I:I) .EQ. 'C' .OR. HEX(I:I) .EQ. 'c' ) UNIT='1100'
      IF( HEX(I:I) .EQ. 'B' .OR. HEX(I:I) .EQ. 'b' ) UNIT='1011'
      IF( HEX(I:I) .EQ. 'A' .OR. HEX(I:I) .EQ. 'a' ) UNIT='1010'
      IF( HEX(I:I) .EQ. '9' ) UNIT='1001'
      IF( HEX(I:I) .EQ. '8' ) UNIT='1000'
      IF( HEX(I:I) .EQ. '7' ) UNIT='0111'
      IF( HEX(I:I) .EQ. '6' ) UNIT='0110'
      IF( HEX(I:I) .EQ. '5' ) UNIT='0101'
      IF( HEX(I:I) .EQ. '4' ) UNIT='0100'
      IF( HEX(I:I) .EQ. '3' ) UNIT='0011'
      IF( HEX(I:I) .EQ. '2' ) UNIT='0010'
      IF( HEX(I:I) .EQ. '1' ) UNIT='0001'
      IF( HEX(I:I) .EQ. '0' ) UNIT='0000'
      IF( UNIT .NE. '' ) THEN
         NUM=NUM+4
         BIN(NUM-3:NUM)=UNIT
      END IF
      END DO
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      REAL*8 FUNCTION HEXTOINT( HEX, SHIFT, NBIT )
      IMPLICIT NONE
      CHARACTER HEX*(*)
      INTEGER*4 SHIFT,NBIT
      INTEGER*4 I,UNIT
      REAl*8 VAL,POWER2
      VAL = 0.D0
      DO I=1,LEN(HEX)
      UNIT=16
      IF( HEX(I:I) .EQ. 'F' .OR. HEX(I:I) .EQ. 'f' ) UNIT=15
      IF( HEX(I:I) .EQ. 'E' .OR. HEX(I:I) .EQ. 'e' ) UNIT=14
      IF( HEX(I:I) .EQ. 'D' .OR. HEX(I:I) .EQ. 'd' ) UNIT=13
      IF( HEX(I:I) .EQ. 'C' .OR. HEX(I:I) .EQ. 'c' ) UNIT=12
      IF( HEX(I:I) .EQ. 'B' .OR. HEX(I:I) .EQ. 'b' ) UNIT=11
      IF( HEX(I:I) .EQ. 'A' .OR. HEX(I:I) .EQ. 'a' ) UNIT=10
      IF( HEX(I:I) .EQ. '9' ) UNIT=9
      IF( HEX(I:I) .EQ. '8' ) UNIT=8
      IF( HEX(I:I) .EQ. '7' ) UNIT=7
      IF( HEX(I:I) .EQ. '6' ) UNIT=6
      IF( HEX(I:I) .EQ. '5' ) UNIT=5
      IF( HEX(I:I) .EQ. '4' ) UNIT=4
      IF( HEX(I:I) .EQ. '3' ) UNIT=3
      IF( HEX(I:I) .EQ. '2' ) UNIT=2
      IF( HEX(I:I) .EQ. '1' ) UNIT=1
      IF( HEX(I:I) .EQ. '0' ) UNIT=0
      IF( UNIT .GE. 0 .AND. UNIT .LE. 15 ) THEN
         VAL=VAL*16
         VAL=VAL+UNIT
      END IF
      END DO
      HEXTOINT=DMOD(DINT(VAL/POWER2(SHIFT)),POWER2(NBIT))
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      SUBROUTINE EXTRACT_TIMETYPE( HEX, TIME, TYPE )
      IMPLICIT NONE
      CHARACTER HEX*(*)
      INTEGER*4 TIME,TYPE
      REAL*8 HEXTOINT
C  Extract
      TIME=DINT(HEXTOINT(HEX(1:2),0,8))
      TYPE=DINT(HEXTOINT(HEX(3:4),2,6))
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T1( HEX, TIME, TYPE,
     +                              MASK, IODP, DIST )
      IMPLICIT NONE
      CHARACTER HEX*(*),DIST*(*)
      INTEGER*4 TIME,TYPE,MASK(*),IODP
      CHARACTER*36 BIN
      INTEGER*4    I,TIME2,TYPE2
      REAL*8 HEXTOINT
C  Extract
      DECODE_T1=-1
      CALL EXTRACT_TIMETYPE( HEX, TIME2, TYPE2 )
      IF( TIME2 .NE. TIME .OR. TYPE2 .NE. TYPE ) RETURN
      DECODE_T1=0
      CALL HEXTOBIT(HEX(4:12),BIN)
      DO I=1,32
      IF( BIN(I+2:I+2) .EQ. '0' ) MASK(I)=0
      IF( BIN(I+2:I+2) .EQ. '1' ) MASK(I)=1
      END DO
      IODP=DINT(HEXTOINT(HEX(57:57),2,2))
      CALL HEXTOBIT(HEX(63:64),BIN)
      DIST=BIN(3:8)
      RETURN
100   FORMAT(A9,1X,A64)
200   FORMAT(A9,A9,A29,A10)
300   FORMAT(A9,A9,A29,I10)
500   FORMAT(A9,A9,A29,32I1)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T45( HEX, TIME, TYPE,
     +          SLOT, IODE, DX, DXDOT, REFT, IODP, DIST )
      IMPLICIT NONE
      CHARACTER HEX*(*),DIST*(*)
      INTEGER*4 TIME,TYPE,SLOT(4),IODE(4),REFT(4),IODP
      REAL*8    DX(4,4),DXDOT(4,4)
      CHARACTER*36 BIN
      INTEGER*4 I,J,TIME2,TYPE2
      REAL*8 POWER2,HEXTOINT
C Extract
      DECODE_T45=-1
      CALL EXTRACT_TIMETYPE( HEX, TIME2, TYPE2 )
      IF( TIME2 .NE. TIME .OR. TYPE2 .NE. TYPE ) RETURN
      DECODE_T45=0
      SLOT(1)=DINT(HEXTOINT(HEX(4:5),0,6))
      IODE(1)=DINT(HEXTOINT(HEX(6:7),0,8))
      DX(1,1)=HEXTOINT(HEX(8:11),2,14)
      DX(1,2)=HEXTOINT(HEX(11:14),0,14)
      DX(1,3)=HEXTOINT(HEX(15:18),2,14)
      DXDOT(1,1)=HEXTOINT(HEX(18:20),3,7)
      DXDOT(1,2)=HEXTOINT(HEX(20:21),0,7)
      DXDOT(1,3)=HEXTOINT(HEX(22:23),1,7)
      DX(1,4)=HEXTOINT(HEX(23:27),2,15)
      REFT(1)=DINT(HEXTOINT(HEX(27:30),1,13))
      DXDOT(1,4)=0.D0
      SLOT(2)=DINT(HEXTOINT(HEX(30:32),3,6))
      IODE(2)=DINT(HEXTOINT(HEX(32:34),3,8))
      DX(2,1)=HEXTOINT(HEX(34:37),1,14)
      DX(2,2)=HEXTOINT(HEX(37:41),3,14)
      DX(2,3)=HEXTOINT(HEX(41:44),1,14)
      DXDOT(2,1)=HEXTOINT(HEX(44:46),2,7)
      DXDOT(2,2)=HEXTOINT(HEX(46:48),3,7)
      DXDOT(2,3)=HEXTOINT(HEX(48:49),0,7)
      DX(2,4)=HEXTOINT(HEX(50:53),1,15)
      REFT(2)=DINT(HEXTOINT(HEX(53:56),0,13))
      DXDOT(2,4)=0.D0
      IODP=DINT(HEXTOINT(HEX(57:57),2,2))
      CALL HEXTOBIT(HEX(63:64),BIN)
      DIST=BIN(3:8)
C Convert
      DO I=1,2
         DO J=1,3
            IF( DX(I,J) .GE. POWER2(13) )
     +          DX(I,J)=DX(I,J)-POWER2(14)
            DX(I,J)=DX(I,J)/POWER2(8)
            IF( DXDOT(I,J) .GE. POWER2(6) )
     +          DXDOT(I,J)=DXDOT(I,J)-POWER2(7)
            DXDOT(I,J)=DXDOT(I,J)/POWER2(13)
         END DO
         IF( DX(I,4) .GE. POWER2(14) )
     +      DX(I,4)=DX(I,4)-POWER2(15)
         DX(I,4)=DX(I,4)*299792458./POWER2(36)
       REFT(I)=REFT(I)*16
      END DO
      RETURN
100   FORMAT(A9,1X,A64)
200   FORMAT(A9,A9,A29,A10)
300   FORMAT(A9,A9,A29,I10)
400   FORMAT(A9,A9,A29,G16.10)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T25( HEX, TIME, TYPE,
     +          V, SLOT, IODE, DX, DXDOT, REFT, IODP, DIST )
      IMPLICIT NONE
      CHARACTER HEX*(*),DIST*(*)
      INTEGER*4 TIME,TYPE,V(2),SLOT(4),IODE(4),IODP(2),REFT(4)
      REAL*8    DX(4,4),DXDOT(4,4)
      CHARACTER*36 BIN
      INTEGER*4 I,J,TIME2,TYPE2
      REAL*8 POWER2,HEXTOINT
C Extract
      DECODE_T25=-1
      CALL EXTRACT_TIMETYPE( HEX, TIME2, TYPE2 )
      IF( TIME2 .NE. TIME .OR. TYPE2 .NE. TYPE ) RETURN
      DECODE_T25=0
      V(1)=DINT(HEXTOINT(HEX(4:4),1,1))
      SLOT(1)=DINT(HEXTOINT(HEX(4:6),3,6))
      IODE(1)=DINT(HEXTOINT(HEX(6:8),3,8))
      IF( V(1) .EQ. 0 ) THEN
       DX(1,1)=HEXTOINT(HEX(8:10),2,9)
       DX(1,2)=HEXTOINT(HEX(10:12),1,9)
       DX(1,3)=HEXTOINT(HEX(12:14),0,9)
       DX(1,4)=HEXTOINT(HEX(15:17),2,10)
       DXDOT(1,1)=0.D0
       DXDOT(1,2)=0.D0
       DXDOT(1,3)=0.D0
       DXDOT(1,4)=0.D0
       REFT(1)=0
       SLOT(2)=DINT(HEXTOINT(HEX(17:18),0,6))
       IODE(2)=DINT(HEXTOINT(HEX(19:20),0,8))
       DX(2,1)=HEXTOINT(HEX(21:23),3,9)
       DX(2,2)=HEXTOINT(HEX(23:25),2,9)
       DX(2,3)=HEXTOINT(HEX(25:27),1,9)
       DX(2,4)=HEXTOINT(HEX(27:30),3,10)
       DXDOT(2,1)=0.D0
       DXDOT(2,2)=0.D0
       DXDOT(2,3)=0.D0
       DXDOT(2,4)=0.D0
       REFT(2)=0
       IODP(1)=DINT(HEXTOINT(HEX(30:30),1,2))
      ELSE IF( V(1) .EQ. 1 ) THEN
       DX(1,1)=HEXTOINT(HEX(8:10),0,11)
       DX(1,2)=HEXTOINT(HEX(11:13),1,11)
       DX(1,3)=HEXTOINT(HEX(13:16),2,11)
       DX(1,4)=HEXTOINT(HEX(16:19),3,11)
       DXDOT(1,1)=HEXTOINT(HEX(19:21),3,8)
       DXDOT(1,2)=HEXTOINT(HEX(21:23),3,8)
       DXDOT(1,3)=HEXTOINT(HEX(23:25),3,8)
       DXDOT(1,4)=HEXTOINT(HEX(25:27),3,8)
       REFT(1)=DINT(HEXTOINT(HEX(27:30),2,13))
       SLOT(2)=0
       IODE(2)=0
       DX(2,1)=0.D0
       DX(2,2)=0.D0
       DX(2,3)=0.D0
       DX(2,4)=0.D0
       DXDOT(2,1)=0.D0
       DXDOT(2,2)=0.D0
       DXDOT(2,3)=0.D0
       DXDOT(2,4)=0.D0
       REFT(2)=0
       IODP(1)=DINT(HEXTOINT(HEX(30:30),0,2))
      END IF
      V(2)=DINT(HEXTOINT(HEX(31:31),3,1))
      SLOT(3)=DINT(HEXTOINT(HEX(31:32),1,6))
      IODE(3)=DINT(HEXTOINT(HEX(32:34),1,8))
      IF( V(2) .EQ. 0 ) THEN
       DX(3,1)=HEXTOINT(HEX(34:36),0,9)
       DX(3,2)=HEXTOINT(HEX(37:39),3,9)
       DX(3,3)=HEXTOINT(HEX(39:41),2,9)
       DX(3,4)=HEXTOINT(HEX(41:43),0,10)
       DXDOT(3,1)=0.D0
       DXDOT(3,2)=0.D0
       DXDOT(3,3)=0.D0
       DXDOT(3,4)=0.D0
       REFT(3)=0
       SLOT(4)=DINT(HEXTOINT(HEX(44:45),2,6))
       IODE(4)=DINT(HEXTOINT(HEX(45:47),2,8))
       DX(4,1)=HEXTOINT(HEX(47:49),1,9)
       DX(4,2)=HEXTOINT(HEX(49:51),0,9)
       DX(4,3)=HEXTOINT(HEX(52:54),3,9)
       DX(4,4)=HEXTOINT(HEX(54:56),1,10)
       DXDOT(4,1)=0.D0
       DXDOT(4,2)=0.D0
       DXDOT(4,3)=0.D0
       DXDOT(4,4)=0.D0
       REFT(4)=0
       IODP(2)=DINT(HEXTOINT(HEX(56:57),3,2))
      ELSE IF( V(2) .EQ. 1 ) THEN
       DX(3,1)=HEXTOINT(HEX(34:37),2,11)
       DX(3,2)=HEXTOINT(HEX(37:40),3,11)
       DX(3,3)=HEXTOINT(HEX(40:42),0,11)
       DX(3,4)=HEXTOINT(HEX(43:45),1,11)
       DXDOT(3,1)=HEXTOINT(HEX(45:47),1,8)
       DXDOT(3,2)=HEXTOINT(HEX(47:49),1,8)
       DXDOT(3,3)=HEXTOINT(HEX(49:51),1,8)
       DXDOT(3,4)=HEXTOINT(HEX(51:53),1,8)
       REFT(3)=DINT(HEXTOINT(HEX(53:56),0,13))
       SLOT(4)=0
       IODE(4)=0
       DX(4,1)=0.D0
       DX(4,2)=0.D0
       DX(4,3)=0.D0
       DX(4,4)=0.D0
       DXDOT(4,1)=0.D0
       DXDOT(4,2)=0.D0
       DXDOT(4,3)=0.D0
       DXDOT(4,4)=0.D0
       REFT(4)=0
       IODP(2)=DINT(HEXTOINT(HEX(57:57),2,2))
      END IF
      CALL HEXTOBIT(HEX(63:64),BIN)
      DIST=BIN(3:8)
C Convert
      DO I=1,4
         DO J=1,3
         IF( V((I-1)/2+1) .EQ. 1 .AND. DX(I,J) .GE. POWER2(10) )
     +       DX(I,J)=DX(I,J)-POWER2(11)
         IF( V((I-1)/2+1) .EQ. 0 .AND. DX(I,J) .GE. POWER2(8) )
     +       DX(I,J)=DX(I,J)-POWER2(9)
         DX(I,J)=DX(I,J)/POWER2(3)
         IF( DXDOT(I,J) .GE. POWER2(7) )
     +       DXDOT(I,J)=DXDOT(I,J)-POWER2(8)
         DXDOT(I,J)=DXDOT(I,J)/POWER2(11)
       END DO
       IF( V((I-1)/2+1) .EQ. 1 .AND. DX(I,4) .GE. POWER2(10) )
     +     DX(I,4)=DX(I,4)-POWER2(11)
       IF( V((I-1)/2+1) .EQ. 0 .AND. DX(I,4) .GE. POWER2(9) )
     +     DX(I,4)=DX(I,4)-POWER2(10)
       DX(I,4)=DX(I,4)*299792458./POWER2(31)
       IF( DXDOT(I,4) .GE. POWER2(7) )
     +             DXDOT(I,4)=DXDOT(I,4)-POWER2(8)
       DXDOT(I,4)=DXDOT(I,4)*299792458./POWER2(39)
       REFT(I)=REFT(I)*16
      END DO
      RETURN
100   FORMAT(A9,1X,A64)
200   FORMAT(A9,A9,A29,A10)
300   FORMAT(A9,A9,A29,I10)
400   FORMAT(A9,A9,A29,G16.10)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T2( HEX, TIME, TYPE,
     +                              IODF, IODP, FAST, UDRE, DIST )
      IMPLICIT NONE
      CHARACTER HEX*(*),DIST*(*)
      INTEGER*4 TIME,TYPE,IODF,IODP,UDRE(*)
      REAL*8    FAST(*)
      CHARACTER*36 BIN
      INTEGER*4 I,TIME2,TYPE2
      REAL*8 POWER2,HEXTOINT
C Extract
      DECODE_T2=-1
      CALL EXTRACT_TIMETYPE( HEX, TIME2, TYPE2 )
      IF( TIME2 .NE. TIME .OR. TYPE2 .NE. TYPE ) RETURN
      DECODE_T2=0
      IODF=DINT(HEXTOINT(HEX(4:4),0,2))
      IODP=DINT(HEXTOINT(HEX(5:5),2,2))
      FAST(1)=HEXTOINT(HEX(5:8),2,12)
      FAST(2)=HEXTOINT(HEX(8:11),2,12)
      FAST(3)=HEXTOINT(HEX(11:14),2,12)
      FAST(4)=HEXTOINT(HEX(14:17),2,12)
      FAST(5)=HEXTOINT(HEX(17:20),2,12)
      FAST(6)=HEXTOINT(HEX(20:23),2,12)
      FAST(7)=HEXTOINT(HEX(23:26),2,12)
      FAST(8)=HEXTOINT(HEX(26:29),2,12)
      FAST(9)=HEXTOINT(HEX(29:32),2,12)
      FAST(10)=HEXTOINT(HEX(32:35),2,12)
      FAST(11)=HEXTOINT(HEX(35:38),2,12)
      FAST(12)=HEXTOINT(HEX(38:41),2,12)
      FAST(13)=HEXTOINT(HEX(41:44),2,12)
      UDRE(1)=DINT(HEXTOINT(HEX(44:45),2,4))
      UDRE(2)=DINT(HEXTOINT(HEX(45:46),2,4))
      UDRE(3)=DINT(HEXTOINT(HEX(46:47),2,4))
      UDRE(4)=DINT(HEXTOINT(HEX(47:48),2,4))
      UDRE(5)=DINT(HEXTOINT(HEX(48:49),2,4))
      UDRE(6)=DINT(HEXTOINT(HEX(49:50),2,4))
      UDRE(7)=DINT(HEXTOINT(HEX(50:51),2,4))
      UDRE(8)=DINT(HEXTOINT(HEX(51:52),2,4))
      UDRE(9)=DINT(HEXTOINT(HEX(52:53),2,4))
      UDRE(10)=DINT(HEXTOINT(HEX(53:54),2,4))
      UDRE(11)=DINT(HEXTOINT(HEX(54:55),2,4))
      UDRE(12)=DINT(HEXTOINT(HEX(55:56),2,4))
      UDRE(13)=DINT(HEXTOINT(HEX(56:57),2,4))
      CALL HEXTOBIT(HEX(63:64),BIN)
      DIST=BIN(3:8)
C Convert
      DO I=1,13
       IF( FAST(I) .GE. POWER2(11) ) FAST(I)=FAST(I)-POWER2(12)
       FAST(I)=FAST(I)/POWER2(3)
      END DO
      RETURN
100   FORMAT(A5,I2,A2,1X,A64)
200   FORMAT(A5,I2,A2,A9,A29,A6)
300   FORMAT(A5,I2,A2,A9,A29,I10)
400   FORMAT(A5,I2,A2,A9,A29,G16.10)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T32( HEX, TIME, TYPE,
     +                               IODP, FAST, UDRE, DIST )
      IMPLICIT NONE
      CHARACTER HEX*(*),DIST*(*)
      INTEGER*4 TIME, TYPE, IODP, UDRE(*)
      REAL*8    FAST(*)
      CHARACTER*36 BIN
      INTEGER*4 I,TIME2,TYPE2
      REAL*8 POWER2,HEXTOINT
C Extract
      DECODE_T32=-1
      CALL EXTRACT_TIMETYPE( HEX, TIME2, TYPE2 )
      IF( TIME2 .NE. TIME .OR. TYPE2 .NE. TYPE ) RETURN
      DECODE_T32=0
      IODP=DINT(HEXTOINT(HEX(4:4),0,2))
      FAST(1)=HEXTOINT(HEX(5:8),1,15)
      FAST(2)=HEXTOINT(HEX(8:12),2,15)
      FAST(3)=HEXTOINT(HEX(12:16),3,15)
      FAST(4)=HEXTOINT(HEX(16:19),0,15)
      FAST(5)=HEXTOINT(HEX(20:23),1,15)
      FAST(6)=HEXTOINT(HEX(23:27),2,15)
      FAST(7)=HEXTOINT(HEX(27:31),3,15)
      FAST(8)=HEXTOINT(HEX(31:34),0,15)
      FAST(9)=HEXTOINT(HEX(35:38),1,15)
      FAST(10)=HEXTOINT(HEX(38:42),2,15)
      FAST(11)=HEXTOINT(HEX(42:46),3,15)
      UDRE(1)=DINT(HEXTOINT(HEX(46:47),3,4))
      UDRE(2)=DINT(HEXTOINT(HEX(47:48),3,4))
      UDRE(3)=DINT(HEXTOINT(HEX(48:49),3,4))
      UDRE(4)=DINT(HEXTOINT(HEX(49:50),3,4))
      UDRE(5)=DINT(HEXTOINT(HEX(50:51),3,4))
      UDRE(6)=DINT(HEXTOINT(HEX(51:52),3,4))
      UDRE(7)=DINT(HEXTOINT(HEX(52:53),3,4))
      UDRE(8)=DINT(HEXTOINT(HEX(53:54),3,4))
      UDRE(9)=DINT(HEXTOINT(HEX(54:55),3,4))
      UDRE(10)=DINT(HEXTOINT(HEX(55:56),3,4))
      UDRE(11)=DINT(HEXTOINT(HEX(56:57),3,4))
      CALL HEXTOBIT(HEX(63:64),BIN)
      DIST=BIN(3:8)
C Convert
      DO I=1,11
       IF( FAST(I) .GE. POWER2(14) ) FAST(I)=FAST(I)-POWER2(15)
       FAST(I)=FAST(I)/POWER2(8)
      END DO
      RETURN
100   FORMAT(A5,I2,A2,1X,A64)
200   FORMAT(A5,I2,A2,A9,A29,A6)
300   FORMAT(A5,I2,A2,A9,A29,I10)
400   FORMAT(A5,I2,A2,A9,A29,G16.10)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T18( HEX, TIME, TYPE,
     +                               NBND, BNDN, IODI, MASK, DIST )
      IMPLICIT NONE
      CHARACTER HEX*(*),DIST*(*)
      INTEGER*4 TIME, TYPE, NBND, BNDN, IODI, MASK(*)
      CHARACTER BIN*204
      INTEGER*4 I,TIME2,TYPE2
      REAL*8 HEXTOINT
C  Extract
      DECODE_T18=-1
      CALL EXTRACT_TIMETYPE( HEX, TIME2, TYPE2 )
      IF( TIME2 .NE. TIME .OR. TYPE2 .NE. TYPE ) RETURN
      DECODE_T18=0
      NBND=DINT(HEXTOINT(HEX(4:5),2,4))
      BNDN=DINT(HEXTOINT(HEX(5:6),2,4))
      IODI=DINT(HEXTOINT(HEX(6:6),0,2))
      CALL HEXTOBIT(HEX(7:57),BIN)
      DO I=1,201
      IF( BIN(I:I) .EQ. '0' ) MASK(I)=0
      IF( BIN(I:I) .EQ. '1' ) MASK(I)=1
      END DO
      CALL HEXTOBIT(HEX(63:64),BIN)
      DIST=BIN(3:8)
      RETURN
100   FORMAT(A9,1X,A64)
200   FORMAT(A9,A9,A40,A10)
300   FORMAT(A9,A9,A40,I10)
400   FORMAT(A9,A9,A40,G16.10)
500   FORMAT(A9,A9,A40,67I1)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T26( HEX, TIME, TYPE,
     +                       BNDN, BLKN, VERT, GIVE, IODI, DIST )
      IMPLICIT NONE
      CHARACTER HEX*(*),DIST*(*)
      INTEGER*4 TIME,TYPE,BNDN,BLKN,GIVE(*),IODI
      REAL*8    VERT(*)
      CHARACTER*36 BIN
      INTEGER*4 I,TIME2,TYPE2
      REAL*8 POWER2,HEXTOINT
C Extract
      DECODE_T26=-1
      CALL EXTRACT_TIMETYPE( HEX, TIME2, TYPE2 )
      IF( TIME2 .NE. TIME .OR. TYPE2 .NE. TYPE ) RETURN
      DECODE_T26=0
      BNDN=DINT(HEXTOINT(HEX(4:5),2,4))
      BLKN=DINT(HEXTOINT(HEX(5:6),2,4))
      VERT(1)=HEXTOINT(HEX(6:8),1,9)
      GIVE(1)=DINT(HEXTOINT(HEX(8:9),1,4))
      VERT(2)=HEXTOINT(HEX(9:11),0,9)
      GIVE(2)=DINT(HEXTOINT(HEX(12:12),0,4))
      VERT(3)=HEXTOINT(HEX(13:15),3,9)
      GIVE(3)=DINT(HEXTOINT(HEX(15:16),3,4))
      VERT(4)=HEXTOINT(HEX(16:18),2,9)
      GIVE(4)=DINT(HEXTOINT(HEX(18:19),2,4))
      VERT(5)=HEXTOINT(HEX(19:21),1,9)
      GIVE(5)=DINT(HEXTOINT(HEX(21:22),1,4))
      VERT(6)=HEXTOINT(HEX(22:24),0,9)
      GIVE(6)=DINT(HEXTOINT(HEX(25:25),0,4))
      VERT(7)=HEXTOINT(HEX(26:28),3,9)
      GIVE(7)=DINT(HEXTOINT(HEX(28:29),3,4))
      VERT(8)=HEXTOINT(HEX(29:31),2,9)
      GIVE(8)=DINT(HEXTOINT(HEX(31:32),2,4))
      VERT(9)=HEXTOINT(HEX(32:34),1,9)
      GIVE(9)=DINT(HEXTOINT(HEX(34:35),1,4))
      VERT(10)=HEXTOINT(HEX(35:37),0,9)
      GIVE(10)=DINT(HEXTOINT(HEX(38:38),0,4))
      VERT(11)=HEXTOINT(HEX(39:41),3,9)
      GIVE(11)=DINT(HEXTOINT(HEX(41:42),3,4))
      VERT(12)=HEXTOINT(HEX(42:44),2,9)
      GIVE(12)=DINT(HEXTOINT(HEX(44:45),2,4))
      VERT(13)=HEXTOINT(HEX(45:47),1,9)
      GIVE(13)=DINT(HEXTOINT(HEX(47:48),1,4))
      VERT(14)=HEXTOINT(HEX(48:50),0,9)
      GIVE(14)=DINT(HEXTOINT(HEX(51:51),0,4))
      VERT(15)=HEXTOINT(HEX(52:54),3,9)
      GIVE(15)=DINT(HEXTOINT(HEX(54:55),3,4))
      IODI=DINT(HEXTOINT(HEX(55:55),1,2))
      CALL HEXTOBIT(HEX(63:64),BIN)
      DIST=BIN(3:8)
C Convert
      DO I=1,15
       VERT(I)=VERT(I)/POWER2(3)
      END DO
      RETURN
100   FORMAT(A9,1X,A64)
200   FORMAT(A9,A9,A29,A10)
300   FORMAT(A9,A9,A29,I10)
400   FORMAT(A9,A9,A29,G16.10)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T12( HEX, TIME, TYPE,
     +                               TOW, WEEK, DIST )
      IMPLICIT NONE
      CHARACTER HEX*(*),DIST*(*)
      INTEGER*4 TIME,TYPE,TOW,WEEK
      CHARACTER*36 BIN
      INTEGER*4 TIME2,TYPE2
      REAL*8 HEXTOINT
C  Extract
      DECODE_T12=-1
      CALL EXTRACT_TIMETYPE( HEX, TIME2, TYPE2 )
      IF( TIME2 .NE. TIME .OR. TYPE2 .NE. TYPE ) RETURN
      DECODE_T12=0
      TOW=DINT(HEXTOINT(HEX(31:36),3,20))
      WEEK=DINT(HEXTOINT(HEX(36:38),1,10))
      CALL HEXTOBIT(HEX(63:64),BIN)
      DIST=BIN(3:8)
      RETURN
100   FORMAT(A9,1X,A64)
200   FORMAT(A9,A9,A29,A10)
300   FORMAT(A9,A9,A29,I10)
400   FORMAT(A9,A9,A29,G16.10)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T28( HEX, TIME, TYPE,
     +                    IODP, SLOT, IODE, SUBFN, SUBF, DIST )
      IMPLICIT NONE
      CHARACTER HEX*(*),SUBF*(*),DIST*(*)
      INTEGER*4 TIME,TYPE,IODP,SLOT,IODE,SUBFN
      CHARACTER*36 BIN
      INTEGER*4 TIME2,TYPE2
      REAL*8 HEXTOINT
C  Extract
      DECODE_T28=-1
      CALL EXTRACT_TIMETYPE( HEX, TIME2, TYPE2 )
      IF( TIME2 .NE. TIME .OR. TYPE2 .NE. TYPE ) RETURN
      DECODE_T28=0
      IODP=DINT(HEXTOINT(HEX(4:4),0,2))
      SLOT=DINT(HEXTOINT(HEX(5:6),2,6))
      IODE=DINT(HEXTOINT(HEX(6:8),2,8))
      SUBFN=DINT(HEXTOINT(HEX(8:8),0,2))
      SUBF=HEX(9:56)
      CALL HEXTOBIT(HEX(63:64),BIN)
      DIST=BIN(3:8)
      RETURN
100   FORMAT(A9,1X,A64)
200   FORMAT(A9,A9,A29,A10)
300   FORMAT(A9,A9,A29,I10)
400   FORMAT(A9,A9,A29,G16.10)
500   FORMAT(A20,1X,A64)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION NAV_TO_EPH( TIME, PRN, IODE, NAV1,NAV2,NAV3,
     +                               NEW_EPH )
C     EPH    - EPHEMERIS DATA:
C            ---------------------- SUBFRAME 1 -----------------------
C            EPH( 1) - SV NUMBER
C            EPH( 2) - GPS WEEK NUMBER
C            EPH( 3) - MODE (0 = C/A & P, 1=P ONLY, 2=C/A ONLY)
C            EPH( 4) - SV ACCURACY
C            EPH( 5) - SV HEALTH
C            EPH( 6) - TG (GROUP DELAY DIFFERENTIAL)
C            EPH( 7) - AODC (AGE OF DATA, CLOCK)
C            EPH( 8) - TO (REFERENCE TIME FOR CLOCK PARAMETERS)
C            EPH( 9) - AF2 (POLYNOMIAL COEFFICIENT FOR CLOCK)
C            EPH(10) - AF1 (POLYNOMIAL COEFFICIENT FOR CLOCK)
C            EPH(11) - AF0 (POLYNOMIAL COEFFICIENT FOR CLOCK)
C            --------------------- SUBFRAME 2 -----------------------
C            EPH(12) - AODE (AGE OF DATA, EPHEMERIS)
C            EPH(13) - CRS (AMPLITUDE OF SINE HARMONIC CORRECTION
C                TERM TO ORBIT RADIUS)
C            EPH(14) - DN (MEAN MOTION DIFFERENCE FROM COMPUTED VALUE)
C            EPH(15) - MO (MEAN ANOMOLY AT REFERENCE TIME)
C            EPH(16) - CUC (AMPLITUDE OF COSINE HARMONIC CORRECTION
C                TERM TO ARGUMENT OF LATITUDE)
C            EPH(17) - E (ECCENTRICITY)
C            EPH(18) - CUS (AMPLITUDE OF SINE HARMONIC CORRECTION
C                TERM TO ARGUMENT OF LATITUDE)
C            EPH(19) - A**.5 (SQUARE ROOT OF MAJOR SEMI-AXIS)
C            EPH(20) - TOE (REFERENCE TIME OF EPHEMERIS)
C            EPH(21) - CURVE FIT INTERVAL (4 HRS OR 6 HRS)
C            ---------------------- SUBFRAME 3 -----------------------
C            EPH(22) - CIC (AMPLITUDE OF COSINE HARMONIC CORRECTION
C                TERM TO ANGLE OF INCLINATION)
C            EPH(23) - OMEGAO (RIGHT ASCENSION AT REFERENCE TIME)
C            EPH(24) - CIS (AMPLITUDE OF SINE HARMONIC CORRECTION
C                TERM TO ANGLE OF INCLINATION)
C            EPH(25) - IO  (INCLINATION ANGLE AT REFERENCE TIME)
C            EPH(26) - CRC (AMPLITUDE OF COSINE HARMONIC CORRECTION
C                TERM TO ORBIT RADIUS)
C            EPH(27) - W (ARGUMENT OF PERIGEE)
C            EPH(28) - OMEGADOT (RATE OF RIGHT ASCENSION)
C            EPH(29) - AODE (AGE OF DATA, EPHEMERIS)
C            EPH(30) - IDOT (RATE OF INCLINATION ANGLE)
      CHARACTER*48 NAV1,NAV2,NAV3
      INTEGER*4 TIME, PRN, IODE
      REAL*8 NEW_EPH(30)
      REAL*8 WORD, IODC
      REAL*8 PI,svacrcy(16)
      REAL*8 POWER2,HEXTOINT
      DATA SVACRCY/ 2.0D0,2.8D0,4.0D0,5.7D0,8.0D0,11.3D0,1.6D01,
     +       3.2D01,6.4D01,1.28D02,2.56D02,5.12D02,1.024D03,2.048D03,
     +   4.096D03,-1.0D0/
      DATA PI / 3.1415926535898D0/
C Clock Offset - Af0
      WORD = HEXTOINT(NAV1(41:48),2,22)
      if( WORD .GE. POWER2(21) ) WORD = WORD - POWER2(22)
      NEW_EPH(11) = WORD/POWER2(31)
C Clock Drift - Af1
      WORD = HEXTOINT(NAV1(41:48),24,8)+
     +       HEXTOINT(NAV1(33:40),0,8)*POWER2(8)
      IF( WORD .GE. POWER2(15) ) WORD=WORD-POWER2(16)
      NEW_EPH(10) = WORD/POWER2(43)
C Clock Drift Rate - Af2
      WORD = HEXTOINT(NAV1(33:40),8,8)
      IF( WORD .GE. POWER2(7) ) WORD=WORD-POWER2(8)
      NEW_EPH(9) = WORD/POWER2(55)
C Clock Ref Time - TOC
      WORD = HEXTOINT(NAV1(33:40),16,16)
      NEW_EPH(8) = WORD*POWER2(4)
C Total Group Delay - TGD 
      WORD = HEXTOINT(NAV1(25:32),8,8)
      IF( WORD .GE. POWER2(7) ) WORD=WORD-POWER2(8)
      NEW_EPH(6) = WORD/POWER2(31)
C L2P FLAG
      NEW_EPH(3) = HEXTOINT(NAV1(1:8),7,1) * POWER2(8)
C Issue of Data Clock - IODC 
      NEW_EPH(7) = HEXTOINT(NAV1(25:32),0,8)+
     +             HEXTOINT(NAV1(1:8),8,2)*POWER2(8)
      IODC = IODE+HEXTOINT(NAV1(1:8),8,2)*POWER2(8)
C SV health
      WORD = HEXTOINT(NAV1(1:8),10,6)
      NEW_EPH(5) = DINT(WORD/POWER2(5))
C SV accuracy - URA
      WORD = HEXTOINT(NAV1(1:8),16,4)
      NEW_EPH(4) = SVACRCY(IDINT(WORD+1))
C C/A or P on L2
      NEW_EPH(3) = NEW_EPH(3) + HEXTOINT(NAV1(1:8),20,2)
C Week Number
      NEW_EPH(2) = HEXTOINT(NAV1(1:8),22,10)
C Satellite PRN
      NEW_EPH(1) = PRN
C Curve fit interval flag
      NEW_EPH(21) = HEXTOINT(NAV2(41:48),7,1)
C Ephem Ref Time - TOE
      NEW_EPH(20) = HEXTOINT(NAV2(41:48),8,16) * 16
C SQRT(Semi-Maj. axix) - A1/2
      WORD = HEXTOINT(NAV2(33:40),0,24)*POWER2(8)+
     +       HEXTOINT(NAV2(41:48),24,8)
      NEW_EPH(19) = WORD/POWER2(19)
      IF( NEW_EPH(19) .LT. 0 ) NEW_EPH(19)=NEW_EPH(19)+8192.0d0
C Amplitude Sine of arg lat - CUS
      WORD = HEXTOINT(NAV2(25:32),0,8)*POWER2(8)+
     +       HEXTOINT(NAV2(33:40),24,8)
      if( WORD .GE. POWER2(15) ) WORD = WORD-POWER2(16)
      NEW_EPH(18) = WORD/POWER2(29)
C Exxentricity - E
      WORD = HEXTOINT(NAV2(17:24),0,8)*POWER2(24)+
     +       HEXTOINT(NAV2(25:32),8,24)
      NEW_EPH(17) = WORD/POWER2(33)
      if( NEW_EPH(17) .LT. 0 ) NEW_EPH(17)=NEW_EPH(17)+0.5d0
C Amplitude Cosine of arg lat - CUC
      WORD = HEXTOINT(NAV2(17:24),8,16)
      IF ( WORD .GE. POWER2(15) ) WORD=WORD-POWER2(16)
      NEW_EPH(16) = WORD/POWER2(29)
C Mean anomaly art ref - M0
      WORD = HEXTOINT(NAV2(9:16),0,24)*POWER2(8)+
     +       HEXTOINT(NAV2(17:24),24,8)
      NEW_EPH(15) = WORD*(PI/POWER2(31))
      IF( NEW_EPH(15) .GT. PI ) NEW_EPH(15) = NEW_EPH(15)-2*PI
C Mean motion difference - dn
      WORD = HEXTOINT(NAV2(1:8),0,8)*POWER2(8)+
     +       HEXTOINT(NAV2(9:16),24,8)
      IF( WORD .GE. POWER2(15) ) WORD=WORD-POWER2(16)
      NEW_EPH(14) = WORD*(PI/POWER2(43))
C Amplitude Sine of orb radius - CRS
      WORD = HEXTOINT(NAV2(1:8),8,16)
      IF( WORD .GE. POWER2(15) ) WORD=WORD-POWER2(16)
      NEW_EPH(13) = WORD/POWER2(5)
C Issue of data ephemeris - IODE
      NEW_EPH(12) = HEXTOINT(NAV2(1:8),24,8)
C Inclination rate - IDOT
      WORD = HEXTOINT(NAV3(41:48),2,14)
      IF( WORD .GE. POWER2(13) ) WORD = WORD-POWER2(14)
      NEW_EPH(30) = WORD*(PI/POWER2(43))
C Issue of data ephemeris - IODE
      NEW_EPH(29) = HEXTOINT(NAV3(41:48),16,8)
C Right ascension rate - OMEGADOT
      WORD = HEXTOINT(NAV3(33:40),0,16)*POWER2(8)+
     +       HEXTOINT(NAV3(41:48),24,8)
      IF( WORD .GE. POWER2(23) ) WORD = WORD-POWER2(24)
      NEW_EPH(28) = WORD*(PI/POWER2(43))
C Argument of perigee - w
      WORD = HEXTOINT(NAV3(25:32),0,16)*POWER2(16)+
     +       HEXTOINT(NAV3(33:40),16,16)
      NEW_EPH(27) = WORD*(PI/POWER2(31))
      IF( NEW_EPH(27) .GT. PI ) NEW_EPH(27) = NEW_EPH(27)-2*PI
C Amplitude Cosine of orb radius - CRC
      WORD = HEXTOINT(NAV3(25:32),16,16)
      IF( WORD .GE. POWER2(15) ) WORD = WORD-POWER2(16)
      NEW_EPH(26) = WORD/POWER2(5)
C Inclination - I0
      NEW_EPH(25) = HEXTOINT(NAV3(17:24),0,32)*(PI/POWER2(31))
      IF( NEW_EPH(25) .GT. PI ) NEW_EPH(25) = NEW_EPH(25)-2*PI
C Amplitude Sine of inclination - CIS
      WORD = HEXTOINT(NAV3(9:16),0,16)
      IF( WORD .GE. POWER2(15) ) WORD = WORD-POWER2(16)
      NEW_EPH(24) = WORD/POWER2(29)
C Right ascension - OMEGA0
      WORD = HEXTOINT(NAV3(1:8),0,16)*POWER2(16)+
     +       HEXTOINT(NAV3(9:16),16,16)
      NEW_EPH(23) = WORD*(PI/POWER2(31))
      IF( NEW_EPH(23) .GT. PI ) NEW_EPH(23) = NEW_EPH(23)-2*PI
C Amplitude Cosine of inclination - CIC
      WORD = HEXTOINT(NAV3(1:8),16,16)
      IF( WORD .GE. POWER2(15) ) WORD = WORD-POWER2(16)
      NEW_EPH(22) = WORD/POWER2(29)
      IF( IODE .LT. 240.d0 ) THEN
       IF( NEW_EPH(21) .EQ. 0 ) NEW_EPH(21)=4.d0
       IF( NEW_EPH(21) .EQ. 1 ) NEW_EPH(21)=6.d0
      ELSE IF( IODC .LT. 248.d0 ) THEN
       NEW_EPH(21)=8.d0
      ELSE IF(  IODC .LT. 497.d0 ) THEN
       NEW_EPH(21)=14.d0
      ELSE IF(  IODC .LT. 504.d0 ) THEN
       NEW_EPH(21)=26.d0
      ELSE IF(  IODC .LT. 511.d0 ) THEN
       NEW_EPH(21)=50.d0
      ELSE IF(  IODC .LT. 757.d0 ) THEN
       NEW_EPH(21)=74.d0
      ELSE IF(  IODC .LT. 764.d0 ) THEN
       NEW_EPH(21)=98.d0
      ELSE IF(  IODC .LT. 1011.d0 ) THEN
       NEW_EPH(21)=122.d0
      ELSE IF(  IODC .LT. 1021.d0 ) THEN
       NEW_EPH(21)=146.d0
      ENDIF
      IF( IODC .NE. NEW_EPH(7) .OR. IODE .NE. NEW_EPH(12) .OR.
     +    IODE .NE. NEW_EPH(29) ) THEN
         NAV_TO_EPH=-2
      ELSE IF ( MOD(INT(TIME/604800),1024) .NE. NEW_EPH(2) .AND.
     +          MOD(INT(TIME/604800),1024) .NE. NEW_EPH(2)+1 ) THEN
         NAV_TO_EPH=-1
      ELSE
         NAV_TO_EPH=0
      END IF
      NEW_EPH(2) = NEW_EPH(2) +
     +             1024.D0*DINT(DBLE(TIME)/604800.D0/1024.D0)
      IF( TIME - (NEW_EPH(2)*604800.d0) - NEW_EPH(20) .GT.
     +           302400.d0 ) NEW_EPH(2) = NEW_EPH(2) + 1.
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION IGP2GEO( IGPN, LAT, LON )
      IMPLICIT NONE
      INTEGER*4 IGPN,LAT,LON
      INTEGER*4 NN85,NS85,FN85,FS85
      INTEGER*4 N10LON,N5LON,IGPN0
      IGP2GEO=0
      IF( IGPN .LE. 0 .OR. IGPN .GE. 1809 ) THEN
       IGP2GEO=-1
       RETURN
      END IF
C     # # of N85 pts
      NN85=(IGPN+424)/452
C     # is this a N85 pt?   !((IGPN+424)%452)
      FN85=0
      IF( MOD(IGPN+424,452) .EQ. 0 ) FN85=1
C     # # of S85 pts
      NS85=(IGPN+250)/452
C     # is this a S85 pt?   !((IGPN+250)%452)
      FS85=0
      IF( MOD(IGPN+250,452) .EQ. 0 ) FS85=1
C     # # of 10Lon bands
      N10LON=(IGPN-1-NN85-FN85-(NS85-FS85))/50
C      # is this a small lat span?
      IF( IGPN-NN85-FN85-(NS85-FS85)-N10Lon*50 .LT. 28 ) THEN
       N5LON=0
      ELSE
       N5LON=1
      ENDIF
      IGPN0=NN85-FN85+NS85+N10LON*50+N5LON*27+12-(N5LON-1)*2
C
      LON=-180+10*N10LON+5*N5LON
      LAT=5*(IGPN-IGPN0)+5*MAX(IGPN-IGPN0-11,0)+5*MIN(IGPN-IGPN0+11,0)
C!    WRITE(*,222) IGPN,
C!   +             FN85,NN85,FS85,NS85,N10LON,N5LON,
C!   +             IGPN/201,MOD(IGPN,201),LAT,LON
C!222 FORMAT(I4.4,2(' | ',2I2),' | ',I2.2,I2,' | ',I1,I4,' | ',I3,I5)
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION GEO2IGP( LLAT, LLON )
      IMPLICIT NONE
      INTEGER*4 LLAT,LLON
      INTEGER*4 I,LAT,LON,N5LON,FN85,FS85,NN85,NS85,N10LON,IGP0,DIGP
      LON=MOD(LLON,360)
      IF( LON .GE. 180 .OR. LON .LT. -180 ) LON=LON-SIGN(1,LON)*360
      LAT=LLAT
      IF( LAT .GE. 90 .OR. LAT .LE. -90 .OR.
     +    MOD(LON,5) .NE. 0 .OR. MOD(LAT,5) .NE. 0 .OR.
     +    ( ( LAT .LT. -55 .OR. LAT .GT. 55 ) .AND. 
     +                                    MOD(LON,10) .NE. 0 ) .OR.
     +    IABS(LAT) .EQ. 60 .OR. IABS(LAT) .EQ. 70 .OR.
     +    IABS(LAT) .EQ. 80 .OR.
     +    ( LAT .EQ. 85 .AND. MOD(LON,90) .NE. 0 ) .OR.
     +    ( LAT .EQ. -85 .AND. MOD(LON-40,90) .NE. 0 ) ) THEN
       GEO2IGP=-1
       RETURN
      END IF
C     # is this a small lat span?
      N5LON=0
      IF( MOD(LON,10) .NE. 0 ) N5LON=1
C     # is this a N85 lon?
      FN85=0
      IF( MOD(LON,90) .EQ. 0 ) FN85=1
C     # is this a S85 lon?
      FS85=0
      IF( MOD(LON+50,90) .EQ. 0 ) FS85=1
C     # # of 10LON bands
      N10LON=(LON+180)/10
C     # # of N85 pts
      NN85=(LON+270)/90
C     # # of S85 pts
      NS85=(LON+230)/90
C
      IGP0=NN85-FN85+NS85+N10LON*50+N5LON*27+12-(N5LON-1)*2
      DIGP=LAT/5
      DO I=55,75,10
       IF( LAT .GT. I .OR. LAT .LT. -I )
     +                DIGP=DIGP-ISIGN(1,LAT)
      END DO
C!    WRITE(*,222) LAT,LON,
C!   +             FS85,FN85,NS85,NN85,N10LON,N5LON,
C!   +             IGP0,DIGP,IGP0+DIGP
C!222 FORMAT(I4,I5,' | ',2I2,' | ',2I2,' | ',I3,I2,' | ',I4,I3,' | ',I5)
      GEO2IGP=IGP0+DIGP
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
C****************************************************************** RTCM
C
      SUBROUTINE RTCMIONRD( LUION, IDIR, TTAG, TION, TIONX, TIONINIT, 
     &                      TION_END, SLMHGT, INTRV, NSETS, NDEG, MORD,
     &                      SH_REF, SH_T, SH_N, SH_M, SH_ANM, SH_BNM,
     &                      SH_SANM, SH_SBNM )
C
      IMPLICIT NONE
      INCLUDE 'MAXDIM'
C ARGUMENT VARIABLES
      INTEGER*4 LUION, IDIR, IRC, NDEG, MORD, SH_REF,NSETS,
     &          SH_N(MAXSHCOEF,*),SH_M(MAXSHCOEF,*)
      REAL*8    TTAG, TION, TIONX, TIONINIT, TION_END, SLMHGT, INTRV,
     &          SH_T(*), SH_ANM(MAXSHCOEF,*), SH_BNM(MAXSHCOEF,*),
     &          SH_SANM(MAXSHCOEF,*), SH_SBNM(MAXSHCOEF,*)
C READING VARIABLES
      CHARACTER*2048 HEX
      LOGICAL*4 REACQD
      INTEGER*4 TIME,IDXINT,TYPE,FLG,MMI,INTV,TEND,ERR,EOF,TREF
      INTEGER*4 DEGREE(4), ORDER(4)
      REAL*8    REFT, HEIGHT(4), CNMRD(153,4), SNMRD(153,4), QUALITY
C PROCESSING VARIABLES
      INTEGER*4 I,N,M
      INTEGER*4 LAT,LON
      REAL*8    TVAL,TPREV,TGRD,ROT_TO_0H00
C FUNCTIONS
      INTEGER*4 DECODE_T1264, RTCM_INTV
C INITIALIZATION
C LOCATE BEGINING OF PREVIOUS/NEXT IONO BLOCK: FILE IS POSITIONED AT LAST READ
      TPREV=-1
      TGRD=-1
      IF( IDIR .EQ. -1 ) BACKSPACE(LUION)
 500  CONTINUE
      CALL GET_RTCM_REC( LUION, TIME, HEX, TYPE, TREF, IDXINT,
     +                   ERR, EOF )
      IF( ERR .EQ. 1 ) GOTO 9999
      IF( EOF .EQ. 1 ) THEN
       WRITE(*,*) 'RTCMIONRD - REACHED END OF FILE WHILE LOOKING'
       TION_END=TION
       GOTO 900
      ENDIF
      IF ( IDXINT .GE. 0 .AND. IDXINT .LE. 15 )
     +   TVAL = TREF - MOD(TREF,RTCM_INTV(IDXINT) )
      IF( TVAL-TYPE .EQ. TIONINIT .AND.
     +    TPREV-TYPE .EQ. TIONINIT ) THEN
       WRITE(*,*) 'RTCMIONRD - REACHED START FILE WHILE LOOKING '
       TIONX=-1
       GOTO 900
      ENDIF
C SKIP NON-IONO RECORDS
      IF( TYPE .NE. 1264 ) THEN
       TPREV=TVAL
       GOTO 500
      ENDIF
C TAG FIRST RECORD FOR BACKWARD SEARCH
      IF( TIONINIT .LT. 0 ) THEN
       TIONINIT=TVAL-TYPE
       TION=TVAL
      ENDIF
C SEARCHED TIME IS BEFORE CURRENT T1264 REFERENCE: GOBACK 2 AND READ
      IF( TTAG .LT. TVAL .AND.
     +    ( TTAG .LT. TPREV .OR. TPREV .LT. 0 ) ) THEN
       TPREV=TVAL
       BACKSPACE( LUION ) 
       BACKSPACE( LUION ) 
       GOTO 500
      ENDIF
C SEARCHED TIME IS BEYOND CURRENT T1264 VALIDITY: READ NEXT
      IF( TTAG .GE. TVAL+RTCM_INTV(IDXINT) .AND.
     +    ( TVAL .GT. TPREV .OR. TPREV .LT. 0 ) ) THEN
       TPREV=TVAL
       GOTO 500
      ENDIF
C PROCESS T1264
      FLG=DECODE_T1264( TIME, HEX, TYPE, TREF, MMI, INTV,
     +                  REACQD, REFT, NSETS, DEGREE, ORDER,
     +                  QUALITY, HEIGHT, CNMRD, SNMRD, TEND )
C CANCEL IF DECODE ERROR OR MORE THAN 1 SET
      IF( FLG .NE. 0 .OR. NSETS .GT. 1 ) GOTO 900
      TION=TVAL
C SET NEXT REFERENCE FOR FORWARD
      IF(IDIR .EQ. 1) THEN
       TIONX=TVAL+RTCM_INTV(IDXINT)
C SET NEXT REFERENCE FOR BACKWARD
      ELSE
       TIONX=TVAL-RTCM_INTV(IDXINT)
      ENDIF
C LOAD TWO SIMILAR SETS ( ONLY FIRST OF MULTI )
      SLMHGT=HEIGHT(1)
      NDEG=DEGREE(1)
      MORD=ORDER(1)
C ROTATE COEFFICIENTS FROM 14H00 TO 0H00
      ROT_TO_0H00=DACOS(0.D0)*(-50400.D0)/21600.D0
      DO N=0,MAXSHDEG
      DO M=0,N
      DO I=1,2
       IF( N .LE. NDEG .AND. M .LE. MORD ) THEN
        SH_N(1+M+N*(N+1)/2,I)=N
        SH_M(1+M+N*(N+1)/2,I)=M
        SH_ANM(1+M+N*(N+1)/2,I)=
     +                       DCOS(M*ROT_TO_0H00)*CNMRD(1+M+N*(N+1)/2,1)
     +                      +DSIN(M*ROT_TO_0H00)*SNMRD(1+M+N*(N+1)/2,1)
        SH_BNM(1+M+N*(N+1)/2,I)=
     +                       DCOS(M*ROT_TO_0H00)*SNMRD(1+M+N*(N+1)/2,1)
     +                      -DSIN(M*ROT_TO_0H00)*CNMRD(1+M+N*(N+1)/2,1)
       ELSE
        SH_N(1+M+N*(N+1)/2,I)=-1
        SH_M(1+M+N*(N+1)/2,I)=-1
        SH_ANM(1+M+N*(N+1)/2,I)=0.D0
        SH_BNM(1+M+N*(N+1)/2,I)=0.D0
       ENDIF
       SH_SANM(1+M+N*(N+1)/2,I)=0.D0
       SH_SBNM(1+M+N*(N+1)/2,I)=0.D0
       IF(N .EQ. 0 .AND. M .EQ. 0 ) SH_SANM(1+M+N*(N+1)/2,I)=QUALITY
      END DO
      END DO
      END DO
      NSETS=2
      INTRV=RTCM_INTV(IDXINT)
      SH_T(1)=TION
      SH_T(2)=TION+INTRV
      SH_REF=1
900   CONTINUE
      BACKSPACE(LUION)
      RETURN
9000  CONTINUE
      RETURN
9999  CONTINUE
      STOP
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      SUBROUTINE RTCMEPH( LPR, LUEPH, NEPSV, IEPSV,
     &                    NEPTIM, EPHTIM, EPHTBL, ISRCH)
      IMPLICIT NONE
      INCLUDE 'MAXDIM'
C ARGUMENTS
      INTEGER*4      LPR, LUEPH, NEPSV, ISRCH
      INTEGER*4      IEPSV(MAXSAT), NEPTIM(MAXSAT)
      REAL*8         EPHTIM(MAXSAT,MAXEPH)
      REAL*8         EPHTBL(MAXKEP,MAXSAT,MAXEPH)
C READING VARIABLES
      CHARACTER HEX*134
      INTEGER*4 TIME,TYPE,TREF,FLG,IPRN,IDXINT
      REAL*8    EPH(30)
C PROCESSING VARIABLES
      INTEGER*4 ERR, EOF
C FUNCTIONS
      INTEGER*4 DECODE_T1019
 1000 CONTINUE
      CALL GET_RTCM_REC( LUEPH, TIME, HEX, TYPE, TREF, IDXINT,
     &                   ERR, EOF )
      IF( ERR .NE. 0 ) GOTO 9999
      IF( EOF .NE. 0 ) GOTO 9000
      FLG=0
      IF( TYPE .EQ. 1019 ) THEN
       FLG=DECODE_T1019( TIME,HEX,TYPE,IPRN,EPH )
       IF( FLG .EQ. 0 ) THEN
        CALL UPTBL(IPRN,DBLE(TIME),EPH,
     +             NEPSV,IEPSV,NEPTIM,EPHTIM,EPHTBL,ISRCH)
       END IF
      END IF
      IF( FLG .NE. 0 ) WRITE(*,*) 'ERROR - TYPE MISMATCH:',TYPE,HEX
      GOTO 1000
 9000 CONTINUE
      RETURN
 9999 CONTINUE
      STOP
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      SUBROUTINE RTCMSLCT( LPR, NSVCLK, ISVCLK, LSVCLK, IEOFCLK,
     &                     FRSVCLK, LTSVCLK,
     &                     RTCMTBUF, RTCMBUF, RTCMIBUF,
     &                     RTCMBFLG, RTCMBBUF,
     &                     RTCMPFLG, RTCMPBUF,
     &                     RTCMCLKAMB, RTCMCLKBUF,
     &                     NOSV, IOSV, IGPSWK, TTAG,
     &                     PRDC, DORBC, IODC,
     &                     CLKAMB,
     &                     NSVRJCT, ISVRJCT, C, IDIR, INTCLK )
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C ARGUMENTS
      LOGICAL*4 CLKAMB(*), RTCMCLKAMB(*), RTCMCLKBUF(*)
      INTEGER*4 LPR, LTSVCLK(*), FRSVCLK(*)
      INTEGER*4 NSVCLK, LSVCLK(*), ISVCLK(*), IEOFCLK(*)
      INTEGER*4 NOSV, IOSV(*), IODC(*)
      INTEGER*4 NSVRJCT, ISVRJCT(*)
      INTEGER*4 INTCLK, IDIR, IGPSWK
      REAL*8    C, TTAG(*), PRDC(10,*), DORBC(12,*)
      LOGICAL*4 RTCMBFLG(32,*),RTCMPFLG(32,*)
      INTEGER*4 RTCMTBUF(*), RTCMIBUF(2,*)
      REAL*8    RTCMBUF(9,*),RTCMBBUF(32,*),RTCMPBUF(32,*)
C LOCAL VARIABLES
      INTEGER*4 I,ISO,ISC,ITTAG
      NSVRJCT=0
      DO ISO=1,NOSV
       IODC(ISO) = -1
       ITTAG = IDNINT(TTAG(ISO)+IGPSWK*604800.D0)
       DO ISC=1,NSVCLK
        IF( IOSV(ISO) .EQ. ISVCLK(ISC) ) THEN
         DO WHILE ( RTCMTBUF(ISC) .EQ. -1 .OR.
     &              (IDIR .EQ. 1 .AND.
     &               RTCMTBUF(ISC) .LE. ITTAG - INTCLK .AND.
     &                RTCMTBUF(ISC) .LT. LTSVCLK(ISC)) .OR. 
     &              (IDIR .EQ. -1 .AND.
     &               RTCMTBUF(ISC) .GT. ITTAG .AND.
     &                RTCMTBUF(ISC) .GT. FRSVCLK(ISC)) ) 
C
C BUFFER THE DCM RESET BY ONE PROCESSED EPOCH IN FWD/BWD MODE
C
          RTCMCLKAMB(ISC) = RTCMCLKBUF(ISC)
          IF( IDIR .EQ. -1 .AND. ( RTCMTBUF(ISC) .EQ. -1 .OR.
     &        RTCMTBUF(ISC) .GT. FRSVCLK(ISC) )) 
     &       BACKSPACE(LSVCLK(ISC))
          READ(LSVCLK(ISC))
     &       RTCMTBUF(ISC),(RTCMBUF(I,ISC),I=1,9),
     &                     (RTCMIBUF(I,ISC),I=1,2)
     &      ,RTCMCLKBUF(ISC)
     &      ,(RTCMBFLG(I,ISC),I=1,32),(RTCMBBUF(I,ISC),I=1,32)
     &      ,(RTCMPFLG(I,ISC),I=1,32),(RTCMPBUF(I,ISC),I=1,32)
          IF( IDIR .EQ. -1 ) BACKSPACE(LSVCLK(ISC))
C
C UNBUFFER THE DCM RESET BY WHEN IN FWD MODE
C
          IF( IDIR .EQ. 1 ) RTCMCLKAMB(ISC) = RTCMCLKBUF(ISC)
C
C KEEPING/SETTING CLKAMB <ON> UNTIL EXTERNAL CLEARING
C
          CLKAMB(IOSV(ISO)) =
     &          CLKAMB(IOSV(ISO)) .OR. RTCMCLKAMB(ISC)
         END DO
         IF( ITTAG .GE. RTCMTBUF(ISC) .AND.
     &       ITTAG - RTCMTBUF(ISC) .LT. INTCLK ) THEN
          DO I=1,6
           DORBC(I+6,ISO) = RTCMBUF(I,ISC)
          END DO
          DO I=1,2
           PRDC(I,ISO) = RTCMBUF(I+6,ISC)
          END DO
          IF( RTCMBFLG(1,ISC).AND.RTCMBBUF(1,ISC).GT.-81.92D0 ) THEN
            PRDC(3,ISO)=RTCMBBUF(1,ISC)
          ELSE
            PRDC(3,ISO)=0.D0
          ENDIF
          IF( RTCMBFLG(3,ISC).AND.RTCMBBUF(3,ISC).GT.-81.92D0 ) THEN
            PRDC(4,ISO)=RTCMBBUF(3,ISC)
          ELSE
            PRDC(4,ISO)=0.D0
          ENDIF
          IF( RTCMBFLG(6,ISC).AND.RTCMBBUF(6,ISC).GT.-81.92D0 ) THEN
            PRDC(5,ISO)=RTCMBBUF(6,ISC)
          ELSE
            PRDC(5,ISO)=0.D0
          ENDIF
          IF( RTCMBFLG(12,ISC).AND.RTCMBBUF(12,ISC).GT.-81.92D0 ) THEN
            PRDC(6,ISO)=RTCMBBUF(12,ISC)
          ELSE
            PRDC(6,ISO)=0.D0
          ENDIF
          PRDC(7,ISO)=RTCMBUF(9,ISC)
          IF((RTCMBFLG( 3,ISC).AND.
     &                        RTCMBBUF( 3,ISC).GT.-81.92D0) .AND.
     &       (RTCMBFLG(12,ISC).AND.
     &                        RTCMBBUF(12,ISC).GT.-81.92D0) .AND.
     &       ((.NOT.RTCMPFLG( 3,ISC) .AND. .NOT.RTCMPFLG(12,ISC)) .OR.
     &        (RTCMPBUF( 3,ISC).GT.-52.4288D0 .AND.
     &                        RTCMPBUF(12,ISC).GT.-52.4288D0) ) ) THEN
           PRDC(8,IOSV(ISO)) =
     &      ((77D0**2) * (RTCMBBUF( 3,ISC) -RTCMPBUF( 3,ISC)) -
     &       (60D0**2) * (RTCMBBUF(12,ISC)-RTCMPBUF(12,ISC)))/
     &                                        ((77D0**2)-(60D0**2))
           PRDC(9,IOSV(ISO)) =
     &      - (77D0/137D0) * RTCMBBUF( 3,ISC)
     &                                 - (60D0/137D0) * RTCMBBUF(12,ISC)
     &      + (77D0/ 17D0) * RTCMPBUF( 3,ISC)
     &                                 - (60D0/ 17D0) * RTCMPBUF(12,ISC)
          ENDIF
          IODC(ISO) = RTCMIBUF(2,ISC)
         END IF
        END IF
       END DO
       IF( IODC(ISO) .EQ. -1 ) THEN
        NSVRJCT = NSVRJCT+1
        ISVRJCT(NSVRJCT) = IOSV(ISO)
       END IF
      END DO
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      SUBROUTINE RTCMSORT( LUCLK, CLKFILE, ILUCLK, LLUCLK, NSVCLK,
     &                     ISVCLK, LTRTCM, FRRTCM, RTCMTBUF, IREFIN,
     &                     ENDTTAG, YAWMODEL,
     &                     IERR, IEOF, INTCLK, NBDAY, C, IPC  )
      IMPLICIT NONE
      INCLUDE 'MAXDIM'
C ARGUMENTS
      CHARACTER*80  CLKFILE(*)
      INTEGER*4 LUCLK,ILUCLK,NSVCLK,IERR,IEOF,INTCLK,NBDAY,IPC
      INTEGER*4 IREFIN, YAWMODEL
      INTEGER*4 LLUCLK(*), ISVCLK(*)
      INTEGER*4 LTRTCM(*), FRRTCM(*), RTCMTBUF(*)
      REAL*8    C
      REAL*8    ENDTTAG
C READING VARIABLES
      CHARACTER HEX*2048
      INTEGER*4 TREAD,TYPE,FLG,TREF
C RTCM STORAGE VARIABLES
      LOGICAL*4 CLKAMB(MAXSAT)
      INTEGER*4 IPRN,MMI57,MMI58,MMI59,MMI60,MMI61,MMI62,MMI65
      INTEGER*4 INTV57,INTV58,INTV59,INTV60,INTV61,INTV62,INTV65
      INTEGER*4 TMSG57,TMSG58,TMSG59,TMSG60,TMSG61,TMSG62,TMSG65
      INTEGER*4 TEND57(MAXSAT),TEND58(MAXSAT),TEND59(MAXSAT)
      INTEGER*4 TEND60(MAXSAT),TEND61(MAXSAT),TEND62(MAXSAT)
      INTEGER*4 TEND65(MAXSAT)
      INTEGER*4 REFD57,REFD60
      LOGICAL*4 REACQD57(MAXSAT),REACQD58(MAXSAT),REACQD59(MAXSAT)
      LOGICAL*4 REACQD60(MAXSAT),REACQD61(MAXSAT),REACQD62(MAXSAT)
      LOGICAL*4 REACQD65(MAXSAT)
      LOGICAL*4 CTRKFLG(32,MAXSAT),PTRKFLG(32,MAXSAT)
      INTEGER*4 URA(MAXSAT),IODE57(MAXSAT),IODE60(MAXSAT)
      REAL*8    REFT57(MAXSAT),REFT58(MAXSAT),REFT60(MAXSAT)
      REAL*8    REFT65(MAXSAT)
      REAL*8    EPH(30),ACC(MAXSAT),FAST(MAXSAT)
      REAL*8    DX57(3,MAXSAT),DXDOT57(3,MAXSAT),DCLK58(3,MAXSAT)
      REAL*8    DX60(3,MAXSAT),DXDOT60(3,MAXSAT),DCLK60(3,MAXSAT)
      REAL*8    CDBIAS(32,MAXSAT),YAW65(2,MAXSAT)
      INTEGER*4 DISCNT(32,MAXSAT),DISCNTSAV(32,MAXSAT)
      REAL*8    PHBIAS(32,MAXSAT)
C PROCESSING VARIABLES
      LOGICAL*4 OUTPUT, SVRESET(MAXSAT)
      LOGICAL*4 SVFLG57(MAXSAT),SVFLG58(MAXSAT),SVFLG59(MAXSAT)
      LOGICAL*4 SVFLG60(MAXSAT),SVFLG61(MAXSAT),SVFLG62(MAXSAT)
      LOGICAL*4 SVFLG65(MAXSAT)
      CHARACTER FNAM*12
      INTEGER*4 I,J,K,IDAY,NINTRV60,NINTRV62,INTRV60,INTRV62,IDXINT
      INTEGER*4 TVAL,TVALP,TFSTP60,TFSTPP60,TFSTP62,TFSTPP62
      REAL*8    ACCPREV(MAXSAT),YAWANGLE,PI
C FUNCTIONS
      INTEGER*4 DECODE_T1060,DECODE_T1058,DECODE_T1057
      INTEGER*4 DECODE_T1061, DECODE_T1062, DECODE_T1265
      INTEGER*4 DECODE_T1059, RTCM_INTV
C INITIALIZATION
      DATA PI / 3.1415926535898D0/
      DATA CLKAMB/MAXSAT*.FALSE./
      DATA ACC/MAXSAT*0.D0/
      DATA REFD60,REFD57/-1,-1/
      DATA TEND57/MAXSAT*-1/
      DATA TEND58/MAXSAT*-1/
      DATA TEND59/MAXSAT*-1/
      DATA TEND60/MAXSAT*-1/
      DATA TEND61/MAXSAT*-1/
      DATA TEND62/MAXSAT*-1/
      DATA TEND65/MAXSAT*-1/
      DATA SVFLG57/MAXSAT*.FALSE./
      DATA SVFLG58/MAXSAT*.FALSE./
      DATA SVFLG59/MAXSAT*.FALSE./
      DATA SVFLG60/MAXSAT*.FALSE./
      DATA SVFLG61/MAXSAT*.FALSE./
      DATA SVFLG62/MAXSAT*.FALSE./
      DATA SVFLG65/MAXSAT*.FALSE./
      DATA REACQD57/MAXSAT*.FALSE./
      DATA REACQD58/MAXSAT*.FALSE./
      DATA REACQD59/MAXSAT*.FALSE./
      DATA REACQD60/MAXSAT*.FALSE./
      DATA REACQD61/MAXSAT*.FALSE./
      DATA REACQD62/MAXSAT*.FALSE./
      DATA REACQD65/MAXSAT*.FALSE./
      DATA SVRESET/MAXSAT*.FALSE./
      DATA TREF,TVALP,TFSTP60,TFSTPP60,TFSTP62,TFSTPP62/6*-1/
      NSVCLK=0
      IEOF=0
      IERR=0
      IDAY=0
      INTCLK=0
      INTRV60=0
      NINTRV60=0
      INTRV62=0
      NINTRV62=0
      YAWMODEL=0
      DO I=1,MAXSAT
       DO K=1,32
        CTRKFLG(K,I) = .FALSE.
        PTRKFLG(K,I) = .FALSE.
       END DO
      END DO
  500 CONTINUE
      IDAY=IDAY+1
      IF( IDAY .GT. NBDAY ) GOTO 9000
      OPEN(LUCLK,FILE=CLKFILE(IDAY),STATUS='OLD',FORM='FORMATTED')
C
C LOOP READING RECORDS
C
 1000 CONTINUE
      CALL GET_RTCM_REC( LUCLK, TREAD, HEX, TYPE, TREF, IDXINT,
     &                   IERR, IEOF )
      IF( IERR .NE. 0 ) GOTO 9999
      IF( IEOF .NE. 0 ) GOTO 2000
      IF ( IDXINT .GE. 0 .AND. IDXINT .LE. 15 )
     &   TVAL = TREF - MOD(TREF,RTCM_INTV(IDXINT) )
      GOTO 3000
 2000 CONTINUE
      CLOSE(LUCLK)
      TVAL=-1
 3000 CONTINUE
C
C WRITE EPOCH SATELLITE CLOCK&ORB CORRECTIONS
C
      IF( TVAL .NE. TVALP ) THEN
       IF( TVALP .NE. -1 ) THEN
        IF( TFSTP60 .EQ. TVALP ) THEN
         IF( TFSTPP60 .NE. -1 ) THEN
          IF( NINTRV60 .EQ. 0 .OR.
     &       (TFSTP60-TFSTPP60 .LT. INTRV60 .AND.
     &                      TFSTP60-TFSTPP60 .GT. 0) )
     &     INTRV60=TFSTP60-TFSTPP60
          NINTRV60=NINTRV60+1
         END IF
         TFSTPP60=TFSTP60
        END IF
        IF( TFSTP62 .EQ. TVALP ) THEN
         IF( TFSTPP62 .NE. -1 ) THEN
          IF( NINTRV62 .EQ. 0 .OR.
     &       (TFSTP62-TFSTPP62 .LT. INTRV62 .AND.
     &                      TFSTP62-TFSTPP62 .GT. 0) )
     &     INTRV62=TFSTP62-TFSTPP62
          NINTRV62=NINTRV62+1
         END IF
         TFSTPP62=TFSTP62
        END IF
C
C LOOP ON SATELLITES
C
        DO I=1,MAXSAT
         OUTPUT=.TRUE.
C
C MANAGE VALIDITY TIMES
C
         SVFLG65(I) = TVALP .LE. TEND65(I)
         SVFLG62(I) = TVALP .LE. TEND62(I)
         SVFLG61(I) = TVALP .LE. TEND61(I)
         SVFLG60(I) = TVALP .LE. TEND60(I)
         SVFLG59(I) = TVALP .LE. TEND59(I)
         SVFLG58(I) = TVALP .LE. TEND58(I)
         SVFLG57(I) = TVALP .LE. TEND57(I)
C
C DO NOT ISSUE WHEN FAST=-209.7152, IF PRESENT (CASE 2,4,6)
C
         OUTPUT = OUTPUT .AND.
     &     (.NOT. SVFLG62(I) .OR. FAST(I) .GT. -209.7152D0)
C
C DO NOT ISSUE WHEN URA=0 AND NO FAST, IF PRESENT (CASE 0)
C
         OUTPUT = OUTPUT .AND.
     &     (.NOT. SVFLG61(I) .OR. SVFLG62(I) .OR. URA(I) .NE. 0)
C
C STOP USING CURRENT SLOW AND WAIT UNTIL REACQUIRED, IF ANY (CASE 5 )
C SKIP FISRT EPOCH WHEN THIS HAPPENS
C THIS CONDITION REMAINS FOR A WHILE EVEN AFTER REACQUISITION
C SET ACC TO PREVIOUS WHILE SLOW IS REACQUIRED
C
         IF( SVFLG61(I) .AND. URA(I) .EQ. 0 .AND.
     &       SVFLG62(I) .AND. FAST(I) .GT. -209.7152D0 ) THEN
          IF( .NOT. SVRESET(I) .AND.
     &        SVFLG57(I) .AND. .NOT. REACQD57(I) ) THEN
           TEND57(I) = MIN(TEND57(I),TVALP-1)
           SVFLG57(I) = .FALSE.
          ENDIF
          IF( .NOT. SVRESET(I) .AND.
     &        SVFLG58(I) .AND. .NOT. REACQD58(I) ) THEN
           TEND58(I) = MIN(TEND58(I),TVALP-1)
           SVFLG58(I) = .FALSE.
          ENDIF
          IF( .NOT. SVRESET(I) .AND.
     &        SVFLG60(I) .AND. .NOT. REACQD60(I) ) THEN
           TEND60(I) = MIN(TEND60(I),TVALP-1)
           SVFLG60(I) = .FALSE.
          ENDIF
          SVRESET(I) = .TRUE.
          OUTPUT = OUTPUT .AND.
     &             (SVFLG60(I) .OR. (SVFLG57(I) .AND. SVFLG58(I)))
          IF( OUTPUT ) ACC(I)=ACCPREV(I)
         ENDIF
         IF( SVFLG65(I) .AND.
     &     YAW65(1,I)*256/PI .GE. 0.D0 .AND.
     &     YAW65(1,I)*256/PI .LT. 512.D0 .AND.
     &     YAW65(2,I)*8192/PI .GT. -128.D0 .AND.
     &     YAW65(2,I)*8192/PI .LT.  128.D0 ) THEN
           YAWANGLE=YAW65(1,I)+(TVALP-REFT65(I))*YAW65(2,I)
         ELSE
           YAWANGLE=-999D0
         ENDIF
C
C MANAGING DCM RESETS: SETTING/KEEPING THE RESET FLAG ON
C
         CLKAMB(I) = CLKAMB(I) .OR. ( SVFLG61(I) .AND. URA(I) .EQ. 63 )
         IF( SVFLG65(I) ) THEN
           DO K=1,32
             IF( PTRKFLG(K,I) ) THEN
               CLKAMB(I) = CLKAMB(I) .OR.
     &                     DISCNT(I,K) .NE. DISCNTSAV(I,K)
               DISCNTSAV(I,K) = DISCNT(I,K)
            ENDIF
           END DO
         ENDIF
C
C STORE VALID ACC FOR FUTURE USE
C
         IF( SVFLG62(I) .AND. URA(I) .GT. 0 ) THEN
          IF( SVRESET(I) ) SVRESET(I) = .FALSE.
          ACCPREV(I)=ACC(I)
         ENDIF
C
C ALLOW 1060,1059,1265 DCM OPERATION
C
         OUTPUT = OUTPUT .OR.
     &            (SVFLG60(I) .AND. INTV60 .EQ. 1 .AND.
     &             SVFLG59(I) .AND. INTV59 .EQ. 1 .AND.
     &             SVFLG65(I) .AND. INTV65 .EQ. 1)
C
C OUTPUT EITHER, IN PRIORITY LIST:
C   1) 1057's, 1058's (slow), 1061's (ura), 1062's (fast)
C   2) 1060's (slow), 1061's (ura), 1062's (fast)
C   3) 1060's ALONE IF ITS UPDATE INTERVALS ARE 1SEC, URAs SET TO 0
C   1059's must always output
C
         OUTPUT = OUTPUT .AND. SVFLG59(I) .AND. 
     &      (( SVFLG60(I) .AND. INTV60 .EQ. 1 ) .OR.
     &       ( SVFLG62(I) .AND. SVFLG61(I) .AND.
     &        ( SVFLG60(I) .OR.
     &                ( SVFLG57(I) .AND. SVFLG58(I) ) ) ))
         IF( OUTPUT ) THEN
C
C MANAGE TEMPORARY SATELLITE CORRECTION FILES
C
          DO K=1,NSVCLK
           IF( I .EQ. ISVCLK(K) ) GOTO 3100
          END DO
          NSVCLK=NSVCLK+1
          LLUCLK(NSVCLK) = ILUCLK + NSVCLK
          ISVCLK(NSVCLK) = I
          WRITE(FNAM,'(A4,I3.3,A1,I3.3)') 'RTCM',NSVCLK,'.',I
          OPEN(LLUCLK(NSVCLK),FILE=FNAM,STATUS='OLD',ERR=3050)
          CLOSE(LLUCLK(NSVCLK),STATUS='DELETE')
 3050     CONTINUE
          OPEN(LLUCLK(NSVCLK),FILE=FNAM,FORM='UNFORMATTED',
     +         STATUS='NEW')
          FRRTCM(K)=TVALP
 3100     CONTINUE
          LTRTCM(K)=TVALP
          ENDTTAG = TVALP
C
C OUTPUT ORB/CLK CORRECTIONS
C
          IF( SVFLG57(I) ) THEN
           WRITE(LLUCLK(K)) TVALP,
     &        (-(DX57(J,I)+(TVALP-REFT57(I))*DXDOT57(J,I)),J=1,3),
     &        (-DXDOT57(J,I),J=1,3),
     &        -(FAST(I)+DCLK58(1,I)+
     &                    (TVALP-REFT58(I))*(DCLK58(2,I)+
     &                           (TVALP-REFT58(I))*DCLK58(3,I))),
     &        ACC(I)/C, YAWANGLE, URA(I), IODE57(I)
     &        ,CLKAMB(I)
     &        ,(CTRKFLG(J,I),J=1,32),(     CDBIAS(J,I)  ,J=1,32)
     &        ,(PTRKFLG(J,I),J=1,32),(     PHBIAS(J,I)  ,J=1,32)
          ELSE IF( SVFLG60(I) .AND. INTV60 .GT. 1 ) THEN
           WRITE(LLUCLK(K)) TVALP,
     &        (-(DX60(J,I)+(TVALP-REFT60(I))*DXDOT60(J,I)),J=1,3),
     &        (-DXDOT60(J,I),J=1,3),
     &        -(FAST(I)+DCLK60(1,I)+
     &                    (TVALP-REFT60(I))*(DCLK60(2,I)+
     &                           (TVALP-REFT60(I))*DCLK60(3,I))),
     &        ACC(I)/C, YAWANGLE, URA(I), IODE60(I)
     &        ,CLKAMB(I)
     &        ,(CTRKFLG(J,I),J=1,32),(     CDBIAS(J,I)  ,J=1,32)
     &        ,(PTRKFLG(J,I),J=1,32),(     PHBIAS(J,I)  ,J=1,32)
          ELSE IF( SVFLG60(I) ) THEN
           WRITE(LLUCLK(K)) TVALP,
     &        (-(DX60(J,I)+(TVALP-REFT60(I))*DXDOT60(J,I)),J=1,3),
     &        (-DXDOT60(J,I),J=1,3),
     &        -(DCLK60(1,I)+(TVALP-REFT60(I))*(DCLK60(2,I)+
     &                            (TVALP-REFT60(I))*DCLK60(3,I))),
     &        ACC(I)/C, YAWANGLE, 0, IODE60(I)
     &        ,CLKAMB(I)
     &        ,(CTRKFLG(J,I),J=1,32),(     CDBIAS(J,I)  ,J=1,32)
     &        ,(PTRKFLG(J,I),J=1,32),(     PHBIAS(J,I)  ,J=1,32)
          END IF
C
C MANAGING DCM RESETS : RETURNING FLAG TO <OFF> WHEN WRITTEN OUT
C
          CLKAMB(I) = .FALSE.
         END IF
C
C CLEAR REACQD## FLAGS
C
         REACQD57(I) = .FALSE.
         REACQD58(I) = .FALSE.
         REACQD59(I) = .FALSE.
         REACQD60(I) = .FALSE.
         REACQD61(I) = .FALSE.
         REACQD62(I) = .FALSE.
         REACQD65(I) = .FALSE.
         DO K=1,32
           CTRKFLG(K,I) = .FALSE.
           PTRKFLG(K,I) = .FALSE.
         END DO
        END DO
       END IF
       TVALP=TVAL
      END IF
C
C REACHED END OF FILE; GET NEXT ON THE LIST
C
      IF( IEOF .NE. 0 ) GOTO 500
C
C PROCESS EACH MSG TYPE
C
      IF( TYPE .EQ. 1057 )
     & FLG=DECODE_T1057( TREAD, HEX, TYPE, TMSG57, MMI57, INTV57,
     &                   REFD57, REACQD57, REFT57, IODE57, DX57,
     &                   DXDOT57, TEND57 )
      IF( TYPE .EQ. 1058 )
     & FLG=DECODE_T1058( TREAD, HEX, TYPE, TMSG58, MMI58, INTV58,
     &                   REACQD58, REFT58, DCLK58, TEND58 )
      IF( TYPE .EQ. 1059 )
     & FLG=DECODE_T1059( TREAD, HEX, TYPE, TMSG59, MMI59, INTV59,
     &                   REACQD59, CTRKFLG, CDBIAS, TEND59 )
      IF( TYPE .EQ. 1060 )
     & FLG=DECODE_T1060( TREAD, HEX, TYPE, TMSG60, MMI60, INTV60,
     &           REFD60, REACQD60, REFT60, IODE60, DX60, DXDOT60,
     &                   DCLK60, TEND60 )
      IF( TYPE .EQ. 1061 )
     & FLG=DECODE_T1061( TREAD, HEX, TYPE, TMSG61, MMI61, INTV61,
     &                   REACQD61, URA, ACC, TEND61 )
      IF( TYPE .EQ. 1062 )
     & FLG=DECODE_T1062( TREAD, HEX, TYPE, TMSG62, MMI62, INTV62,
     &                   REACQD62, FAST, TEND62 )
      IF( TYPE .EQ. 1265 )
     & FLG=DECODE_T1265( TREAD, HEX, TYPE, TMSG65, MMI65, INTV65,
     &                   REACQD65, REFT65, YAW65, PTRKFLG, DISCNT,
     &                   PHBIAS, TEND65 )
      IF( FLG .EQ. 0 .AND. TYPE .EQ. 1060 .AND. MMI60 .EQ. 0 )
     &                                               TFSTP60=TVAL
      IF( FLG .EQ. 0 .AND. TYPE .EQ. 1062 .AND. MMI62 .EQ. 0 )
     &                                               TFSTP62=TVAL
      IF( FLG .EQ. 0 .AND. TYPE .EQ. 1265 ) YAWMODEL=2
      IF( FLG .NE. 0 ) WRITE(*,*) 'ERROR - TYPE MISMATCH:',TYPE,HEX
      GOTO 1000
 9000 CONTINUE
C
C FIGURE CLK INTERVAL FROM T1062 (T1060)
C
      IF( NINTRV62 .GT. 0 ) THEN
       INTCLK=INTRV62
      ELSE IF( NINTRV60 .GT. 0 ) THEN
       INTCLK=INTRV60
      ENDIF
C
C FIGURE REF FRAME FROM T1057 (T1060)
C
      IF( REFD57 .GE. 0 ) THEN
       IREFIN=2-REFD57
      ELSE IF( REFD60 .GE. 0 ) THEN
       IREFIN=2-REFD60
      ENDIF
      DO I=1,NSVCLK
       REWIND(LLUCLK(I))
       RTCMTBUF(I)=-1
      END DO
      IEOF=1
      RETURN
 9999 CONTINUE
      STOP
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      SUBROUTINE RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, BIN )
      IMPLICIT NONE
      INTEGER*4 BITSTR,BITLEN
      CHARACTER HEX*(*),BIN*(*)
      CHARACTER*4 UNIT
      INTEGER*4 I,CBEG,CEND,BBEG,BEND,NUM
      BIN=''
      CBEG=INT((BITSTR)/4)+1
      CEND=INT((BITSTR+BITLEN-1)/4)+1
      BBEG=MOD(BITSTR,4)+1
      BEND=4
      NUM=0
      DO I=CBEG,CEND
       UNIT=''
       IF( HEX(I:I) .EQ. 'F' .OR. HEX(I:I) .EQ. 'f' ) UNIT='1111'
       IF( HEX(I:I) .EQ. 'E' .OR. HEX(I:I) .EQ. 'e' ) UNIT='1110'
       IF( HEX(I:I) .EQ. 'D' .OR. HEX(I:I) .EQ. 'd' ) UNIT='1101'
       IF( HEX(I:I) .EQ. 'C' .OR. HEX(I:I) .EQ. 'c' ) UNIT='1100'
       IF( HEX(I:I) .EQ. 'B' .OR. HEX(I:I) .EQ. 'b' ) UNIT='1011'
       IF( HEX(I:I) .EQ. 'A' .OR. HEX(I:I) .EQ. 'a' ) UNIT='1010'
       IF( HEX(I:I) .EQ. '9' ) UNIT='1001'
       IF( HEX(I:I) .EQ. '8' ) UNIT='1000'
       IF( HEX(I:I) .EQ. '7' ) UNIT='0111'
       IF( HEX(I:I) .EQ. '6' ) UNIT='0110'
       IF( HEX(I:I) .EQ. '5' ) UNIT='0101'
       IF( HEX(I:I) .EQ. '4' ) UNIT='0100'
       IF( HEX(I:I) .EQ. '3' ) UNIT='0011'
       IF( HEX(I:I) .EQ. '2' ) UNIT='0010'
       IF( HEX(I:I) .EQ. '1' ) UNIT='0001'
       IF( HEX(I:I) .EQ. '0' ) UNIT='0000'
       IF( UNIT .NE. '' ) THEN
         IF( I.EQ.CEND ) BEND=MOD(BITSTR+BITLEN,4)
         BIN(NUM+1:NUM+1+BEND-BBEG)=UNIT(BBEG:BEND)
         NUM=NUM+BEND-BBEG+1
         IF( I.EQ.CBEG ) BBEG=1
       END IF
      END DO
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      REAL*8 FUNCTION RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      IMPLICIT NONE
      CHARACTER HEX*(*)
      INTEGER*4 BITSTR,BITLEN
      REAL*8    SCALE
      INTEGER*4 I,CBEG,CEND,UNIT,SHIFT
      REAL*8 VAL,POWER2
      VAL = 0.D0
      CBEG=INT(BITSTR/4)+1
      CEND=INT((BITSTR+BITLEN-1)/4)+1
      SHIFT=MOD(4-MOD(BITSTR+BITLEN,4),4)
      DO I=CBEG,CEND
       UNIT=16
       IF( HEX(I:I) .EQ. 'F' .OR. HEX(I:I) .EQ. 'f' ) UNIT=15
       IF( HEX(I:I) .EQ. 'E' .OR. HEX(I:I) .EQ. 'e' ) UNIT=14
       IF( HEX(I:I) .EQ. 'D' .OR. HEX(I:I) .EQ. 'd' ) UNIT=13
       IF( HEX(I:I) .EQ. 'C' .OR. HEX(I:I) .EQ. 'c' ) UNIT=12
       IF( HEX(I:I) .EQ. 'B' .OR. HEX(I:I) .EQ. 'b' ) UNIT=11
       IF( HEX(I:I) .EQ. 'A' .OR. HEX(I:I) .EQ. 'a' ) UNIT=10
       IF( HEX(I:I) .EQ. '9' ) UNIT=9
       IF( HEX(I:I) .EQ. '8' ) UNIT=8
       IF( HEX(I:I) .EQ. '7' ) UNIT=7
       IF( HEX(I:I) .EQ. '6' ) UNIT=6
       IF( HEX(I:I) .EQ. '5' ) UNIT=5
       IF( HEX(I:I) .EQ. '4' ) UNIT=4
       IF( HEX(I:I) .EQ. '3' ) UNIT=3
       IF( HEX(I:I) .EQ. '2' ) UNIT=2
       IF( HEX(I:I) .EQ. '1' ) UNIT=1
       IF( HEX(I:I) .EQ. '0' ) UNIT=0
       IF( UNIT .GE. 0 .AND. UNIT .LE. 15 ) THEN
          VAL=VAL*16
          VAL=VAL+UNIT
       END IF
      END DO
      RTCM_HEXTOINT=DMOD(DINT(VAL/POWER2(SHIFT)),POWER2(BITLEN))*SCALE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      REAL*8 FUNCTION RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      IMPLICIT NONE
      CHARACTER HEX*(*)
      INTEGER*4 BITSTR,BITLEN
      REAL*8    SCALE
      INTEGER*4 I,CBEG,CEND,UNIT,SHIFT
      REAL*8 VAL,POWER2
      VAL = 0.D0
      CBEG=INT(BITSTR/4)+1
      CEND=INT((BITSTR+BITLEN-1)/4)+1
      SHIFT=MOD(4-MOD(BITSTR+BITLEN,4),4)
      DO I=CBEG,CEND
       UNIT=16
       IF( HEX(I:I) .EQ. 'F' .OR. HEX(I:I) .EQ. 'f' ) UNIT=15
       IF( HEX(I:I) .EQ. 'E' .OR. HEX(I:I) .EQ. 'e' ) UNIT=14
       IF( HEX(I:I) .EQ. 'D' .OR. HEX(I:I) .EQ. 'd' ) UNIT=13
       IF( HEX(I:I) .EQ. 'C' .OR. HEX(I:I) .EQ. 'c' ) UNIT=12
       IF( HEX(I:I) .EQ. 'B' .OR. HEX(I:I) .EQ. 'b' ) UNIT=11
       IF( HEX(I:I) .EQ. 'A' .OR. HEX(I:I) .EQ. 'a' ) UNIT=10
       IF( HEX(I:I) .EQ. '9' ) UNIT=9
       IF( HEX(I:I) .EQ. '8' ) UNIT=8
       IF( HEX(I:I) .EQ. '7' ) UNIT=7
       IF( HEX(I:I) .EQ. '6' ) UNIT=6
       IF( HEX(I:I) .EQ. '5' ) UNIT=5
       IF( HEX(I:I) .EQ. '4' ) UNIT=4
       IF( HEX(I:I) .EQ. '3' ) UNIT=3
       IF( HEX(I:I) .EQ. '2' ) UNIT=2
       IF( HEX(I:I) .EQ. '1' ) UNIT=1
       IF( HEX(I:I) .EQ. '0' ) UNIT=0
       IF( UNIT .GE. 0 .AND. UNIT .LE. 15 ) THEN
          VAL=VAL*16
          VAL=VAL+UNIT
       END IF
      END DO
      RTCM_HEXTOREAL=DMOD(DINT(VAL/POWER2(SHIFT)),POWER2(BITLEN))
      IF( RTCM_HEXTOREAL .GE. POWER2(BITLEN-1) )
     &  RTCM_HEXTOREAL = RTCM_HEXTOREAL - POWER2(BITLEN)
      RTCM_HEXTOREAL = RTCM_HEXTOREAL * SCALE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      REAL*8 FUNCTION RTCM_HEXTOUREAL( HEX, BITSTR, BITLEN, SCALE )
      IMPLICIT NONE
      CHARACTER HEX*(*)
      INTEGER*4 BITSTR,BITLEN
      REAL*8    SCALE
      INTEGER*4 I,CBEG,CEND,UNIT,SHIFT
      REAL*8 VAL,POWER2
      VAL = 0.D0
      CBEG=INT(BITSTR/4)+1
      CEND=INT((BITSTR+BITLEN-1)/4)+1
      SHIFT=MOD(4-MOD(BITSTR+BITLEN,4),4)
      DO I=CBEG,CEND
       UNIT=16
       IF( HEX(I:I) .EQ. 'F' .OR. HEX(I:I) .EQ. 'f' ) UNIT=15
       IF( HEX(I:I) .EQ. 'E' .OR. HEX(I:I) .EQ. 'e' ) UNIT=14
       IF( HEX(I:I) .EQ. 'D' .OR. HEX(I:I) .EQ. 'd' ) UNIT=13
       IF( HEX(I:I) .EQ. 'C' .OR. HEX(I:I) .EQ. 'c' ) UNIT=12
       IF( HEX(I:I) .EQ. 'B' .OR. HEX(I:I) .EQ. 'b' ) UNIT=11
       IF( HEX(I:I) .EQ. 'A' .OR. HEX(I:I) .EQ. 'a' ) UNIT=10
       IF( HEX(I:I) .EQ. '9' ) UNIT=9
       IF( HEX(I:I) .EQ. '8' ) UNIT=8
       IF( HEX(I:I) .EQ. '7' ) UNIT=7
       IF( HEX(I:I) .EQ. '6' ) UNIT=6
       IF( HEX(I:I) .EQ. '5' ) UNIT=5
       IF( HEX(I:I) .EQ. '4' ) UNIT=4
       IF( HEX(I:I) .EQ. '3' ) UNIT=3
       IF( HEX(I:I) .EQ. '2' ) UNIT=2
       IF( HEX(I:I) .EQ. '1' ) UNIT=1
       IF( HEX(I:I) .EQ. '0' ) UNIT=0
       IF( UNIT .GE. 0 .AND. UNIT .LE. 15 ) THEN
          VAL=VAL*16
          VAL=VAL+UNIT
       END IF
      END DO
      RTCM_HEXTOUREAL=DMOD(DINT(VAL/POWER2(SHIFT)),POWER2(BITLEN))*SCALE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION RTCM_TYPE( HEX )
      IMPLICIT NONE
      CHARACTER HEX*(*)
      REAL*8 RTCM_HEXTOINT
C  Extract
      RTCM_TYPE=DINT(RTCM_HEXTOINT( HEX, 24, 12, 1.D0 ))
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION RTCM_MSGLEN( HEX )
      IMPLICIT NONE
      CHARACTER HEX*(*)
      REAL*8 RTCM_HEXTOINT
C  Extract
      RTCM_MSGLEN=DINT(RTCM_HEXTOINT( HEX, 14, 10, 1.D0 ))
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION RTCM_TIME( HEX )
      IMPLICIT NONE
      CHARACTER HEX*(*)
      REAL*8 RTCM_HEXTOINT
C  Extract
      RTCM_TIME=DINT(RTCM_HEXTOINT( HEX, 36, 20, 1.D0 ))
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION RTCM_IDXINT( HEX )
      IMPLICIT NONE
      CHARACTER HEX*(*)
      REAL*8 RTCM_HEXTOINT
C  Extract
      RTCM_IDXINT=DINT(RTCM_HEXTOINT( HEX, 56, 4, 1.D0 ))
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T1057( TIME, HEX, TYPE, TMSG, MMI, INTV,
     &                                 REFD, REACQD, REFT, IODE, DX,
     &                                 DXDOT, TEND )
      IMPLICIT NONE
C ARGUMENTS
      CHARACTER HEX*(*)
      LOGICAL*4 REACQD(*)
      INTEGER*4 TIME,TYPE,MMI,INTV,REFD,TMSG
      INTEGER*4 IODE(*),TEND(*)
      REAL*8    REFT(*),DX(3,*),DXDOT(3,*)
C LOCAL DECODING VARIABLES
      INTEGER*4 I,BITSTR,BITLEN
      REAL*8 SCALE
C LOCAL READING VARIABLES
      CHARACTER*14 PREAMBLE
      CHARACTER*24 CRC24
      INTEGER*4 MSGLEN,MSGLEN2,UINTV
      INTEGER*4 IODSSR,PROVID,SOLID
      INTEGER*4 IPRN,NSAT,TENDALL
C FUNCTIONS
      INTEGER*4 RTCM_INTV,RTCM_TEND
      REAL*8 RTCM_HEXTOINT,RTCM_HEXTOREAL
C START EXTRACTION; RETURN WHENEVER AN ERROR IS FOUND
      DECODE_T1057=-1
      BITSTR=0
C PREAMBLE&RESERVED
      BITLEN=14
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, PREAMBLE )
      BITSTR=BITSTR+BITLEN
C MSG LENGTH
      BITLEN=10
      SCALE=1.D0
      MSGLEN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C MSG TYPE ; RETURN ERROR IF TYPE IS WRONG
      BITLEN=12
      SCALE=1.D0
      TYPE=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      IF( TYPE .NE. 1057 ) RETURN
C EPOCH TIME
      BITLEN=20
      SCALE=1.D0
      TMSG=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      CALL RTCM_UNROLL( TIME, TMSG )
C UPDATE INTERVAL
      BITLEN=4
      SCALE=1.D0
      UINTV=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      INTV=RTCM_INTV( UINTV )
      TENDALL=RTCM_TEND( TMSG, INTV, 1 )
C MMI
      BITLEN=1
      SCALE=1.D0
      MMI=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C REFERENCE DATUM
      BITLEN=1
      SCALE=1.D0
      REFD=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C IODSSR
      BITLEN=4
      SCALE=1.D0
      IODSSR=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C PROVIDER ID
      BITLEN=16
      SCALE=1.D0
      PROVID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C SOLUTION ID
      BITLEN=4
      SCALE=1.D0
      SOLID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C NSAT ; RETURN ERROR IF MSGLEN AND NSAT DOES NOT CORRESPOND
      BITLEN=6
      SCALE=1.D0
      NSAT=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      MSGLEN2 = DINT((NSAT*135+68)/8.D0)
      IF( MOD(NSAT*135+68,8) .NE. 0 ) MSGLEN2 = MSGLEN2+1
      IF( MSGLEN .NE. MSGLEN2 ) RETURN
C
      DO I=1,NSAT
C PRN
       BITLEN=6
       SCALE=1.D0
       IPRN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       IF( IPRN .LT. 1 .OR. IPRN .GT. 32 ) RETURN
       REACQD(IPRN)=.TRUE.
C REFERENCE TIME
       REFT(IPRN)=TMSG
       IF( INTV .GT. 1 ) REFT(IPRN)=REFT(IPRN)+INTV/2.D0
C IODE
       BITLEN=8
       SCALE=1.D0
       IODE(IPRN)=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C DRAD
       BITLEN=22
       SCALE=1.D-4
       DX(1,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C DALONG
       BITLEN=20
       SCALE=4.D-4
       DX(2,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C DCROSS
       BITLEN=20
       SCALE=4.D-4
       DX(3,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C DRADdot
       BITLEN=21
       SCALE=1.D-6
       DXDOT(1,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C DALONGdot
       BITLEN=19
       SCALE=4.D-6
       DXDOT(2,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C DCROSSdot
       BITLEN=19
       SCALE=4.D-6
       DXDOT(3,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       TEND(IPRN)=TENDALL
      END DO
C ADVANCE FOR BYTE ALIGNMENT
      IF( MOD(BITSTR,8) .NE. 0 ) BITSTR=BITSTR+8-MOD(BITSTR,8)
C CRC24
      BITLEN=24
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, CRC24 )
      BITSTR=BITSTR+BITLEN
C CHECK READ BYTES AGAINST MSGLEN
      IF( BITSTR .EQ. 8*MSGLEN+48 ) DECODE_T1057=0
      RETURN
 100  format(1X,'TYPE:',1X,I04,1X,A)
 200  format(1X,'TYPE:',1X,I04,1X,A30,1X,A14)
 300  format(1X,'TYPE:',1X,I04,1X,A30,1X,I12)
 400  format(1X,'TYPE:',1X,I04,1X,A30,1X,G16.10)
 500  format(1X,'TYPE:',1X,I04,1X,A30,1X,A24)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T1058( TIME, HEX, TYPE, TMSG, MMI, INTV,
     &                                 REACQD, REFT, DCLK, TEND )
      IMPLICIT NONE
C ARGUMENTS
      CHARACTER HEX*(*)
      LOGICAL*4 REACQD(*)
      INTEGER*4 TIME,TYPE,MMI,INTV,TMSG
      INTEGER*4 TEND(*)
      REAL*8    REFT(*),DCLK(3,*)
C LOCAL DECODING VARIABLES
      INTEGER*4 I,BITSTR,BITLEN
      REAL*8 SCALE
C LOCAL READING VARIABLES
      CHARACTER*14 PREAMBLE
      CHARACTER*24 CRC24
      INTEGER*4 MSGLEN,MSGLEN2,UINTV
      INTEGER*4 IODSSR,PROVID,SOLID
      INTEGER*4 IPRN,NSAT,TENDALL
C FUNCTIONS
      INTEGER*4 RTCM_INTV,RTCM_TEND
      REAL*8 RTCM_HEXTOINT,RTCM_HEXTOREAL
C START EXTRACTION; RETURN WHENEVER AN ERROR IS FOUND
      DECODE_T1058=-1
      BITSTR=0
C PREAMBLE&RESERVED
      BITLEN=14
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, PREAMBLE )
      BITSTR=BITSTR+BITLEN
C MSG LENGTH
      BITLEN=10
      SCALE=1.D0
      MSGLEN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C MSG TYPE ; RETURN ERROR IF TYPE IS WRONG
      BITLEN=12
      SCALE=1.D0
      TYPE=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      IF( TYPE .NE. 1058 ) RETURN
C EPOCH TIME
      BITLEN=20
      SCALE=1.D0
      TMSG=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      CALL RTCM_UNROLL( TIME, TMSG )
C UPDATE INTERVAL
      BITLEN=4
      SCALE=1.D0
      UINTV=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      INTV=RTCM_INTV( UINTV )
      TENDALL=RTCM_TEND( TMSG, INTV, 1 )
C MMI
      BITLEN=1
      SCALE=1.D0
      MMI=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C IODSSR
      BITLEN=4
      SCALE=1.D0
      IODSSR=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C PROVIDER ID
      BITLEN=16
      SCALE=1.D0
      PROVID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C SOLUTION ID
      BITLEN=4
      SCALE=1.D0
      SOLID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C NSAT ; RETURN ERROR IF MSGLEN AND NSAT DOES NOT CORRESPOND
      BITLEN=6
      SCALE=1.D0
      NSAT=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      MSGLEN2 = DINT((NSAT*76+67)/8.D0)
      IF( MOD(NSAT*76+67,8) .NE. 0 ) MSGLEN2 = MSGLEN2+1
      IF( MSGLEN .NE. MSGLEN2 ) RETURN
C
      DO I=1,NSAT
C PRN
       BITLEN=6
       SCALE=1.D0
       IPRN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       IF( IPRN .LT. 1 .OR. IPRN .GT. 32 ) RETURN
       REACQD(IPRN)=.TRUE.
C REFERENCE TIME
       REFT(IPRN)=TMSG
       IF( INTV .GT. 1 ) REFT(IPRN)=REFT(IPRN)+INTV/2.D0
C C0
       BITLEN=22
       SCALE=1.D-4
       DCLK(1,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C C1
       BITLEN=21
       SCALE=1.D-6
       DCLK(2,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C C2
       BITLEN=27
       SCALE=2.D-8
       DCLK(3,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       TEND(IPRN)=TENDALL
      END DO
C ADVANCE FOR BYTE ALIGNMENT
      IF( MOD(BITSTR,8) .NE. 0 ) BITSTR=BITSTR+8-MOD(BITSTR,8)
C CRC24
      BITLEN=24
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, CRC24 )
      BITSTR=BITSTR+BITLEN
C CHECK READ BYTES AGAINST MSGLEN
      IF( BITSTR .EQ. 8*MSGLEN+48 ) DECODE_T1058=0
      RETURN
 100  format(1X,'TYPE:',1X,I04,1X,A)
 200  format(1X,'TYPE:',1X,I04,1X,A30,1X,A14)
 300  format(1X,'TYPE:',1X,I04,1X,A30,1X,I12)
 400  format(1X,'TYPE:',1X,I04,1X,A30,1X,G16.10)
 500  format(1X,'TYPE:',1X,I04,1X,A30,1X,A24)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T1059( TIME, HEX, TYPE, TMSG, MMI, INTV,
     &                                 REACQD, ITRKFLG, CDBIAS, TEND )
      IMPLICIT NONE
C ARGUMENTS
      CHARACTER HEX*(*)
      LOGICAL*4 REACQD(*),ITRKFLG(32,*)
      INTEGER*4 TIME,TYPE,MMI,INTV,TMSG
      INTEGER*4 TEND(*)
      REAL*8    CDBIAS(32,*)
C LOCAL DECODING VARIABLES
      INTEGER*4 I,J,BITSTR,BITLEN,MSGLEN2
      REAL*8 SCALE
C LOCAL READING VARIABLES
      CHARACTER*14 PREAMBLE
      CHARACTER*24 CRC24
      INTEGER*4 MSGLEN,UINTV
      INTEGER*4 IODSSR,PROVID,SOLID
      INTEGER*4 IPRN,NSAT,NBIAS,TRKIND,TENDALL
C FUNCTIONS
      INTEGER*4 RTCM_INTV,RTCM_TEND
      REAL*8 RTCM_HEXTOINT,RTCM_HEXTOREAL
C START EXTRACTION; RETURN WHENEVER AN ERROR IS FOUND
      DECODE_T1059=-1
      BITSTR=0
C PREAMBLE&RESERVED
      BITLEN=14
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, PREAMBLE )
      BITSTR=BITSTR+BITLEN
C MSG LENGTH
      BITLEN=10
      SCALE=1.D0
      MSGLEN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C MSG TYPE ; RETURN ERROR IF TYPE IS WRONG
      BITLEN=12
      SCALE=1.D0
      TYPE=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      IF( TYPE .NE. 1059 ) RETURN
C EPOCH TIME
      BITLEN=20
      SCALE=1.D0
      TMSG=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      CALL RTCM_UNROLL( TIME, TMSG )
C UPDATE INTERVAL
      BITLEN=4
      SCALE=1.D0
      UINTV=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      INTV=RTCM_INTV( UINTV )
      TENDALL=RTCM_TEND( TMSG, INTV, 1 )
C MMI
      BITLEN=1
      SCALE=1.D0
      MMI=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C IODSSR
      BITLEN=4
      SCALE=1.D0
      IODSSR=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C PROVIDER ID
      BITLEN=16
      SCALE=1.D0
      PROVID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C SOLUTION ID
      BITLEN=4
      SCALE=1.D0
      SOLID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C NSAT ; RETURN ERROR IF MSGLEN AND NSAT DOES NOT CORRESPOND
      BITLEN=6
      SCALE=1.D0
      NSAT=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      MSGLEN2 = 67+NSAT*11
C
      DO I=1,NSAT
C PRN
       BITLEN=6
       SCALE=1.D0
       IPRN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       IF( IPRN .LT. 1 .OR. IPRN .GT. 32 ) RETURN
       REACQD(IPRN)=.TRUE.
C NBIAS
       BITLEN=5
       SCALE=1.D0
       NBIAS=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       MSGLEN2=MSGLEN2+NBIAS*19
C
       DO J=1,NBIAS
C TRKIND
        BITLEN=5
        SCALE=1.D0
        TRKIND=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
        BITSTR=BITSTR+BITLEN
        IF( TRKIND .LT. 0 .OR. TRKIND .GT. 31 ) RETURN
        ITRKFLG(TRKIND+1,IPRN)=.TRUE.
C BIAS
        BITLEN=14
        SCALE=1.D-2
        CDBIAS(TRKIND+1,IPRN)=
     &       RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
        BITSTR=BITSTR+BITLEN
       END DO
       TEND(IPRN)=TENDALL
      END DO
      IF( MOD(MSGLEN2,8) .NE. 0 ) THEN
        MSGLEN2 = DINT(MSGLEN2/8.D0)+1
      ELSE
        MSGLEN2 = DINT(MSGLEN2/8.D0)
      ENDIF
      IF( MSGLEN .NE. MSGLEN2 ) RETURN
C ADVANCE FOR BYTE ALIGNMENT
      IF( MOD(BITSTR,8) .NE. 0 ) BITSTR=BITSTR+8-MOD(BITSTR,8)
C CRC24
      BITLEN=24
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, CRC24 )
      BITSTR=BITSTR+BITLEN
C CHECK READ BYTES AGAINST MSGLEN
      IF( BITSTR .EQ. 8*MSGLEN+48 ) DECODE_T1059=0
      RETURN
 100  format(1X,'TYPE:',1X,I04,1X,A)
 200  format(1X,'TYPE:',1X,I04,1X,A30,1X,A14)
 300  format(1X,'TYPE:',1X,I04,1X,A30,1X,I12)
 400  format(1X,'TYPE:',1X,I04,1X,A30,1X,G16.10)
 500  format(1X,'TYPE:',1X,I04,1X,A30,1X,A24)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T1060( TIME, HEX, TYPE, TMSG, MMI, INTV,
     &                                 REFD, REACQD, REFT, IODE, DX,
     &                                 DXDOT, DCLK, TEND )
      IMPLICIT NONE
C ARGUMENTS
      CHARACTER HEX*(*)
      LOGICAL*4 REACQD(*)
      INTEGER*4 TIME,TYPE,MMI,INTV,REFD,TMSG
      INTEGER*4 IODE(*),TEND(*)
      REAL*8    REFT(*),DX(3,*),DXDOT(3,*),DCLK(3,*)
C LOCAL DECODING VARIABLES
      INTEGER*4 I,BITSTR,BITLEN
      REAL*8 SCALE
C LOCAL READING VARIABLES
      CHARACTER*14 PREAMBLE
      CHARACTER*24 CRC24
      INTEGER*4 MSGLEN,MSGLEN2,UINTV
      INTEGER*4 IODSSR,PROVID,SOLID
      INTEGER*4 IPRN,NSAT,TENDALL
C FUNCTIONS
      INTEGER*4 RTCM_INTV,RTCM_TEND
      REAL*8 RTCM_HEXTOINT,RTCM_HEXTOREAL
C START EXTRACTION; RETURN WHENEVER AN ERROR IS FOUND
      DECODE_T1060=-1
      BITSTR=0
C PREAMBLE&RESERVED
      BITLEN=14
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, PREAMBLE )
      BITSTR=BITSTR+BITLEN
C MSG LENGTH
      BITLEN=10
      SCALE=1.D0
      MSGLEN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C MSG TYPE ; RETURN ERROR IF TYPE IS WRONG
      BITLEN=12
      SCALE=1.D0
      TYPE=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      IF( TYPE .NE. 1060 ) RETURN
C EPOCH TIME
      BITLEN=20
      SCALE=1.D0
      TMSG=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      CALL RTCM_UNROLL( TIME, TMSG )
C UPDATE INTERVAL
      BITLEN=4
      SCALE=1.D0
      UINTV=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      INTV=RTCM_INTV( UINTV )
      TENDALL=RTCM_TEND( TMSG, INTV, 1 )
C MMI
      BITLEN=1
      SCALE=1.D0
      MMI=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C REFERENCE DATUM
      BITLEN=1
      SCALE=1.D0
      REFD=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C IODSSR
      BITLEN=4
      SCALE=1.D0
      IODSSR=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C PROVIDER ID
      BITLEN=16
      SCALE=1.D0
      PROVID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C SOLUTION ID
      BITLEN=4
      SCALE=1.D0
      SOLID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C NSAT ; RETURN ERROR IF MSGLEN AND NSAT DOES NOT CORRESPOND
      BITLEN=6
      SCALE=1.D0
      NSAT=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      MSGLEN2 = DINT((NSAT*205+68)/8.D0)
      IF( MOD(NSAT*205+68,8) .NE. 0 ) MSGLEN2 = MSGLEN2+1
      IF( MSGLEN .NE. MSGLEN2 ) RETURN
C
      DO I=1,NSAT
C PRN
       BITLEN=6
       SCALE=1.D0
       IPRN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       IF( IPRN .LT. 1 .OR. IPRN .GT. 32 ) RETURN
       REACQD(IPRN)=.TRUE.
C REFERENCE TIME
       REFT(IPRN)=TMSG
       IF( INTV .GT. 1 ) REFT(IPRN)=REFT(IPRN)+INTV/2.D0
C IODE
       BITLEN=8
       SCALE=1.D0
       IODE(IPRN)=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C DRAD
       BITLEN=22
       SCALE=1.D-4
       DX(1,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C DALONG
       BITLEN=20
       SCALE=4.D-4
       DX(2,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C DCROSS
       BITLEN=20
       SCALE=4.D-4
       DX(3,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C DRADdot
       BITLEN=21
       SCALE=1.D-6
       DXDOT(1,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C DALONGdot
       BITLEN=19
       SCALE=4.D-6
       DXDOT(2,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C DCROSSdot
       BITLEN=19
       SCALE=4.D-6
       DXDOT(3,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C C0
       BITLEN=22
       SCALE=1.D-4
       DCLK(1,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C C1
       BITLEN=21
       SCALE=1.D-6
       DCLK(2,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C C2
       BITLEN=27
       SCALE=2.D-8
       DCLK(3,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       TEND(IPRN)=TENDALL
      END DO
C ADVANCE FOR BYTE ALIGNMENT
      IF( MOD(BITSTR,8) .NE. 0 ) BITSTR=BITSTR+8-MOD(BITSTR,8)
C CRC24
      BITLEN=24
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, CRC24 )
      BITSTR=BITSTR+BITLEN
C CHECK READ BYTES AGAINST MSGLEN
      IF( BITSTR .EQ. 8*MSGLEN+48 ) DECODE_T1060=0
      RETURN
 100  format(1X,'TYPE:',1X,I04,1X,A)
 200  format(1X,'TYPE:',1X,I04,1X,A30,1X,A14)
 300  format(1X,'TYPE:',1X,I04,1X,A30,1X,I12)
 400  format(1X,'TYPE:',1X,I04,1X,A30,1X,G16.10)
 500  format(1X,'TYPE:',1X,I04,1X,A30,1X,A24)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T1061( TIME, HEX, TYPE, TMSG, MMI, INTV,
     &                                 REACQD, URA, ACC, TEND )
      IMPLICIT NONE
C ARGUMENTS
      CHARACTER HEX*(*)
      LOGICAL*4 REACQD(*)
      INTEGER*4 TIME,TYPE,MMI,INTV,TMSG
      INTEGER*4 URA(*),TEND(*)
      REAL*8    ACC(*)
C LOCAL DECODING VARIABLES
      INTEGER*4 I,BITSTR,BITLEN
      REAL*8 SCALE
C LOCAL READING VARIABLES
      CHARACTER*14 PREAMBLE
      CHARACTER*24 CRC24
      INTEGER*4 MSGLEN,MSGLEN2,UINTV
      INTEGER*4 IODSSR,PROVID,SOLID
      INTEGER*4 IPRN,NSAT,TENDALL
C FUNCTIONS
      INTEGER*4 RTCM_INTV,RTCM_TEND
      REAL*8 RTCM_HEXTOINT,RTCM_ACC
C START EXTRACTION; RETURN WHENEVER AN ERROR IS FOUND
      DECODE_T1061=-1
      BITSTR=0
C PREAMBLE&RESERVED
      BITLEN=14
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, PREAMBLE )
      BITSTR=BITSTR+BITLEN
C MSG LENGTH
      BITLEN=10
      SCALE=1.D0
      MSGLEN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C MSG TYPE ; RETURN ERROR IF TYPE IS WRONG
      BITLEN=12
      SCALE=1.D0
      TYPE=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      IF( TYPE .NE. 1061 ) RETURN
C EPOCH TIME
      BITLEN=20
      SCALE=1.D0
      TMSG=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      CALL RTCM_UNROLL( TIME, TMSG )
C UPDATE INTERVAL
      BITLEN=4
      SCALE=1.D0
      UINTV=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      INTV=RTCM_INTV( UINTV )
      TENDALL=RTCM_TEND( TMSG, INTV, 1 )
C MMI
      BITLEN=1
      SCALE=1.D0
      MMI=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C IODSSR
      BITLEN=4
      SCALE=1.D0
      IODSSR=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C PROVIDER ID
      BITLEN=16
      SCALE=1.D0
      PROVID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C SOLUTION ID
      BITLEN=4
      SCALE=1.D0
      SOLID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C NSAT ; RETURN ERROR IF MSGLEN AND NSAT DOES NOT CORRESPOND
      BITLEN=6
      SCALE=1.D0
      NSAT=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      MSGLEN2 = DINT((NSAT*12+67)/8.D0)
      IF( MOD(NSAT*12+67,8) .NE. 0 ) MSGLEN2 = MSGLEN2+1
      IF( MSGLEN .NE. MSGLEN2 ) RETURN
C
      DO I=1,NSAT
C PRN
       BITLEN=6
       SCALE=1.D0
       IPRN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       IF( IPRN .LT. 1 .OR. IPRN .GT. 32 ) RETURN
       REACQD(IPRN)=.TRUE.
C URA
       BITLEN=6
       SCALE=1.D0
       URA(IPRN)=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       ACC(IPRN)=RTCM_ACC( URA(IPRN) )
       TEND(IPRN)=TENDALL
      END DO
C ADVANCE FOR BYTE ALIGNMENT
      IF( MOD(BITSTR,8) .NE. 0 ) BITSTR=BITSTR+8-MOD(BITSTR,8)
C CRC24
      BITLEN=24
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, CRC24 )
      BITSTR=BITSTR+BITLEN
C CHECK READ BYTES AGAINST MSGLEN
      IF( BITSTR .EQ. 8*MSGLEN+48 ) DECODE_T1061=0
      RETURN
 100  format(1X,'TYPE:',1X,I04,1X,A)
 200  format(1X,'TYPE:',1X,I04,1X,A30,1X,A14)
 300  format(1X,'TYPE:',1X,I04,1X,A30,1X,I12)
 400  format(1X,'TYPE:',1X,I04,1X,A30,1X,G16.10)
 500  format(1X,'TYPE:',1X,I04,1X,A30,1X,A24)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T1062( TIME, HEX, TYPE, TMSG, MMI, INTV,
     &                                 REACQD, FAST, TEND )
      IMPLICIT NONE
C ARGUMENTS
      CHARACTER HEX*(*)
      LOGICAL*4 REACQD(*)
      INTEGER*4 TIME,TYPE,MMI,INTV,TMSG
      INTEGER*4 TEND(*)
      REAL*8    FAST(*)
C LOCAL DECODING VARIABLES
      INTEGER*4 I,BITSTR,BITLEN,MSGLEN2
      REAL*8 SCALE
C LOCAL READING VARIABLES
      CHARACTER*14 PREAMBLE
      CHARACTER*24 CRC24
      INTEGER*4 MSGLEN,UINTV
      INTEGER*4 IODSSR,PROVID,SOLID
      INTEGER*4 IPRN,NSAT,TENDALL
C FUNCTIONS
      INTEGER*4 RTCM_INTV,RTCM_TEND
      REAL*8 RTCM_HEXTOINT,RTCM_HEXTOREAL
C START EXTRACTION; RETURN WHENEVER AN ERROR IS FOUND
      DECODE_T1062=-1
      BITSTR=0
C PREAMBLE&RESERVED
      BITLEN=14
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, PREAMBLE )
      BITSTR=BITSTR+BITLEN
C MSG LENGTH
      BITLEN=10
      SCALE=1.D0
      MSGLEN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C MSG TYPE ; RETURN ERROR IF TYPE IS WRONG
      BITLEN=12
      SCALE=1.D0
      TYPE=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      IF( TYPE .NE. 1062 ) RETURN
C EPOCH TIME
      BITLEN=20
      SCALE=1.D0
      TMSG=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      CALL RTCM_UNROLL( TIME, TMSG )
C UPDATE INTERVAL
      BITLEN=4
      SCALE=1.D0
      UINTV=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      INTV=RTCM_INTV( UINTV )
      TENDALL=RTCM_TEND( TMSG, INTV, 1 )
C MMI
      BITLEN=1
      SCALE=1.D0
      MMI=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C IODSSR
      BITLEN=4
      SCALE=1.D0
      IODSSR=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C PROVIDER ID
      BITLEN=16
      SCALE=1.D0
      PROVID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C SOLUTION ID
      BITLEN=4
      SCALE=1.D0
      SOLID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C NSAT ; RETURN ERROR IF MSGLEN AND NSAT DOES NOT CORRESPOND
      BITLEN=6
      SCALE=1.D0
      NSAT=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      MSGLEN2 = DINT((NSAT*28+67)/8.D0)
      IF( MOD(NSAT*28+67,8) .NE. 0 ) MSGLEN2 = MSGLEN2+1
      IF( MSGLEN .NE. MSGLEN2 ) RETURN
C
      DO I=1,NSAT
C PRN
       BITLEN=6
       SCALE=1.D0
       IPRN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       IF( IPRN .LT. 1 .OR. IPRN .GT. 32 ) RETURN
       REACQD(IPRN)=.TRUE.
C FAST
       BITLEN=22
       SCALE=1.D-4
       FAST(IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       TEND(IPRN)=TENDALL
      END DO
C ADVANCE FOR BYTE ALIGNMENT
      IF( MOD(BITSTR,8) .NE. 0 ) BITSTR=BITSTR+8-MOD(BITSTR,8)
C CRC24
      BITLEN=24
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, CRC24 )
      BITSTR=BITSTR+BITLEN
C CHECK READ BYTES AGAINST MSGLEN
      IF( BITSTR .EQ. 8*MSGLEN+48 ) DECODE_T1062=0
      RETURN
 100  format(1X,'TYPE:',1X,I04,1X,A)
 200  format(1X,'TYPE:',1X,I04,1X,A30,1X,A14)
 300  format(1X,'TYPE:',1X,I04,1X,A30,1X,I12)
 400  format(1X,'TYPE:',1X,I04,1X,A30,1X,G16.10)
 500  format(1X,'TYPE:',1X,I04,1X,A30,1X,A24)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T1264( TIME, HEX, TYPE, TMSG, MMI, INTV,
     &                                 REACQD, REFT, NSETS, DEGREE,
     &                                 ORDER, VTECRMS, HEIGHT, CNM, SNM,
     &                                 TEND )
C
      IMPLICIT NONE
C ARGUMENTS
      CHARACTER HEX*(*)
      LOGICAL*4 REACQD
      INTEGER*4 TIME,TYPE,MMI,INTV,TMSG
      INTEGER*4 NSETS, DEGREE(*), ORDER(*), TEND
      REAL*8    REFT, VTECRMS, HEIGHT(*), CNM(153,*), SNM(153,*)
C LOCAL DECODING VARIABLES
      INTEGER*4 I,N,M,BITSTR,BITLEN
      REAL*8 SCALE
C LOCAL READING VARIABLES
      CHARACTER*14 PREAMBLE
      CHARACTER*24 CRC24
      INTEGER*4 MSGLEN,MSGLEN2,UINTV
      INTEGER*4 IODSSR,PROVID,SOLID
      INTEGER*4 TENDALL
C FUNCTIONS
      INTEGER*4 RTCM_INTV,RTCM_TEND
      REAL*8 RTCM_HEXTOINT,RTCM_HEXTOREAL,RTCM_HEXTOUREAL
C
C START EXTRACTION; RETURN WHENEVER AN ERROR IS FOUND
      DECODE_T1264=-1
      BITSTR=0
C PREAMBLE&RESERVED
      BITLEN=14
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, PREAMBLE )
      BITSTR=BITSTR+BITLEN
C MSG LENGTH
      BITLEN=10
      SCALE=1.D0
      MSGLEN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C MSG TYPE ; RETURN ERROR IF TYPE IS WRONG
      BITLEN=12
      SCALE=1.D0
      TYPE=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      IF( TYPE .NE. 1264 ) RETURN
C EPOCH TIME
      BITLEN=20
      SCALE=1.D0
      TMSG=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      CALL RTCM_UNROLL( TIME, TMSG )
C UPDATE INTERVAL
      BITLEN=4
      SCALE=1.D0
      UINTV=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      INTV=RTCM_INTV( UINTV )
      TENDALL=RTCM_TEND( TMSG, INTV, 1 )
C REFERENCE TIME
      REFT=TMSG
      TEND=TENDALL
C MMI
      BITLEN=1
      SCALE=1.D0
      MMI=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C IODSSR
      BITLEN=4
      SCALE=1.D0
      IODSSR=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C PROVIDER ID
      BITLEN=16
      SCALE=1.D0
      PROVID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C SOLUTION ID
      BITLEN=4
      SCALE=1.D0
      SOLID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C VTEC RMS
       BITLEN=9
       SCALE=5.D-2
       VTECRMS=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C NSETS
      BITLEN=2
      SCALE=1.D0
      NSETS=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      NSETS=NSETS+1
C
C SET MSGLEN2 TO HEADER SIZE = 9BYTES = 72BITS
      MSGLEN2=72
      DO I=1,NSETS
C HEIGHT
       BITLEN=8
       SCALE=1.D1
       HEIGHT(I)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C DEGREE
       BITLEN=4
       SCALE=1.D0
       DEGREE(I)=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       DEGREE(I)=DEGREE(I)+1
C ORDER
       BITLEN=4
       SCALE=1.D0
       ORDER(I)=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       ORDER(I)=ORDER(I)+1
C CHECK MESSAGE LENGHT
       MSGLEN2=MSGLEN2+
     +        16*(1+(DEGREE(I)+1)*(DEGREE(I)+1) -
     +            (DEGREE(I)-ORDER(I))*(DEGREE(I)-ORDER(I)+1))
       IF( MSGLEN2/8 .GT. MSGLEN ) RETURN
C CNM COEFFICIENTS
       DO M=0,ORDER(I)
       DO N=M,DEGREE(I)
        BITLEN=16
        SCALE=5.D-3
        CNM(1+M+N*(N+1)/2,I)=
     +      RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
        BITSTR=BITSTR+BITLEN
       END DO
       END DO
C SNM COEFFICIENTS
       DO M=1,ORDER(I)
       DO N=M,DEGREE(I)
        BITLEN=16
        SCALE=5.D-3
        SNM(1+M+N*(N+1)/2,I)=
     +      RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
        BITSTR=BITSTR+BITLEN
       END DO
       END DO
       DO N=0,DEGREE(I)
        SNM(1+N*(N+1)/2,I)=0.D0
       END DO
      END DO
C ADVANCE FOR BYTE ALIGNMENT
      IF( MOD(BITSTR,8) .NE. 0 ) BITSTR=BITSTR+8-MOD(BITSTR,8)
C CRC24
      BITLEN=24
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, CRC24 )
      BITSTR=BITSTR+BITLEN
C CHECK READ BYTES AGAINST MSGLEN
      IF( BITSTR .EQ. 8*MSGLEN+48 ) DECODE_T1264=0
      RETURN
 100  format(1X,'TYPE:',1X,I04,1X,A)
 200  format(1X,'TYPE:',1X,I04,1X,A30,1X,A14)
 300  format(1X,'TYPE:',1X,I04,1X,A30,1X,I12)
 400  format(1X,'TYPE:',1X,I04,1X,A30,1X,G16.10)
 500  format(1X,'TYPE:',1X,I04,1X,A30,1X,A24)
 600  format(1X,'TYPE:',1X,I04,1X,A30,1X,3I5)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T1265( TIME, HEX, TYPE, TMSG, MMI, INTV,
     &                                 REACQD, REFT, YAW, ITRKFLG,
     &                                 DISCNT, PHBIAS, TEND )
      IMPLICIT NONE
C ARGUMENTS
      CHARACTER HEX*(*)
      LOGICAL*4 REACQD(*),ITRKFLG(32,*)
      INTEGER*4 TIME,TYPE,MMI,INTV,TMSG
      INTEGER*4 TEND(*),DISCNT(32,*)
      REAL*8    REFT(*),YAW(2,*)
      REAL*8    PHBIAS(32,*)
C LOCAL DECODING VARIABLES
      INTEGER*4 I,J,BITSTR,BITLEN
      REAL*8 SCALE
C LOCAL READING VARIABLES
      CHARACTER*14 PREAMBLE
      CHARACTER*24 CRC24
      INTEGER*4 MSGLEN,MSGLEN2,UINTV
      INTEGER*4 IODSSR,PROVID,SOLID
      INTEGER*4 IPRN,NSAT,NBIAS,TENDALL,TRKIND
      REAL*8    PI
C FUNCTIONS
      INTEGER*4 RTCM_INTV,RTCM_TEND
      REAL*8 RTCM_HEXTOINT,RTCM_HEXTOREAL,RTCM_HEXTOUREAL
C
      DATA PI / 3.1415926535898D0/
C
C START EXTRACTION; RETURN WHENEVER AN ERROR IS FOUND
      DECODE_T1265=-1
      BITSTR=0
C PREAMBLE&RESERVED
      BITLEN=14
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, PREAMBLE )
      BITSTR=BITSTR+BITLEN
C MSG LENGTH
      BITLEN=10
      SCALE=1.D0
      MSGLEN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C MSG TYPE ; RETURN ERROR IF TYPE IS WRONG
      BITLEN=12
      SCALE=1.D0
      TYPE=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      IF( TYPE .NE. 1265 ) RETURN
C EPOCH TIME
      BITLEN=20
      SCALE=1.D0
      TMSG=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      CALL RTCM_UNROLL( TIME, TMSG )
C UPDATE INTERVAL
      BITLEN=4
      SCALE=1.D0
      UINTV=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      INTV=RTCM_INTV( UINTV )
      IF( INTV .GT. 1 ) THEN
       TENDALL=RTCM_TEND( TMSG, INTV, 2 )
      ELSE
       TENDALL=RTCM_TEND( TMSG, INTV, 1 )
      ENDIF
C MMI
      BITLEN=1
      SCALE=1.D0
      MMI=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C IODSSR
      BITLEN=4
      SCALE=1.D0
      IODSSR=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C PROVIDER ID
      BITLEN=16
      SCALE=1.D0
      PROVID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C SOLUTION ID
      BITLEN=4
      SCALE=1.D0
      SOLID=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C DISPERSIVE BIAS CONSISTENCY: SKIPPED
      BITLEN=1
      BITSTR=BITSTR+BITLEN
C NL/WL BIAS CONSISTENCY: SKIPPED
      BITLEN=1
      BITSTR=BITSTR+BITLEN
C NSAT ; RETURN ERROR IF MSGLEN AND NSAT DOES NOT CORRESPOND
      BITLEN=6
      SCALE=1.D0
      NSAT=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      MSGLEN2 = 69+NSAT*28
C
      DO I=1,NSAT
C PRN
       BITLEN=6
       SCALE=1.D0
       IPRN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       IF( IPRN .LT. 1 .OR. IPRN .GT. 32 ) RETURN
       REACQD(IPRN)=.TRUE.
C REFERENCE TIME
       REFT(IPRN)=TMSG
C NUMBER OF PHASE BIASES (SHOULD BE ZERO)
       BITLEN=5
       SCALE=1.D0
       NBIAS=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C YAW ANGLE
       BITLEN=9
       SCALE=PI/256D0
       YAW(1,IPRN)=RTCM_HEXTOUREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
C YAW RATE
       BITLEN=8
       SCALE=PI/8192.D0
       YAW(2,IPRN)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
       BITSTR=BITSTR+BITLEN
       MSGLEN2=MSGLEN2+NBIAS*32
       DO J=1,NBIAS
C TRKIND
        BITLEN=5
        SCALE=1.D0
        TRKIND=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
        BITSTR=BITSTR+BITLEN
        IF( TRKIND .LT. 0 .OR. TRKIND .GT. 31 ) RETURN
        ITRKFLG(TRKIND+1,IPRN)=.TRUE.
C SignalInteger: SKIPPED
        BITLEN=1
        BITSTR=BITSTR+BITLEN
C WidelnInteger: SKIPPED
        BITLEN=2
        BITSTR=BITSTR+BITLEN
C DiscontinuityCounter
        BITLEN=4
        SCALE=1.D0
        DISCNT(TRKIND+1,IPRN)=
     &       RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
        BITSTR=BITSTR+BITLEN
C BIAS
        BITLEN=20
        SCALE=1.D-4
        PHBIAS(TRKIND+1,IPRN)=
     &       RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
        BITSTR=BITSTR+BITLEN
       END DO
       TEND(IPRN)=TENDALL
      END DO
      IF( MOD(MSGLEN2,8) .NE. 0 ) THEN
        MSGLEN2 = DINT(MSGLEN2/8.D0)+1
      ELSE
        MSGLEN2 = DINT(MSGLEN2/8.D0)
      ENDIF
      IF( MSGLEN .NE. MSGLEN2 ) RETURN
C ADVANCE FOR BYTE ALIGNMENT
      IF( MOD(BITSTR,8) .NE. 0 ) BITSTR=BITSTR+8-MOD(BITSTR,8)
C CRC24
      BITLEN=24
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, CRC24 )
      BITSTR=BITSTR+BITLEN
C CHECK READ BYTES AGAINST MSGLEN
      IF( BITSTR .EQ. 8*MSGLEN+48 ) DECODE_T1265=0
      RETURN
 100  format(1X,'TYPE:',1X,I04,1X,A)
 200  format(1X,'TYPE:',1X,I04,1X,A30,1X,A14)
 300  format(1X,'TYPE:',1X,I04,1X,A30,1X,I12)
 400  format(1X,'TYPE:',1X,I04,1X,A30,1X,G16.10)
 500  format(1X,'TYPE:',1X,I04,1X,A30,1X,A24)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION DECODE_T1019( TIME, HEX, TYPE, IPRN, EPH )
      IMPLICIT NONE
C ARGUMENTS
      CHARACTER HEX*(*)
      INTEGER*4 TIME,TYPE,IPRN
      REAL*8    EPH(*)
C LOCAL DECODING VARIABLES
      CHARACTER*14 PREAMBLE
      CHARACTER*24 CRC24
      INTEGER*4 I,BITSTR,BITLEN
      REAL*8 SCALE,PI
C LOCAL READING VARIABLES
      INTEGER*4 MSGLEN,MSGLEN2,SVACC
C FUNCTIONS
      REAL*8 POWER2,RTCM_HEXTOINT,RTCM_HEXTOREAL,RTCM_HEXTOUREAL
C
      DATA PI / 3.1415926535898D0/
C START EXTRACTION; RETURN WHENEVER AN ERROR IS FOUND
      DECODE_T1019=-1
      BITSTR=0
C PREAMBLE&RESERVED
      BITLEN=14
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, PREAMBLE )
      BITSTR=BITSTR+BITLEN
C MSG LENGTH
      BITLEN=10
      SCALE=1.D0
      MSGLEN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C MSG TYPE ; RETURN ERROR IF TYPE IS WRONG
      BITLEN=12
      SCALE=1.D0
      TYPE=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      IF( TYPE .NE. 1019 ) RETURN
C PRN
      BITLEN=6
      SCALE=1.D0
      IPRN=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      EPH(1)=IPRN
      IF( IPRN .LT. 1 .AND. IPRN .GT. 32 ) RETURN
C WEEK
      BITLEN=10
      SCALE=1.D0
      EPH(2)=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      IF( EPH(2) .LT. 1024.D0 ) THEN
       EPH(2) = EPH(2) + 1024.D0*DINT(DBLE(TIME)/604800D0/1024.D0)
      END IF
C SVACC
      BITLEN=4
      SCALE=1.D0
      SVACC=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      IF( SVACC .LE. 6 ) EPH(4)=POWER2(1+SVACC/2)
      IF( SVACC .GT. 6 ) EPH(4)=POWER2(SVACC-2)
C L2 CODE
      BITLEN=2
      SCALE=1.D0
      EPH(3)=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C IDOT
      BITLEN=14
      SCALE=POWER2(-43)*PI
      EPH(30)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C IODE
      BITLEN=8
      SCALE=1.D0
      EPH(12)=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C TOC
      BITLEN=16
      SCALE=16
      EPH(8)=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C AF2
      BITLEN=8
      SCALE=POWER2(-55)
      EPH(9)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C AF1
      BITLEN=16
      SCALE=POWER2(-43)
      EPH(10)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C AF0
      BITLEN=22
      SCALE=POWER2(-31)
      EPH(11)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C IODC
      BITLEN=10
      SCALE=1.D0
      EPH(7)=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C CRS
      BITLEN=16
      SCALE=POWER2(-5)
      EPH(13)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C DELTAN
      BITLEN=16
      SCALE=POWER2(-43)*PI
      EPH(14)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C M0
      BITLEN=32
      SCALE=POWER2(-31)*PI
      EPH(15)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C CUC
      BITLEN=16
      SCALE=POWER2(-29)
      EPH(16)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C ECC
      BITLEN=32
      SCALE=POWER2(-33)
      EPH(17)=RTCM_HEXTOUREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C CUS
      BITLEN=16
      SCALE=POWER2(-29)
      EPH(18)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C SQRTA
      BITLEN=32
      SCALE=POWER2(-19)
      EPH(19)=RTCM_HEXTOUREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C TOE
      BITLEN=16
      SCALE=16
      EPH(20)=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      IF( TIME - EPH(2)*604800.D0 - EPH(20) .GT. 302400D0 ) THEN
       EPH(2) = EPH(2) + 1.D0
      ENDIF
C CIC
      BITLEN=16
      SCALE=POWER2(-29)
      EPH(22)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C OMEGA0
      BITLEN=32
      SCALE=POWER2(-31)*PI
      EPH(23)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C CIS
      BITLEN=16
      SCALE=POWER2(-29)
      EPH(24)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C I0
      BITLEN=32
      SCALE=POWER2(-31)*PI
      EPH(25)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C CRC
      BITLEN=16
      SCALE=POWER2(-5)
      EPH(26)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C ARGPER
      BITLEN=32
      SCALE=POWER2(-31)*PI
      EPH(27)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C OMEGADOT
      BITLEN=24
      SCALE=POWER2(-43)*PI
      EPH(28)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C TGD
      BITLEN=8
      SCALE=POWER2(-31)*1.e9
      EPH(6)=RTCM_HEXTOREAL( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C HEALTH
      BITLEN=6
      SCALE=1.D0
      EPH(5)=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C L2_P
      BITLEN=1
      SCALE=256
      EPH(3)=EPH(3)+RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
C FITINT
      BITLEN=1
      SCALE=1.D0
      EPH(21)=RTCM_HEXTOINT( HEX, BITSTR, BITLEN, SCALE )
      BITSTR=BITSTR+BITLEN
      IF( EPH(12) .LT. 240.D0 ) THEN
       IF( EPH(21) .EQ. 0 ) EPH(21) = 4.D0
       IF( EPH(21) .EQ. 1 ) EPH(21) = 6.D0
      ELSE IF ( EPH(7) .LT. 248.D0 ) THEN
       EPH(21) = 8.D0
      ELSE IF ( EPH(7) .LT. 497.D0 ) THEN
       EPH(21) = 14.D0
      ELSE IF ( EPH(7) .LT. 504.D0 ) THEN
       EPH(21) = 26.D0
      ELSE IF ( EPH(7) .LT. 511.D0 ) THEN
       EPH(21) = 50.D0
      ELSE IF ( EPH(7) .LT. 757.D0 ) THEN
       EPH(21) = 74.D0
      ELSE IF ( EPH(7) .LT. 764.D0 ) THEN
       EPH(21) = 98.D0
      ELSE IF ( EPH(7) .LT. 1011.D0 ) THEN
       EPH(21) = 122.D0
      ELSE IF ( EPH(7) .LT. 1021.D0 ) THEN
       EPH(21) = 146.D0
      ENDIF
C ADVANCE FOR BYTE ALIGNMENT
      IF( MOD(BITSTR,8) .NE. 0 ) BITSTR=BITSTR+8-MOD(BITSTR,8)
C CRC24
      BITLEN=24
      SCALE=1.D0
      CALL RTCM_HEXTOBIT( HEX, BITSTR, BITLEN, CRC24 )
      BITSTR=BITSTR+BITLEN
C CHECK READ BYTES AGAINST MSGLEN
      IF( BITSTR .EQ. 8*MSGLEN+48 ) DECODE_T1019=0
      RETURN
 100  format(1X,'TYPE:',1X,I04,1X,A)
 200  format(1X,'TYPE:',1X,I04,1X,A30,1X,A14)
 300  format(1X,'TYPE:',1X,I04,1X,A30,1X,I12)
 400  format(1X,'TYPE:',1X,I04,1X,A30,1X,G16.10)
 500  format(1X,'TYPE:',1X,I04,1X,A30,1X,A24)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      SUBROUTINE GET_RTCM_REC( LU, TREAD, HEX, TYPE, TREF, IDXINT,
     &                         ERR, EOF )
      IMPLICIT NONE
      CHARACTER HEX*(*)
      INTEGER*4 LU,TREAD,TYPE,TREF,ERR,EOF,IDXINT
C LOCAL VARIABLES
      CHARACTER*2069 RECORD
      INTEGER*4 SIZE,MSGLEN,TYPE2
C FUNCTIONS
      INTEGER*4 RTCM_TYPE,RTCM_MSGLEN,RTCM_TIME,RTCM_IDXINT
      ERR=0
      EOF=0
      READ(LU,'(A)',END=3998,ERR=3999) RECORD
      READ(RECORD(1:15),'(I10,1X,I4)',ERR=3999) TREAD,SIZE
      SIZE=2*SIZE
      IF( SIZE    .GT. 2048 ) GOTO 3999
      IF( RECORD(16:16) .NE. ' ' ) GOTO 3999
      IF( RECORD(17+SIZE:17+SIZE) .NE. ' ' ) GOTO 3999
      HEX=RECORD(17:17+SIZE-1)
      READ(RECORD(18+SIZE:21+SIZE),'(I4)',ERR=3999) TYPE2
      MSGLEN=RTCM_MSGLEN( HEX )
      IF( MSGLEN .NE. 0 ) THEN
       TYPE=RTCM_TYPE( HEX )
      ELSE
       TYPE=0
      ENDIF
      IF(( TYPE .GE. 1057 .AND. TYPE .LE. 1062 ) .OR.
     &   ( TYPE .GE. 1264 .AND. TYPE .LE. 1265 ) ) THEN
       TREF=RTCM_TIME( HEX )
       TREF=TREF+604800D0*DINT(TREAD/604800D0)
       IF( MOD(TREAD,604800) .LT. MOD(TREF,604800) ) TREF=TREF-604800D0
       IDXINT=RTCM_IDXINT( HEX )
      ELSE
       TREF=-1
       IDXINT=-1
      ENDIF
      RETURN
 3998 CONTINUE
      EOF=1
      RETURN
 3999 CONTINUE
      ERR=1
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      SUBROUTINE RTCM_UNROLL( TREAD, TMSG )
      IMPLICIT NONE
      INTEGER*4 TREAD, TMSG
C
C ADD MISSING WEEKS TO TMSG
C
      IF( TMSG .LT. 604800 .AND. TREAD .GT. 604800 )
     & TMSG=TMSG+604800*INT(TREAD/604800)
C
C CORRECT FOR WEEK CROSSOVER
C
      IF( MOD(TMSG,604800) .GT. MOD(TREAD,604800) ) TMSG=TMSG+604800
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION RTCM_TEND( TMSG, INTRV, NUM )
      IMPLICIT NONE
      INTEGER*4 TMSG, INTRV, NUM
      IF( NUM .LE. 0 .OR. NUM .GT. 10 ) NUM=1
      RTCM_TEND = -1
      IF( INTRV .GT. 0 )
     & RTCM_TEND = TMSG+INTRV-MOD(TMSG+INTRV,INTRV)-1
     &            +(NUM-1)*INTRV
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      REAL*8 FUNCTION RTCM_ACC( URA )
      IMPLICIT NONE
      INTEGER*4 URA
      INTEGER*4 URACLASS, URAVAL
      URACLASS = DINT(URA/8.D0)
      URAVAL = MOD(URA,8)
      RTCM_ACC = 1.D-3*(3**URACLASS)*(1+URAVAL/4.D0)-1.D-3
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION RTCM_INTV( IDX )
      IMPLICIT NONE
      INTEGER*4 IDX
      IF( IDX .EQ.  0 ) THEN
       RTCM_INTV = 1
      ELSE IF( IDX .EQ.  1 ) THEN
       RTCM_INTV = 2
      ELSE IF( IDX .EQ.  2 ) THEN
       RTCM_INTV = 5
      ELSE IF( IDX .EQ.  3 ) THEN
       RTCM_INTV = 10
      ELSE IF( IDX .EQ.  4 ) THEN
       RTCM_INTV = 15
      ELSE IF( IDX .EQ.  5 ) THEN
       RTCM_INTV = 30
      ELSE IF( IDX .EQ.  6 ) THEN
       RTCM_INTV = 60
      ELSE IF( IDX .EQ.  7 ) THEN
       RTCM_INTV = 120
      ELSE IF( IDX .EQ.  8 ) THEN
       RTCM_INTV = 240
      ELSE IF( IDX .EQ.  9 ) THEN
       RTCM_INTV = 300
      ELSE IF( IDX .EQ. 10 ) THEN
       RTCM_INTV = 600
      ELSE IF( IDX .EQ. 11 ) THEN
       RTCM_INTV = 900
      ELSE IF( IDX .EQ. 12 ) THEN
       RTCM_INTV = 1800
      ELSE IF( IDX .EQ. 13 ) THEN
       RTCM_INTV = 3600
      ELSE IF( IDX .EQ. 14 ) THEN
       RTCM_INTV = 7200
      ELSE IF( IDX .EQ. 15 ) THEN
       RTCM_INTV = 10800
      ELSE 
       RTCM_INTV = -1
      END IF
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      SUBROUTINE RTCM_RACTOXYZ( DELTAT, XSV, VSV, DRACC, DXYZC )
      IMPLICIT NONE
C
C ARGUMENTS
      REAL*8 XSV(3), VSV(3), DRACC(6), DXYZC(6)
     &      ,DELTAT
C
C LOCAL VARIABLES
      INTEGER*4 I,J
      REAL*8    NORM
      REAL*8 RADIAL(3),ALONG(3),CROSS(3)
     &      ,POS(3)
      DO I=1,3
        POS(I)=XSV(I)+VSV(I)*DELTAT
      END DO
C
C COMPUTE UNIT VECTORS
      NORM=0.D0
      NORM=DSQRT(VSV(1)*VSV(1)+VSV(2)*VSV(2)+VSV(3)*VSV(3))
      DO I=1,3
        ALONG(I)=VSV(I)/NORM
      END DO
      CALL XPROD3( POS, VSV, CROSS )
      NORM=DSQRT(CROSS(1)*CROSS(1)+CROSS(2)*CROSS(2)+CROSS(3)*CROSS(3))
      DO I=1,3
        CROSS(I)=CROSS(I)/NORM
      END DO
      CALL XPROD3( ALONG, CROSS, RADIAL )
C
C TRANSFORM DRACC INTO DXYZC
      DO I=1,3
       DXYZC(I) = RADIAL(I) * DRACC(1) +
     &            ALONG(I)  * DRACC(2) + CROSS(I) * DRACC(3)
       DXYZC(I+3) = RADIAL(I) * DRACC(4) +
     &              ALONG(I)  * DRACC(5) + CROSS(I) * DRACC(6)
       DXYZC(I)=DXYZC(I)-DELTAT*DXYZC(I+3)
      END DO
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** RVECT
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE RVECT(XSV,XRV,RNG)
C
C     PURPOSE:   TO COMPUTE A 3-D RANGE VECTOR
C
C
C-----------------------------------------------------------------------
C
      IMPLICIT NONE
C
      REAL*8    XSV(3),XRV(3),RNG
C
      INTEGER*4 I
      REAL*8    R
C
      R = 0.0D0
      DO 1 I=1,3
      R = (XSV(I)-XRV(I))**2 + R
1     CONTINUE
      RNG = DSQRT(R)
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** SABUF1
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SABUF1 ( NSVSA, LSVSA, LTSVSA, IEOFSA,
     &   NBPBUF, IBPBUF, IEPBUF, DSABUF, DSGBUF, DSPBUF, DSWBUF, ITMBUF,
     &                   AMBBUF, YAWBUF,
     &                   IODBUF )
C
C     NAME              SABUF
C
C     PURPOSE           READ CLOCK OFFSETS FOR ALL SATELLITES
C                       AND STORE IN BUFFERS
C
C     PARAMETERS        DESCRIPTION
C
C     NSVSA             NUMBER OF SATELLITES WITH PRECISE CLOCKS
C     LSVSA             LOGICAL UNITS OF SATELLITE CLOCK FILES
C     LTSVSA            LAST TIME TAG WITH PRECISE SATELLITE CLOCK
C     IEOFSA            SATELLITE CLOCK END OF FILE FLAG
C     MAXBUF            MAXIMUM NUMBER OF SAMPLES TO BUFFER
C     NBPBUF            NUMBER OF POSITIONS FILLED IN BUFFER
C     IBPBUF            POSITION OF FIRST SAMPLE IN BUFFER
C     IEPBUF            POSITION OF LAST SAMPLE IN BUFFER
C     DSABUF            BUFFER OF SATELLITE CLOCK OFFSETS
C     DSPBUF            BUFFER OF DCM SATELLITE PR CLOCK CORRECTIONs
C     DSWBUF            BUFFER OF DCM SATELLITE WL DCB's  
C     ITMBUF            BUFFER OF SATELLITE CLOCK TIMES
C     AMBBUF            BUFFER OF SATELLITE AMBIGUITY RESET FLAGS
C     YAWBUF            BUFFER OF SATELLITE FULL YAW ANGLE
C     IODBUF            BUFFER OF SATELLITE ISSUE OF DATA
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4     NSVSA
      INTEGER*4     LSVSA(*),   IEOFSA(*), LTSVSA(*)
      INTEGER*4     NBPBUF(*)
      INTEGER*4     IBPBUF(*),  IEPBUF(*)
      INTEGER*4     ITMBUF(MAXSAT,*)
      INTEGER*4     IODBUF(MAXSAT,*)
C
      INTEGER*4     ISA
      INTEGER*4     ISATTAG, IOD
      LOGICAL*4     CLKAMB,AMBBUF(MAXSAT,*)
      REAL*8        DELTAYAW,FULLYAW,YAWRATE,YAWBUF(MAXSAT,*)
C
      REAL*8        DSABUF(MAXSAT,*), DSGBUF(MAXSAT,*)
      REAL*8        AVGESA,      RMSESA
      REAL*8 PSB, PSBRMS, WSB, WSBRMS, DSPBUF(MAXSAT,*),DSWBUF(MAXSAT,*)
C
      DO 400 ISA=1,NSVSA
C
C     READ 'MAXBUF' SAMPLES INTO BUFFERS DSABUF AND ITMBUF 
C     NBPBUF = NUMBER OF POSITIONS FILLED IN BUFFER
C     IBPBUF = POSITION IN CIRCULAR BUFFER OF FIRST SAMPLE
C     IEPBUF = POSITION IN CIRCULAR BUFFER OF LAST SAMPLE 
C
      IEOFSA(ISA) = 0
      NBPBUF(ISA) = 0
 200  CONTINUE
      READ(LSVSA(ISA),*) ISATTAG, AVGESA, RMSESA, 
     &                   PSB    , PSBRMS, WSB   , WSBRMS, IOD
     &                  ,CLKAMB,FULLYAW
c!    WRITE(*,*)  ISATTAG, AVGESA, RMSESA, IOD
      NBPBUF(ISA)  = NBPBUF(ISA) + 1
      IF (NBPBUF(ISA) .EQ. 1) IBPBUF(ISA) = 1
      IEPBUF(ISA) = NBPBUF(ISA)
      DSABUF(ISA,NBPBUF(ISA))  = AVGESA
      DSGBUF(ISA,NBPBUF(ISA))  = RMSESA
      DSPBUF(ISA,NBPBUF(ISA))  = PSB   
      DSWBUF(ISA,NBPBUF(ISA))  = WSB   
      ITMBUF(ISA,NBPBUF(ISA))  = ISATTAG
      IODBUF(ISA,NBPBUF(ISA))  = IOD
      AMBBUF(ISA,NBPBUF(ISA))  = CLKAMB
      YAWBUF(ISA,NBPBUF(ISA))  = FULLYAW
      IF ( ISATTAG .EQ. LTSVSA(LSVSA(ISA)) ) GO TO 300
      IF ( NBPBUF(ISA) .LT. MAXBUF ) GO TO 200
      GO TO 400
 300  CONTINUE
      IEOFSA(ISA) = 1
 400  CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** SAFIT2
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SAFIT2 ( LPR, NSVSA, ISVSA, LSVSA, LTSVSA, IEOFSA,
     &   NBPBUF, IBPBUF, IEPBUF, DSABUF, DSGBUF, DSPBUF, DSWBUF, ITMBUF,
     &                   AMBBUF, YAWBUF, CLKAMB,
     &                   IODBUF, NOSV, IOSV, IGPSWK, TTAG, CSA, 
     &                   AVCLK, IOCSA, 
     &                   NSVRJCT, ISVRJCT, C, IDIR, INTCLK, IFITCLK ,
     &                   IBLK)
C
C     NAME              SAFIT
C
C     PURPOSE           GET SATELLITE CLOCK OFFSET AT SPECIFIED TTAG
C
C     PARAMETERS        DESCRIPTION
C
C     LPR               LOGICAL UNIT OF PRINTER
C     NSVSA             NUMBER OF SATELLITES WITH PRECISE CLOCKS
C     ISVSA             PRN'S OF SATELLITES WITH PRECISE CLOCKS
C     LSVSA             LOGICAL UNITS OF SATELLITE CLOCK FILES
C     LTSVSA            LAST TIME TAG WITH PRECISE SATELLITE CLOCK
C     IEOFSA            SATELLITE CLOCK END OF FILE FLAG
C     NBPBUF            NUMBER OF POSITIONS FILLED IN BUFFER
C     IBPBUF            POSITION OF FIRST SAMPLE IN BUFFER
C     IEPBUF            POSITION OF LAST SAMPLE IN BUFFER
C     DSABUF            BUFFER OF SATELLITE CLOCK OFFSETS
C     DSGBUF            BUFFER OF SATELLITE CLOCK SIGMAS 
C     DSPBUF            BUFFER OF DCM PR CLOCK CORRECTIONS
C     DSWBUF            BUFFER OF DCM WL DCB's          
C     ITMBUF            BUFFER OF REFERENCE TIMES
C     AMBBUF            BUFFER OF AMBIGUITY RESET FLAG
C     YAWBUF            BUFFER OF YAW ANGLES
C     CLKAMB            CURRENT AMBIGUITY STATE
C     NOSV              NUMBER OF OBSERVED SATELLITES
C     IOSV              ARRAY OF OBSERVED SATELLITE PRN NUMBERS
C     TTAG              TIME TAGS OF OBSERVED SATELLITES
C     PR1               L1 PSEUDO-RANGES OF OBSERVED SATELLITES
C     PR2               L2 PSEUDO-RANGES OF OBSERVED SATELLITES
C     P1                L1 CARRIER PHASES OF OBSERVED SATELLITES
C     P2                L2 CARRIER PHASES OF OBSERVED SATELLITES
C     INTCLK            SATELLITE CLOCK TIME INTERVAL
C     IFITCLK           FIT POLYNOMIAL TO SATELLITE CLOCKS
C     IBLK              BLOCK I=1 , II = 2, IIA=3, IIR=4,5
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'      
C
      INTEGER*4 IBLK(*)
      INTEGER*4 LPR,         LSVSA(*),     LTSVSA(*)
      INTEGER*4 NSVSA,       ISVSA(*),     IEOFSA(*)
      INTEGER*4 NBPBUF(*),   IOCSA(*)
      INTEGER*4 IBPBUF(*),  IEPBUF(*)
      INTEGER*4 ITMBUF(MAXSAT,*)
      INTEGER*4 IODBUF(MAXSAT,*)
      INTEGER*4 NOSV,        IOSV(*)
      INTEGER*4 NSVRJCT,     ISVRJCT(*)
      INTEGER*4 INTCLK,      IFITCLK,  IDIR
      INTEGER*4 ISATTAG,IODSA,IGPSWK
      LOGICAL*4 AMBBUF(MAXSAT,*), CLKAMB(*)
      REAL*8    YAWBUF(MAXSAT,*)
C
C
      REAL*8        DSABUF(MAXSAT,*), DSGBUF(MAXSAT,*)
      REAL*8        TTAG(*), CSA(10,*), AVCLK(*)
      REAL*8        SAVEC(20), TMVEC(20)
      REAL*8        CY(20),    RMSY
      REAL*8        SACOR,     CTTAG,     C
      REAL*8        AVGESA,    RMSESA
C
      INTEGER*4 ISO,       ISA,       MINDEG
      INTEGER*4 MAXDT,     NFIT,      NDEG
      INTEGER*4 ISOSA
      LOGICAL*4 AMB
      REAL*8    DELTAYAW, FULLYAW, YAWRATE
C
      INTEGER*4 NCSV,IDTMIN,ITTAG,ISAISO,MIDTM,IHFTM
      INTEGER*4 IDTM,MINTM,MAXTM,IPOS,IBUFPOS,IS,ITEND
      INTEGER*4 IBUFPO1,IPRN
      REAL*8    PCFACT,FQC,DTM,SIGMA
      REAL*8 PSB, PSBRMS, WSB, WSBRMS,DSPBUF(MAXSAT,*),DSWBUF(MAXSAT,*)
      LOGICAL       IRDSA
C     INTEGER*4 IHR,       IMIN
C
C     PROCESS OBSERVED SATELLITES SEQUENTIALLY
C
C   PCFACT- phase obs factor, transforms orb/clk errors into phase err
C   see subroutine UPDSUW
C
      PCFACT=.2
      MAXDT =    INTCLK
C
      MINDEG = 2
      NCSV = 0
      NSVRJCT=0
      IBUFPOS=0
      SIGMA=0.D0
      DO 500 ISO=1,NOSV
        IPRN=IOSV(ISO)
        IDTMIN = INTCLK/2
        ITTAG = IDNINT(TTAG(ISO)+IGPSWK*604800.D0)
        ISOSA=0
        ISAISO=0
        SACOR =0.D0
C       Rb  FREQCY  FQC=0.3d-11
        FQC = 0.3d-11/PCFACT
        IF(AVCLK(IPRN).GT.0.d0) FQC= AVCLK(IPRN)/PCFACT/1.d11
        DO 400 ISA=1,NSVSA
          IF ( IPRN .EQ. ISVSA(ISA) ) THEN
            ISAISO=ISA
C
C           SEE IF ITTAG IS IN BUFFER
C      
 100        CONTINUE   
            IRDSA=.FALSE.
C
            IHFTM  = IDIR*(ITMBUF(ISA,IEPBUF(ISA))
     &               - ITMBUF(ISA,IBPBUF(ISA)))/2
            MIDTM  = ITMBUF(ISA,IBPBUF(ISA)) + IDIR*IHFTM
            IDTM   =  ITTAG - MIDTM
C
C           ITTAG IS IN TOP HALF OF TIME WINDOW, READ NEXT RECORD
C           AND ADJUST BUFFER POSITION POINTERS
C
c!          WRITE(*,*) IPRN,IDIR,ITTAG,MIDTM,IBPBUF(ISA),
c!   &         ITMBUF(ISA,IBPBUF(ISA)), IEPBUF(ISA),
c!   &         ITMBUF(ISA,IEPBUF(ISA)),IHFTM,IDTM
            IF ( IDIR .EQ. 1 .AND. ITTAG .GT. MIDTM ) IRDSA=.TRUE.
            IF ( IDIR .EQ. -1 .AND. ITTAG .LT. MIDTM ) THEN
            BACKSPACE(LSVSA(ISA))
            BACKSPACE(LSVSA(ISA))
            IRDSA=.TRUE.
            END IF
            IF ( IRDSA .AND. IEOFSA(ISA) .NE. 1 ) THEN
C            IF ( ITTAG .GT. MIDTM .AND. IEOFSA(ISA) .NE. 1 ) THEN
            IRDSA=.FALSE.
            READ(LSVSA(ISA),*)
     &              ISATTAG, AVGESA, RMSESA, 
     &              PSB    , PSBRMS, WSB   , WSBRMS, IODSA
     &             ,AMB, FULLYAW
c!            WRITE(*,*) ISATTAG, AVGESA, RMSESA, IODSA, 
c!   &                   ITMBUF(ISA,IEPBUF(ISA))
              IF ( ISATTAG .EQ. ITMBUF(ISA,IEPBUF(ISA)) ) GO TO 300
              DSABUF(ISA,IBPBUF(ISA)) = AVGESA
              DSGBUF(ISA,IBPBUF(ISA)) = RMSESA
              DSPBUF(ISA,IBPBUF(ISA)) = PSB   
              IF(WSB.NE.0.D0) DSWBUF(ISA,IBPBUF(ISA)) = WSB   
              ITMBUF(ISA,IBPBUF(ISA)) = ISATTAG
              IODBUF(ISA,IBPBUF(ISA)) = IODSA
              AMBBUF(ISA,IBPBUF(ISA))  = AMB
              YAWBUF(ISA,IBPBUF(ISA))  = FULLYAW
              IBPBUF(ISA) = MOD(IBPBUF(ISA)+IDIR,NBPBUF(ISA)) 
              IEPBUF(ISA) = MOD(IEPBUF(ISA)+IDIR,NBPBUF(ISA))
              IF ( IBPBUF(ISA) .EQ. 0 ) IBPBUF(ISA)=NBPBUF(ISA)
              IF ( IEPBUF(ISA) .EQ. 0 ) IEPBUF(ISA)=NBPBUF(ISA)
              IF ( ISATTAG .EQ. LTSVSA(LSVSA(ISA))) GO TO 300
              GO TO 100
 300          CONTINUE
              WRITE(*,*) 'REACHED END OF FILE FOR SAT',ISVSA(ISA)
              IEOFSA(ISA) = 1
            GOTO 100
          ENDIF
C
C           ITTAG IS IN TIME WINDOW, DO FIT
C
            IF ( IABS(IDTM) .LE. IHFTM ) THEN
C
              NFIT = 0
              MINTM = 604800
              MAXTM = 0
              DO 200 IPOS=1,NBPBUF(ISA) 
                IF ( IDIR .EQ. 1 )
     &            IBUFPOS = MOD(IPOS+IBPBUF(ISA)-1, NBPBUF(ISA))
                IF ( IDIR .EQ. -1 )
     &            IBUFPOS = MOD(IPOS+IEPBUF(ISA)-1, NBPBUF(ISA))
                IF ( IBUFPOS .EQ. 0 ) IBUFPOS=NBPBUF(ISA)
                IDTM   = IABS(ITTAG-ITMBUF(ISA,IBUFPOS))
C
C               SELECT ONLY SAMPLES THAT ARE WITHIN ALLOWABLE
C               TIME INTERVAL
C
C                WRITE(*,*) IBUFPOS,ITMBUF(ISA,IBUFPOS),
C     &              ITTAG-ITMBUF(ISA,IBUFPOS),NFIT
                IF ( IDTM .LT. MAXDT ) THEN
                  IF(IDTM.LT.IDTMIN) IDTMIN = IDTM
                  DTM= (1.D0*IDTM)/MAXDT
                  IF ( NFIT .EQ. 0 ) THEN
                    NFIT = 1
                    SAVEC(NFIT) = DSABUF(ISA,IBUFPOS)
                    IF(IDTM .LT. INTCLK)
     &                SIGMA     = (DSGBUF(ISA,IBUFPOS)**2)*(1.d0-DTM)
                    TMVEC(NFIT) = ITMBUF(ISA,IBUFPOS)
                    MINTM       = MIN(ITMBUF(ISA,IBUFPOS),MINTM)
                  ELSE
                    NFIT = NFIT + 1
                    SAVEC(NFIT) = DSABUF(ISA,IBUFPOS)
                    IF(IDTM .LT. INTCLK)
     &                SIGMA = SIGMA+(DSGBUF(ISA,IBUFPOS)**2)*(1.d0-DTM)
                    TMVEC(NFIT) = ITMBUF(ISA,IBUFPOS)
                    MAXTM       = MAX(ITMBUF(ISA,IBUFPOS),MAXTM)
                  ENDIF
                  CSA(8,IPRN) = DSPBUF(ISA,IBUFPOS)*C
                  IF(DSWBUF(ISA,IBUFPOS).NE.0.D0)
     &            CSA(9,IPRN) = DSWBUF(ISA,IBUFPOS)*C
                  CSA(7,ISO)=YAWBUF(ISA,IBUFPOS)
                  CLKAMB(IPRN)=CLKAMB(IPRN).OR.AMBBUF(ISA,IBUFPOS)
             CSA(3,ISO)=0.D0
             CSA(4,ISO)=0.D0
             CSA(5,ISO)=0.D0
             CSA(6,ISO)=0.D0
                ENDIF
 200          CONTINUE
            IF ( NFIT .EQ. 1 .AND. ITTAG .EQ. TMVEC(1) ) THEN
               CSA(1,ISO) = SAVEC(1)*C
               CSA(2,ISO) = SQRT(SIGMA)/PCFACT
               ISOSA = 1
            ENDIF
C
              IF ( NFIT .GE. MINDEG ) THEN
                NDEG = NFIT
                CTTAG = ITTAG
C                DO I=1,NFIT
C              CALL TOWHMS( IWKDAY, TMVEC(I), IHR, IMIN, SEC, 0 )
C                   WRITE(*,'(I5,2(I2,A), F4.1, F15.3)') 
C     &               I,IHR, ':',IMIN,':', SEC ,SAVEC(I)*C
C                END DO
C
                CALL CHEBP (CTTAG, TMVEC, SAVEC, NFIT, NDEG, 
     &                      CY, SACOR, RMSY)
C                WRITE(*,*) 'NDEG,SACOR*C,RMSY*C',NDEG,SACOR*C,RMSY*C
                IF ( SACOR .NE. 0.D0 .AND. RMSY .LT. 1.D-09 ) THEN
              CSA(1,ISO) = SACOR*C
C   ACCOUNT for interpolation sigmas & FQCY stability
C
                  CSA(2,ISO) = SQRT(SIGMA/PCFACT**2+FQC**2*IDTMIN*
     &                         (INTCLK-IDTMIN)/INTCLK)
C IIR CLOCK WHITE NOISE !
                  IF(IBLK(IPRN).GE.4) 
     &                  CSA(2,ISO)=SQRT(SIGMA/PCFACT**2+FQC**2)
                  ISOSA = 1
               END IF
              END IF
 250          CONTINUE
            ENDIF
          END IF
 400    CONTINUE
C
C       NO CLOCKS FOR THIS SATELLITE
C
        IF (ISOSA .EQ. 0 ) THEN
C
C  EXTRAPOLATE CLK AT THE END OF DAY 
C         IF SATELLITE HAS CLOCKS
C
          IF (ISAISO .NE. 0) THEN
         IS= ISAISO
         ITEND = LTSVSA(LSVSA(IS))
C
C          IF EPOCH > SVCLK END TTAG       
C
         IF(ITTAG.GT.ITEND) THEN
           NCSV=NCSV + 1
           IBUFPOS= IEPBUF(IS)
           IF(IDIR.EQ.-1) IBUFPOS= IBPBUF(IS)
             IDTM   = ITTAG-ITMBUF(IS,IBUFPOS) 
C
C             IF EPOCH MINUS SVCLK TTAG IS LESS THAN SVCLK INTERVAL         
C
            IF(IDTM.LT.INTCLK                    ) THEN
             IBUFPO1=IBUFPOS - 1
             IBUFPO1= MOD(IBUFPO1,NBPBUF(IS))
             DTM= IDTM/INTCLK
             CSA(1,ISO) = (DSABUF(IS,IBUFPOS)+(DSABUF(IS,IBUFPOS)-
     &             DSABUF(IS,IBUFPO1))*IDTM/INTCLK)*C
             CSA(2,ISO) = SQRT((DSGBUF(IS,IBUFPOS)*(1.D0-DTM))**2+
     &             (DSGBUF(IS,IBUFPO1)*DTM)**2+ FQC**2*IDTM)
             CSA(8,IPRN) = (DSPBUF(IS,IBUFPOS)+(DSPBUF(IS,IBUFPOS)-
     &             DSPBUF(IS,IBUFPO1))*IDTM/INTCLK)*C
             CSA(9,IPRN) = (DSWBUF(IS,IBUFPOS)+(DSWBUF(IS,IBUFPOS)-
     &             DSWBUF(IS,IBUFPO1))*IDTM/INTCLK)*C
C IIR CLOCK WHITE NOISE !
                  IF(IBLK(IPRN).GE.4) 
     &            CSA(2,ISO) = SQRT((DSGBUF(IS,IBUFPOS)*(1.D0-DTM))**2+
     &                (DSGBUF(IS,IBUFPO1)*DTM)**2+ FQC**2)
             ISOSA=1
             IF(YAWBUF(IS,IBUFPOS).LT.0.D0.OR.
     &          YAWBUF(IS,IBUFPO1).LT.0.D0) THEN
               CSA(7,ISO)= -999.D0
             ELSE
               CSA(7,ISO)=
     &           (YAWBUF(IS,IBUFPOS)                     +
     &            (YAWBUF(IS,IBUFPOS)                     -
     &             YAWBUF(IS,IBUFPO1)                     )*
     &                                                      IDTM/INTCLK)
             ENDIF
             CLKAMB(IPRN)=CLKAMB(IPRN).OR.
     &                    (IDTM.GE.0.AND.AMBBUF(IS,IBUFPO1)).OR.
     &                    (IDTM.LT.0.AND.AMBBUF(IS,IBUFPOS))
             CSA(3,ISO)=0.D0
             CSA(4,ISO)=0.D0
             CSA(5,ISO)=0.D0
             CSA(6,ISO)=0.D0
            ELSE
               NSVRJCT = NSVRJCT+1
               ISVRJCT(NSVRJCT)=IPRN
            ENDIF
          ELSE
             NSVRJCT = NSVRJCT+1
             ISVRJCT(NSVRJCT)=IPRN
          END IF
         END IF
         NSVRJCT = NSVRJCT+1
         ISVRJCT(NSVRJCT)=IPRN
        END IF
 500  CONTINUE
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** SAGNAC
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SAGNAC (XRV, XSV, OMEGA, C, SAGCOR )
C
C
C     PURPOSE:   COMPUTE SAGNAC EFFECT ON RANGE
C              SAGNAC EFFECT RESULTS FROM EARTH ROTATION 
C                DURING SATELLITE->RECEIVER TRANSIT
C
C  CALLING PARAMETERS:
C
C     INPUT:  XRV(3)   - RECEIVER COORDINATES
C           XSV(3)   - SATELLITE COORDINATES
C           OMEGA    - EARTH ROTATION RATE (RAD/SEC)
C           C        - SPEED OF LIGHT
C           SAGCOR   - SAGNAC CORRECTION
C
C***********************************************************************
C
C
      IMPLICIT NONE
C
      REAL*8   XRV(*),XSV(*),OMEGA,C,SAGCOR
C
      INTEGER*4 I
      REAL*8   DX(3),RXSV(3),DXSV,DYSV,SCALE,RANGE,RRANGE,DW
      REAL*8   X,Y
C
C  VARIABLE INITIALIZATION
C
      DXSV = 10.0D0
      DYSV = 10.0D0
      SCALE = OMEGA/C
      RANGE = 0.0D0
C
      DO I=1,3
        RXSV(I) = XRV(I)
      DX(I) = RXSV(I) - XSV(I)
      RANGE = RANGE + DX(I) * DX(I)
      END DO
      RANGE = DSQRT(RANGE)
      RRANGE = RANGE
C
  100 CONTINUE
C Station sagnac formulation
      DW = -(RRANGE * SCALE)
      X  = XRV(1) *   DCOS(DW) + XRV(2) * DSIN(DW)
      Y  = XRV(1) * (-DSIN(DW)) + XRV(2) * DCOS(DW)
      DXSV = X - RXSV(1)
      RXSV(1) = X
      DYSV = Y - RXSV(2)
      RXSV(2) = Y
      RRANGE=0.0d0
      DO I=1,3
        DX(I) = RXSV(I) - XSV(I)
      RRANGE = RRANGE + DX(I) * DX(I)
      END DO
      RRANGE = DSQRT(RRANGE)
C
C CHECK ON CONVERGENCE
      IF( DABS(DXSV) .GT. .0001D0 .AND.
     &    DABS(DYSV) .GT. .0001D0) GO TO 100
      SAGCOR = RRANGE - RANGE
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** SANTX
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
C     INITIALIZE SATELLITE BIAS RECORDS
C
      SUBROUTINE SANTX( XSV, MJD , FMJDDT, SIDT,
     &                  RANTX, RANTY, RANTZ, ECLIPSE, vsv, beta)
C
C FUNCTION: SANTX COMPUTES EXCENTRICITY OF SATELLITE ANTENNA
C
C INPUT:    XSV   = SATELLITE COORDINATES
C           MJD   = MODIFIED JULIAN DATE
C           SIDT = SIDERAL TIME
C
C OUTPUT:   RANTX = ANTENNA EXCENTRICITY IN X
C           RANTY = ANTENNA EXCENTRICITY IN Y
C           RANTZ = ANTENNA EXCENTRICITY IN Z
C           ECLIPSE= COS(angle BTW SUN & SV radius vectors) 
C
      IMPLICIT NONE
C
      INTEGER*4 MJD
      REAL*8    XSV(3),FMJDDT,SIDT,RANTX,RANTY,RANTZ,ECLIPSE
      real*8   vsv(3), beta
C
      REAL*8    DMJDT,XSUN,YSUN,ZSUN,RAD,RSUN,DXSUN,DYSUN,DZSUN
      REAL*8    DXX,DXY,DXZ,RADX
C
C     COMPUTE SUN COORDINATES
C
C
      DMJDT = MJD + FMJDDT
      CALL SUNXYZ(DMJDT, SIDT, XSUN, YSUN, ZSUN)
C
      RAD = SQRT(XSV(1)**2 + XSV(2)**2 + XSV(3)**2)  
      RSUN= SQRT(XSUN**2+YSUN**2+ZSUN**2)
C   COS of eclipse angle
      ECLIPSE= (XSV(1)*XSUN+XSV(2)*YSUN+ XSV(3)*ZSUN)/RAD/RSUN
C
      DXSUN=(XSUN-XSV(1))/RSUN
      DYSUN=(YSUN-XSV(2))/RSUN
      DZSUN=(ZSUN-XSV(3))/RSUN
c!    write(*,*) DXsun, dysun, dzsun, sidt, DMJDT
C
C  SV X-BODY COORD (FOR X-ANT. OFFSET! ANTX)
C
      DXX =( (( (DYSUN*XSV(1))-(DXSUN*XSV(2)))*XSV(2))
     *       -(-(DZSUN*XSV(1))+(DXSUN*XSV(3)))*XSV(3))/RAD/RAD
      DXY =(-(( (DYSUN*XSV(1))-(DXSUN*XSV(2)))*XSV(1))
     *       +( (DZSUN*XSV(2))-(DYSUN*XSV(3)))*XSV(3))/RAD/RAD
      DXZ =( ((-(DZSUN*XSV(1))+(DXSUN*XSV(3)))*XSV(1))
     *       -( (DZSUN*XSV(2))-(DYSUN*XSV(3)))*XSV(2))/RAD/RAD
      RADX = SQRT(DXX**2 + DXY**2 + DXZ**2)
C
C     CARTESIAN COMPONENTS OF ANTENNA EXCENTRICITY
C     IN EARTH CENTERED FRAME
C
      RANTX= -DXX/RADX
      RANTY= -DXY/RADX
      RANTZ= -DXZ/RADX
C
      beta = acos(( (vsv(2)*XSV(3)-vsv(3)*xsv(2))*dxsun +
     &              (vsv(3)*XSV(1)-vsv(1)*xsv(3))*dysun +
     &              (vsv(1)*XSV(2)-vsv(2)*xsv(1))*dzsun )/rad/
     & sqrt(vsv(1)**2+vsv(2)**2+vsv(3)**2))
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** SAPOS
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SAPOS ( NSVSA, LSVSA, IEOFSA,
     &                   NBPBUF, IBPBUF, IEPBUF, ITMBUF,
     &                   IODBUF )
C
C     NAME              SAPOS
C
C     PURPOSE           POSITION WITHIN SATELLITE CLOCK FILES
C                       IN PREPARATION FOR BACKWARD PASS
C
C     PARAMETERS        DESCRIPTION
C
C     NSVSA             NUMBER OF SATELLITES WITH PRECISE CLOCKS
C     LSVSA             LOGICAL UNITS OF SATELLITE CLOCK FILES
C     IEOFSA            SATELLITE CLOCK END OF FILE FLAG
C     MAXBUF            MAXIMUM NUMBER OF SAMPLES TO BUFFER
C     NBPBUF            NUMBER OF POSITIONS FILLED IN BUFFER
C     IBPBUF            POSITION OF FIRST SAMPLE IN BUFFER
C     IEPBUF            POSITION OF LAST SAMPLE IN BUFFER
C     ITMBUF            BUFFER OF SATELLITE CLOCK TIMES
C     IODBUF            BUFFER OF SATELLITE ISSUE OF DATA
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4     NSVSA
      INTEGER*4     LSVSA(*),   IEOFSA(*)
      INTEGER*4     NBPBUF(*)
      INTEGER*4     IBPBUF(*),  IEPBUF(*)
      INTEGER*4     ITMBUF(MAXSAT,*)
      INTEGER*4     IODBUF(MAXSAT,*)
C
      INTEGER*4     ISA,     ITEMP
      INTEGER*4     ISATTAG, IOD
C
      REAL*8        AVGESA,      RMSESA
      REAL*8        PSB, PSBRNS, WSB, WSBRMS
C
      DO ISA=1,NSVSA
C
C       POSITION SATELLITE CLOCK FILE 
C       TO EPOCH OF EARLIEST RECORD IN BUFFER
C
c!      WRITE(*,*) 'POSITIONING BUFFER FOR LU ',LSVSA(ISA),IEOFSA(ISA)
        IEOFSA(ISA)=0
 200    CONTINUE
        BACKSPACE(LSVSA(ISA))
        READ(LSVSA(ISA),*,ERR=300,END=300) ISATTAG, AVGESA, RMSESA, 
     &                                    PSB, PSBRNS, WSB, WSBRMS, IOD
c!      WRITE(*,*) LSVSA(ISA),ISATTAG,ITMBUF(ISA,IBPBUF(ISA))
        IF ( ISATTAG .NE. ITMBUF(ISA,IBPBUF(ISA)) ) THEN
          BACKSPACE(LSVSA(ISA))
          GO TO 200
        END IF
C
C     EXCHANGE BUFFER BEGIN AND END POINTERS 
C
        ITEMP=IBPBUF(ISA)
        IBPBUF(ISA)=IEPBUF(ISA)
        IEPBUF(ISA)=ITEMP
c!      WRITE(*,*) NBPBUF(ISA),IEPBUF(ISA),IBPBUF(ISA)
C      
      END DO
      RETURN
 300  CONTINUE
      IEOFSA(ISA) = 1
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** SATUV
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SATUV( XSV, UXX, UYY, UZZ )
C
C FUNCTION: SATUV: COMPUTES UNIT VECTORS OF SATELLITE LOCAL SYSTEM
C
C INPUT:    XSV   = SATELLITE COORDINATES
C
C OUTPUT:   UXX   = UNIT VECTOR IN SATELL Frame X DIRECTION 
C           UYY   = UNIT VECTOR IN SATELL FRAME Y DIRECTION 
C           UZZ   = UNIT VECTOR IN SATELL FRAME Z DIRECTION (RADIAL)
C
      IMPLICIT NONE
C
      REAL*8    XSV(*),UXX(*),UYY(*),UZZ(*)
C
      INTEGER*4 I
C
C     COMPUTE UNIT VECTORS ALONG THE DIRECTIONS OF THE SPACE VEHICLE
C     POSITION (Z AXIS-UZZ) AND OF THE SPACE VEHICLE LOCAL FRAME    ) 
C     UXX INPUT, (COMPUTED ALREADY BY SATNX), UYY=  UZZ x UXX
C
       CALL UNITV3(XSV,UZZ)
       DO I=1,3
       UZZ(I)=-UZZ(I)
       END DO
C      NOMINAL Y AXIS IS ZxX
C
       CALL XPROD3(UZZ,UXX,UYY)
C
C
       RETURN
       END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C *********************************************************** SCHACOEFF
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
C Calculate great circle centeral angle on sphere 
C Reference: Vincinty [1975] inverse formula on sphere 
C Input:
C      lats and lons: lat and lon of first point on sphere (deg)
C      LATF and LONF: lat and lon of second point on sphere (deg)
C Output:
C     Subroutine returns central angle (great circle) between the two points in degree
C
      REAL*8 FUNCTION GCIRCLEDIST( LATS, LONS , LATF, LONF )
C
      IMPLICIT NONE
C
C ARGUMENT DECLARATION
C
      REAL*8 LATS, LONS , LATF, LONF
C
C LOCAL DECLARATION
C
      REAL*8 DLON, NOM, DENOM, LATSR, LONSR, LATFR, LONFR, M_PI
C
      M_PI=2.D0*DACOS(0.0D0)
C
      LATSR=LATS*M_PI/180.D0
      LONSR=LONS*M_PI/180.D0
      LATFR=LATF*M_PI/180.D0
      LONFR=LONF*M_PI/180.D0
C
      DLON = LONFR-LONSR
C
      NOM =DSQRT((DCOS(LATFR)*DSIN(DLON))**2+
     &     (DCOS(LATSR)*DSIN(LATFR)-
     &      DSIN(LATSR)*DCOS(LATFR)*DCOS(DLON))**2)
      DENOM = DSIN(LATSR)*DSIN(LATFR)+DCOS(LATSR)*DCOS(LATFR)*DCOS(DLON)
      GCIRCLEDIST = INT(100D0*DATAN2(NOM,DENOM)*180.D0/M_PI)/100.D0
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C SUBROUTINE TO CALCULATE TEC AT A SINGLE POINT FROM SCHA COEF SETS.
C THIS ALSO INCLUDES TEMPORAL INTERPOLATION OF RESULTS BETWEEN COEF SETS 
C IF USER TIME IS COINCIDE EXACTLY WITH THE TIME OF LAST AVAILABLE COEF SET, IT IS ALSO PROCESSED
C
C INPUT: 
C     LAT:       LATITUDE [-90,90] (DEG) 
C     LON:       LONGITUDE [-180,180] OR [0,360] (DEG)
C     TIM:       GPS TIME
C     SCHA_T:    EPOCHS OF COEFFICIENTS
C     SCHA_L:    DEGREES OF COEFFICIENTS
C     SCHA_M:    ORDERS OF COEFFICIENTS
C     SCHA_NMN:  NMN COEFFICIENTS
C     SCHA_ALM:  ALM COEFFICIENTS
C     SCHA_BLM:  BLM COEFFICIENTS
C     NSET:      NUMBER OF COEF. SETS IN THE SCHA COEF. FILE
C OUTPUT:
C      TECP: TEC (TECU)
C      SUBROUTINE RETURNS: 1  ABLE TO PROCESS
C                          0  ELSE
C NOTE: TEC VALUES MIGHT BE REPORTED AS: -999.99 IN 3 CASES:
C  1- THE RESULTED VALUE IS NEGATIVE OR VERY LARGE (>100) 
C  2- WHEN COEF SETS PERIOD DO NOT COVER THE USER TIME
C  3- WHEN THE REQUESTED LOCATION IS FARTHER THAN (CAP-2) DEGREE
C     (CENTERAL GREAT CIRCLE ANGLE) FROM CENTRE OF THE CAP)
C
      SUBROUTINE IPP2TEC( LAT, LON, TIM, CLAT, CLON, CAP, SCHA_INT,
     &                    SCHA_T, SCHA_L, SCHA_M,
     &                    SCHA_NMN, SCHA_ALM, SCHA_BLM, NSET, TECP )
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
C ARGUMENT DECLARATION
C
      INTEGER*4 NSET, SCHA_L(MAXSHCOEF,*), SCHA_M(MAXSHCOEF,*)
      REAL*8 LAT, LON, TIM, TECP
      REAL*8 SCHA_T(*), SCHA_NMN(MAXSHCOEF,*),SCHA_ALM(MAXSHCOEF,*),
     &       SCHA_BLM(MAXSHCOEF,*)
      REAL*8 CLAT, CLON, CAP, SCHA_INT
C
C LOCAL DECLARATION
C
      INTEGER*4 J,D
      REAL*8 DEG2RAD
      REAL*8 PMNX1(15), PMNX2(15), SLAT, SLON, T1INT, T2INT,
     &       TEC1, TEC2, TEC, GCDIST
C
C EXTERNAL FUNCTION DECLARATION
C
      REAL*8 GCIRCLEDIST
C
C INITIALIZATIONS
C
      TEC=-999.99D0
      DEG2RAD=2.D0*DACOS(0.D0)/180.D0
C
      IF( CAP .EQ. 0.D0 ) RETURN
C REPLACE PIERCE POINTS CLOSE TO OR OUTSIDE OF CAP BORDER WITH -999.99
C
      GCDIST=GCIRCLEDIST( CLAT, CLON, LAT, LON )
      IF( GCDIST .LE. CAP - 2.0D0 ) THEN
        CALL SHIFT_TO_POLEP (CLAT, CLON, LAT, LON, SLAT, SLON)
C
        DO J=2,NSET
          IF( ( TIM .GE. SCHA_T(J-1)+SCHA_INT/2.D0 .AND.
     &          TIM .LE. SCHA_T(J  )+SCHA_INT/2.D0 ) .OR.
     &        ( J .EQ.    2 .AND.
     &                   TIM .LT. SCHA_T(J-1)+SCHA_INT/2.D0 .AND.
     &                   TIM .GE. SCHA_T(J-1) ) .OR.
     &        ( J .EQ. NSET .AND.
     &                   TIM .GT. SCHA_T(J  )+SCHA_INT/2.D0 .AND.
     &                   TIM .LE. SCHA_T(J  )+SCHA_INT ) ) THEN
            T1INT = (SCHA_T(J  )+SCHA_INT/2.D0 - TIM)/
     &                             (SCHA_T(J) - SCHA_T(J-1))
            T2INT = (TIM - SCHA_T(J-1)-SCHA_INT/2.D0)/
     &                             (SCHA_T(J) - SCHA_T(J-1))
            IF(  T1INT .NE. 0.D0 )
     &      CALL GET_LEGENDP( 90.0-SLAT, SCHA_M(1,J-1), SCHA_NMN(1,J-1),
     &                                                        PMNX1, 15)
            IF(  T2INT .NE. 0.D0 )
     &      CALL GET_LEGENDP( 90.0-SLAT, SCHA_M(1,J),SCHA_NMN(1,J),
     &                                                       PMNX2, 15 )
            TEC1=0.0D0
            TEC2=0.0D0
            DO D=1,15
             IF(  T1INT .NE. 0.D0 )
     &         TEC1 = TEC1 +
     &          PMNX1(D)*( SCHA_ALM(D,J-1)*
     &                   DCOS(SCHA_M(D,J-1)*SLON*DEG2RAD)+
     &                      SCHA_BLM(D,J-1)*
     &                   DSIN(SCHA_M(D,J-1)*SLON*DEG2RAD) )
             IF(  T2INT .NE. 0.D0 )
     &         TEC2 = TEC2 +
     &          PMNX2(D)*( SCHA_ALM(D,J)*
     &                    DCOS(SCHA_M(D,J)*SLON*DEG2RAD)+
     &                   SCHA_BLM(D,J)*
     &                     DSIN(SCHA_M(D,J)*SLON*DEG2RAD) )
            END DO
            TEC = T1INT*TEC1+T2INT*TEC2
C
C REPLACE INVALID VALUES OR THOSE CLOSE TO OR OUTSIDE OF CAP BORDER WITH -999.99
C
            IF( TEC .LT. 0.D0 .OR. TEC .GT. 1.D2 ) TEC = -999.99
          END IF
        END DO
      END IF
C
      TECP = TEC
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION SCHACOEFHEAD( LUCOEFF, NORD, CLAT, CLON, CAP,
     &                                 SLMHGT, CNT, TINT, SCHA_DCB )
C
      IMPLICIT NONE
C
C ARGUMENT DECLARATION
C
      INTEGER*4 LUCOEFF,NORD,CNT
      REAL*8    CLAT,CLON,CAP,SLMHGT, TINT, SCHA_DCB(*)
C
C LOCAL DECLARATION
C
      INTEGER*4 I, II, ISV, IDX1
      CHARACTER*256 LINETEXT
      REAL*8    DCB
     &         ,TIME
      TINT=0.D0
      CNT=0
C
      I=-2
      II=-2
10    CONTINUE
      READ(LUCOEFF,'(A)',ERR=99,END=20) LINETEXT
      IF( LINETEXT(1:5) .EQ. '>>> G' ) THEN
        DCB=-999.D0
        READ(LINETEXT(4:256),*) ISV, DCB
        IF( ISV .GT. 0 .AND. ISV .LE. 32 .AND. DCB .NE. -999.D0 )
     &      SCHA_DCB(ISV)=DCB
      ELSE IF( LINETEXT(1:5) .EQ. '>>> G' ) THEN
        DCB=-999.D0
        READ(LINETEXT(4:256),*) ISV, DCB
        IF( ISV .GT. 0 .AND. ISV .LE. 24 .AND. DCB .NE. -999.D0 ) 
     &      SCHA_DCB(ISV+32)=DCB
      ELSE IF( LINETEXT(1:14) .EQ. '>>> SCHA clat=' ) THEN
        IDX1=INDEX(LINETEXT,'clat=')
        IF( IDX1 .GT. 0 ) THEN
         READ(LINETEXT(IDX1+5:256),*,ERR=10) CLAT
        ELSE
         GOTO 10
        ENDIF
        IDX1=INDEX(LINETEXT,'clon=')
        IF( IDX1 .GT. 0 ) THEN
         READ(LINETEXT(IDX1+5:256),*,ERR=10) CLON
        ELSE
         GOTO 10
        ENDIF
        IDX1=INDEX(LINETEXT,'cap=')
        IF( IDX1 .GT. 0 ) THEN
         READ(LINETEXT(IDX1+4:256),*,ERR=10) CAP
        ELSE
         GOTO 10
        ENDIF
        IDX1=INDEX(LINETEXT,'order=')
        IF( IDX1 .GT. 0 ) THEN
         READ(LINETEXT(IDX1+6:256),*,ERR=10) NORD
        ELSE
         GOTO 10
        ENDIF
        I=I+1
      ELSE IF( LINETEXT(1:4) .EQ. '>>> ' ) THEN
        IDX1=INDEX(LINETEXT,'SHgt=')
        IF( IDX1 .GT. 0 ) THEN
         READ(LINETEXT(IDX1+5:256),*,ERR=10) SLMHGT
        ELSE
         GOTO 10
        ENDIF
        I=I+1
      ELSE IF( LINETEXT(1:19) .EQ. 'START OF SCHA COEF:' ) THEN
        CNT=CNT+1
      ELSE IF( II .LT. 0 .AND. LINETEXT(1:10) .EQ. 'GPS TIME: ' ) THEN
        IDX1=INDEX(LINETEXT,': ')
        IF( IDX1 .GT. 0 ) THEN
         READ(LINETEXT(IDX1+2:256),*,ERR=10) TIME
         IF( II .EQ. -2 ) THEN
           TINT=TIME
         ELSE
           TINT=TIME-TINT
         ENDIF
         II=II+1
        ELSE
         II=-2
        ENDIF
      ENDIF
      GOTO 10
C
20    CONTINUE
      I=I+II
      REWIND(LUCOEFF)
      IF( I .LT. 0 ) THEN
        CNT=0
        TINT = 0.D0
        SLMHGT=0.D0
        CLAT=0.D0
        CLON=0.D0
        CAP=0.D0
        NORD=-1
        SCHACOEFHEAD=-1
      ELSE
        SCHACOEFHEAD=0
      ENDIF
C
      RETURN
C
99    CONTINUE
      SCHACOEFHEAD=-2
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C READ ONE SET OF SCHA COEFFICIENTS
C
C INPUT:
C      LUCOEFF: LOGICAL UNIT OF COEFFICIENTS FILE
C
C OUTPUT:
C      SCHA_T:    EPOCHS OF COEFFICIENTS
C      SCHA_L:    DEGREES OF COEFFICIENTS
C      SCHA_M:    ORDERS OF COEFFICIENTS
C      SCHA_NMN:  NMN COEFFICIENTS
C      SCHA_ALM:  ALM COEFFICIENTS
C      SCHA_BLM:  BLM COEFFICIENTS
C
      INTEGER*4 FUNCTION SCHACOEFREAD( LUCOEFF, SCHA_T,
     &                                 SCHA_L, SCHA_M, SCHA_NMN,
     &                                 SCHA_ALM, SCHA_BLM )
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
C ARGUMENT DECLARATION
C
      INTEGER*4 LUCOEFF
      INTEGER*4 SCHA_L(*), SCHA_M(*)
      REAL*8 SCHA_T, SCHA_NMN(*), SCHA_ALM(*), SCHA_BLM(*)
C
C LOCAL DECLARATION
C
      INTEGER*4 I,ISV
      REAL*8 SUM_ALM, SUM_BLM
      CHARACTER*256 LINETEXT
C
      I=-2
      SUM_ALM=0.D0
      SUM_BLM=0.D0
100   CONTINUE
      READ(LUCOEFF,'(A)',ERR=999,END=200) LINETEXT
      IF( LINETEXT(1:19) .EQ. 'START OF SCHA COEF:' ) THEN
      I=I+1
      ELSE IF( LINETEXT(1:9) .EQ. 'GPS TIME:' ) THEN
      I=I+1
        READ(LINETEXT(10:256),*) SCHA_T
      ELSE IF( LINETEXT(1:16) .EQ. 'END OF SCHA COEF' ) THEN
        IF( I.EQ.15 )GOTO 200
      I=-2
      ELSE IF( I .LT. 0 .OR. I .GT. 15 ) THEN
      I=-2
      ELSE
      I=I+1
        READ(LINETEXT,*) SCHA_L(I),SCHA_M(I),SCHA_NMN(I),
     &                     SCHA_ALM(I),SCHA_BLM(I)
      SUM_ALM=SUM_ALM+ABS(SCHA_ALM(I))
      SUM_BLM=SUM_BLM+ABS(SCHA_BLM(I))
      ENDIF
      GOTO 100
C
200   CONTINUE
      IF( I .NE. 15 ) THEN
        IF( I .NE. -2 ) THEN
          I=-2
          GOTO 100
        ENDIF
        SCHA_T=0.D0
        DO I=1,15
          SCHA_L(I)=0
          SCHA_M(I)=0
          SCHA_NMN(I)=0.D0
          SCHA_ALM(I)=0.D0
          SCHA_BLM(I)=0.D0
        END DO
        SCHACOEFREAD=-1
      ELSE IF( SUM_ALM .EQ. 0.D0 .AND. SUM_BLM .EQ. 0.D0 ) THEN
        I=-2
        GOTO 100
      ELSE 
        SCHACOEFREAD=0
      ENDIF
C
      RETURN
C
999   CONTINUE
      SCHACOEFREAD=-2
      RETURN
C
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C calculate factorial of non-integer positive value using Gamma function 
C Note: Negative input value is replaced by it's absolute value 
      REAL*8 FUNCTION FACTRL( X )
C
      IMPLICIT NONE
C
C ARGUMENT DECLARATION
C
      REAL*8 X
C
C LOCAL DECLARATION
C
      REAL*8 XX
C
C EXTERNAL FUNCTION DECLARATION
C
      REAL*8 GAMMLN
C
      XX = X
      IF( XX .EQ. 0.D0 ) THEN
        FACTRL=1.D0
      ELSE
        IF( X .LT. 0.D0 ) THEN
         WRITE(*,1000)
         XX = DABS(XX)
      END IF
        FACTRL = DEXP(GAMMLN(XX+1.0D0))
      END IF
      RETURN
1000  FORMAT('FACTRL: WARNING: negative input value!',
     &       ' Absolute value is replaced.')
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C ln gamma(xx) from "Numerical Recipes in C" page 168, cambridge university press 1988 
      REAL*8 FUNCTION GAMMLN( XX )
C
      IMPLICIT NONE
C
C     ARGUMENT DECLARATION
C
      REAL*8 XX
C
C LOCAL DECLARATION
C
      INTEGER*4 J
      REAL*8 X,TMP,SER, COF(6)
C
      DATA COF/76.18009173D0,-86.50532033D0,24.01409822D0,
     &         -1.231739516D0,0.120858003D-2,-0.536382D-5/
C
      X = XX - 1.0D0
      TMP = X + 5.5D0
      TMP = TMP - (X+0.5D0)*DLOG(TMP)
      SER = 1.0D0
      DO J=1,6
        X = X + 1.0
        SER = SER + COF(J)/X
      END DO
      GAMMLN = (-TMP+DLOG(2.50662827465D0*SER))
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C GENERATE AN ARRAY OF ASSOCIATED LEGENDRE FUNCTIONS. 
C
C INPUT:
C     COLAT:        CO-LATITUDE (DEG)
C     M     ARRAY OF DEGREES (POSITIVE ONLY)
C     NMN           ARRAY OF NON-INTEGER ORDERS
C     NUM_MN:     SIZE OF L, M AND NMN
C
C OUTPUT:
C      PDP:  ARRAY OF ASSOCIATED LEGENDRE FUNCTIONS
      SUBROUTINE GET_LEGENDP( COLAT, M, NMN, PDP, NUM_MN )
C
      IMPLICIT NONE
C
C ARGUMENT DECLARATION
C
      INTEGER*4 M(*), NUM_MN
      REAL*8 COLAT, NMN(*), PDP(*)
C
C LOCAL DECLARATION
C
      INTEGER*4 I,J
      REAL*8 AMN(30,60),Y1,Y2,MM,NN,KMN,PMN,DEG2RAD
C
C EXTERNAL FUNCTION DECLARATION
C
      REAL*8 FACTRL
C
      DEG2RAD=2.D0*DACOS(0.D0)/180.D0
C
      Y1 = DSIN(COLAT*DEG2RAD)
      Y2 = DSIN((COLAT/2.0D0)*DEG2RAD)
C
      DO I=1,NUM_MN
        PMN = 0.0D0
        MM  = M(I)
        NN  = NMN(I)
        IF( MM .EQ. 0 ) THEN
          KMN = 1.0D0
        ELSE
         KMN = ((-1)**MM)/(2**MM)/FACTRL(MM)*FACTRL(NN+MM)/FACTRL(NN-MM)
        ENDIF
        AMN(I,1) = KMN*(Y1**MM)
        PMN = PMN + AMN(I,1)
        DO J=1,59
         AMN(I,J+1) = ((J+MM-1)*(J+MM)-NN*(NN+1))/(J*(J+MM))*AMN(I,J)
         PMN = PMN + AMN(I,J+1) * (Y2**(2*J))
        ENDDO
        PDP(I) = PMN
      END DO
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C Shift coordinate to spherical cap around user requested center 
C
C Input:        
C        nlat:   center latitude (deg)
C        nnlon:  center longitude  (deg)
C      lat1:   latitude in the original coordinate system (deg)
C      lon1:    longitude in the original coordinate system (deg)
C Output: 
C        Slat: shifted lat (deg)
C        Slon: shifted lon (deg)
      SUBROUTINE shift_to_poleP( nlat, nnlon, lat1, llon1, Slat, Slon )
C
      IMPLICIT NONE
C
C ARGUMENT DECLARATION
C
      REAL*8 nlat, nnlon, lat1, llon1, Slat, Slon
C
C LOCAL DECLARATION
C
      REAL*8 nlon,lon1
      REAL*8 ncolat, csn, snn, colat1, colat2, lon3, cs1,
     &       tempac, tempac2, tempdenom, lat2, lon2, DEG2RAD
C
      DEG2RAD=2.D0*DACOS(0.D0)/180.D0
C
C spherical cap centered about the north pole 
C
      IF( nlat .EQ. 90.0D0 ) THEN
        Slat = lat1
        Slon = llon1
        RETURN
      END IF
C
C spherical cap centered about the south pole 
C
      IF( nlat .EQ. -90.0D0 ) THEN
        Slat = -lat1
        Slon = llon1
        RETURN
      END IF
C
C definitions and checks require that longitude be defined in the range [0,360) 
C
      nlon=nnlon
      lon1=llon1
      IF( nlon .LT. 0.0D0 ) nlon = nlon + 360.0D0
      IF( lon1 .LT. 0.0D0 ) lon1 = lon1 + 360.0D0
C
C  transform latitude into colatitude 
C
      ncolat = 90.0D0 - nlat
      colat1 = 90.0D0 - lat1
C
C rotate the longitude to 0 degrees 
C
      lon2 = lon1-nlon
      IF( lon2 .LT. 0.0D0 ) lon2 = lon2 + 360.0
      cs1=DCOS(colat1*DEG2RAD)
      csn=DCOS(ncolat*DEG2RAD)
      snn=DSIN(ncolat*DEG2RAD)
C
C determine the shifted colatitude and latitude 
C
      tempac2=cs1*csn+DSIN(colat1*DEG2RAD)*snn*DCOS(lon2*DEG2RAD)
      IF( tempac2 .LT. -1.0D0 ) tempac2 = -1.0D0
      IF( tempac2 .GT. 1.0D0 ) tempac2 = 1.0D0
      colat2=DACOS(tempac2)/DEG2RAD
      lat2 = 90.0D0 - colat2
C
C determine the shifted longitude
C since acosd=[0,180] and longitude=[0,360], the angle quadrant must be checked  
C
      tempdenom = DSIN(colat2*DEG2RAD)*snn
C  avoid singularity problem 
      IF( tempdenom .EQ. 0.0D0 ) tempdenom = 1D-9
      tempac = (-cs1+DCOS(colat2*DEG2RAD)*csn)/tempdenom
      IF( tempac .LT. -1.0D0 ) tempac = -1.0D0
      IF( tempac .GT. 1.0D0 ) tempac = 1.0D0
      lon3 = DACOS(tempac)/DEG2RAD
      IF( lon2 .GT. 180.0D0 )  lon3=360.0D0-lon3
      lon2 = lon3
      IF( lat1 .EQ. nlat .AND. lon1 .EQ. nlon ) THEN
        lat2 = 90.0D0
        lon2 = 0.0D0
      END IF
      Slat = lat2
      Slon = lon2
C
      RETURN
C
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      SUBROUTINE SCHACOEFBUF( LUION, IDIR, UTTAG, CNT, TINT,
     &                        SCHA_T, SCHA_L, SCHA_M, SCHA_NMN,
     &                        SCHA_ALM, SCHA_BLM, NSET )
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
C ARGUMENT DECLARATION
C
      INTEGER*4 LUION, IDIR, NSET, SCHA_L(MAXSHCOEF,*),
     &          SCHA_M(MAXSHCOEF,*)
     &         ,CNT
      REAL*8 UTTAG, SCHA_T(*), SCHA_NMN(MAXSHCOEF,*),
     &       SCHA_ALM(MAXSHCOEF,*),
     &       SCHA_BLM(MAXSHCOEF,*), TINT
C
C LOCAL DECLARATION
C
      INTEGER*4 RESULT,NREAD
C
C EXTERNAL FUNCTION DECLARATION
C
      INTEGER*4 SCHACOEFREAD
C
      REWIND(LUION)
      NSET = 2-NSET
      IF( NSET .LT. 0 ) NSET=0
      IF( NSET .GT. 1 ) NSET=1
    1 CONTINUE
      RESULT=SCHACOEFREAD( LUION, SCHA_T(NSET+1), SCHA_L(1,NSET+1),
     &                     SCHA_M(1,NSET+1), SCHA_NMN(1,NSET+1),
     &                     SCHA_ALM(1,NSET+1), SCHA_BLM(1,NSET+1))
      IF( RESULT .EQ. 0 ) THEN
        NREAD=NREAD+1
        IF( NREAD .GE. CNT-1 .OR.
     &      (SCHA_T(NSET+1)+(1-NSET+0.5)*TINT .GE. UTTAG) )
     &      NSET=NSET+1
        IF( NREAD .LT. CNT .AND. NSET .LT. 2 ) GOTO 1
      ENDIF
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C************************************************************ SHCOEFF
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
C SUBROUTINE TO CALCULATE TEC AT A SINGLE POINT FROM SH COEF SETS.
C THIS ALSO INCLUDES TEMPORAL INTERPOLATION OF RESULTS BETWEEN COEF SETS 
C 
C 
C     IF USER TIME IS COINCIDE EXACTLY WITH THE TIME OF LAST AVAILABLE COEF SET, IT IS ALSO PROCESSED
C
C INPUT: 
C     GEOLAT:    GEODETIC LATITUDE [-90,90] (DEG) 
C     GEOLON:    GEODETIC LONGITUDE [-180,180] OR [0,360] (DEG)
C     TIM:       GPS TIME
C     SH_T:      EPOCHS OF COEFFICIENTS
C     SH_N:      DEGREES OF COEFFICIENTS
C     SH_M:      ORDERS OF COEFFICIENTS
C     SH_ANM:    ANM COEFFICIENTS FOR TEC
C     SH_BNM:    BNM COEFFICIENTS FOR TEC
C     SH_SANM:   ANM COEFFICIENTS FOR TEC SIGMA
C     SH_SBNM:   BNM COEFFICIENTS FOR TEC SIGMA
C     NSET:      NUMBER OF COEF. SETS IN THE SH COEF. FILE
C OUTPUT:
C      TECP: TEC (TECU)
C      STECP: TEC (TECU) SIGMA
C      SUBROUTINE RETURNS: 1  ABLE TO PROCESS
C                          0  ELSE
C NOTE: (S)TEC VALUES MIGHT BE REPORTED AS: -999.99 IN 2 CASES:
C  1- THE RESULTED VALUE IS NEGATIVE OR VERY LARGE (>100) 
C  2- WHEN COEF SETS PERIOD DO NOT COVER THE USER TIME
C
      SUBROUTINE IPPSH2TEC( GEOLAT, GEOLON, TIM, SH_TINT, SH_REF,
     &                      SH_T, SH_N, SH_M, SH_ANM, SH_BNM,
     &                      SH_SANM, SH_SBNM, NSET, TECP, STECP )
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
C ARGUMENT DECLARATION
C
      INTEGER*4 NSET, SH_REF, SH_N(MAXSHCOEF,*), SH_M(MAXSHCOEF,*)
      REAL*8 GEOLAT, GEOLON, TIM, TECP, STECP, SH_TINT
      REAL*8 SH_T(*), SH_ANM(MAXSHCOEF,*), SH_BNM(MAXSHCOEF,*),
     &       SH_SANM(MAXSHCOEF,*), SH_SBNM(MAXSHCOEF,*)
C
C LOCAL DECLARATION
C
      INTEGER*4 I,J,IDX
     &        , DOY, YEAR, MTH, DAY, GPSWK, WKDAY
      REAL*8 DEG2RAD
      REAL*8 PMNX(MAXSHCOEF), SLAT, SLON, T1INT, T2INT, MAGLON,
     &       TEC1, TEC2, STEC1, STEC2, TEC, STEC
C
C INITIALIZATIONS
C
      TEC=-999.99D0
      STEC=-999.99D0
C
      DEG2RAD=2.D0*DACOS(0.D0)/180.D0
      IF( SH_REF .EQ. 1 ) THEN
        SLAT=GEOLAT*DEG2RAD
        SLON=GEOLON*DEG2RAD
     &      +DMOD(TIM/240D0,360.D0)*DEG2RAD
      ELSE
        GPSWK = TIM/604800.
        WKDAY = TIM/86400 - GPSWK*7
        CALL GPSDC( DOY, YEAR, MTH, DAY, GPSWK, WKDAY, 3 )
        CALL GEO_TO_MAG( YEAR, DOY, INT(TIM),
     &                   GEOLAT*DEG2RAD, GEOLON*DEG2RAD,
     &                   SLAT, MAGLON, SLON, 0 )
      ENDIF
      CALL GET_SHLEGENDP( SLAT, PMNX, MAXSHDEG)
C
C INTERPOLATION
C
      DO J=2,NSET
        IF( ( TIM .GE. SH_T(J-1)+SH_TINT/2.D0 .AND.
     &        TIM .LE. SH_T(J  )+SH_TINT/2.D0 ) .OR.
     &      ( J .EQ. 2 .AND.
     &               TIM .LT. SH_T(J-1)+SH_TINT/2.D0  .AND.
     &               TIM .GE. SH_T(J-1) ) .OR.
     &      ( J .EQ. NSET .AND.
     &               TIM .GT. SH_T(J  )+SH_TINT/2.D0 .AND.
     &               TIM .LE. SH_T(J  )+SH_TINT ) ) THEN
          T1INT = (SH_T(J)+SH_TINT/2.D0 - TIM)/
     &                         (SH_T(J) - SH_T(J-1))
          T2INT = (TIM - SH_T(J-1)-SH_TINT/2.D0)/
     &                         (SH_T(J) - SH_T(J-1))
          TEC1=0.0D0
          TEC2=0.0D0
          STEC1=0.0D0
          STEC2=0.0D0
          DO I=1,MAXSHCOEF
            IF( T1INT .NE. 0.D0 ) THEN
             IDX=1+SH_M(I,J-1)+(SH_N(I,J-1)*(SH_N(I,J-1)+1))/2
             IF( IDX .GT. 0 ) THEN
             TEC1 = TEC1 +
     &        PMNX(IDX)*
     &        ( SH_ANM(IDX,J-1)*DCOS(SH_M(IDX,J-1)*SLON)+
     &          SH_BNM(IDX,J-1)*DSIN(SH_M(IDX,J-1)*SLON) )
             STEC1 = STEC1 +
     &        (PMNX(IDX)*
     &         SH_SANM(IDX,J-1)*DCOS(SH_M(IDX,J-1)*SLON))**2+
     &        (PMNX(IDX)*
     &         SH_SBNM(IDX,J-1)*DSIN(SH_M(IDX,J-1)*SLON))**2
             ENDIF
            ENDIF
            IF( T2INT .NE. 0.D0 ) THEN
             IDX=1+SH_M(I,J  )+(SH_N(I,J  )*(SH_N(I,J  )+1))/2
             IF( IDX .GT. 0 ) THEN
             TEC2 = TEC2 +
     &        PMNX(IDX)*
     &        ( SH_ANM(IDX,J  )*DCOS(SH_M(IDX,J  )*SLON)+
     &          SH_BNM(IDX,J  )*DSIN(SH_M(IDX,J  )*SLON) )
             STEC2 = STEC2 +
     &        (PMNX(IDX)*
     &         SH_SANM(IDX,J  )*DCOS(SH_M(IDX,J  )*SLON))**2+
     &        (PMNX(IDX)*
     &         SH_SBNM(IDX,J  )*DSIN(SH_M(IDX,J  )*SLON))**2
             ENDIF
            ENDIF
          END DO
          TEC = T1INT*TEC1+T2INT*TEC2
          STEC = SQRT( T1INT**2*STEC1 + T2INT**2*STEC2 )
C
C REPLACE INVALID VALUES WITH -999.99
C
          IF( TEC .LT. 0.D0 .OR. TEC .GT. 4.D2 ) THEN
            TEC = -999.99
            STEC = -999.99
          END IF
        END IF
      END DO
C
      TECP = TEC
      STECP = STEC
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C GENERATE AN ARRAY OF ASSOCIATED LEGENDRE FUNCTIONS. 
C INPUT:
C     LAT:        CO-LATITUDE (DEG)
C     NUM_MN:     SIZE OF L, M AND NMN
C
C OUTPUT:
C      PDP:  ARRAY OF ASSOCIATED LEGENDRE FUNCTIONS
C
      SUBROUTINE GET_SHLEGENDP( LAT, PDP, NUM_MN )
C
      IMPLICIT NONE
C
C ARGUMENT DECLARATION
C
      INTEGER*4 NUM_MN
      REAL*8 LAT, PDP(*)
C
C LOCAL DECLARATION
C
      INTEGER*4 I,J
      REAL*8 U,T
C
      U = DCOS(LAT)
      T = DSIN(LAT)
C
C     PMNX=VECTOR(0,NUM_MN)
C
      PDP(1) = 1.D0
      IF( NUM_MN .EQ. 0 ) RETURN
      PDP(2) = SQRT(3.D0)*T
      PDP(3) = SQRT(3.D0)*U
      IF( NUM_MN .EQ. 1 ) RETURN
      DO I=2,NUM_MN
        PDP(1+I+I*(I+1)/2) =
     &     SQRT( (2.D0*I+1.D0)/2.D0/I ) * U * PDP(1+(I-1)+I*(I-1)/2)
      END DO
      DO I=2,NUM_MN
        DO J=0,I-1
          PDP(1+J+I*(I+1)/2) = 
     &  SQRT( (2.D0*I+1.D0)/(I+J)/(I-J)*(2.D0*I-1.D0)) * T *
     &                                   PDP(1+J+(I-1)*I/2)
          IF( I-2.GE.J ) THEN
           PDP(1+J+I*(I+1)/2) = PDP(1+J+I*(I+1)/2) -
     &        PDP(1+J+(I-2)*(I-1)/2) *
     &        SQRT((2.D0*i+1.d0)/(2.d0*i-3.D0)*
     &                    (I+J-1.D0)/(I+J)*(I-J-1.D0)/(I-J))
          ENDIF
        END DO
      END DO
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      INTEGER*4 FUNCTION SHCOEFHEAD( LUCOEFF, NDEG, NORD, CNT, TINT,
     &                               SLMHGT, SH_DCB, SH_REF  )
C
      IMPLICIT NONE
C
C ARGUMENT DECLARATION
C
      INTEGER*4 LUCOEFF,NDEG,NORD,CNT
     &         , SH_REF
      REAL*8    SLMHGT,TINT,SH_DCB(*)

C LOCAL DECLARATION
C
      INTEGER*4 I,II,ISV,IDX1,IDX2
      REAL*8    DCB,TIME
      CHARACTER*256 LINETEXT
C
      SH_REF=-1
      I=-2
      II=-2
      TINT=0.D0
      CNT=0.D0
10    CONTINUE
      READ(LUCOEFF,'(A)',ERR=99,END=20) LINETEXT
      IF( LINETEXT(1:5) .EQ. '>>> G' ) THEN 
        DCB=-999.D0
        READ(LINETEXT(6:256),*) ISV, DCB
        IF( ISV .GT. 0 .AND. ISV .LE. 32 .AND. DCB .NE. -999.D0 )
     &      SH_DCB(ISV)=DCB
      ELSE IF( LINETEXT(1:5) .EQ. '>>> R' ) THEN 
        DCB=-999.D0
        READ(LINETEXT(6:256),*) ISV, DCB
        IF( ISV .GT. 0 .AND. ISV .LE. 24 .AND. DCB .NE. -999.D0 ) 
     &      SH_DCB(ISV+32)=DCB
      ELSE IF( LINETEXT(1:18) .EQ. '>>> SH(Gmag), deg=' .OR.
     &         LINETEXT(1:18) .EQ. '>>> SH(Geod), deg=' ) THEN
        IF( LINETEXT(1:18) .EQ. '>>> SH(Gmag), deg=' ) THEN
         SH_REF=0
        ELSE IF( LINETEXT(1:18) .EQ. '>>> SH(Geod), deg=' ) THEN
         SH_REF=1
        END IF
        IDX1=INDEX(LINETEXT,'deg=')
        IF( IDX1 .GT. 0 ) THEN
         READ(LINETEXT(IDX1+4:256),*,ERR=10) NDEG
        ELSE
         GOTO 10
        ENDIF
        IDX1=INDEX(LINETEXT,'ord=')
        IF( IDX1 .GT. 0 ) THEN
         READ(LINETEXT(IDX1+4:256),*,ERR=10) NORD
        ELSE
         GOTO 10
        ENDIF
        I=I+1
      ELSE IF( LINETEXT(1:4) .EQ. '>>> ' ) THEN
        IDX1=INDEX(LINETEXT,'SHgt=')
        IF( IDX1 .GT. 0 ) THEN
         READ(LINETEXT(IDX1+5:256),*,ERR=10) SLMHGT
        ELSE
         GOTO 10
        ENDIF
        I=I+1
      ELSE IF( LINETEXT(1:17) .EQ. 'START OF SH COEF:' ) THEN
        CNT=CNT+1
      ELSE IF( II.LT.0 .AND. LINETEXT(1:10) .EQ. 'GPS TIME: ' ) THEN
        IDX1=INDEX(LINETEXT,': ')
        IF( IDX1 .GT. 0 ) THEN
          READ(LINETEXT(IDX1+2:256),*,ERR=10) TIME
          IF( II .EQ. -2 ) THEN
           TINT=TIME
          ELSE
           TINT=TIME-TINT
          ENDIF
          II=II+1
        ELSE
          II=-2
        ENDIF
      ENDIF
      GOTO 10
C
20    CONTINUE
      I=I+II
      REWIND(LUCOEFF)
      IF( I .LT. 0 .OR.
     &    SH_REF .LT. 0 .OR.
     &    NORD .GT. 15 .OR. NDEG .GT. 15 .OR.
     &    NORD .GT. NDEG .OR.
     &    NORD .LT.  1 .OR. NDEG .LT.  1 ) THEN
        CNT=0
        SLMHGT=0.D0
        NDEG=-1
        NORD=-1
        TINT=0.D0
        SH_REF = -1
        SHCOEFHEAD=-1
      ELSE
        SHCOEFHEAD=0
      ENDIF
C
      RETURN
C
99    CONTINUE
      SHCOEFHEAD=-2
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C READ ONE SET OF SH COEFFICIENTS
C
C INPUT:
C      LUCOEFF: LOGICAL UNIT OF COEFFICIENTS FILE
C      NDEG: 
C      NORD: 
C
C OUTPUT:
C      SH_T:    EPOCHS OF COEFFICIENTS
C      SH_N:    DEGREE OF COEFFICIENTS
C      SH_M:    ORDER OF COEFFICIENTS
C      SH_ANM:  ANM COEFFICIENTS FOR TEC
C      SH_BNM:  BNM COEFFICIENTS FOR TEC
C      SH_SANM: ANM COEFFICIENTS FOR TEC SIGMA
C      SH_SBNM: BNM COEFFICIENTS FOR TEC SIGMA
C
      INTEGER*4 FUNCTION SHCOEFREAD( LUCOEFF, NDEG, NORD, SH_REF,
     &                               SH_T, SH_N, SH_M, SH_ANM, SH_BNM,
     &                               SH_SANM, SH_SBNM)
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
C ARGUMENT DECLARATION
C
      INTEGER*4 LUCOEFF,NDEG,NORD, SH_REF
      INTEGER*4 SH_N(*), SH_M(*)
      REAL*8 SH_T, SH_ANM(*), SH_BNM(*), SH_SANM(*), SH_SBNM(*)
C
C LOCAL DECLARATION
C
      INTEGER*4 I,NREC
      CHARACTER*256 LINETEXT
      REAL*8 CNM,SNM,SCNM,SSNM,ROT_TO_0H00
C
      ROT_TO_0H00=0.D0
      NREC=((NORD+1)*(NORD+2))/2+(NDEG-NORD)*NORD
      I=-2
100   CONTINUE
      READ(LUCOEFF,'(A)',ERR=999,END=200) LINETEXT
      IF( LINETEXT(1:17) .EQ. 'START OF SH COEF:' ) THEN
        I=I+1
      ELSE IF( LINETEXT(1:9) .EQ. 'GPS TIME:' ) THEN
        I=I+1
        READ(LINETEXT(10:256),*,ERR=999) SH_T
      ELSE IF( LINETEXT(1:14) .EQ. 'END OF SH COEF' ) THEN
        IF( I.EQ.NREC )GOTO 200
        I=-2
      ELSE IF( I .LT. 0 .OR. I .EQ. NREC ) THEN
        I=-2
      ELSE
        I=I+1
        READ(LINETEXT,*,ERR=999) SH_N(I),SH_M(I),CNM,
     &                   SNM,SCNM,SSNM
        IF( SH_REF .EQ. 1 )
     &  ROT_TO_0H00=-DACOS(0.D0)*DMOD(SH_T,86400.D0)/21600D0
        SH_ANM(I)=DCOS(SH_M(I)*ROT_TO_0H00)*CNM
     &           +DSIN(SH_M(I)*ROT_TO_0H00)*SNM
        SH_BNM(I)=DCOS(SH_M(I)*ROT_TO_0H00)*SNM
     &           -DSIN(SH_M(I)*ROT_TO_0H00)*CNM
        SH_SANM(I)=DCOS(SH_M(I)*ROT_TO_0H00)*SCNM
     &            +DSIN(SH_M(I)*ROT_TO_0H00)*SSNM
        SH_SBNM(I)=DCOS(SH_M(I)*ROT_TO_0H00)*SSNM
     &            -DSIN(SH_M(I)*ROT_TO_0H00)*SCNM
      ENDIF
      GOTO 100
C
200   CONTINUE
      IF( I .NE. NREC ) THEN
        IF( I .NE. -2 ) THEN
          I=-2
          GOTO 100
        ENDIF
        SH_T=0.D0
        DO I=1,NREC
          SH_N(I)=0
          SH_M(I)=0
          SH_ANM(I)=0.D0
          SH_BNM(I)=0.D0
          SH_SANM(I)=0.D0
          SH_SBNM(I)=0.D0
        END DO
        SHCOEFREAD=-1
      ELSE
        SHCOEFREAD=0
      ENDIF
      IF( NREC .LT. MAXSHCOEF ) THEN
        DO I=NREC+1,MAXSHCOEF
          SH_N(I)=-1
          SH_M(I)=-1
          SH_ANM(I)=0.D0
          SH_BNM(I)=0.D0
          SH_SANM(I)=0.D0
          SH_SBNM(I)=0.D0
        END DO
      ENDIF
C
      RETURN
C
999   CONTINUE
      SHCOEFREAD=-2
      RETURN
C
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
      SUBROUTINE SHCOEFBUF( LUION, IDIR, UTTAG, CNT, TINT, SH_REF,
     &                      NDEG, NORD, SH_T, SH_N, SH_M, SH_ANM,
     &                      SH_BNM, SH_SANM, SH_SBNM, NSET )
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
C ARGUMENT DECLARATION
C
      INTEGER*4 LUION, IDIR, CNT, NSET, NDEG, NORD,
     &          SH_N(MAXSHCOEF,*), SH_M(MAXSHCOEF,*), SH_REF
      REAL*8 UTTAG, TINT, SH_T(*), SH_ANM(MAXSHCOEF,*),
     &       SH_BNM(MAXSHCOEF,*), SH_SANM(MAXSHCOEF,*),
     &       SH_SBNM(MAXSHCOEF,*)
C
C LOCAL DECLARATION
C
      INTEGER*4 RESULT,NREAD
C
C EXTERNAL FUNCTION DECLARATION
C
      INTEGER*4 SHCOEFREAD
C
      REWIND(LUION)
      NSET = 2-NSET
      IF( NSET .LT. 0 ) NSET=0
      IF( NSET .GT. 1 ) NSET=1
    1 CONTINUE
      RESULT=SHCOEFREAD( LUION, NDEG, NORD, SH_REF, SH_T(NSET+1),
     &                   SH_N(1,NSET+1), SH_M(1,NSET+1),
     &                   SH_ANM(1,NSET+1), SH_BNM(1,NSET+1),
     &                   SH_SANM(1,NSET+1), SH_SBNM(1,NSET+1))
      IF( RESULT .EQ. 0 ) THEN
        NREAD=NREAD+1
        SH_T(NSET+1)=SH_T(NSET+1)-DMOD(SH_T(NSET+1),TINT)
        IF( NREAD .GE. CNT-1 .OR.
     &      SH_T(NSET+1)+(1-NSET+0.5)*TINT .GE. UTTAG )
     &    NSET=NSET+1
        IF( NREAD .LT. CNT .AND. NSET .LT. 2 ) GOTO 1
      ENDIF
      RETURN
    2 FORMAT("SHCOEFBUF READ ",I4," SETS FROM",F12.1," TO",F12.1)
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** SIDTM
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SIDTM(MJD,FMJDDT,GPSUTC,UT1UTC,DUT1,
     &                   ALPHAE,SIDT)
C
C FUNCTION:  SIDTM CONVERTS MODIFIED JULIAN DATE (DMJ)
C                        AND TIME OF DAY (IHR,IMN,SEC)
C                        TO SIDERAL TIME IN DECIMAL HOURS.
C
C INPUT: MJD   = MODIFIED JULIAN DATE
C        FMJDDT= FRACTIONAL PART OF MODIFIED JULIAN DATE
C        GPSUTC= GPS-UTC TIME DIFFERENCE
C        UT1UTC= UT1-UTC TIME DIFFERENCE
C        DUT1  = UT1 TIME OFFSET
C
C OUTPUT:SIDT = SIDERAL TIME
C
      IMPLICIT NONE
C
      INTEGER*4 MJD
      REAL*8    FMJDDT,GPSUTC,UT1UTC,DUT1,ALPHAE,SIDT
C
      INTEGER*4 ISIDY
      REAL*8    FMJD,SECDAY,GMJD,D,HDOT,H,SID,UT1,SIDHR
C
      UT1UTC = 0.D0
      DUT1   = 0.D0
      ALPHAE = 0.D0
      SECDAY=FMJDDT*86400.D0
C  Jan 1, 2000 , 0h UT = MJD 51544
      FMJD=MJD-0.5D0-51544.0D0
      GMJD=FMJD/36525.D0
C
      UT1=UT1UTC+DUT1+GPSUTC
C
C   UPDATED TO J2000 SYSTEM.
C
      D=13750.987083139756D0
      HDOT=1.002737909350795D0+5.900575456D-11*GMJD
      H=24110.54841D0+GMJD*(8640184.812866D0+GMJD*(0.093104D0-
     +  GMJD*6.2D-6))+(UT1+ SECDAY)*HDOT
      SID=H+ALPHAE*D
      SIDHR=SID/3600.D0
      ISIDY=SIDHR/24.D0
      SIDT=SIDHR-DBLE(ISIDY*24)
C  change from hrs to radians
      SIDT= SIDT*3.141592654d0/12.d0
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C************************************************************** SLMNAME
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SLMNAME ( LU, LUO, LPR, LUSLM, NAMSLM,
     &                     IYEAR, IMTH, IDAY, NMID, ISLMFMT, 
     &                     IERR, LNG )
C
C     NAME:      SLMNAME
C
C     PURPOSE:   ASSIGN SINGLE LAYER FILE NAMES TO LOGICAL UNITS
C
C     PARAMETERS        DESCRIPTION
C
C        LU             LOGICAL UNIT OF SCREEN INPUT
C        LUO            LOGICAL UNIT OF SCREEN OUTPUT
C        LUSLM  LOGICAL UNIT OF INPUT SINGLE LAYER FILE
C        NAMSLM SINGLE LAYER FILE NAME
C          IYEAR        YEAR OF OBSERVATIONS
C          IMTH         MONTH OF OBSERVATIONS
C          IDAY         DAY OF OBSERVATIONS
C          IMID         MIDNIGHT CROSSING FLAG
C
      IMPLICIT NONE
C
      INTEGER*4     LU,LUO,LPR,LUSLM
      INTEGER*4     IYEAR,IMTH,IDAY,NMID,ISLMFMT,IERR,LNG
      CHARACTER*80  NAMSLM(*)
C
      CHARACTER*80  RECORD
      CHARACTER*20  COMMENT
C
      INTEGER*4     IR
      INTEGER*4     IOS,    IDUM,  IMIDX, IDOY
      INTEGER*4     IYSLM,  IMSLM, IDSLM, IDATES
      INTEGER*4     IYOBS,  IMOBS, IDOBS, IDATEO
      INTEGER*4     IWKOBS, IDWKOBS, IRC, IPRN
      INTEGER*4     IWKSLM, IMID
      INTEGER*4     NERR
      INTEGER*4     LUGRD
      REAL*8        DUM, ISEC
      INTEGER*4 EOF, InxHeadRead, GetInxDay
      DATA EOF/0/
C
      IERR=0
      NERR=3
      IDATES=0
      IYOBS=IYEAR
      IMOBS=IMTH
      IDOBS=IDAY
      IMIDX = NMID
      LUGRD=LUSLM
C
      DO IMID=1,NMID
  100   CONTINUE
        CALL GPSDC ( IDOY, IYOBS, IMOBS, IDOBS, IWKOBS, IDWKOBS, 2)
        IDATEO=IWKOBS*7+IDWKOBS
        IF ( LNG .EQ. 1 ) 
     &    WRITE(LUO,10040) MOD(IYOBS,100),IMOBS,IDOBS
        IF ( LNG .EQ. 2 ) 
     &    WRITE(LUO,10041) MOD(IYOBS,100),IMOBS,IDOBS
        READ(LU,10020) NAMSLM(IMID)
c!      write(*,*) namslm(imid)
C      
        OPEN  ( LUGRD, FILE=NAMSLM(IMID), STATUS='OLD', IOSTAT=IOS, 
     &          ERR=120 )        
C
C       DETERMINE IONOSPHERIC GRID FORMAT
C
        CALL GRDFMT(LUGRD,LUO,ISLMFMT)
c!      WRITE(*,*) 'ISLMFMT IN SLMNAM',ISLMFMT
C
C Non-MRTCA formats
C
C
C       READ AND CHECK DATE FROM NRCan FILE
C
        IF ( ISLMFMT .LT. 3 ) THEN
C
C       READ AND CHECK DATE FROM IONEX FILE
C
         IF ( ISLMFMT .EQ. 1 ) THEN
          IRC= InxHeadRead( LUGRD, EOF )
          IF (IRC .NE. 0 .OR. EOF .NE. 0 ) GOTO 120
          IRC= GetInxDay( IYSLM, IMSLM, IDSLM )
          IF (IRC .NE. 0 ) GOTO 120
          REWIND (LUGRD)
         END IF
C
C       READ AND CHECK DATE FROM RINEX FILE
C
         IF ( ISLMFMT .EQ. 2 ) THEN
  110     CONTINUE
          READ(LUGRD,'(A80)',END=120,ERR=120) RECORD
          COMMENT = RECORD(61:80)
          IF ( COMMENT .EQ. '                    ' .OR.
     &            COMMENT .EQ. 'END OF HEADER       ') THEN
            READ(LUGRD,'(4I3)',END=120,ERR=120) IPRN,IYSLM,IMSLM,IDSLM
            IF ( IYSLM .GE. 0 .AND. IYSLM .LT. 80 ) THEN
            IYSLM = IYSLM + 2000
            ELSE
            IYSLM = IYSLM + 1900
            END IF
            REWIND (LUGRD)
          ELSE  
            GO TO 110
          END IF
         END IF
C      
         CALL GPSDC ( IDOY, IYSLM, IMSLM, IDSLM, IWKSLM, IDSLM, 2)
         IDATES=IWKSLM*7+IDSLM
C
C       READ AND CHECK DATE FROM MRTCA FILE
C
        ELSE IF ( ISLMFMT .LT. 7 ) THEN
         IF( ISLMFMT .EQ. 3 .OR. ISLMFMT .EQ. 6 ) THEN
           READ(LUGRD,*,ERR=120) ISEC
         ELSE
           DO IR=1,100
             READ(LUGRD,'(A80)',ERR=120) RECORD
             IF( RECORD(1:9) .EQ. 'GPS TIME:' )
     &         READ(RECORD,'(10X,F10.0)',ERR=120) ISEC    
           ENDDO
         ENDIF
         IDATES=(ISEC/86400)+1
         IWKSLM=(ISEC/604800)
         IDSLM=IDATES-IWKSLM*7
         CALL GPSDC ( IDOY, IYSLM, IMSLM, IDSLM, IWKSLM, IDSLM, 4)
        ELSE
C
C       UNKNOWN FORMAT
C
         GOTO 120
        END IF
        IF ( IDATEO .EQ. 0 .OR. IDATES .EQ. IDATEO ) GO TO 130
C
C     ERROR ENCOUNTERED OPENING OR READING FILE, TRY AGAIN
C
  120   CONTINUE
        IF ( IDATES .NE. IDATEO ) THEN 
          IF ( LNG .EQ. 1 )
     &      WRITE(LUO,10090) MOD(IYSLM,100),IMSLM,IDSLM
          IF ( LNG .EQ. 2 )
     &      WRITE(LUO,10091) MOD(IYSLM,100),IMSLM,IDSLM
        ELSE
        WRITE(LUO,10100) IOS, NAMSLM(IMID)
        END IF
        IERR = IERR+1
        IF (IERR .GT. NERR) GO TO 1000
        CLOSE (LUGRD)
        GO TO 100
C
C       PREPARE TO VALIDATE NEXT DATE
C
  130   CONTINUE
        IDWKOBS=IDWKOBS+1
        IF (MOD(IDWKOBS,8).EQ.0) THEN
          IDWKOBS=1
        IWKOBS=IWKOBS+1
        END IF
        CALL GPSDC ( IDOY, IYOBS, IMOBS, IDOBS, IWKOBS, IDWKOBS, 4)
      END DO
C
C
C     ASSIGN FIRST DATE TO LUEPH
C
      CLOSE(LUSLM)
      OPEN  (LUSLM,FILE=NAMSLM(1),STATUS='OLD')  
C
 1000 CONTINUE
C
C-----------------------------------------------------------------------
C               FORMAT STATEMENTS
C-----------------------------------------------------------------------
C
10020 FORMAT( A80 )
10040 FORMAT( ' Enter IONOSPHERIC GRID file name for ',
     &          2(I2.2,'/'),I2.2,' :')
10041 FORMAT( ' Entrez le nom du fichier de GRILLES IONOSPHERIQUE du ',
     &          2(I2.2,'/'),I2.2,' :')
10090 FORMAT( ' IONOSPHERIC GRID file for ', 2(I2.2,'/'),I2.2,
     &        ' does not match OBSERVATION ')
10091 FORMAT( ' La date du fichier de GRILLES IONOSPHERIQUES du ',
     &          2(I2.2,'/'),I2.2,
     &        ' ne correspond pas a celle des OBSERVATIONS du ', 
     &          2(I2.2,'/'),I2.2)
10100 FORMAT( ' ERROR/ERREUR SR FNAME',I9,' FILE/FICHIER ',  A80 )
20000 FORMAT (11(I4,1X))
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** SMBWD
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SMBWD ( LUPX, NFPAR, NSVO, C, TTAGB, UPDINT,
     &              XRVEPO, XRVAPR, XCOR, PX, OPX, LSTFWDVX,
     &              SMTHCLK,
C Feb 12, 2015
     &              SOBWD,SO,STRTTAG, MINFX, NFIX,ISMEPO, IMODE )
C
C     NAME              SMBWD 
C
C     PURPOSE         BACKWARD SUBSTITUTION    
C
C     PARAMETERS        DESCRIPTION
C
C          LUPX         LOGIGAL UNIT OF FORWARD PARAMETERS AND VARIANCES
C          NFPAR        NUMBER OF STATION PARAMETERS 
C          NSVO         NUMBER OF SATELLTES OBSERVED AT THIS EPOCH
C          C            SPEED OF LIGHT
C          TTAGB        TIME TAG OF BACKWARD OBSERVATION EPOCH
C          UPDINT       SOLUTION UPDATE INTERVAL
C          XRVEPO       EPOCH PARAMETERS
C          XRVAPR       APRIORI PARAMETERS
C          PX           EPOCH VARIANCE-COVARIANCE
C          OPX          APRIORI VARIANCE-COVARIANCE
C          ISMEPO       SMOOTHED EPOCH (0=NO,1=YES)
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4 NFPAR, LUPX, NSVO, ISMEPO
     &         ,IMODE
      LOGICAL*4 SMTHCLK
      REAL*8    XRVEPO(*),XRVAPR(*),XCOR(MAXPAR2,1)  
      REAL*8    PX(MAXPAR2,MAXPAR2),OPX(MAXPAR2,MAXPAR2)
     &         ,LSTFWDVX(*)
      REAL*8    C, TTAGF, TTAGB, 
     &          DAMBF(MAXPAR), VXF(MAXPAR,MAXPAR),
     &          UF(MAXPAR), UB(MAXPAR2), DX(MAXPAR2), DET, 
     &          XRVEPF(MAXPAR)
      REAL*8    SOBWD, SO
      INTEGER*4 NFIX
C
      INTEGER*4 I, J, IDEXP
      REAL*8    SUMVX
     &         ,BWDVX(MAXPAR)
     &         ,UPDINT
     &         , STRTTAG
      INTEGER*4 MINFX
C
C     UPDATE BWD RUN APRIORI PARAMETERS
C     AND INITIALIZE FWD-BWD PARAMETER MISCLOSURES
C
      ISMEPO =  0
      SUMVX=0.D0
      DO I=1, NFPAR
        XRVAPR(I) = XRVEPO(I)
        UB(I)=0.D0
        DAMBF(I)=0.D0
        IF( IMODE .EQ. 1) SUMVX=SUMVX+LSTFWDVX(I)
      END DO
C
C     UPDATE BWD RUN APRIORI VARIANCE-COVARIANCE
C
      DO I=1,NFPAR+NSVO
        DO J=1,NFPAR+NSVO
          OPX(I,J)=PX(I,J)
        END DO
      END DO
C
C     MATCH THE FWD RUN EPOCH AND READ
C
30     CONTINUE
       READ(LUPX,END=20,ERR=20) TTAGF, (XRVEPF(I),I=1,NFPAR),
     &                          ((VXF(I,J),J=I,NFPAR), I=1,NFPAR)
       BACKSPACE(LUPX)
C 
C      MATCH FOUND, APPLY SMOOTHING 
C
       IF(DABS(TTAGB-TTAGF).LE.2.0D-3) THEN
         ISMEPO=1
C
C        FORM FWD MISCLOSURE VECTOR
C
         DO I=1,NFPAR
         BWDVX(I)=PX(I,I)
         IF( IMODE .EQ.1 .AND. SUMVX .NE. 0.D0 ) BWDVX(I)=LSTFWDVX(I)
           DAMBF(I)= XRVEPO(I)-XRVEPF(I)
C CORRECT FOR POSSIBLE BWD/FWD MS INCONSISTENCIES & SCALE TO NS
         IF(I.EQ.4.OR.I.GE.8.AND.I.LE.10) THEN
          IF(DAMBF(I).NE.0.D0) THEN
           DAMBF(I)=DAMBF(I)*1.D9
             DAMBF(I)=DAMBF(I)
     &        -1.0D6*DBLE(INT((DABS(DAMBF(I))+1.0D 2)/1.D 6))*
     &                                      DAMBF(I)/DABS(DAMBF(I))
          ENDIF
         ENDIF
         END DO
         IF(DABS(DAMBF(1)).GT.9.D5) DAMBF(1) = DAMBF(1)
     &   -1.D6*DBLE(INT((DABS(DAMBF(1))+5.D4)**2/DAMBF(1)/1.D6))
         DO I=1,3
          IF((DAMBF(I)**2/(VXF(I,I)+BWDVX(I))).GT.
     &                   (16.d0*SOBWD/(NFIX+1)/SO))THEN 
           ISMEPO=0
           WRITE( *,*)"SMBWD REJECTION X(I=",I,") AT",TTAGB,  DAMBF(I),
     &             SQRT(10.d0*(VXF(I,I)+BWDVX(I))*SOBWD/(NFIX+1)/SO) 
           GO TO 20
          ENDIF
          SOBWD= SOBWD + DAMBF(I)**2/(VXF(I,I)+BWDVX(I))
         END DO
         IF( .NOT. SMTHCLK ) THEN
           VXF(4,4)= VXF(4,4)+100.d0
           VXF(8,8)= VXF(8,8)+100.d0
           VXF(9,9)= VXF(9,9)+100.d0
           VXF(10,10)= VXF(10,10)+100.d0
         ELSE IF((TTAGB-STRTTAG).LE.(MINFX*60.D0)) THEN
C
C Check for chage of FWD INI REF SATELLITE 
         IF(((DAMBF(4)**2/(VXF(4,4)+BWDVX(4))).GT.(36.d0*SOBWD/(NFIX+1)
     &   /SO).AND.ABS(DAMBF(4)).GT.5.D-1).OR.DAMBF(4)**2/BWDVX(4).GT.
     &    2.5D2) THEN
C FWD INI REF SATELLITE RESET!
          write(*,*) "SMBWD FWD GPS CLK RESET TO BWD CLK AT",
     &    TTAGB,  XRVEPF(4)*1.D9, XRVEPO(4)*1.d9,
     &   (DAMBF(4)**2/(VXF(4,4)+BWDVX(4))),SOBWD/(NFIX+1),SO
            vxf(4,4)= vxf(4,4)+4.d0
         ENDIF
        ENDIF
C
c!     write(*,'("XRVEPO",F10.0,10D11.3)')
c!   &            TTAGB,(XRVEPO(i),i=1,8)
c!     write(*,'("XRVEPF",F10.0,10D11.3)')
c!   &            TTAGF,(XRVEPF(i),i=1,8)
c!     write(*,'("DAMBF",F10.0,10D11.3)')
c!   &            TTAGB,(DAMBF(i),i=1,8)
C
C        INVERT FWD (VXF) AND BWD (PX) VARIANCE-COVARIANCE 
C        TO GET REDUCED NORMALS
C
c!     write(*,'("PX   ",F10.0,10D11.3)')
c!   &        TTAGF,( sqrt(PX(i,i)),i=1,8)
c!     write(*,'("VXF  ",F10.0,10D11.3)')
c!   &        TTAGB,(sqrt(VXF(i,i)),i=1,8)
         CALL SPIN (VXF, NFPAR, NFPAR, DET, IDEXP)
         CALL SPIN (PX, NFPAR, MAXPAR2, DET, IDEXP)
c!     write(*,'("SMBWD",F10.0,10D11.3)')
c!   &        TTAGB,(VXF(i,i),PX(i,i),i=1,5)
C
C        FWD U-VECTOR
C
         CALL MATMPY(VXF,DAMBF,UF,NFPAR ,NFPAR,1,NFPAR,NFPAR,NFPAR,1)
C      
C        FORM UB & ADD REDUCED NORMALS
       DO I=1,NFPAR
           UB(I)=UF(I)
         DO J=1,NFPAR
             PX(I,J)=PX(I,J)+VXF(I,J)
         END DO
       END DO
C
C        INVERT SUM OF REDUCED NORMALS 
C
         CALL SPIN (PX, NFPAR, MAXPAR2, DET, IDEXP )
         CALL MATMPY(PX,UB,DX,NFPAR,NFPAR,1,MAXPAR2,MAXPAR2,MAXPAR2,1)
c!     write(*,'("SMBWD",F10.0,10D11.3)')
c!   &         TTAGB,(DX(i),XCOR(i,1)+DX(i),i=1,5)
C
C        UPDATE THE BWD RUN PARAMETERS (NFPAR PARAMETRS ONLY)
         DO I=1, NFPAR
         IF(I.EQ.4.OR.I.GE.8.AND.I.LE.10) THEN
            XRVEPO(I) = XRVEPO(I)- DX(I)*1.D-9
           ELSE
            XRVEPO(I) = XRVEPO(I)- DX(I)
         ENDIF
        END DO
C
C     NO MATCH - READ PREVIOUS FWD OR RETURN
C
      ELSE
C     
C       BWD EPOCH IS EARLIER THAN FWD EPOCH - READ PREVIOUS FWD
C
        IF(TTAGF-TTAGB.GT.UPDINT-.2)THEN
          BACKSPACE(LUPX)
          GO TO 30
C     
C       BWD EPOCH IS LATER THAN FWD EPOCH - NO MATCH
C
        ELSE
          ISMEPO=0
        RETURN
      END IF
      END IF
20    RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** SP3REF
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SP3REF ( LUPEP, IREFIN, RFRAME, RFREAL, EPOCH  , IEND )
C
C     NAME:      SP3REF
C
C     PURPOSE:   READ PRECISE SP3 EPHEMERIS REFERENCE FRAME & TIME
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     LUPEP             LOGICAL UNIT OF PRECISE EPHEMERIS FILE
C       TRFREF          EPHEM REFERENCE FRAME
C       EPOCH           EPOCH OF SP3 EPH IN YEARS
C     IEND              END OF FILE FLAG
C
C***********************************************************************
C
      IMPLICIT NONE
C
      CHARACTER*5   RFREAL(*), RFRAME(*)
      INTEGER*4 LUPEP, IREFIN, IEND 
      REAL*8    EPOCH  
C
      CHARACTER*2   IDLIN
      CHARACTER*5   USEDAT
      CHARACTER*5   IFRSP3
      CHARACTER*3   ORBTYP
      CHARACTER*4   AGENCY
      INTEGER*4  IMONTH(12),IYEAR,IMNTH,IDAY,IHOUR,IMIN,NEPOCH
      REAL*8     SEC
      DATA IMONTH/0,31,60,91,121,152,182,213,244,274,305,335/
C      
      RFRAME(1)='NAD83'
      RFREAL(1)='CSRS '
      RFRAME(2)='ITRF '
C
C  READ HEADER INFORMATION
C  -----------------------
C
       READ(LUPEP,1000,END=900) IDLIN, IYEAR, IMNTH, IDAY, IHOUR, 
     &                IMIN, SEC, NEPOCH, USEDAT, IFRSP3, ORBTYP, 
     &            AGENCY
       EPOCH= IYEAR + (IMONTH(IMNTH)+IDAY)/365.25d0
         IF( IFRSP3(1:3) .EQ. 'NAD' .OR. IFRSP3(1:3) .EQ. 'nad' ) THEN
           IREFIN=1
       ELSE
         RFREAL(2)=IFRSP3
         END IF
         REWIND (LUPEP)
       RETURN
C
900      REWIND (LUPEP)
         IEND = 1
C
C  FORMAT STATEMENTS
C  -----------------
C
 1000 FORMAT ( A2,1X,I4,1X,4(I2,1X),F11.8,1X,I7,1X,A5,1X,A5,1X,
     &         A3,1X,A4 )
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C***************************************************************** SPIN
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SPIN(Q,N,MM,DET,IDEXP)
C
C     PURPOSE:   SPIN IS A MATRIX INVERSION ROUTINE FOR SYMMETRIC
C                POSITIVE-DEFINITE MATRICES.  THE MATRIX INVERTED
C                IS THE UPPER N BY N PORTION OF THE MATRIX Q WHICH
C                IS DIMENSIONED MM BY MM IN THE CALLING ROUTINE.
C
C  INPUT:
C     Q - THE MATRIX DIMENSIONED MM BY MM WHICH CONTAINS THE
C         MATRIX TO BE INVERTED.
C
C     N - THE DIMENSION OF THE ACTUAL PART( UPPER LEFT CORNER)
C         OF Q WHICH IS TO BE INVERTED. ( N MAY BE EQUAL BUT MUST
C         NOT BE LARGER THAN MM) .
C     MM- DIMENSIONED SIZE OF Q IN THE CALLING ROUTINE.
C
C
C  OUTPUT:
C
C       Q - THE UPPER LEFT N BY N PORTION CONTAINS THE INVERSE OF
C           THE INPUT UPPER LEFT N BY N PORTION.
C
C     DET - THE NON-EXPONENT PORTION OF THE DETERMINANT OF THE
C           INPUT N BY N (UPPER LEFT PORTION OF Q) MATRIX. SEE
C           IDEXP  BELOW.
C
C     IDEXP - THE EXPONENT (OF 10) PART OF THE DETERMINANT DESCRIBED
C           UNDER DET ABOVE. THUS THE DETERMINANT IS RETURNED IN
C           TWO PARTS CORRESPONDING TO
C            DETERMINANT = DET * 10 ** IDEXP .
C           THIS IS DONE TO AVOID UNDER OR OVERFLOW IN THE
C           COMPUTATION OF THE DETERMINANT.  TO PRINT THE DETERM-
C            INANT THE USER SHOULD PRINT BOTH NUMBERS AS FOLLOWS;
C            (FOR EXAMPLE)
C              PRINT 10,DET,IDEXP
C           10 FORMAT(' ','DETERMINANT= ',F7.4,'D',I4)
C
C
      IMPLICIT NONE
C
       INTEGER*4 N,MM,IDEXP
       REAL*8 Q(MM,MM),DET
C
       INTEGER*4 I,J,M,K
       REAL*8 SUM,RPART,APART
C
       DET=0.D0
       DO 4 J=1,N
       DO 4 I=1,J
       IF(I.EQ.1) GO TO 2
       M=I-1
       SUM=0.0D0
         DO 1 K=1,M
 1       SUM=SUM+Q(K,I)*Q(K,J)
       Q(I,J)=Q(I,J)-SUM
 2     IF(I.EQ.J) GO TO 3
       Q(I,J)=Q(I,J)/Q(I,I)
       GO TO 4
 3     CONTINUE
C MODIFIED KL
      DET=DET+DLOG10(Q(I,I))
      Q(I,I)=DSQRT(Q(I,I))
 4     CONTINUE
       IDEXP=DET
       RPART=DET-IDEXP
       APART=DABS(RPART)
       IF(APART.LT.1.D-20) DET=1.D0
       IF(APART.LT.1.D-20) GO TO 10
       DET=10**RPART
 10    CONTINUE
       DO 7 J=1,N
       DO 7 I=1,J
       IF(I.LT.J) GO TO 5
       Q(J,J)=1.0D0/Q(J,J)
       GO TO 7
 5     SUM=0.0D0
       M=J-1
         DO 6 K=I,M
 6       SUM=SUM-Q(I,K)*Q(K,J)
       Q(I,J)=SUM/Q(J,J)
 7     CONTINUE
       DO 9 J=1,N
         DO 9 I=1,J
         SUM=0.0D0
       DO 8 K=J,N
 8     SUM=SUM+Q(I,K)*Q(J,K)
       Q(I,J)=SUM
       IF(I.EQ.J) GO TO 9
       Q(J,I)=SUM
 9     CONTINUE
       RETURN
       END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** STRLIM
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
C
      SUBROUTINE STRLIM(STRING, IL,IR)
C
C       PURPOSE         FIND THE POSITION IN STRING OF 
C                       THE LEFTMOST NON-BLANK, NON-NULL
C                       CHARACTER (IL) AND THE RIGHTMOST 
C                       NON-BLANK, NON-NULL CHARACTER (IR).
C
C
      IMPLICIT NONE
C
      CHARACTER STRING*(*)
      INTEGER*4 IL,  IR
C
      INTEGER*4 L
      CHARACTER BLANK*1,NULL*1
C
      BLANK=CHAR(32)
      NULL =CHAR(0)
C
      L = LEN(STRING)
C
C     START FROM LEFT LOOKING FOR FIRST
C     NON-BLANK, NON-NULL CHARACTER
C
      IL = 1
      DO WHILE ((STRING(IL:IL).EQ.BLANK.OR.STRING(IL:IL).EQ.NULL).AND.
     &         IL.LE.L)
         IL = IL + 1
      END DO
C
C     STRING IS WHOLLY BLANK OR NULL
C     INDICATES EMPTY STRING
C     SO THAT LENGTH (IR - IL + 1) WIL BE ZERO
C
      IF (IL.GT.L)  THEN
         IL =  0
         IR = -1
C
C     STRING CONTAINS AT LEAST 1 NON-BLANK, NON-NULL CHARACTER
C     START FROM RIGHT END LOOKING FOR LAST "REAL" CHARACTER
C
      ELSE
         IR = L
         DO WHILE (STRING(IR:IR).EQ.BLANK.OR.STRING(IR:IR).EQ.NULL)
            IR = IR - 1
         END DO
      END IF
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** SUMCLK
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SUMCLK ( LPR, LSES, STNA, IYEAR, IMTH, IDAY, 
     &                    ICLKFIT, REFTM, NCLK, OFFSET, DRIFT,
     &                    DRIFTRATE,SDOFF,SDRIFT,SDRIFTRATE, CLKRMS,
     &                    RNCLK, ROFFSET, RDRIFT, RDRIFTRATE,
     &                    RSDOFF, RSDRIFT, RSDRIFTRATE, RCLKRMS,
     &                    DFNCLK, DFOFFSET, DFDRIFT, DFDRIFTRATE,
     &                    DFSDOFF, DFSDRIFT, DFSDRIFTRATE, DFCLKRMS,
     &                    ENCLK, EOFFSET, EDRIFT, EDRIFTRATE,
     &                    ESDOFF, ESDRIFT, ESDRIFTRATE, ECLKRMS,
     &                    DENCLK, DEOFFSET, DEDRIFT, DEDRIFTRATE,
     &                    DESDOFF, DESDRIFT, DESDRIFTRATE, DECLKRMS,
     &                    CNCLK, COFFSET, CDRIFT, CDRIFTRATE,
     &                    CSDOFF, CSDRIFT, CSDRIFTRATE, CCLKRMS,
     &                    DCNCLK, DCOFFSET, DCDRIFT, DCDRIFTRATE,
     &                    DCSDOFF, DCSDRIFT, DCSDRIFTRATE, DCCLKRMS,
     &                    NMSOFF, NMSJMP, IMODE, LNG,
     &                    ICLKAP,CLKY0,CLKD0,UCLKY0,UCLKD0,CLKSD0,
     &                    SDCLK0,
     &                    NMSCPJ, NMSCLJ, ICORRTT, ICORRPR, ICORRCP, 
     &                    IDIR, NDATJMP, DATJMP, RIFRATE,SRIFRT,RAVGALL,
     &                    SMTHCLK )
C
C     PURPOSE:   SUMMARIZE RECEIVER CLOCK ESTIMATES
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     LPR               LOGICAL UNIT OF PRINTER
C     REFTM             REFERENCE TIME OF CLOCK ESTIMATES
C     OFFSET            RECEIVER CLOCK OFFSET
C     DRIFT             RECEIVER DRIFT
C     DRIFTRATE       CLOCK DRIFTRATE
C     SDOFF             STANDARD DEVIATION OF RECEIVER CLOCK OFFSET
C     SDRIFT            STANDARD DEVIATION OF RECEIVER CLOCK DRIFT
C     SDRIFTRATE      STANDARD DEVIATION OF CLOCK DRIFTRATE
C***********************************************************************
C
      IMPLICIT NONE
C
      CHARACTER*40   STNA
      LOGICAL*4 SMTHCLK
      INTEGER*4 LPR,LSES,IYEAR,IMTH,IDAY,NCLK,NMSJMP,NMSOFF,IMODE,
     &          LNG
      INTEGER*4 NMSCPJ,NMSCLJ,ICORRTT,ICORRPR,ICORRCP,IDIR,NDATJMP
      CHARACTER*80 DATJMP(*)
      INTEGER*4 ICLKFIT
      REAL*8 REFTM,OFFSET,DRIFT,DRIFTRATE
      REAL*8 SDOFF,SDRIFT,SDRIFTRATE,CLKRMS
      INTEGER*4 ICLKAP
      REAL*8  CLKY0,CLKD0,UCLKY0,UCLKD0,CLKSD0,SDCLK0
      INTEGER*4 RNCLK,DFNCLK
      REAL*8  ROFFSET, RDRIFT, RDRIFTRATE,
     &        RSDOFF, RSDRIFT, RSDRIFTRATE, RCLKRMS
      REAL*8  DFOFFSET, DFDRIFT, DFDRIFTRATE,
     &        DFSDOFF, DFSDRIFT, DFSDRIFTRATE, DFCLKRMS
      INTEGER*4 ENCLK,DENCLK
      REAL*8              EOFFSET, EDRIFT, EDRIFTRATE,
     &                    ESDOFF, ESDRIFT, ESDRIFTRATE, ECLKRMS,
     &                    DEOFFSET, DEDRIFT, DEDRIFTRATE,
     &                    DESDOFF, DESDRIFT, DESDRIFTRATE, DECLKRMS
      INTEGER*4 CNCLK,DCNCLK
      REAL*8              COFFSET, CDRIFT, CDRIFTRATE,
     &                    CSDOFF, CSDRIFT, CSDRIFTRATE, CCLKRMS,
     &                    DCOFFSET, DCDRIFT, DCDRIFTRATE,
     &                    DCSDOFF, DCSDRIFT, DCSDRIFTRATE, DCCLKRMS
C RIFRATE IF DCB (NS/CH)
      REAL*8 RIFRATE , SRIFRT, RAVGALL(4)
C
      CHARACTER*60   SECHDR(2)
      CHARACTER*35   EPOHDR(2)
      CHARACTER*35   MSOHDR(2)
C
      CHARACTER*35   APAHDR(2)
      CHARACTER*35   APDHDR(2)
      CHARACTER*35   APDDHDR(2)
C
      CHARACTER*60   LSTHDR(2)
      CHARACTER*60   WRNHDR(2)
      CHARACTER*35   MSCHDR(2)
      CHARACTER*35   CKOHDR(2)
      CHARACTER*35   CKDHDR(2)
C
      CHARACTER*35   CKDRHDR(2)
      CHARACTER*13   CKDRSCL(2)
C
      CHARACTER*35   RESHDR(2)
      CHARACTER*13   CKOSCL(2) 
      CHARACTER*13   CKDSCL(2)
      CHARACTER*35   SYSHDR(2)
      CHARACTER*35   CLKHDR(2)
      CHARACTER*15   CLKFWDU(2)
      CHARACTER*15   CLKBWDS(2)
      CHARACTER*15   CLKBWDU(2)
      CHARACTER*5    CLK
      CHARACTER*2    UNIT
      INTEGER*4 I,MJD,JULD,IGPSWK,IWKDAY,IHRS,IMINS
      REAL*8    DAYSEC,ONSM,SECS,SCALE,DDRIFT
C
      DATA (SECHDR(I),I=1,2)
     &     /'3.5 Receiver clock estimates                           ',
     &      "3.5 Estime des parametres d'horloge du recepteur       "/ 
      DATA (EPOHDR(I),I=1,2) /"Reference Epoch                   :",
     &                        "Epoque de reference               :"/
      DATA (SYSHDR(I),I=1,2) /"Constellation reference           :",
     &                        "Constellation de reference        :"/
      DATA (CLKHDR(I),I=1,2) /"Filter                            :",
     &                        "Filtre                            :"/
      DATA (APAHDR(I),I=1,2) /"1s Allan deviation                :",
     &                        "Ecart type Allan a 1s             :"/
      DATA (APDHDR(I),I=1,2) /"Clock frequency offset      (s/s) :",
     &                        "Biais de frequence          (s/s) :"/
      DATA (APDDHDR(I),I=1,2)/"Clock frequency drift       (1/s) :",
     &                        "Derive de frequence         (1/s) :"/
      DATA (MSOHDR(I),I=1,2) /"1ms corrections tag/pseudor/phase :",
     &                        "Correct. 1ms  temps/pseudod/phase :"/
      DATA (MSCHDR(I),I=1,2) /"1ms jumps detected in clock       :",
     &                        "Sauts 1ms detectes dans l'horloge :"/
      DATA (LSTHDR(I),I=1,2) 
     & /'DIR YYYY/MM/DD HH:MM:SS.SSS      Timetag Pseudorng     Phase',
     &  "DIR YYYY/MM/DD HH:MM:SS.SSS      Temps   Pseudodst     Phase"/
      DATA (WRNHDR(I),I=1,2)
     & /"** Warning: inconsistent 1ms jumps between FWD and BWD**",
     &  "** Avertissement: sauts 1ms inconsistents entre FWD et BWD"/
      DATA (CKOHDR(I),I=1,2) /"Clock Phase         ",
     &                        "Phase horloge       "/
      DATA (CKDHDR(I),I=1,2) /"Phase Drift         ",
     &                        "Derive phase        "/
      DATA (CKDRHDR(I),I=1,2)/"Frequency Drift     ",
     &                        "Derive frequence    "/
      DATA (RESHDR(I),I=1,2) /"RMS residuals       ",
     &                        "RMS residuelles     "/
      DATA (CKOSCL(I),I=1,2) /"s)          :",
     &                        "s)          :"/
      DATA (CKDSCL(I),I=1,2) /"s/day)      :",
     &                        "s/jour)     :"/
      DATA (CKDRSCL(I),I=1,2) /"s/day/day)  :",
     &                         "s/jour/jour):"/
      DATA (CLKFWDU(I),I=1,2) /"FWD            ",
     &                         "FWD            "/
      DATA (CLKBWDU(I),I=1,2) /"BWD unsmoothed ",
     &                         "BWD non-lisse  "/
      DATA (CLKBWDS(I),I=1,2) /"BWD smoothed   ",
     &                         "BWD lisse      "/
C
      DAYSEC=86400.D0
      ONSM = .299792458D0
      CALL JLIAN ( MJD, IYEAR, IMTH, IDAY)
C
C------------------------------------------------------------------------
C     WRITE RECEIVER CLOCK ESTIMATES
C------------------------------------------------------------------------
C
      WRITE(LPR,900) SECHDR(LNG)
C
      CALL GPSDC ( JULD,IYEAR,IMTH,IDAY,IGPSWK,IWKDAY,2 )
      CALL TOWHMS( IWKDAY, REFTM, IHRS, IMINS, SECS, 0 )
      SCALE=1.D-6
      UNIT='(m'
      DDRIFT=DRIFT*DAYSEC
      IF ( DABS(OFFSET) .LT. 1.D3 .AND. DABS(DDRIFT) .LT. 1.D3 ) THEN
        SCALE=1.D-3
      UNIT='(u'
      END IF
      IF ( DABS(OFFSET) .LT. 1.D6 .AND. DABS(DDRIFT) .LT. 1.D6 ) THEN
        SCALE=1.D0
      UNIT='(n'
      END IF
      IF( ICLKAP .EQ. 1 ) THEN
       WRITE(LPR,1210) APAHDR(LNG),CLKSD0
       WRITE(LPR,1210) APDHDR(LNG),CLKY0
       WRITE(LPR,1210) APDDHDR(LNG),CLKD0
      ELSE IF ( ICLKAP .EQ. 2 ) THEN
       WRITE(LPR,1210) APAHDR(LNG),CLKSD0
       WRITE(LPR,1211) APDHDR(LNG),CLKY0,UCLKY0
       WRITE(LPR,1211) APDDHDR(LNG),CLKD0,UCLKD0
      ELSE
       IF( SDCLK0 .GT. 0.D0 ) WRITE(LPR,1210) APAHDR(LNG),SDCLK0
      END IF
      WRITE(LPR,1100) EPOHDR(LNG),IYEAR,IMTH,IDAY,IHRS,IMINS,
     &   INT(SECS),INT((SECS-INT(SECS))*100)
      IF(IDIR.EQ.1) THEN
        CLK='FWD  '
        WRITE(LPR,1102) CLKHDR(LNG),CLKFWDU(LNG)
      ELSE IF(SMTHCLK) THEN
        WRITE(LPR,1102) CLKHDR(LNG),CLKBWDS(LNG)
        CLK='SMTHD'
      ELSE
        WRITE(LPR,1102) CLKHDR(LNG),CLKBWDU(LNG)
        CLK='BWD  '
      ENDIF
      IF( CLKRMS .GT. 0 ) THEN
      WRITE(LPR,1103) SYSHDR(LNG),'GPS            '
      WRITE(LPR,1200) CKOHDR(LNG),UNIT,CKOSCL(LNG),
     &                OFFSET*SCALE,SDOFF*SCALE
      IF ( ICLKAP .EQ. 0 ) THEN
      WRITE(LPR,1200) CKDHDR(LNG),UNIT,CKDSCL(LNG),DRIFT*SCALE*DAYSEC,
     &                SDRIFT*SCALE*DAYSEC
      IF( ICLKFIT .EQ. 2 )
     &WRITE(LPR,1200) CKDRHDR(LNG),UNIT,CKDRSCL(LNG),
     &                DRIFTRATE*SCALE*DAYSEC*DAYSEC,
     &                SDRIFTRATE*SCALE*DAYSEC*DAYSEC
      ELSE
      WRITE(LPR,1201) CKDHDR(LNG),'(s/s)          :',
     &                DRIFT*1.D-9,SDRIFT*1.D-9
      IF( ICLKFIT .EQ. 2 ) 
     &WRITE(LPR,1201) CKDRHDR(LNG),'(1/s)         :',
     &                DRIFTRATE*1.D-9,SDRIFTRATE*1.D-9
      ENDIF
      WRITE(LPR,1202) RESHDR(LNG),UNIT,CKOSCL(LNG),CLKRMS*SCALE
     &               ,NCLK
      ENDIF
C
C GLONASS CLOCK MODEL
C
      IF( RCLKRMS .GT. 0 ) THEN
      WRITE(LPR,1103) SYSHDR(LNG),'GLONASS        '
      WRITE(LPR,1200) CKOHDR(LNG),UNIT,CKOSCL(LNG),
     &                ROFFSET*SCALE,RSDOFF*SCALE
      IF ( ICLKAP .EQ. 0 ) THEN
      WRITE(LPR,1200) CKDHDR(LNG),UNIT,CKDSCL(LNG),
     &RDRIFT*SCALE*DAYSEC,RSDRIFT*SCALE*DAYSEC
      IF( ICLKFIT .EQ. 2 )
     &WRITE(LPR,1200) CKDRHDR(LNG),UNIT,CKDRSCL(LNG),
     &                RDRIFTRATE*SCALE*DAYSEC*DAYSEC,
     &                RSDRIFTRATE*SCALE*DAYSEC*DAYSEC
      ELSE
      WRITE(LPR,1201) CKDHDR(LNG),'(s/s)          :',
     &                RDRIFT*1.D-9,RSDRIFT*1.D-9
      IF( ICLKFIT .EQ. 2 ) 
     &WRITE(LPR,1201) CKDRHDR(LNG),'(1/s)         :',
     &                RDRIFTRATE*1.D-9,RSDRIFTRATE*1.D-9
      ENDIF
      WRITE(LPR,1202) RESHDR(LNG),UNIT,CKOSCL(LNG),RCLKRMS*SCALE
     &               ,RNCLK
      ENDIF
C
C GALILEO - E
      IF( ECLKRMS .GT. 0 ) THEN
      WRITE(LPR,1103) SYSHDR(LNG),'GALILEO        '
      WRITE(LPR,1200) CKOHDR(LNG),UNIT,CKOSCL(LNG),
     &                EOFFSET*SCALE,ESDOFF*SCALE
       IF ( ICLKAP .EQ. 0 ) THEN
      WRITE(LPR,1200) CKDHDR(LNG),UNIT,CKDSCL(LNG),
     &EDRIFT*SCALE*DAYSEC,ESDRIFT*SCALE*DAYSEC
      IF( ICLKFIT .EQ. 2 )
     &WRITE(LPR,1200) CKDRHDR(LNG),UNIT,CKDRSCL(LNG),
     &                EDRIFTRATE*SCALE*DAYSEC*DAYSEC,
     &                ESDRIFTRATE*SCALE*DAYSEC*DAYSEC
       ELSE
      WRITE(LPR,1201) CKDHDR(LNG),'(s/s)          :',
     &                EDRIFT*1.D-9,ESDRIFT*1.D-9
      IF( ICLKFIT .EQ. 2 )
     &WRITE(LPR,1201) CKDRHDR(LNG),'(1/s)         :',
     &                EDRIFTRATE*1.D-9,ESDRIFTRATE*1.D-9
       ENDIF
      WRITE(LPR,1202) RESHDR(LNG),UNIT,CKOSCL(LNG),ECLKRMS*SCALE
     &               ,ENCLK
      ENDIF
C BEIDOU -C  
      IF( CCLKRMS .GT. 0 ) THEN
      WRITE(LPR,1103) SYSHDR(LNG),'BEIDOU         '
      WRITE(LPR,1200) CKOHDR(LNG),UNIT,CKOSCL(LNG),
     &                COFFSET*SCALE,CSDOFF*SCALE
       IF ( ICLKAP .EQ. 0 ) THEN
      WRITE(LPR,1200) CKDHDR(LNG),UNIT,CKDSCL(LNG),
     &CDRIFT*SCALE*DAYSEC,CSDRIFT*SCALE*DAYSEC
      IF( ICLKFIT .EQ. 2 )
     &WRITE(LPR,1200) CKDRHDR(LNG),UNIT,CKDRSCL(LNG),
     &                CDRIFTRATE*SCALE*DAYSEC*DAYSEC,
     &                CSDRIFTRATE*SCALE*DAYSEC*DAYSEC
       ELSE
      WRITE(LPR,1201) CKDHDR(LNG),'(s/s)          :',
     &                CDRIFT*1.D-9,CSDRIFT*1.D-9
      IF( ICLKFIT .EQ. 2 )
     &WRITE(LPR,1201) CKDRHDR(LNG),'(1/s)         :',
     &                CDRIFTRATE*1.D-9,CSDRIFTRATE*1.D-9
       ENDIF
      WRITE(LPR,1202) RESHDR(LNG),UNIT,CKOSCL(LNG),CCLKRMS*SCALE
     &               ,CNCLK
      ENDIF
C
C GPS-GLONASS CLOCK MODEL
C
      IF( DFCLKRMS .GT. 0 ) THEN
      WRITE(LPR,1103) SYSHDR(LNG),'GLONASS-GPS    '
      WRITE(LPR,1200) CKOHDR(LNG),UNIT,CKOSCL(LNG),
     &                DFOFFSET*SCALE,DFSDOFF*SCALE
      IF ( ICLKAP .EQ. 0 ) THEN
      WRITE(LPR,1200) CKDHDR(LNG),UNIT,CKDSCL(LNG),
     &DFDRIFT*SCALE*DAYSEC,DFSDRIFT*SCALE*DAYSEC
      IF( ICLKFIT .EQ. 2 )
     &WRITE(LPR,1200) CKDRHDR(LNG),UNIT,CKDRSCL(LNG),
     &                DFDRIFTRATE*SCALE*DAYSEC*DAYSEC,
     &                DFSDRIFTRATE*SCALE*DAYSEC*DAYSEC
      ELSE
      WRITE(LPR,1201) CKDHDR(LNG),'(s/s)          :',
     &                DFDRIFT*1.D-9,DFSDRIFT*1.D-9
      IF( ICLKFIT .EQ. 2 ) 
     &WRITE(LPR,1201) CKDRHDR(LNG),'(1/s)         :',
     &                DFDRIFTRATE*1.D-9,DFSDRIFTRATE*1.D-9
      ENDIF
      WRITE(LPR,1202) RESHDR(LNG),UNIT,CKOSCL(LNG),DFCLKRMS*SCALE
     &               ,DFNCLK
      ENDIF
      IF( DECLKRMS .GT. 0 ) THEN
      WRITE(LPR,1103) SYSHDR(LNG),'GALILEO-GPS    '
      WRITE(LPR,1200) CKOHDR(LNG),UNIT,CKOSCL(LNG),
     &                DEOFFSET*SCALE,DESDOFF*SCALE
       IF ( ICLKAP .EQ. 0 ) THEN
      WRITE(LPR,1200) CKDHDR(LNG),UNIT,CKDSCL(LNG),
     &DEDRIFT*SCALE*DAYSEC,DESDRIFT*SCALE*DAYSEC
      IF( ICLKFIT .EQ. 2 )
     &WRITE(LPR,1200) CKDRHDR(LNG),UNIT,CKDRSCL(LNG),
     &                DEDRIFTRATE*SCALE*DAYSEC*DAYSEC,
     &                DESDRIFTRATE*SCALE*DAYSEC*DAYSEC
       ELSE
      WRITE(LPR,1201) CKDHDR(LNG),'(s/s)          :',
     &                DEDRIFT*1.D-9,DESDRIFT*1.D-9
      IF( ICLKFIT .EQ. 2 )
     &WRITE(LPR,1201) CKDRHDR(LNG),'(1/s)         :',
     &                DEDRIFTRATE*1.D-9,DESDRIFTRATE*1.D-9
       ENDIF
      WRITE(LPR,1202) RESHDR(LNG),UNIT,CKOSCL(LNG),DECLKRMS*SCALE
     &               ,DENCLK
      ENDIF
      IF( DCCLKRMS .GT. 0 ) THEN
      WRITE(LPR,1103) SYSHDR(LNG),'BEIDOU-GPS    '
      WRITE(LPR,1200) CKOHDR(LNG),UNIT,CKOSCL(LNG),
     &                DCOFFSET*SCALE,DCSDOFF*SCALE
       IF ( ICLKAP .EQ. 0 ) THEN
      WRITE(LPR,1200) CKDHDR(LNG),UNIT,CKDSCL(LNG),
     &DCDRIFT*SCALE*DAYSEC,DCSDRIFT*SCALE*DAYSEC
      IF( ICLKFIT .EQ. 2 )
     &WRITE(LPR,1200) CKDRHDR(LNG),UNIT,CKDRSCL(LNG),
     &                DCDRIFTRATE*SCALE*DAYSEC*DAYSEC,
     &                DCSDRIFTRATE*SCALE*DAYSEC*DAYSEC
       ELSE
      WRITE(LPR,1201) CKDHDR(LNG),'(s/s)          :',
     &                DCDRIFT*1.D-9,DCSDRIFT*1.D-9
      IF( ICLKFIT .EQ. 2 )
     &WRITE(LPR,1201) CKDRHDR(LNG),'(1/s)         :',
     &                DCDRIFTRATE*1.D-9,DCSDRIFTRATE*1.D-9
       ENDIF
      WRITE(LPR,1202) RESHDR(LNG),UNIT,CKOSCL(LNG),DCCLKRMS*SCALE
     &               ,DCNCLK
      ENDIF
C
      IF( IDIR .LT. -1 ) THEN
        NMSCLJ=NMSCLJ/2
        NMSCPJ=NMSCPJ/2
        NMSJMP=NMSJMP/2
        NMSOFF=NMSOFF/2
      END IF
      IF( NMSCLJ .NE. 0 )
     &  WRITE(LPR,1151) MSCHDR(LNG),NMSCLJ
      IF( NMSOFF .NE. 0 .OR. NMSJMP .NE. 0 .OR. NMSCPJ .NE. 0 )
     &  WRITE(LPR,1150) MSOHDR(LNG),NMSOFF,NMSJMP,NMSCPJ-NMSJMP
      IF( NDATJMP .NE. 0 ) WRITE(LPR,1400) LSTHDR(LNG)
      WRITE(LPR,1410) (DATJMP(I),I=1,NDATJMP)
      IF( IDIR .LT. -1 .AND.
     &( ICORRTT .NE. 0 .OR. ICORRCP .NE. 0 .OR. ICORRPR .NE. 0 ))
     &  WRITE(LPR,1300) WRNHDR(LNG)
C
C     SESSION CLOCK RECORD
C
c!    write(*,*) 'RAVGALL' , RAVGALL
      IF( CLKRMS .GT. 0 )
     &WRITE(LSES,1440) 'CLK',STNA, IYEAR, IMTH, IDAY, OFFSET,
     &      SDOFF, DRIFT*DAYSEC,SDRIFT*DAYSEC, CLKRMS*ONSM, MJD
     &     ,'GPS', CLK
      IF( RCLKRMS .GT. 0 )
     &WRITE(LSES,1440) 'CLK',STNA, IYEAR, IMTH, IDAY, ROFFSET,
     &      RSDOFF, RDRIFT*DAYSEC,RSDRIFT*DAYSEC, RCLKRMS*ONSM, MJD
     &     ,'GLONASS', CLK, 'IFDCB', RIFRATE, SRIFRT, 'NS/CH'
      IF( ECLKRMS .GT. 0 )
     &WRITE(LSES,1440) 'CLK',STNA, IYEAR, IMTH, IDAY, EOFFSET,
     &      ESDOFF, EDRIFT*DAYSEC,ESDRIFT*DAYSEC, ECLKRMS*ONSM, MJD
     &     ,'GALILEO', CLK
      IF( CCLKRMS .GT. 0 )
     &WRITE(LSES,1440) 'CLK',STNA, IYEAR, IMTH, IDAY, COFFSET,
     &      CSDOFF, CDRIFT*DAYSEC,CSDRIFT*DAYSEC, CCLKRMS*ONSM, MJD
     &     ,'BEIDOU', CLK
      IF( DFCLKRMS .GT. 0 )
     &WRITE(LSES,1440) 'CLK',STNA, IYEAR, IMTH, IDAY, DFOFFSET,
     &      DFSDOFF, DFDRIFT*DAYSEC,DFSDRIFT*DAYSEC, DFCLKRMS*ONSM, MJD
     &     ,'GLN-GPS', CLK
      IF( DECLKRMS .GT. 0 )
     &WRITE(LSES,1440) 'CLK',STNA, IYEAR, IMTH, IDAY, DEOFFSET,
     &      DESDOFF, DEDRIFT*DAYSEC,DESDRIFT*DAYSEC, DECLKRMS*ONSM, MJD
     &     ,'GAL-GPS', CLK
      IF( DCCLKRMS .GT. 0 )
     &WRITE(LSES,1440) 'CLK',STNA, IYEAR, IMTH, IDAY, DCOFFSET,
     &      DCSDOFF, DCDRIFT*DAYSEC,DCSDRIFT*DAYSEC, DCCLKRMS*ONSM, MJD
     &     ,'BEI-GPS', CLK
C
C------------------------------------------------------------------------
C     FORMAT STATEMENTS
C------------------------------------------------------------------------
C
  900 FORMAT( /,1X,A60,/)
 1100 FORMAT(5X,A35,3X,I4,2('/',I2.2),' ',2(I2.2,':'),I2.2,'.',I2.2)
 1102 FORMAT(5X,A35,3X,A15)
 1103 FORMAT(/,5X,A35,3X,A15)
 1150 FORMAT(5X,A35,I13,'/',I7,'/',I7)
 1200 FORMAT(5X,A20,A2,A13,2F13.2)
 1201 FORMAT(5X,A20,A15,2D20.10)
 1202 FORMAT(5X,A20,A2,A13,1F13.2,1X,I10)
 1210 FORMAT(5X,A35,1(1x,D17.10))
 1211 FORMAT(5X,A35,2(1x,D17.10))
 1151 FORMAT(5X,A35,I13)
 1300 FORMAT(5X,A35)
 1400 FORMAT(/,5X,A60)
 1410 FORMAT(5X,A78)
 1440 FORMAT ( A3,1X,A4,1X,I4,'/',I2.2,'/',I2.2,1X,2(1X,F12.2,1X,F6.2),
     &         1X, F5.3,1X,I10,1X,A7,1X,A5,1X,A5,2F6.2,1X,A5)
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** SUMCMD
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SUMCMD( LPR, LSES, STNA, IYEAR, IMTH, IDAY, IMODE, 
     &                   IOBTYP, IFREQ, ISVEPH, ISVCLK, IFITCLK, 
     &                   IONSLM, ISLMFMT, IMFSEL, IPOSSOL, ITRPSOL,
     &                   NDIR, IREFOUT, ICOROUT, SIGOBS, SDCP, ANTH,
     &                   PLHMRK,XRVVEL, MISCFACTR, MISCFACTP,
     &                   INTCLK, CUTOFF, IPCV, SMTHCLK, LNG )
C
C     NAME              SUMCMD
C
C     PURPOSE   SUMMARIZE PROCESSING OPTIONS
C
C     PARAMETERS        DESCRIPTION
C
C          LPR          LOGICAL UNIT OF PRINTER
C        IMODE        PROCESSING MODE (1=STATIC,2=KINEMATIC)
C          IOBTYP       OBSERVATION PROCESSED (1=PSEUDORANGE,2=PHASE)
C        IFREQ  FREQUENCY PROCESED (1=L1,2=L2,3=L3)
C          ISVEPH       SATELLITE ORBITS (1=BROADCAST,2=PRECISE)
C          ISVCLK       SATELLITE CLOCKS (1=BROADCAST,2=PRECISE,3=MRTCA,4=RTCM-SSR)
C          IFITCLK      CLOCK INTERPOLATION (1=YES,2=NO)
C          IONSLM       IONOSPHERIC CORRECTION (1=BROADCAST,2=PRECISE)
C          ISLMFMT      
C          IPOSSOL      STATION COORDINATES (1=FIXED, 2=ESTIMATED)
C          ITRPSOL      STATION TROPOSPHERIC DELAY (1=FIXED, 2=ESTIMATED)
C          NDIR         BACKWARD SMOOTHING (1=NO, 2=YES)
C          IREFOUT      REFERENCE FRAME (1=NAD83, 2=ITRF)
C          ICOROUT      COORDINATE SYSTEM (1=ELLIPSOIDAL,2=CARTESIAN)
C          SIGOBS       PSEUDORANGE SIGMA (M)
C          SDCP         PHASE SIGMA (M)
C          ANTH         ARP HEIGHT (M)
C          CUTOFF       CUTOFF ELEVATION (DEG)
C *********************************************************************
C
      IMPLICIT NONE
C
      CHARACTER*40 STNA
      LOGICAL*4 SMTHCLK
      INTEGER*4 LPR,LSES,IYEAR,IMTH,IDAY,IMODE,IOBTYP,IFREQ,ISVEPH
      INTEGER*4 ISVCLK,IFITCLK,IONSLM,ISLMFMT,IPOSSOL,ITRPSOL,NDIR
     &         ,IMFSEL
      INTEGER*4 IREFOUT, ICOROUT,LNG
     &         , IPCV, ANTMATCH
      REAL*8    SIGOBS,SDCP,ANTH,CUTOFF,TRPRW
      REAL*8    GRDRW
      REAL*8    PLHMRK(3),XRVVEL(3)
     &         ,MISCFACTR,MISCFACTP
C
      CHARACTER*30 OPTF(24)
      CHARACTER*30 OPTE(24)
      CHARACTER*25 SELF(12,6)
      CHARACTER*25 SELE(12,6)
      INTEGER*4 IOPT(12),I,IONMOD
      INTEGER*4    IEPH,ICLK
      INTEGER*4    INTCLK
      REAL*8    VEL,PLHVEL(3)
C
      DATA (SELE(1,I),I=1,5) /"STATIC                   ",
     &                        "KINEMATIC                ",
     &                        "STAT/KINE                ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELE(2,I),I=1,5) /"CODE                     ",
     &                        "CODE&PHASE               ",
     &                        "                         ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELE(3,I),I=1,5) /"L1                       ",
     &                        "L2                       ",
     &                        "L3                       ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELE(4,I),I=1,5) /"BROADCAST                ",
     &                        "PRECISE                  ",
     &                        "BROADCAST+MRTCA          ",
     &                        "BROADCAST+RTCM-SSR       ",
     &                        "                         "/
      DATA (SELE(5,I),I=1,5) /"BROADCAST                ",
     &                        "CLK-RINEX                ",
     &                        "BROADCAST+MRTCA          ",
     &                        "BROADCAST+RTCM-SSR       ",
     &                        "SP3                      "/
      DATA (SELE(6,I),I=1,5) /"BROADCAST                ",
     &                        "IONEX                    ",
     &                        "MRTCA                    ",
     &                        "L1&L2                    ",
     &                        "NOT AVAIL.               "/
      DATA (SELE(6,I),I=6,6) /"C.SPH.HARM.              "/
      DATA (SELE(7,I),I=1,5) /"FIXED                    ",
     &                        "ESTIMATED                ",
     &                        "                         ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELE(8,I),I=1,5) /"FIXED                    ",
     &                        "ESTIMATED                ",
     &                        "ESTIMATED+GRADIENTS      ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELE(9,I),I=1,5) /"NO                       ",
     &                        "YES                      ",
     &                        "                         ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELE(10,I),I=1,5) /"NO                       ",
     &                        "YES                      ",
     &                        "                         ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELE(11,I),I=1,5) /"NAD83(CSRS)             ",
     &                        "ITRF                     ",
     &                        "                         ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELE(12,I),I=1,5) /"ELLIPSOIDAL              ",
     &                        "CARTESIAN                ",
     &                        "                         ",
     &                        "                         ",
     &                        "                         "/
C
      DATA (SELF(1,I),I=1,5) /"STATIQUE                 ",
     &                        "KINEMATIQUE              ",
     &                        "STAT/KINE                ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELF(2,I),I=1,5) /"CODE                     ",
     &                        "CODE&PHASE               ",
     &                        "                         ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELF(3,I),I=1,5) /"L1                       ",
     &                        "L2                       ",
     &                        "L3                       ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELF(4,I),I=1,5) /"DIFFUSEES                ",
     &                        "PRECISES                 ",
     &                        "DIFFUSEES+MRTCA          ",
     &                        "DIFFUSEES+RTCM-SSR       ",
     &                        "                         "/
      DATA (SELF(5,I),I=1,5) /"DIFFUSEES                ",
     &                        "RINEX-horloge            ",
     &                        "DIFFUSEES+MRTCA          ",
     &                        "DIFFUSEES+RCM-SSR        ",
     &                        "SP3                      "/
      DATA (SELF(6,I),I=1,5) /"DIFFUSE                  ",
     &                        "IONEX                    ",
     &                        "MRTCA                    ",
     &                        "L1&L2                    ",
     &                        "NON-DISP.                "/
      DATA (SELF(6,I),I=6,6) /"HARM.SPH.C.              "/
      DATA (SELF(7,I),I=1,5) /"FIXES                    ",
     &                        "ESTIMEES                 ",
     &                        "                         ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELF(8,I),I=1,5) /"FIXE                     ",
     &                        "ESTIME                   ",
     &                        "ESTIME+GRADIENTS         ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELF(9,I),I=1,5) /"NON                      ",
     &                        "OUI                      ",
     &                        "                         ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELF(10,I),I=1,5) /"NON                      ",
     &                        "OUI                      ",
     &                        "                         ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELF(11,I),I=1,5) /"NAD83(CSRS)             ",
     &                        "ITRF                     ",
     &                        "                         ",
     &                        "                         ",
     &                        "                         "/
      DATA (SELF(12,I),I=1,5) /"ELLIPSOIDALES            ",
     &                        "CARTESIENNES             ",
     &                        "                         ",
     &                        "                         ",
     &                        "                         "/
C
      DATA (OPTF(I),I=1,24)  /"Dynamique de l'usager        :",
     &                        "Observation traitee          :",
     &                        "Frequence observee           :",
     &                        "Orbites des satellites       :",
     &                        "Produit satellites utilise   :",
     &                        "Modele ionospherique         :",
     &                        "Coordonnees de la borne      :",
     &                        "Delai tropo au zenith  (TZD) :",
     &                        "Interpolation d'horloge      :",
     &                        "Lissage des parametres       :",
     &                        "Cadre de reference           :",
     &                        "Systeme de coordonnees       :",
     &                        "Sigma des pseudo-distances(m):",
     &                        "Sigma des porteuses       (m):",
     &                        "Bruit TZD/random walk (mm/hr):",
     &                        "Distance borne->ARP       (m):",
     &                        "Elevation minimale      (deg):",
     &                        "Bruit Grad.Trop.      (mm/hr):",
     &                        "Intervalle horloge satel. (s):",
     &                        "Velocite X & Nord     (mm/an):",
     &                        "Velocite Y & Est      (mm/an):",
     &                        "Velocite Z & vertical (mm/an):",
     &                        "Lim. test fermeture code  (m):",
     &                        "Lim. test fermeture phase (m):"/
C
      DATA (OPTE(I),I=1,24)  /"User dynamics                :",
     &                        "Observation processed        :",
     &                        "Frequency observed           :",
     &                        "Satellite orbits             :",
     &                        "Satellite product input      :",
     &                        "Ionospheric model            :",
     &                        "Marker coordinates           :",
     &                        "Troposphere zenith delay(TZD):",
     &                        "Clock interpolation          :",
     &                        "Parameter smoothing          :",
     &                        "Reference frame              :",
     &                        "Coordinate system            :",
     &                        "Pseudorange sigma         (m):",
     &                        "Carrier phase sigma       (m):",
     &                        "TZD random walk       (mm/hr):",
     &                        "Marker->ARP distance      (m):",
     &                        "Cutoff elevation        (deg):",
     &                        "Tropo. Grad. rndm-walk(mm/hr):",
     &                        "Satellite clock interval  (s):",
     &                        "Velocity X & North    (mm/yr):",
     &                        "Velocity Y & East     (mm/yr):",
     &                        "Velocity Z & Vertical (mm/yr):",
     &                        "Code misc. test limit     (m):",
     &                        "Phase misc. test limit    (m):"/
      VEL=0.D0
      DO I=1,3
        VEL=VEL+XRVVEL(I)**2
      END DO
      IF( VEL .GT. 0.D0 ) THEN
        PLHVEL(1)=-SIN(PLHMRK(1))*COS(PLHMRK(2))*XRVVEL(1)
     &            -SIN(PLHMRK(1))*SIN(PLHMRK(2))*XRVVEL(2)
     &            +COS(PLHMRK(1))*               XRVVEL(3)
        PLHVEL(2)=-               SIN(PLHMRK(2))*XRVVEL(1)
     &            +               COS(PLHMRK(2))*XRVVEL(2)
        PLHVEL(3)=+COS(PLHMRK(1))*COS(PLHMRK(2))*XRVVEL(1)
     &            +COS(PLHMRK(1))*SIN(PLHMRK(2))*XRVVEL(2)
     &            +SIN(PLHMRK(1))*               XRVVEL(3) 
      ENDIF
C
C
C     IF FREQUENCY PROCESED IS L3, IONOSPHERIC MODEL IS 2-FREQUENCY
C
      IF ( IONSLM .EQ. 1 ) THEN
        IF ( IFREQ .GE. 3 ) THEN
         IONMOD=4
        ELSE
         IONMOD=5
        END IF
      ELSE
        IF ( ISLMFMT .EQ. 3 ) THEN
         IONMOD=1
        ELSE IF ( ISLMFMT .EQ. 4 ) THEN
         IONMOD=3
        ELSE IF ( ISLMFMT .GE. 5 .OR.
     &            ISLMFMT .LE. 7 ) THEN
         IONMOD=6
         IF ( ISLMFMT .EQ. 6 ) THEN
           WRITE(SELF(6,IONMOD)(1:12),'(A12)') "HARM.SPH.G. "
           WRITE(SELE(6,IONMOD)(1:12),'(A12)') "G.SPH.HARM. "
         ELSE IF ( ISLMFMT .EQ. 7 ) THEN
           WRITE(SELF(6,IONMOD)(1:12),'(A12)') "RTCM(1264)  "
           WRITE(SELE(6,IONMOD)(1:12),'(A12)') "RTCM(1264)  "
         ENDIF
        ELSE
         IONMOD=2
        END IF
      END IF
      IF( IMFSEL .EQ. 0 ) THEN
        WRITE(SELF(6,IONMOD)(13:25),'(A12)') "      Defaut"
        WRITE(SELE(6,IONMOD)(13:25),'(A12)') "     Default"
      ELSE IF( IMFSEL .EQ. 1 ) THEN
        WRITE(SELF(6,IONMOD)(13:25),'(A12)') "    Standard"
        WRITE(SELE(6,IONMOD)(13:25),'(A12)') "    Standard"
      ELSE IF( IMFSEL .EQ. 2 ) THEN
        WRITE(SELF(6,IONMOD)(13:25),'(A12)') "        CODE"
        WRITE(SELE(6,IONMOD)(13:25),'(A12)') "        CODE"
      ELSE IF( IMFSEL .EQ. 3 ) THEN
        WRITE(SELF(6,IONMOD)(13:25),'(A12)') "     RadTest"
        WRITE(SELE(6,IONMOD)(13:25),'(A12)') "     RadTest"
      ELSE IF( IMFSEL .EQ. 4 ) THEN
        WRITE(SELF(6,IONMOD)(13:25),'(A12)') "Clynch et al"
        WRITE(SELE(6,IONMOD)(13:25),'(A12)') "Clynch et al"
      ELSE IF( IMFSEL .EQ. 5 ) THEN
        WRITE(SELF(6,IONMOD)(13:25),'(A12)') " Smith et al"
        WRITE(SELE(6,IONMOD)(13:25),'(A12)') " Smith et al"
      ELSE IF( IMFSEL .EQ. 6 ) THEN
        WRITE(SELF(6,IONMOD)(13:25),'(A12)') "   Broadcast"
        WRITE(SELE(6,IONMOD)(13:25),'(A12)') "   Broadcast"
      ELSE IF( IMFSEL .EQ. 7 ) THEN
        WRITE(SELF(6,IONMOD)(13:25),'(A12)') " Klobuchar75"
        WRITE(SELE(6,IONMOD)(13:25),'(A12)') " Klobuchar75"
      ELSE IF( IMFSEL .EQ. 8 ) THEN
        WRITE(SELF(6,IONMOD)(13:25),'(A12)') " KlobucharEx"
        WRITE(SELE(6,IONMOD)(13:25),'(A12)') " KlobucharEx"
      ELSE IF( IMFSEL .EQ. 9 ) THEN
        WRITE(SELF(6,IONMOD)(13:25),'(A12)') "     NeQuick"
        WRITE(SELE(6,IONMOD)(13:25),'(A12)') "     NeQuick"
      ELSE IF( IMFSEL .GE. 100 ) THEN
        WRITE(SELF(6,IONMOD)(13:25),'(A12)') "Experimental"
        WRITE(SELE(6,IONMOD)(13:25),'(A12)') "Experimental"
      ELSE
        WRITE(SELF(6,IONMOD)(13:25),'(A12)') "        WAAS"
        WRITE(SELE(6,IONMOD)(13:25),'(A12)') "        WAAS"
      ENDIF
C
      IF(.NOT. SMTHCLK ) THEN
        WRITE(SELF(10,2)(13:25),'(A12)') "clock excl. "
        WRITE(SELE(10,2)(13:25),'(A12)') "horloge excl"
      ENDIF
      IEPH=ISVEPH
      IF( ISVEPH .EQ. 1 .AND. ISVCLK .EQ. 3 ) IEPH=3
      IF( ISVEPH .EQ. 1 .AND. ISVCLK .EQ. 4 ) IEPH=4
      ICLK=ISVCLK
      IF( ISVEPH.EQ. 1 .AND. ISVCLK .EQ. 1 ) ICLK=1
      IF( ISVEPH.EQ. 2 .AND. ISVCLK .EQ. 1 ) ICLK=5
C
      IOPT(1)=IMODE
      IOPT(2)=IOBTYP
      IOPT(3)=IFREQ
      IF(IFREQ.GE.5.AND.IFREQ.LE.8) IOPT(3)=3
      IOPT(4)=IEPH
      IOPT(5)=ICLK
      IOPT(6)=IONMOD
      IOPT(7)=IPOSSOL
      IF (MOD(ITRPSOL,10) .EQ. 1) THEN
        IOPT(8)=1
      ELSE
      TRPRW=FLOAT(MOD(ITRPSOL,10))
      IOPT(8)=2
        GRDRW=0.d0
      IF(ITRPSOL.GT.100.D0) THEN
       IOPT(8)=3
       GRDRW=0.1D0
      ENDIF
      END IF
      IOPT(9)=IFITCLK
      IOPT(10)=NDIR
        IF (IOPT(10) .LT. 0 ) IOPT(10)=2
      IOPT(11)=IREFOUT
      IOPT(12)=ICOROUT
      IF (LNG .EQ. 1 ) THEN
        WRITE(LPR,1000)
      ELSE
        WRITE(LPR,1001)
      END IF
C
      IF (LNG .EQ. 2 ) THEN
        WRITE(LPR,1010) (OPTF(I), SELF(I,IOPT(I)), I=1,12)
        IF( VEL .GT. 0.D0 ) THEN
          DO I=1,3
            WRITE(LPR,1021)  OPTF(I+19), XRVVEL(I)*86400.D3*365.25D0
     &                      ,PLHVEL(I)*86400.D0*365.25D0
          END DO
        END IF
        WRITE(LPR,1025)  OPTF(19), INTCLK
        WRITE(LPR,1020)  OPTF(13), SIGOBS
        WRITE(LPR,1020)  OPTF(14), SDCP
        IF( MISCFACTR.GT.0.D0) THEN
        WRITE(LPR,1020)  OPTF(23), MISCFACTR*SIGOBS
        ELSE
        WRITE(LPR,1010)  OPTF(23), 'DESACTIVE                '
        ENDIF
        IF( MISCFACTP.GT.0.D0) THEN
        WRITE(LPR,1020)  OPTF(24), MISCFACTP*SDCP
        ELSE
        WRITE(LPR,1010)  OPTF(24), 'DESACTIVE                '
        ENDIF
        IF (MOD(ITRPSOL,10) .NE. 1)
     &    WRITE(LPR,1020)  OPTF(15), TRPRW
        IF (ITRPSOL .GT. 100)
     &    WRITE(LPR,1020)  OPTF(18), GRDRW
        WRITE(LPR,1020)  OPTF(16), ANTH
        WRITE(LPR,1020)  OPTF(17), CUTOFF
      ELSE
        WRITE(LPR,1010) (OPTE(I), SELE(I,IOPT(I)), I=1,12)
        IF( VEL .GT. 0.D0 ) THEN
          DO I=1,3
            WRITE(LPR,1021)  OPTE(I+19), XRVVEL(I)*86400.D0*365.25D0,
     &                       PLHVEL(I)*86400.D0*365.25D0
          END DO
        END IF
        WRITE(LPR,1025)  OPTE(19), INTCLK
        WRITE(LPR,1020)  OPTE(13), SIGOBS
        WRITE(LPR,1020)  OPTE(14), SDCP
        IF( MISCFACTR.GT.0.D0) THEN
        WRITE(LPR,1020)  OPTE(23), MISCFACTR*SIGOBS
        ELSE
        WRITE(LPR,1010)  OPTE(23), 'DISABLED                 '
        ENDIF
        IF( MISCFACTP.GT.0.D0) THEN
        WRITE(LPR,1020)  OPTE(24), MISCFACTP*SDCP
        ELSE
        WRITE(LPR,1010)  OPTE(24), 'DISABLED                 '
        ENDIF
        IF (MOD(ITRPSOL,10) .NE. 1)
     &    WRITE(LPR,1020)  OPTE(15), TRPRW
        IF (ITRPSOL .GT. 100)
     &    WRITE(LPR,1020)  OPTE(18), GRDRW
        WRITE(LPR,1020)  OPTE(16), ANTH
        WRITE(LPR,1020)  OPTE(17), CUTOFF
      END IF   
C
      ANTMATCH=0
      IF( IPCV .GE. 1 ) ANTMATCH=1
      WRITE(LSES,1405) 'OPT',STNA,IYEAR,IMTH,IDAY,
     &                  IMODE, IOBTYP, IFREQ, ISVEPH,
     &                  ISVCLK, IFITCLK, IONSLM, IPOSSOL, ITRPSOL,
     &                  NDIR, IREFOUT, ICOROUT, SIGOBS, SDCP, ANTH,
     &                  CUTOFF, ANTMATCH
C
C-----------------------------------------------------------------------
C     FORMAT STATEMENTS
C-----------------------------------------------------------------------
C
 1000 FORMAT( //,' ------------------------------------------------',
     &     '-------------------------------',/,
     &     ' SECTION 3. Session Processing Summary ',/,
     &     ' ------------------------------------------------',
     &     '-------------------------------' ,/,
     &     1X,'3.1 Processing Options')
 1001 FORMAT( //,' ------------------------------------------------',
     &     '-------------------------------',/,
     &     ' SECTION 3. Sommaire du traitement de la session',/,
     &     ' ------------------------------------------------',
     &     '-------------------------------' ,/,
     &     1X,'3.1 Options de traitement')
 1010 FORMAT(5X,A30,3X,A25)
 1020 FORMAT(5X,A30,3X,F10.3)
 1021 FORMAT(5X,A30,3X,2F10.3)
 1025 FORMAT(5X,A30,3X,I10)
 1405 FORMAT ( A3,1X,A4,1X,I4,'/',I2.2,'/',I2.2,
     &         8(1X,I2),1X,I4,3(1X,I2),4(1X,F7.3),1X,I10,1X,I1)
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** SUMDEF
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SUMDEF ( LUI, LUO, LPR, LUDEF, IYEARS, IMTHS, IDAYS,
     &           IFREQ, IOBPOS,
     &           IFLT, NAMFLT, FLTPAR, IFLTON, IPC, VSCALE,
     &           IL1CODE, IL2CODE, ILDCB, SDPR, SDCLK,
     &           ISVB, NAMSVB, IGNSS, ISVN, ISVBLK, 
     &           DSVX, DSVY, DSVZ, DP1P2, DP1C1, DP2C2, AVCLK,
     &           IOLC, NAMOLC, NOCOF, XRVMRK, DTM, DMJDOL, AMPL, PHAS, 
     &           IPCV, NAMPCV, ANTNAM, PCVNEU, PCVELV, PCVSAT,
     &           ITRF, NAMTRF, RFRAME, RFREAL, TRFPAR,
     &           IMET, NAMMET, STNHGT, TEMP, PRES, RH, TROSCL,
     &           IERP, NAMERP, FMJDMP, XMPDIF, YMPDIF, XMPDRT, YMPDRT,
     &           IPXR, NAMIPX, 
     &           ICLKAP,NAMSTC,CLKY0,CLKD0,UCLKY0,UCLKD0,CLKSD0,
     &           ICLKFIT,
     &           EPOCH,
     &           LNG, IGF )
C
C     PURPOSE:   SUMMARIZE DEFAULT PARAMETERS
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     NAMDC             DIFFERENTIAL CORRECTION FILE NAME
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      CHARACTER*80 NAMERP
      INTEGER*4    IERP
      REAL*8       FMJDMP, XMPDIF, YMPDIF, XMPDRT, YMPDRT
      INTEGER*4    IPXR
      CHARACTER*80 NAMIPX
      CHARACTER*80 NAMTRF,NAMMET
      CHARACTER*80 NAMDEF,NAMFLT,NAMSVB,NAMOLC,NAMPCV
      CHARACTER*20 ANTNAM
      CHARACTER*15 METSRC(7,2)
      INTEGER*4    ITRP(3)
      CHARACTER*15 TROSRC(9,2)
      CHARACTER*15 MAPSRC(5,2)
      CHARACTER*5  RFRAME,RFREAL
      CHARACTER*1  IGNSS(*)
      INTEGER*4 LUI,LUO,LPR,LUDEF,IYEARS,IMTHS,IDAYS,IFLT,IFLTON,IPC
      INTEGER*4 ISVB,IOLC,NOCOF,IPCV,ITRF,     LNG, IL1CODE, IL2CODE, 
     &          ILDCB
      INTEGER*4 IMET(*)
      INTEGER*4 IFREQ
      INTEGER*4 ISVN(*),ISVBLK(*), IOBPOS(*), IGF(*)
      REAL*8    FLTPAR(*),DSVX(*),DSVY(*),DSVZ(*),DP1P2(*),DP1C1(*),
     &          DP2C2(*)
      REAL*8    AVCLK(*)
C
C AMPL(4,J) PHAS(4,j) contains frequency/phase of tidal term
C
      REAL*8    DMJDOL
      REAL*8    XRVMRK(*),DTM(*),AMPL(4,*),PHAS(4,*),PCVNEU(6,*)
      REAL*8    PCVSAT(MAXSAT,*)
      REAL*8    DAZ, DZE
      REAL*8 PCVELV(361,182,*),TRFPAR(*),VSCALE,STNHGT,TEMP,PRES,RH,
     &       TROSCL
      REAL*8    SDPR
      REAL*8    SDCLK
      INTEGER*4   ICLKAP
      CHARACTER*80 NAMSTC
      REAL*8      CLKY0,CLKD0,UCLKY0,UCLKD0,CLKSD0
      INTEGER*4   ICLKFIT
      REAL*8     EPOCH
C
      CHARACTER*20 ERPHDR(2)
      CHARACTER*11 ERPMJD(2) 
      CHARACTER*11 ERPX(2) 
      CHARACTER*11 ERPY(2) 
      CHARACTER*20 STCHDR(2)
      CHARACTER*20 IPXHDR(2)
      CHARACTER*20 FLTHDR(2)
      CHARACTER*20 SVBHDR(2)
      CHARACTER*20 PCVHDR(2)
      CHARACTER*20 NOPCV(2)
      CHARACTER*10 TRPDATE(2)
      CHARACTER*20 OLCHDR(2)
      CHARACTER*20 TRFHDR(2)
      CHARACTER*8  BLK(MAXBLK)
      CHARACTER*3  TW(MAXOTLC)
      CHARACTER*60 TBLHDR(2)
      INTEGER*4    ITYP
      CHARACTER*15 FLTTYP(3,2)
      CHARACTER*60 SECHDR(7,2), ELVHDR(2), TRPHDR(2)
      CHARACTER*20 TROHDR(3,2)
      CHARACTER*20 METHDR(3,2)
      CHARACTER*60 SVOHDR(2)
      CHARACTER*60 OLTHDR(2)
      CHARACTER*26 PCOHDR(2)
      CHARACTER*17 ANTHDR(2)
      CHARACTER*11 NLAHDR(2) 
      CHARACTER*11 WLAHDR(2)
      CHARACTER*11 MPTHDR(2)
      CHARACTER*11 GAPHDR(2)
      CHARACTER*11 CPDHDR(2)
      CHARACTER*11 CA1HDR(2)
      CHARACTER*11 CA2HDR(2)
      CHARACTER*11 DCB1HDR(2),DCB2HDR(2)
      CHARACTER*11 P3FHDR(2)
      CHARACTER*5  L1CODE(3)
      CHARACTER*5  L2CODE(3)
      CHARACTER*12 LDCB(3,2)
      CHARACTER*12 P3FLT(2,2)
      INTEGER*4 IDSVBLK(MAXBLK,32),NSVBLK(MAXBLK)
     &         ,I,IREFIN,IBLK,IPRN,IDBLK,J
      REAL*8    DX(MAXBLK),DY(MAXBLK),DZ(MAXBLK)
      LOGICAL*4  FOUND22
      CHARACTER*60 DOMEWARN(2)
      DATA (DOMEWARN(I),I=1,2)
     &     /'***    No corresponding Domes found - Uses NONE     ***',
     &      '*** Aucun Dome correspondant - Utilisation de NONE  ***'/
C
      DATA (ERPMJD(I),I=1,2) /'Ref. date  ','Date ref.  '/
      DATA (ERPX(I),I=1,2)   /'Pole X     ','Pole X     '/
      DATA (ERPY(I),I=1,2)   /'Pole Y     ','Pole Y     '/
      DATA (NLAHDR(I),I=1,2) /'Narrowlane ','Bande mince'/
      DATA (WLAHDR(I),I=1,2) /'Widelane   ','Bande large'/
      DATA (MPTHDR(I),I=1,2) /'Multipath  ','Multitrajet'/
      DATA (GAPHDR(I),I=1,2) /'Time gap   ','Interrupt. '/
      DATA (CPDHDR(I),I=1,2) /'Code-Phase ','Code-Phase '/
      DATA (CA1HDR(I),I=1,2) /'Code L1    ','Code L1    '/
      DATA (CA2HDR(I),I=1,2) /'Code L2    ','Code L2    '/
      DATA (DCB1HDR(I),I=1,2) /'P1-C1 bias ','Biais P1-C1'/
      DATA (DCB2HDR(I),I=1,2) /'P2-C2 bias ','Biais P2-C2'/
      DATA (P3FHDR(I),I=1,2) /'P3 filtered','P3 lisse   '/
C
      DATA (TBLHDR(I),I=1,2) 
     &     /'SECTION 2. Summary of processing parameters            ',
     &      'SECTION 2. Sommaire des parametres du traitement       '/
      DATA (SECHDR(1,I),I=1,2)
     &     /'2.1 Observation filter thresholds - CM                 ',
     &      "2.1 Parametres du filtre d'observations - CM           "/ 
      DATA (SECHDR(2,I),I=1,2)
     &     /'2.2 Satellite antenna phase center (APC) offsets - MM  ',
     &      '2.2 Biais des centre de phase des satellites (CPS)- MM '/ 
      DATA (SECHDR(3,I),I=1,2)
     &     /'2.3 Antenna phase center (APC) offsets - MM            ',
     &      "2.3 Biais du centre de phase de l'antenne (CPA)- MM    "/ 
      DATA (SECHDR(4,I),I=1,2)
     &     /'2.4 Reference frame transformation parameters          ',
     &      '2.4 Parametres de transformation de cadre de reference '/ 
      DATA (SECHDR(5,I),I=1,2)
     &     /'2.5 Ocean loading coefficients                         ',
     &      '2.5 Coefficients de surcharge oceanique                '/ 
      DATA (SECHDR(6,I),I=1,2)
     &     /'2.6 Surface meteorological data                        ',
     &      '2.6 Donnees meteo de surface                           '/ 
      DATA (SECHDR(7,I),I=1,2)
     &     /'2.7 Tropospheric models                                ',
     &      '2.7 Modeles tropospheriques                            '/ 
      DATA (ELVHDR(I),I=1,2)
     &     /'Offset variation with respect to elevation angle       ', 
     &      "Variation du bias en fonction de l'angle d'elevation   "/ 
      DATA (TRPHDR(I),I=1,2) 
     &     /"Translations (Tx,y,z), Rotations (Rx,y,z), Scale (S)   ",
     &      "Translations (Tx,y,z), Rotations (Rx,y,z), Echelle (S) "/ 
      DATA (TRPDATE(I),I=1,2)
     &     /' AT EPOCH:', 
     &      ' A EPOQUE:'/ 
      DATA (NOPCV(I),I=1,2)
     &     /'NOT AVAILABLE', 
     &      'NON DISPONIBLE'/ 
      DATA (PCOHDR(I),I=1,2)
     &     /'APC [North, East, Up]', 
     &      'CPA [Nord, Est, Haut]'/ 
      DATA (ANTHDR(I),I=1,2)
     &     /'Antenna Model    ',
     &      "Modele d'antenne:"/
      DATA (SVOHDR(I),I=1,2)
     &/'Center of mass -> APC [Body frame X,Y,Z]                    ', 
     & 'Centre de masse -> CPS [Cadre de reference satellite X,Y,Z ]'/ 
      DATA (ERPHDR(I),I=1,2) 
     &     /'Polar Tides source  ','Marees pole source  '/
      DATA (STCHDR(I),I=1,2) 
     &     /'A priori sta. clock ','Horloge sta. apriori'/
      DATA (IPXHDR(I),I=1,2) 
     &     /'Initial Normal Eq.  ','Eq. Norm. initiales '/
      DATA (FLTHDR(I),I=1,2) 
     &     /'Filter thresholds   ','Tolerance du filtre '/
      DATA (SVBHDR(I),I=1,2) 
     &     /'Satellite offsets   ','Biais des satellites'/
      DATA (PCVHDR(I),I=1,2) 
     &     /'Antenna offsets     ','Biais des antennes  '/
      DATA (OLCHDR(I),I=1,2) 
     &     /'Ocean loading       ','Surcharge oceanique '/
      DATA (OLTHDR(I),I=1,2) 
     &/'Harmonic            Radial        North-South     East-West ',
     & 'Harmonique          Radiale       Nord-Sud        Est-Ouest '/
      DATA (TRFHDR(I),I=1,2) 
     &     /'ITR->NAD transform  ','Conversion ITR->NAD '/
      DATA (METHDR(1,I),I=1,2) 
     &     /'Temperature  (deg C)','Temperature  (deg C)'/
      DATA (METHDR(2,I),I=1,2) 
     &     /'Pressure        (Mb)','Pression        (Mb)'/
      DATA (METHDR(3,I),I=1,2) 
     &     /'Relative humidity(%)','Humidite relative(%)'/
      DATA (TROHDR(1,I),I=1,2) 
     &     /'Hydrostatic delay   ','Delai hydrostatique '/
      DATA (TROHDR(2,I),I=1,2) 
     &     /'Wet delay           ','Delai humide        '/
      DATA (TROHDR(3,I),I=1,2) 
     &     /'Mapping functions   ','Fonctions projection'/
      DATA (L1CODE(I),I=1,3)
     &     /'P1','C1','P1|C1'/
      DATA (L2CODE(I),I=1,3)
     &     /'P2','C2','P2|C2'/
      DATA (LDCB(1,I),I=1,2)
     &     /' NOT APPLIED','NON APPLIQUE'/
      DATA (LDCB(2,I),I=1,2)
     &     /'     APPLIED','    APPLIQUE'/
      DATA (LDCB(3,I),I=1,2)
     &     /' UPD&APPLIED','MAJ&APPLIQUE'/
      DATA (P3FLT(1,I),I=1,2)
     &     /'          NO','         NON'/
      DATA (P3FLT(2,I),I=1,2)
     &     /'         YES','         OUI'/
      DATA (METSRC(1,I),I=1,2)
     &     /'Default       ','Defaut        '/
      DATA (METSRC(2,I),I=1,2)
     &     /'GPT model     ','Modele GPT    '/
      DATA (METSRC(3,I),I=1,2)
     &     /'VMF1 model    ','Modele VMF1   '/
      DATA (METSRC(4,I),I=1,2)
     &     /'GPT2 model    ','Modele GPT2   '/
      DATA (METSRC(5,I),I=1,2)
     &     /'Local/File    ','Local/Fichier '/
      DATA (METSRC(6,I),I=1,2)
     &     /'Local/Keyed-in','Local/Entree  '/
      DATA (METSRC(7,I),I=1,2)
     &     /'Unknown       ','Inconnu       '/
      DATA ITRP/3*1/
      DATA (TROSRC(1,I),I=1,2)
     &     /'Davis(GPT)    ','Davis(GPT)    '/
      DATA (TROSRC(2,I),I=1,2)
     &     /'Hopf(GPT) init','Hopf(GPT) init'/
      DATA (TROSRC(3,I),I=1,2)
     &     /'VMF1-gridded  ','VMF1-grille   '/
      DATA (TROSRC(4,I),I=1,2)
     &     /'VMF1-site     ','VMF1-site     '/
      DATA (TROSRC(5,I),I=1,2)
     &     /'GPT2          ','GPT2          '/
      DATA (TROSRC(6,I),I=1,2)
     &     /'Davis(Loc)    ','Davis(Loc)    '/
      DATA (TROSRC(7,I),I=1,2)
     &     /'Hopfield(Loc) ','Hopfield(Loc) '/
      DATA (TROSRC(8,I),I=1,2)
     &     /'Hopf(VMF) init','Hopf(VMF) init'/
      DATA (TROSRC(9,I),I=1,2)
     &     /'GPT2 init     ','GPT2 init     '/
      DATA (MAPSRC(1,I),I=1,2)
     &     /'GMF           ','GMF           '/
      DATA (MAPSRC(2,I),I=1,2)
     &     /'IMF           ','IMF           '/
      DATA (MAPSRC(3,I),I=1,2)
     &     /'VMF1-gridded  ','VMF1-grille   '/
      DATA (MAPSRC(4,I),I=1,2)
     &     /'VMF1-site     ','VMF1-site     '/
      DATA (MAPSRC(5,I),I=1,2)
     &     /'GPT2          ','GPT2          '/
      DATA (FLTTYP(1,I),I=1,2)
     &     /'Satel. adaptive','Adaptatif sate.'/
      DATA (FLTTYP(2,I),I=1,2)
     &     /'Fixed          ','Fixe           '/
      DATA (FLTTYP(3,I),I=1,2)
     &     /'Global adaptive','Adaptatif glob.'/
C
      BLK(1)='GPS N/A'
      BLK(2)='GPS II '
      BLK(3)='GPS IIA'
      BLK(4)='GPS IIR'
      BLK(5)='GPS IIRM'
      BLK(6)='GPS IIF'
      BLK(7)='GLN I'
      BLK(8)='GLN M'
      BLK(9)='GLN K'
C
C     READ DEFAULT FILE NAMES
C      
      NAMDEF='gpsppp.def'
      OPEN ( LUDEF, FILE=NAMDEF, STATUS='UNKNOWN')
      CALL RDDEF( LUI, LUO, LUDEF, IYEARS, IMTHS, IDAYS,
     &            IFLT, NAMFLT, FLTPAR, IFLTON, IPC, VSCALE,
     &            IL1CODE, IL2CODE, ILDCB, SDPR, SDCLK,
     &            ISVB, NAMSVB, IGNSS, ISVN, ISVBLK, 
     &            DSVX, DSVY, DSVZ, DP1P2, DP1C1, DP2C2, AVCLK,
     &            IOLC, NAMOLC, XRVMRK, DTM, NOCOF, AMPL, PHAS, 
     &            DMJDOL, TW,
     &            IPCV, NAMPCV, ANTNAM, PCVNEU, PCVELV, PCVSAT,
     &            ITRF, NAMTRF, IREFIN, RFRAME, RFREAL, TRFPAR,
     &            ICLKAP,NAMSTC,CLKY0,CLKD0,UCLKY0,UCLKD0,CLKSD0,
     &           ICLKFIT,
     &            IMET(1), NAMMET, STNHGT, TEMP, PRES, RH, TROSCL,
     &            IGF, FOUND22, IFREQ)

C
C
      DO IBLK=1,MAXBLK
        DX(IBLK)=0.D0
      DY(IBLK)=0.D0
      DZ(IBLK)=0.D0
        NSVBLK(IBLK)=0
      END DO
C
      DO IPRN=1,56
          IDBLK=ISVBLK(IPRN)
          IF(IPRN.LE.32.AND.IDBLK.GT.6) IDBLK=6
          IF(IPRN.GT.32..AND.IPRN.LE.64.AND.IDBLK.GT.9) IDBLK=9
        IF (IDBLK .GE. 1) THEN
          NSVBLK(IDBLK)=NSVBLK(IDBLK)+1
          IDSVBLK(IDBLK,NSVBLK(IDBLK))=IPRN
        IF(IPRN.GT.32.AND.IPRN.LE.64)IDSVBLK(IDBLK,NSVBLK(IDBLK))=IPRN-32
          IF (NSVBLK(IDBLK) .EQ. 1) THEN
            DX(IDBLK)=DSVX(IPRN)
            DY(IDBLK)=DSVY(IPRN)
            DZ(IDBLK)=DSVZ(IPRN)
          END IF
        END IF
      END DO
C
C     Cycle Slip Detection Tresholds
C
      WRITE(LPR,1100) FLTHDR(LNG),' ',NAMFLT 
      WRITE(LPR,1100) SVBHDR(LNG),' ',NAMSVB
      WRITE(LPR,1100) PCVHDR(LNG),' ',NAMPCV
      WRITE(LPR,1100) OLCHDR(LNG),' ',NAMOLC
      WRITE(LPR,1100) TRFHDR(LNG),' ',NAMTRF
      IF ( IPXR .EQ. 1 ) WRITE(LPR,1100) IPXHDR(LNG),' ',NAMIPX
      IF( IERP .NE. 0 ) THEN
        WRITE(LPR,1100) ERPHDR(LNG),' ',NAMERP
        WRITE(LPR,1065) ERPMJD(LNG),FMJDMP
        WRITE(LPR,1066) ERPX(LNG),XMPDIF*1000.,XMPDRT*1000.
        WRITE(LPR,1066) ERPY(LNG),YMPDIF*1000.,YMPDRT*1000.
      ENDIF
      IF ( ICLKAP .EQ. 1 ) WRITE(LPR,1100) STCHDR(LNG),' ',NAMSTC
      WRITE(LPR,1001)      
C
      WRITE(LPR,1000) TBLHDR(LNG)    
      WRITE(LPR,1005) SECHDR(1,LNG)
      WRITE(LPR,1006) MPTHDR(LNG),FLTPAR(3)*1.D2      
      WRITE(LPR,1006) GAPHDR(LNG),FLTPAR(5)
      IF ( IFREQ .GE. 3 ) THEN
        IF( FLTPAR(1).GT.0.D0 .AND. FLTPAR(2).GT.0.D0 ) THEN
          ITYP=1
        ELSE IF( FLTPAR(1).LT.0.D0 .AND. FLTPAR(2).LT.0.D0 ) THEN
          ITYP=2
        ELSE
          ITYP=3
        ENDIF
        WRITE(LPR,1008) NLAHDR(LNG),ABS(FLTPAR(1))*1.D2,FLTTYP(ITYP,LNG)
        WRITE(LPR,1008) WLAHDR(LNG),ABS(FLTPAR(2))*1.D2,FLTTYP(ITYP,LNG)
        WRITE(LPR,1007) P3FHDR(LNG),P3FLT(IFLTON+1,LNG)
      ELSE
        IF ( IOBPOS(3) .EQ. 0 ) THEN
        IL1CODE=1
        IF(ILDCB.EQ.0) ILDCB=1
      END IF
        IF ( IOBPOS(4) .EQ. 0 ) THEN
          IL2CODE=1
          IF(ILDCB.EQ.0) ILDCB=1
        END IF
        WRITE(LPR,1006) CPDHDR(LNG),FLTPAR(4)*1.D2
      END IF      
        WRITE(LPR,1007) CA1HDR(LNG),L1CODE(IL1CODE+1)
        WRITE(LPR,1007) CA2HDR(LNG),L2CODE(IL2CODE+1)
      IF (IL1CODE .NE. 0 ) 
     &    WRITE(LPR,1007) DCB1HDR(LNG),LDCB(ILDCB+1,LNG)
        IF (IL2CODE .NE. 0 ) 
     &    WRITE(LPR,1007) DCB2HDR(LNG),LDCB(ILDCB+1,LNG)
C
C     Satellite Phase Center Offsets
C
      WRITE(LPR,1015) SECHDR(2,LNG), IYEARS, IMTHS, IDAYS, SVOHDR(LNG)
      DO IBLK=2,MAXBLK,1
       IF( NSVBLK(IBLK) .GT. 0 ) THEN
          WRITE(LPR,1020) BLK(IBLK),IDNINT(DX(IBLK)*1.D3),
     &                    IDNINT(DY(IBLK)*1.D3),IDNINT(DZ(IBLK)*1.D3)
       WRITE(LPR,1022) 'PRNs:',(IDSVBLK(IBLK,J),J=1,NSVBLK(IBLK))
       WRITE(LPR,1022) 'vCLK:',
     &    (IDNINT(AVCLK(IDSVBLK(IBLK,J))*10),J=1,NSVBLK(IBLK))
       END IF
      END DO
      IF( NSVBLK(1) .GT. 0 ) THEN
       WRITE(LPR,*) '    UNALLOCATED'
       WRITE(LPR,1022) 'PRNs:',(IDSVBLK(1,J),J=1,NSVBLK(1))
      END IF
C
C     User Antenna Phase Center Offsets 
C
      IF ( IPCV .GE. 1 ) THEN
        WRITE(LPR,1025)  SECHDR(3,LNG), ANTHDR(LNG), ANTNAM, 
     &                   PCOHDR(LNG),
     &                   'L1',(IDNINT(PCVNEU(I,1)),I=1,3),
     &                   'L2',(IDNINT(PCVNEU(I+3,1)),I=1,3)
C GLONASS
        IF(IGF(33).NE.99) WRITE(LPR,1026)
     &                   'L1R',(IDNINT(PCVNEU(I,2)),I=1,3),
     &                   'L2R',(IDNINT(PCVNEU(I+3,2)),I=1,3)
C GALILEO
        IF(IGF(75).NE.99) WRITE(LPR,1026)
     &                   'L1E',(IDNINT(PCVNEU(I,3)),I=1,3),
     &                   'L5E',(IDNINT(PCVNEU(I+3,3)),I=1,3)
C BEIDOU 
        IF(IGF(101).NE.99) WRITE(LPR,1026)
     &                   'L1C',(IDNINT(PCVNEU(I,4)),I=1,3),
     &                   'L7C',(IDNINT(PCVNEU(I+3,4)),I=1,3)
       IF( .NOT. FOUND22 )
     &  WRITE(LPR,1024)  DOMEWARN(LNG)
      DZE=5
        IF( IPCV-(IPCV/100)*100 .GT. 10 ) 
     &   DZE =( IPCV-(IPCV/100)*100)/10
      DAZ=720
        IF( IPCV .GT. 100 )
     &   DAZ=INT(IPCV/100)
        WRITE(LPR,1030)  ELVHDR(LNG),
     &           'L1',(IDNINT(PCVELV(1,
     &                                IDNINT((I-1)*5/DZE+1),1)),I=1,19),
     &           'L1',(IDNINT(PCVELV(IDNINT(360/DAZ+1),
     &                               IDNINT((I-1)*5/DZE+1),1)),I=1,19),
     &           'L2',(IDNINT(PCVELV(1,
     &                               IDNINT((I-1)*5/DZE+92),1)),I=1,19),
     &           'L2',(IDNINT(PCVELV(IDNINT(360/DAZ+1),
     &                               IDNINT((I-1)*5/DZE+92),1)),I=1,19)
C GLONASS RX PCV
        IF(IGF(33).NE.99) WRITE(LPR,1037)
     &           'L1R',(IDNINT(PCVELV(1,
     &                                IDNINT((I-1)*5/DZE+1),2)),I=1,19),
     &           'L1R',(IDNINT(PCVELV(IDNINT(360/DAZ+1),
     &                               IDNINT((I-1)*5/DZE+1),2)),I=1,19),
     &           'L2R',(IDNINT(PCVELV(1,
     &                               IDNINT((I-1)*5/DZE+92),2)),I=1,19),
     &           'L2R',(IDNINT(PCVELV(IDNINT(360/DAZ+1),
     &                               IDNINT((I-1)*5/DZE+92),2)),I=1,19)
C GALILEO RX PCV
        IF(IGF(75).NE.99) WRITE(LPR,1037)
     &           'L1E',(IDNINT(PCVELV(1,
     &                                IDNINT((I-1)*5/DZE+1),3)),I=1,19),
     &           'L1E',(IDNINT(PCVELV(IDNINT(360/DAZ+1),
     &                               IDNINT((I-1)*5/DZE+1),3)),I=1,19),
     &           'L5E',(IDNINT(PCVELV(1,
     &                               IDNINT((I-1)*5/DZE+92),3)),I=1,19),
     &           'L5E',(IDNINT(PCVELV(IDNINT(360/DAZ+1),
     &                               IDNINT((I-1)*5/DZE+92),3)),I=1,19)
C GALILEO RX PCV
        IF(IGF(101).NE.99) WRITE(LPR,1037)
     &           'L1C',(IDNINT(PCVELV(1,
     &                                IDNINT((I-1)*5/DZE+1),4)),I=1,19),
     &           'L1C',(IDNINT(PCVELV(IDNINT(360/DAZ+1),
     &                               IDNINT((I-1)*5/DZE+1),4)),I=1,19),
     &           'L7C',(IDNINT(PCVELV(1,
     &                               IDNINT((I-1)*5/DZE+92),4)),I=1,19),
     &           'L7C',(IDNINT(PCVELV(IDNINT(360/DAZ+1),
     &                               IDNINT((I-1)*5/DZE+92),4)),I=1,19)
        IF( IPC .LE. 1 )
     &  WRITE(LPR,1036)
     &  'SV antenna offsets in body-axis'
        IF( IPC .GT. 1 )
     &  WRITE(LPR,1032)
     &  'SV ant offset variation wrt to nadir angle(NAD) in deg'
        DO IPRN=1,MAXSAT
         IF(ISVBLK(IPRN).GT.1 .AND.IGF(IPRN).NE.99) THEN
        IF(IPC.LE.1)
     &     WRITE(LPR,1034) IPRN, DSVX(IPRN)*1.d3, DSVY(IPRN)*1.d3,
     &              DSVZ(IPRN)*1.d3 
 1034 FORMAT(5x,i4,3f10.2)
C
C write out sat elvpcv only when IPC>1
C PRINT ONLY THE FIRST 15 ENTRIES: 0-14 DEG
C
        IF (IPC.GT.1)
     &     WRITE(LPR,1033) IPRN, DSVX(IPRN)*1.d3, DSVY(IPRN)*1.d3,
     &              DSVZ(IPRN)*1.d3,
     &              ISVBLK(IPRN),'L1',(IDNINT(PCVSAT(IPRN,I)),I=1,15),
     &              ISVBLK(IPRN),'L2',(IDNINT(PCVSAT(IPRN,I+21)),I=1,15)
         ENDIF
        END DO
      ELSE
        WRITE(LPR,1031)  SECHDR(3,LNG), NOPCV(LNG)
      END IF
C
C     Reference Frame Transformation Parameters
C
      WRITE(LPR,1045) SECHDR(4,LNG), RFRAME, RFREAL, TRPDATE(LNG), EPOCH
      WRITE(LPR,1050) TRPHDR(LNG),
     &                (TRFPAR(I)+(EPOCH-TRFPAR(2))*TRFPAR(I+7),I=3,9),
     &                (TRFPAR(I),I=10,16)
C
C     Ocean Loading Coefficients
C
      IF ( IOLC .EQ. 0 ) THEN
        WRITE(LPR,1035) SECHDR(5,LNG),'NOT FOUND'
      ELSE
        WRITE(LPR,1035) SECHDR(5,LNG),'FOUND'
C
C AMPL(4,J) PHAS(4,j) contains frequency/phase of tidal term
C
        WRITE(LPR,1040) OLTHDR(LNG)
      DO J=1,NOCOF
       WRITE(LPR,1041) TW(J),AMPL(4,J),PHAS(4,J),
     &                   AMPL(1,J),PHAS(1,J),
     &                   AMPL(3,J),PHAS(3,J),
     &                   AMPL(2,J),PHAS(2,J)
      END DO
      END IF
C
C     Surface mets
C
      DO I=1,3
      IF( IMET(I).LT.1.OR.IMET(I).GT.6) IMET(I)=7
      END DO
      WRITE(LPR,1055) SECHDR(6,LNG),
     &   METHDR(1,LNG), TEMP, METSRC(IMET(1),LNG),
     &   METHDR(2,LNG), PRES, METSRC(IMET(2),LNG),
     &   METHDR(3,LNG), RH,   METSRC(IMET(3),LNG)
      ITRP(1)=1
      ITRP(2)=2
      ITRP(3)=IMET(5)
      IF( IMET(1) .GT. 4 .OR. IMET(2) .GT. 4 .OR. IMET(3).GT. 4 ) THEN
       ITRP(1)=ITRP(1)+5
       ITRP(2)=ITRP(2)+5
      ELSE IF( IMET(5) .GT. 2 ) THEN
       ITRP(1)=IMET(5)
       ITRP(2)=8
       IF( IMET(5) .GT. 4 ) ITRP(2)=9
      ENDIF
      WRITE(LPR,1056) SECHDR(7,LNG),
     &   TROHDR(1,LNG), TROSRC(ITRP(1),LNG),
     &   TROHDR(2,LNG), TROSRC(ITRP(2),LNG),
     &   TROHDR(3,LNG), MAPSRC(ITRP(3),LNG)
C
C------------------------------------------------------------------------
C     FORMAT STATEMENTS
C------------------------------------------------------------------------
C
 1000 FORMAT( //,' ------------------------------------------------',
     &         '-------------------------------',/,A60,/,
     &         ' ------------------------------------------------',
     &         '-------------------------------' )
 1001 FORMAT(' ------------------------------------------------',
     &         '-------------------------------')
 1005 FORMAT(/,1X,A55)
 1006 FORMAT(5X,A11,':',F12.1)
 1007 FORMAT(5X,A11,':',A12)
 1008 FORMAT(5X,A11,':',F12.1,1X,A15)
 1015 FORMAT(/,1X,A55,2X,'for ',I4.4,'-',I2.2,'-',I2.2,/,5X,A60)
 1020 FORMAT(5X,A8,' [',2(I4,','),I4,']')    
 1022 FORMAT(5X,A4,1X,24(1X,I2.2))
 1024 FORMAT(5X,A60)
 1025 FORMAT(/,1X,A55,/,5X,A17,1X,A20,/,5X,A26,
     &       1X,A3,' [',2(I3,','),I3,'],',
     &       1X,A3,' [',2(I3,','),I3,']')
 1026 FORMAT(31X,
     &       2X,A3,'[',2(I3,','),I3,'],',
     &       2X,A3,'[',2(I3,','),I3,']')
 1030 FORMAT(5X,A55,/,5X,'AZIM ELV 90 85 80 75 70 65 60 55 50 45 40',
     &       ' 35 30 25 20 15 10  5  0',/,
     &       2(5x,'   0 ',A3,19(I3),/,5x,' 360 ',A3,19(I3),/))
 1037 FORMAT(
     &       2(5x,'   0 ',A3,19(I3),/,5x,' 360 ',A3,19(I3),/))
 1032 FORMAT(5X,A55,/,5X,' PRN NAD  0  1  2  3  4  5  6  7  8  9 10',
     &       ' 11 12 13 14')
 1033 FORMAT(5x,i4,3f10.2/5x,I4,2x,A2,15(I3),/,5x,I4,2x,A2,15(I3))
 1031 FORMAT(/,1X,A55,1X,A20)
 1036 FORMAT(5X,A55,/,5X,' PRN  X-offset  Y-offset  Z-offset')
 1035 FORMAT(/,1X,A55,1X,A10)
 1040 FORMAT(1X,A60,/,
     &       2X,'Term  Frequ.   Phase',3('  Ampl.    Phase'),/,
     &       7X,'(rad/h)   (deg)',3('   (mm)    (deg)'))
 1041 FORMAT(3X,A3,1X,F6.4,1X,F8.3,3(2X,F5.1,1X,F8.3))
 1045 FORMAT(/,1X,A60,/,5X,A5,'(',A5,')->NAD83( CSRS)',1X,A10,1X,F6.1)
 1050 FORMAT(5X,A55,//,
     & 7X,' Tx       Ty       Tz      S        Rx       Ry      Rz',/,
     & 7X,'(cm)     (cm)     (cm)    (ppb)    (mas)    (mas)   (mas)',
     & /,2X,7F9.3,//,
     & 7X,' dTx      dTy      dTz     dS       dRx      dRy     dRz',/,
     & 7X,'(cm/y)   (cm/y)   (cm/y)  (ppb/y)  (mas/y)  (mas/y) (mas/y)',
     & /,2X,7F9.3)
 1055 FORMAT(/,1X,A55,//,3(5X,A20,':',F7.2,2X,'(',A15,')',/))
 1056 FORMAT(/,1X,A55,//,3(5X,A20,': ',A15,/))
 1065 FORMAT(5X,A11,':',F12.3)
 1066 FORMAT(5X,A11,':',2F12.3, ' mas, mas/d')
 1100 FORMAT( 1X,A20,1X,A3,1X,A54 )
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** SUMIOF
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SUMIOF ( LPR, NAMOBS, NAMCMD, ISVEPH, NAMEPH, 
     &                    ISVCLK, NAMCLK, IONSLM, NAMION, 
     &                    NBDAY, IFREQ, LNG )
C
C     PURPOSE:   SUMMARIZE INPUT/OUTPUT FILE NAMES IN TABLE 1
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     NAMDC             DIFFERENTIAL CORRECTION FILE NAME
C
C***********************************************************************
C
      IMPLICIT NONE
C
      CHARACTER*80   NAMOBS,NAMCMD,NAMOUT
      CHARACTER*80   NAMEPH(*),NAMCLK(*),NAMION(*)
      INTEGER*4 LPR, ISVEPH,ISVCLK,IONSLM,NBDAY,IFREQ,LNG
C
      CHARACTER*40   TBLHDR(2)
      CHARACTER*20   CONHDR(2),INPHDR(2),OUTHDR(2)
      CHARACTER*24   DEFHDR(2),OBSHDR(2),CMDHDR(2),EPHHDR(2)
      CHARACTER*24   CLKHDR(2),IONHDR(2),POSHDR(2),RESHDR(2)
     &              ,ION2HDR(2)
      CHARACTER*24   SUMHDR(2),SESHDR(2)
      CHARACTER*24   IPXHDR(2)
      CHARACTER*24   MRTCAHDR(2)
      CHARACTER*24   RTCMHDR(2)
      INTEGER*4 I,ID
C
      DATA (TBLHDR(I),I=1,2) 
     &     /'SECTION 1. File Summary                 ',
     &      'SECTION 1. Sommaire des fichiers        '/
      DATA (CONHDR(I),I=1,2) 
     &     /'Content             ',"Contenu             "/
      DATA (INPHDR(I),I=1,2) 
     &     /'INPUT Filenames     ',"Fichiers d'ENTREE   "/
      DATA (OUTHDR(I),I=1,2) 
     &     /'OUTPUT Filenames    ','Fichiers de SORTIE  '/
      DATA (DEFHDR(I),I=1,2) 
     &     /'INTERNAL Filenames  ','Fichiers INTERNES   '/
      DATA (OBSHDR(I),I=1,2) 
     &     /'Observations            ','Observations            '/
      DATA (CMDHDR(I),I=1,2) 
     &     /'Processing options      ','Options de traitement   '/
      DATA (EPHHDR(I),I=1,2) 
     &     /'Satellite orbits        ','Orbites des satellites  '/
      DATA (CLKHDR(I),I=1,2) 
     &     /'Satellite clocks        ','Horloges des satellites '/
      DATA (MRTCAHDR(I),I=1,2) 
     &     /'MRTCA corrections       ','Corrections MRTCA       '/
      DATA (RTCMHDR(I),I=1,2) 
     &     /'RTCM-SSR corrections    ','Corrections RTCM-SSR    '/
      DATA (IONHDR(I),I=1,2) 
     &     /'Ionospheric model       ','Modele ionospherique    '/
      DATA (ION2HDR(I),I=1,2) 
     &     /'Ionospheric model (2nd) ','Modele ionospherique(2e)'/
      DATA (SUMHDR(I),I=1,2) 
     &     /'Processing summary      ','Sommaire du traitement  '/
      DATA (POSHDR(I),I=1,2) 
     &     /'Estimated parameters    ','Parametres estimes      '/
      DATA (RESHDR(I),I=1,2) 
     &     /'Satellite residuals     ','Residuelles satellites  '/
      DATA (SESHDR(I),I=1,2) 
     &     /'Session summary         ','Sommaire de la session  '/
      DATA (IPXHDR(I),I=1,2) 
     &     /'Final Normal Eq.  (bin) ','Eq. Normales Finales    '/
C 
      WRITE(LPR,1000) TBLHDR(LNG)
      WRITE(LPR,1050) CONHDR(LNG),INPHDR(LNG)
      WRITE(LPR,1100) OBSHDR(LNG),NAMOBS
      WRITE(LPR,1100) CMDHDR(LNG),NAMCMD
      DO ID=1,NBDAY
        IF ( ISVEPH .EQ. 1 )
     &    WRITE(LPR,1100) EPHHDR(LNG),NAMEPH(ID)
        IF ( ISVEPH .EQ. 2 )
     &    WRITE(LPR,1100) EPHHDR(LNG),NAMEPH(ID)
        IF ( ISVCLK .EQ. 1 )
     &    WRITE(LPR,1100) CLKHDR(LNG),NAMEPH(ID)
        IF ( ISVCLK .EQ. 2 )
     &    WRITE(LPR,1100) CLKHDR(LNG),NAMCLK(ID)
        IF ( ISVCLK .EQ. 3 )
     &    WRITE(LPR,1100) MRTCAHDR(LNG),NAMCLK(ID)
        IF ( ISVCLK .EQ. 4 )
     &    WRITE(LPR,1100) RTCMHDR(LNG),NAMCLK(ID)
        IF ( IONSLM .GE. 2 ) THEN
        IF( IFREQ .GE. 3 )
     &    WRITE(LPR,1100) ION2HDR(LNG),NAMION(ID)
        IF( IFREQ .LT. 3 )
     &    WRITE(LPR,1100) IONHDR(LNG),NAMION(ID)
        ENDIF
      END DO
      WRITE(LPR,1060) OUTHDR(LNG)
      WRITE(NAMOUT,'(80A1)') CHAR(0)
      CALL CHSFX ( NAMOBS, NAMOUT, '.sum' )
      WRITE(LPR,1100) SUMHDR(LNG),NAMOUT
      CALL CHSFX ( NAMOBS, NAMOUT, '.pos' )
      WRITE(LPR,1100) POSHDR(LNG),NAMOUT
      CALL CHSFX ( NAMOBS, NAMOUT, '.res' )
      WRITE(LPR,1100) RESHDR(LNG),NAMOUT
      CALL CHSFX ( NAMOBS, NAMOUT, '.ses' )
      WRITE(LPR,1100) SESHDR(LNG),NAMOUT
      CALL CHSFX ( NAMOBS, NAMOUT, '.ipx' )
      WRITE(LPR,1100) IPXHDR(LNG),NAMOUT
      WRITE(LPR,1060) DEFHDR(LNG)
C------------------------------------------------------------------------
C     FORMAT STATEMENTS
C------------------------------------------------------------------------
C
 1000 FORMAT( //,' ------------------------------------------------',
     &     '-------------------------------',/,1X,A40,/,
     &    ' ------------------------------------------------',
     &     '-------------------------------')
 1050 FORMAT(1X,A20,5X,A20)
 1060 FORMAT(1X,'                         ',A20)
 1100 FORMAT(1X,A24,1X,A54 )
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** SUMOBS
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SUMOBS ( LPR, LSES, STNA, NARC, STIME, 
     &                    ETIME, OBSINT, UPDINT, NOB, NRJ,
     &                    NCS,
     &                    IACTION,
     &                    IOBTYP,
     &                    RAVG, RRMS, PAVG, PRMS, NFIX, 
     &                    NOBFX, NEPFIX,
     &                    CNTFIX,CNTAMB,
     &                    NEPOCHDEL,
     &                    NSVARC, RESARC, IMODE, IFREQ, 
     &                    NECLIPS, IPEPACC, ILANG , SOBWD, FLTPAR,
     &                    DP1P2 , IBLK)
C
C     PURPOSE:   SUMMARIZE SESSION OBSERVATIONS
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     LPR               LOGICAL UNIT OF PRINTER
C     STNA              STATION NAME
C     STIME             ARC START TIME
C     ETIME             ARC END TIME
C     OBSINT            DATA RATE
C       ILANG           LANGUAGE OF OUTPUT
C
C***********************************************************************
C
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      CHARACTER*90   RESARC(2,*)
      CHARACTER*40   STNA
      CHARACTER*1    IECLIPS
     &              , SV
      INTEGER*4 IOBTYP
     &         ,IACTION
      INTEGER*4 NEPOCHDEL
      INTEGER*4 LPR, LSES,NFIX,NSVARC,IMODE,IFREQ,ILANG
      INTEGER*4 NARC(MAXSAT)
      INTEGER*4 NECLIPS(MAXSAT)
      INTEGER*4 IPEPACC(MAXSAT)
      INTEGER*4 CNTFIX(MAXSAT),CNTAMB(MAXSAT)
      INTEGER*4 NOB(MAXSAT,MAXARC)
     &         ,NOBFX(MAXSAT,MAXARC), NEPFIX
     &         ,FIX, FIX1, FIX2
      INTEGER*4 NRJ(MAXSAT,MAXARC,MAXREJ)
      INTEGER*4 NCS(MAXSAT,MAXARC,MAXREJ),NCSARC(MAXREJ),NCSIR(MAXREJ)
      INTEGER*4 NRJARC(MAXREJ), NRJIR(MAXREJ)
      REAL*8    OBSINT,UPDINT
      REAL*8    RAVG(MAXSAT,MAXARC), RRMS(MAXSAT,MAXARC)
      REAL*8    PAVG(MAXSAT,MAXARC), PRMS(MAXSAT,MAXARC)
      REAL*8    STIME(MAXSAT,MAXARC), ETIME(MAXSAT,MAXARC)
      REAL*8  SOBWD, FLTPAR(*) 
      REAL*8  DP1P2
C
      CHARACTER*35   STAHDR(2)
      CHARACTER*35   STMHDR(2)
      CHARACTER*35   ETMHDR(2)
      CHARACTER*35   INTHDR(2)
      CHARACTER*35   ESTHDR(2)
      CHARACTER*35   NSVHDR(2)
      CHARACTER*35   NOBHDR(2)
      CHARACTER*35   NRJHDR(2)
      CHARACTER*35   NDWHDR(2)
      CHARACTER*35   NEPHDR(2)
      CHARACTER*35   NERHDR(2)
      CHARACTER*35   NAMHDR(2)
      CHARACTER*35   PRRHDR(2)
      CHARACTER*35   CPRHDR(2)
      CHARACTER*3    OBTYPE(2)
      CHARACTER*2    FREQ(8)
      INTEGER*4 I,              ISSWK,ISEWK,NOUNKNS,NOBARC,IR
      INTEGER*4 IA,ISSDAY,IHRS,IMINS,ISEDAY,IHRE,IMINE,JULD
      INTEGER*4 IYEARS,IMTHS,IDAYS,IYEARE,IMTHE,IDAYE,MJD
      CHARACTER*7 CONST(4)
      INTEGER*4 ICONST,NRJALL(4),NOBALL(4),NDWALL(4), NCONST
      INTEGER*4 NOFXALL(4),NAFXALL(4),NARALL(4),
     &  NOBARCFX, NARCFX
      INTEGER*4 IBLK(*)
      REAL*8    RAVGALL(4),RRMSALL(4),PAVGALL(4),PRMSALL(4)
      REAL*8    SSTIME,SETIME
      REAL*8    RAVGARC,RRMSARC,PAVGARC,PRMSARC,SECS,SECE
C
      DATA (OBTYPE(I),I=1,2) /'COD','C&P'/
      DATA (FREQ(I),I=1,8) /'L1','L2','L3','L3','L3','L3','L3','L3'/
C                                
      DATA (STAHDR(I),I=1,2) /"Marker name                       :",
     &                        "Nom de la borne                   :"/
      DATA (STMHDR(I),I=1,2) /"Start                             :",
     &                        "Debut                             :"/
      DATA (ETMHDR(I),I=1,2) /"End                               :",
     &                        "Fin                               :"/
      DATA (INTHDR(I),I=1,2) /"Observation interval        (sec) :",
     &                        "Intervalle des observations (sec) :"/
      DATA (ESTHDR(I),I=1,2) /"Estimation interval         (sec) :",
     &                        "Intervalle des estimes      (sec) :"/
      DATA (NSVHDR(I),I=1,2) /"Number of satellites processed    :",
     &                        "Nombre de satellites traites      :"/
      DATA (NOBHDR(I),I=1,2) /"Number of observations processed  :",
     &                        "Nombre d'observations traitees    :"/
      DATA (NRJHDR(I),I=1,2) /"Number of observations rejected   :",
     &                        "Nombre d'observations rejetees    :"/
      DATA (NDWHDR(I),I=1,2) /"Number of observations deweighted :",
     &                        "Nombre d'observations deponderees :"/
      DATA (NEPHDR(I),I=1,2) /"Number of epochs processed (%fix) :",
     &                        "Nombre d'epoques traitees (%fixe) :"/
      DATA (NAMHDR(I),I=1,2) /"Ambiguity fixed   (%obs  %ambs)   :",
     &                        "Ambiguites fixees (%obs  %ambs)   :"/
      DATA (NERHDR(I),I=1,2) /"Number of epochs rejected         :",
     &                        "Nombre d'epoques rejetees         :"/
      DATA (PRRHDR(I),I=1,2) /"Pseudorange residuals        (m)  :",
     &                        "Residuelles pseudo-distances (m)  :"/
      DATA (CPRHDR(I),I=1,2) /"Carrier phase residuals      (cm) :",
     &                        "Residuelles phases porteuses (cm) :"/
      DATA (CONST(I),I=1,2) /"GPS    ",
     &                       "GLONASS"/
      DATA CONST(3) /"GALILEO"/, CONST(4) /"BEIDOU "/
      NCONST = 4
C
      IF (ILANG .EQ. 1 ) WRITE(LPR,1000)
      IF (ILANG .EQ. 2 ) WRITE(LPR,1001)
C
      DO IR=1,7
        NRJIR(IR) = 0
        NCSIR(IR) = 0
      END DO
      NSVARC = 0
      DO ICONST=1,NCONST
       NOBALL(ICONST) = 0
       NARALL(ICONST) = 0
       NOFXALL(ICONST) = 0
       NAFXALL(ICONST) = 0
       NRJALL(ICONST) = 0
       NDWALL(ICONST) = 0
       RAVGALL(ICONST) = 0.D0
       RRMSALL(ICONST) = 0.D0 
       PAVGALL(ICONST) = 0.D0 
       PRMSALL(ICONST) = 0.D0 
      END DO
      SSTIME=604800.D4
      SETIME=0.D0
      ISSWK=5000.D0
      ISEWK=0.D0
C  NO. OF UNKNOWNS
      NOUNKNS=4
      IF(IMODE.EQ.2) NOUNKNS=NOUNKNS + 4*(NFIX-1)
      DO I=1,MAXSAT
       IF ( NARC(I) .NE. 0 ) THEN
        NSVARC=NSVARC+1   
        NOBARC=0
        NOBARCFX = 0
        NARCFX = 0
        DO IR=1,7
          NRJARC(IR) = 0
          NCSARC(IR) = 0
        END DO
        RAVGARC=0.D0
        RRMSARC=0.D0
        PAVGARC=0.D0
        PRMSARC=0.D0
        DO IA=1,NARC(I)
          NOBARC = NOBARC + NOB(I,IA)
          NOBARCFX = NOBARCFX + NOBFX(I,IA)
          DO IR=1,7
            NRJARC(IR) = NRJARC(IR) + NRJ(I,IA,IR)
            NCSARC(IR) = NCSARC(IR) + NCS(I,IA,IR)
          END DO
          RAVGARC = RAVGARC + RAVG(I,IA)*NOB(I,IA)
          RRMSARC = RRMSARC + RRMS(I,IA)**2*NOB(I,IA)
          PAVGARC = PAVGARC + PAVG(I,IA)*NOB(I,IA)
          PRMSARC = PRMSARC + PRMS(I,IA)**2*NOB(I,IA)
          SSTIME = MIN(STIME(I,IA),SSTIME)
          SETIME = MAX(ETIME(I,IA),SETIME)
C  No OF UNKNOWNS
          IF(NOB(I,IA).GT.0) NOUNKNS= NOUNKNS+1
        END DO
        IF( NOBARC .GT. 0 ) THEN
          RRMSARC=RRMSARC-RAVGARC**2/NOBARC
          IF( DABS(RRMSARC/NOBARC) .LT. 1.E-10 ) RRMSARC=1.D-10*NOBARC
        ENDIF
C
C         STORE ARC RESIDUALS STATISTICS 
C
        IECLIPS=' '
        SV='G'
        IR=I
C start GLONASS
        IF (I.GT.32.AND.I.LE.64) THEN
          SV='R'
          IR=I-32
        END IF
C end GLONASS
C start GALILEO
            IF (I.GT.64.AND.I.LE.100) THEN
                SV='E'
                IR=I-64
            END IF
C end GALILEO
C start BEIDOU 
            IF (I.GT.100.AND.I.LE.136) THEN
                SV='C'
                IR=I-100
C m - Bedou medium orbit
                IF(IBLK(I).EQ.21.OR.IBLK(I).EQ.25)IECLIPS='m'
C i - Bedou ncline orbit
                IF(IBLK(I).EQ.22.OR.IBLK(I).EQ.26)IECLIPS='i'
C g - Bedou geosyn (stationary)  orbit
                IF(IBLK(I).EQ.23.OR.IBLK(I).EQ.27)IECLIPS='g'
             END IF
C end BEIDOU 
        IF (NOBARC .NE. 0 ) THEN
          IF (NECLIPS(I) .NE. 0) IECLIPS='E'
          WRITE(RESARC(1,NSVARC),1500) SV, IR, IECLIPS, IPEPACC(I),
     &        NARC(I), CNTAMB(I),NOBARC, 
     &        (NRJARC(IR),IR=1,7),RAVGARC/NOBARC, SQRT(RRMSARC/NOBARC), 
     &        PAVGARC/NOBARC*1.D2, SQRT(PRMSARC/NOBARC)*1.D2
          IF( IOBTYP .EQ. 2 )
     &      WRITE(RESARC(2,NSVARC),1501) (100*CNTFIX(I))/CNTAMB(I),
     &         (100*NOBARCFX)/NOBARC, 
     &          (NCSARC(IR),IR=1,4)
        ELSE
          WRITE(RESARC(1,NSVARC),1500) SV,IR, IECLIPS, IPEPACC(I),
     &        NARC(I), CNTAMB(I), NOBARC, 
     &        (NRJARC(IR),IR=1,7), 0.D0, 0.D0, 0.D0, 0.D0
        IF( IOBTYP .EQ. 2 )
     &      WRITE(RESARC(2,NSVARC),1501) 0, 
     &         0, (NCSARC(IR),IR=1,4)
        END IF
        ICONST=1
        IF( I .GT. 32 .AND. I .LE. 64 ) ICONST=2
        IF( I .GT. 64 .AND. I .LE. 100) ICONST=3
        IF( I .GT.100 .AND. I .LE. 136) ICONST=4
        RAVGALL(ICONST) = RAVGALL(ICONST) + RAVGARC 
        RRMSALL(ICONST) = RRMSALL(ICONST) + RRMSARC 
        PAVGALL(ICONST) = PAVGALL(ICONST) + PAVGARC 
        PRMSALL(ICONST) = PRMSALL(ICONST) + PRMSARC 
        NOBALL(ICONST) = NOBALL(ICONST) + NOBARC
        NOFXALL(ICONST) = NOFXALL(ICONST) + NOBARCFX
        NAFXALL(ICONST) = NAFXALL(ICONST) + CNTFIX(I)
        NARALL(ICONST) = NARALL(ICONST) + CNTAMB(I)
        DO IR=1,7
         IF(IR.NE.6) THEN
            NRJALL(ICONST) = NRJALL(ICONST) + NRJARC(IR)
         ELSE
            NDWALL(ICONST) = NDWALL(ICONST) + NRJARC(IR)
         ENDIF
         NRJIR(IR) = NRJIR(IR) + NRJARC(IR)
         NCSIR(IR) = NCSIR(IR) + NCSARC(IR)
        END DO
       END IF
      END DO
C
C COMPUTE CP AND CODE  RMS
C
c!    WRITE(*,*) 'NOBALL,NOUNKNS', NOBALL,NOUNKNS,PRMSALL,RRMSALL
      DO ICONST=1,NCONST
       IF ( NOBALL(ICONST) .NE. 0 ) THEN
         RAVGALL(ICONST) = RAVGALL(ICONST)/NOBALL(ICONST)
         PAVGALL(ICONST) = PAVGALL(ICONST)/NOBALL(ICONST)
         RRMSALL(ICONST) = DSQRT(RRMSALL(ICONST)/NOBALL(ICONST))
         PRMSALL(ICONST) = DSQRT(PRMSALL(ICONST)/NOBALL(ICONST))
       ELSE
         RAVGALL(ICONST) = 0.D0
         PAVGALL(ICONST) = 0.D0
         RRMSALL(ICONST) = 0.D0
         PRMSALL(ICONST) = 0.D0
       END IF
      END DO
C
      ISSWK=SSTIME/604800.D0
      ISEWK=SETIME/604800.D0
      SSTIME=DMOD(SSTIME,604800.D0)
      SETIME=DMOD(SETIME,604800.D0)
      CALL TOWHMS( ISSDAY, SSTIME, IHRS, IMINS, SECS, 0 )
      CALL TOWHMS( ISEDAY, SETIME, IHRE, IMINE, SECE, 0 )
      CALL GPSDC ( JULD,IYEARS,IMTHS,IDAYS,ISSWK,ISSDAY, 4 )
      CALL GPSDC ( JULD,IYEARE,IMTHE,IDAYE,ISEWK,ISEDAY, 4 )
      WRITE(LPR,1050) STAHDR(ILANG),STNA
      WRITE(LPR,1100) STMHDR(ILANG),IYEARS, IMTHS, IDAYS, 
     &                                  IHRS, IMINS, INT(SECS), 
     &                                  INT((SECS-INT(SECS))*100)    
      WRITE(LPR,1100) ETMHDR(ILANG),IYEARE, IMTHE, IDAYE, 
     &                                  IHRE, IMINE, INT(SECE), 
     &                                  INT((SECE-INT(SECE))*100)
      WRITE(LPR,1150) INTHDR(ILANG),OBSINT
      WRITE(LPR,1150) ESTHDR(ILANG),UPDINT
      FIX=0
      IF( NFIX .GT. 0 ) FIX=100*NEPFIX/NFIX
      WRITE(LPR,1162) NEPHDR(ILANG),NFIX,FIX
      WRITE(LPR,1160) NERHDR(ILANG),NEPOCHDEL
      WRITE(LPR,1160) NSVHDR(ILANG),NSVARC
      DO ICONST=1,NCONST
        IF( NOBALL(ICONST) .GT. 0 .OR. NRJALL(ICONST) .GT. 0 .OR.
     &      NDWALL(ICONST) .GT. 0 ) THEN
          IF( IACTION .EQ. 0 ) THEN
            NRJALL(ICONST)=NRJALL(ICONST)+NDWALL(ICONST)
            NDWALL(ICONST)=0
          ENDIF
          WRITE(LPR,1161) NOBHDR(ILANG),NOBALL(ICONST),CONST(ICONST)
          WRITE(LPR,1161) NRJHDR(ILANG),NRJALL(ICONST),CONST(ICONST)
          WRITE(LPR,1161) NDWHDR(ILANG),NDWALL(ICONST),CONST(ICONST)
          IF( NOBALL(ICONST) .GT. 0 ) THEN
            WRITE(LPR,1151) PRRHDR(ILANG),RRMSALL(ICONST),CONST(ICONST)
            WRITE(LPR,1151) CPRHDR(ILANG),PRMSALL(ICONST)*1.D2,
     &                    CONST(ICONST)
            FIX1=(100*NOFXALL(ICONST))/NOBALL(ICONST)
            FIX2=0
            IF( NARALL(ICONST) .GT. 0 )
     &       FIX2=(100*NAFXALL(ICONST))/NARALL(ICONST)
            WRITE(LPR,1152) NAMHDR(ILANG),FIX1,FIX2,
     &                      CONST(ICONST)
          ENDIF
        ENDIF
      END DO
C
      FIX1=0
      IF( NARALL(1)+NARALL(2) .GT. 0 )
     & FIX1=(100*(NAFXALL(1)+NAFXALL(2)))/(NARALL(1)+NARALL(2))
      FIX2=0
      IF( NOBALL(1)+NOBALL(2) .GT. 0 ) 
     & FIX2=(100*(NOFXALL(1)+NOFXALL(2)))/(NOBALL(1)+NOBALL(2))
      WRITE(LSES,1405) 'SES',STNA,IYEARS,IMTHS,IDAYS,
     &      IHRS,IMINS,INT(SECS),SECS-INT(SECS),
     &      IYEARE,IMTHE,IDAYE,
     &      IHRE,IMINE,INT(SECE),SECE-INT(SECE),
     &      NSVARC, NOBALL(1)+NOBALL(2)+NOBALL(3)+NOBALL(4),
     &      NRJALL(1)+NRJALL(2)+NRJALL(3)+NRJALL(4),
     &      NFIX,NEPOCHDEL,SQRT(SOBWD/NFIX/3.d0),
     &      FLTPAR(1)*100,FLTPAR(2)*100, FLTPAR(3)*100
     &      ,DP1P2/0.29979D0
     &     ,FIX,FIX1,FIX2
C
C
      CALL JLIAN ( MJD, IYEARS, IMTHS, IDAYS)
      WRITE(LSES,1410) 'RES',STNA,IYEARS,IMTHS,IDAYS,
     &                 OBTYPE(IOBTYP),FREQ(IFREQ), 
     & (NOBALL(1)*RAVGALL(1)+NOBALL(2)*RAVGALL(2)+NOBALL(3)*RAVGALL(3)+
     &  NOBALL(4)*RAVGALL(4))/
     &                 (NOBALL(1)+NOBALL(2)+NOBALL(3)+NOBALL(4)),
     &                 DSQRT((NOBALL(1)*RRMSALL(1)*RRMSALL(1)+
     &                        NOBALL(2)*RRMSALL(2)*RRMSALL(2)+
     &                        NOBALL(3)*RRMSALL(3)*RRMSALL(3)+ 
     &                        NOBALL(4)*RRMSALL(4)*RRMSALL(4))/
     &                       (NOBALL(1)+NOBALL(2)+NOBALL(3)+NOBALL(4))),
     & (NOBALL(1)*PAVGALL(1)+NOBALL(2)*PAVGALL(2)+NOBALL(3)*PAVGALL(3)+
     &  NOBALL(4)*PAVGALL(1))/
     &                 (NOBALL(1)+NOBALL(2)+NOBALL(3)+NOBALL(4)),
     &                 DSQRT((NOBALL(1)*PRMSALL(1)*PRMSALL(1)+
     &                        NOBALL(2)*PRMSALL(2)*PRMSALL(2)+
     &                        NOBALL(3)*PRMSALL(3)*PRMSALL(3)+ 
     &                        NOBALL(4)*PRMSALL(4)*PRMSALL(4))/
     &                       (NOBALL(1)+NOBALL(2)+NOBALL(3)+NOBALL(4))),
     &                 (NRJIR(IR),IR=1,7),(NCSIR(IR),IR=1,4),MJD
C
C------------------------------------------------------------------------
C     FORMAT STATEMENTS
C------------------------------------------------------------------------
C
 1000 FORMAT( /,1X,'3.2 Observation Session',/)
 1001 FORMAT( /,1X,"3.2 Session d'observation",/)
 1050 FORMAT(5X,A35,3X,A40)
 1100 FORMAT(5X,A35,3X,I4,2('/',I2.2),' ',2(I2.2,':'),I2.2,'.',I2.2)
 1150 FORMAT(5X,A35,2X,F6.2)
 1151 FORMAT(5X,A35,2X,F7.2,2X,A7)
 1152 FORMAT(5X,A35,1X,I3'%',1X,I3,'%',1X,A7)
 1160 FORMAT(5X,A35,2X,I7)
 1161 FORMAT(5X,A35,2X,I7,2X,A7)
 1162 FORMAT(5X,A35,2X,I7,2X,I3,'%')
 1405 FORMAT ( A3,1X,A4,2(1X,I4,'/',I2.2,'/',I2.2,
     &       1X,2(I2.2,':'),I2.2,F2.1), 1X,I2,4(1X,I6), 2f5.1,f5.0,f6.0,
     &       f8.3,3(I4,'%') )
 1410 FORMAT ( A3,1X,A4,1X,I4,'/',I2.2,'/',I2.2,
     &         1X,A3,1X,A2,4(1X,F6.3),7(1X,I4),4(1X,I4),1X,I10 )
 1500 FORMAT(1X,A1,I2,A1,I4,I3,1X,I3,1X,I5,7(1X,I4),2(1X,F6.2,1X,F5.2))
 1501 FORMAT(1X,1X,2X,1X,8X,I3,'%',2X,I3,'%',3(1X,4X),4(I4,1X))
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** SUMPOS
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SUMPOS ( LPR, LSES, STNA, IYEAR, IMTH, IDAY,  
     &                    NFIX, NFIXR, DTM, IREFIN , IREFOUT,
     &                    IFREAL, IFRAME, TRFPAR, EPOCH, XRVINP, XRVINI,
     &                    XRVMRK, DXAVG, DXRMS, DXSIG, DPRMS, DPSIG, 
     &                    IXRVRNX,XRVCOD,
     &                    VX, VP,
     &                    IMODE, ANTH, LNG )
C
C     PURPOSE:   SUMMARIZE ESTIMATED POSITIONS
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     LPR               LOGICAL UNIT OF PRINTER
C     XRVINI            INITIAL RECEIVER CARTESIAN COORDINATES
C     NFIX              NUMBER OF POSITION FIX
C     DXAVG             MEAN CORRECTIONS TO X,Y,Z
C     DXRMS             RMS OF CORRECTIONS TO INITIAL X,Y,Z
C     SDPLH              "        "            "      LAT/LONG/H
C     DTM               DATUM PARAMETERS
C
C***********************************************************************
C
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      CHARACTER*40   STNA
      CHARACTER*5    IFRAME(*),IFREAL(*)
      INTEGER*4 LPR,LSES,IYEAR,IMTH,IDAY,NFIX,NFIXR,IREFIN,IREFOUT
      INTEGER*4 IMODE,LNG
      REAL*8    EPOCH,ANTH
      REAL*8    XRVINP(*),XRVINI(*),XRVMRK(*)
      REAL*8    DXAVG(*),DXRMS(*),DXSIG(*)
      REAL*8    DPRMS(*),DPSIG(*),DTM(*)
      REAL*8    TRFPAR(*)
      INTEGER*4 IXRVRNX
      REAL*8    XRVCOD(*)
      REAL*8    VX(MAXPAR2,*)
      REAL*8    VP(MAXPAR2,*)
C
      CHARACTER*16   DMSP(2), DMSL(2)
      CHARACTER*16   DMSPIN, DMSLIN
      CHARACTER*16   DMSPIP, DMSLIP
      CHARACTER*4    CHDEG,  NEG_ZERO
      CHARACTER*15  XYZHDR(2), PLHHDR(2), ESTHDR(2), APRHDR(2)
      CHARACTER*15  PHDR, LHDR, HHDR, XHDR, YHDR, ZHDR
      INTEGER*4 I,MJD,                        IREF,IX
      INTEGER*4 IDMSP(4,2), IDMSL(4,2)
      INTEGER*4 INDMSP(4), INDMSL(4)
      INTEGER*4 IPDMSP(4), IPDMSL(4)
      REAL*8    SECPIP,SECLIP,SECPIN,SECLIN,SECP,SECL,E2
      REAL*8    SIN_P,COS_P,XM,XN
      REAL*8    PLHIN(3),  PLHIP(3)
      REAL*8    PLH(3,2),  XYZ(3,2)
      REAL*8    DXYZ(3),   DPLH(3) , DREF(3)
      REAL*8    XRVAVG(3), PLHAVG(3)
      REAL*8    XRVOUT(3), PLHOUT(3)
      REAL*8    PRMSM(3)
      REAL*8    PSIGM(3)
      CHARACTER*3 SRC(3)
      LOGICAL   INIRESET
      REAL*8    POSCOR
      DATA      SRC/'NIL','CMD','RNX'/
C
      DATA (XYZHDR(I),I=1,2) /'CARTESIAN    ','CARTESIENNES '/
      DATA (PLHHDR(I),I=1,2) /'ELLIPSOIDAL  ','ELLIPSOIDALES'/
      DATA (ESTHDR(I),I=1,2) /'ESTIMATED    ','ESTIMEE      '/
      DATA (APRHDR(I),I=1,2) /'A-PRIORI     ','A-PRIORI     '/
      DATA  PHDR /'Latitude  (dms)'/
      DATA  LHDR /'Longitude (dms)'/
      DATA  HHDR /'Elevation (m)  '/
      DATA  XHDR /'        X (m)  '/
      DATA  YHDR /'        Y (m)  '/
      DATA  ZHDR /'        Z (m)  '/      
      DATA  NEG_ZERO /'  -0'/
C
      CALL JLIAN ( MJD, IYEAR, IMTH, IDAY)
C
      POSCOR=0.D0
      INIRESET=.FALSE.
      DO I=1,3
        XRVAVG(I) = XRVMRK(I) + DXAVG(I)
        POSCOR=POSCOR+(XRVCOD(I)-XRVINP(I))**2
      INIRESET=INIRESET.OR.XRVINI(I).NE.XRVINP(I)
      END DO
      POSCOR=DSQRT(POSCOR)
C
C     TRANSFORM INPUT COORDINATES TO SELECTED OUTPUT FRAME
C     AND CONVERT TO ELLIPSOIDAL
C
      IF ( IREFIN .NE. IREFOUT ) THEN
        CALL TOREF(XRVINP,XRVOUT,IREFIN, IREFOUT, TRFPAR, EPOCH)
        DO I=1,3
          XRVINP(I) = XRVOUT(I)
        END DO
      END IF
C           
      CALL XYZPL2 (DTM(3),DTM(4),DTM(5),DTM(1),DTM(2),
     &             XRVINP(1),XRVINP(2),XRVINP(3),
     &             PLHIP(1),PLHIP(2),PLHIP(3))
      CALL RADMS ( PLHIP(1), IPDMSP(1), IPDMSP(2), SECPIP )
      write(CHDEG,'(I4)') IPDMSP(1)
      if(IPDMSP(1).eq.0 .and. PLHIP(1).lt.0.0) CHDEG=NEG_ZERO
      IPDMSP(3)=INT(SECPIP) 
      IPDMSP(4)=INT((SECPIP-INT(SECPIP))*10000)
      WRITE(DMSPIP,2000) CHDEG,IPDMSP(2),IPDMSP(3),IPDMSP(4)
C
      CALL RADMS ( PLHIP(2), IPDMSL(1), IPDMSL(2), SECLIP )
      write(CHDEG,'(I4)') IPDMSL(1)
      if(IPDMSL(1).eq.0 .and. PLHIP(2).lt.0.0) CHDEG=NEG_ZERO
      IPDMSL(3)=INT(SECLIP) 
      IPDMSL(4)=INT((SECLIP-INT(SECLIP))*10000)
      WRITE(DMSLIP,2000) CHDEG,IPDMSL(2),IPDMSL(3),IPDMSL(4)
C
C     TRANSFORM INITIAL COORDINATES TO SELECTED OUTPUT FRAME
C     AND CONVERT TO ELLIPSOIDAL
C
      IF ( IREFIN .NE. IREFOUT ) THEN
        CALL TOREF(XRVINI,XRVOUT,IREFIN, IREFOUT, TRFPAR, EPOCH)
        DO I=1,3
      XRVINI(I) = XRVOUT(I)
        END DO
      END IF
C     
      CALL XYZPL2 (DTM(3),DTM(4),DTM(5),DTM(1),DTM(2),
     &             XRVINI(1),XRVINI(2),XRVINI(3),
     &             PLHIN(1),PLHIN(2),PLHIN(3))
      CALL RADMS ( PLHIN(1), INDMSP(1), INDMSP(2), SECPIN )
      write(CHDEG,'(I4)') INDMSP(1)
      if(INDMSP(1).eq.0 .and. PLHIN(1).lt.0.0) CHDEG=NEG_ZERO
      INDMSP(3)=INT(SECPIN) 
      INDMSP(4)=INT((SECPIN-INT(SECPIN))*10000)
      WRITE(DMSPIN,2000) CHDEG,INDMSP(2),INDMSP(3),INDMSP(4)
C
      CALL RADMS ( PLHIN(2), INDMSL(1), INDMSL(2), SECLIN )
      WRITE(CHDEG,'(I4)') INDMSL(1)
      if(INDMSL(1).eq.0 .and. PLHIN(2).lt.0.0) CHDEG=NEG_ZERO
      INDMSL(3)=INT(SECLIN) 
      INDMSL(4)=INT((SECLIN-INT(SECLIN))*10000)
      WRITE(DMSLIN,2000) CHDEG,INDMSL(2),INDMSL(3),INDMSL(4)
      DO IREF=1,2
        IF ( IREF .NE. IREFIN ) THEN
          CALL TOREF(XRVINI,XYZ(1,IREF),IREFIN, IREF, TRFPAR, EPOCH)
        ELSE
        DO I=1,3
        XYZ(I,IREF)=XRVINI(I)
        END DO
        END IF
C
        CALL XYZPL2 (DTM(3),DTM(4),DTM(5),DTM(1),DTM(2),
     &             XYZ(1,IREF),XYZ(2,IREF),XYZ(3,IREF),
     &             PLH(1,IREF),PLH(2,IREF),PLH(3,IREF))
      END DO
C
C
C     CONVERT ESTIMATED COORDINATES TO ELLIPSOIDAL
C
      CALL XYZPL2 (DTM(3),DTM(4),DTM(5),DTM(1),DTM(2),
     &             XRVAVG(1),XRVAVG(2),XRVAVG(3),
     &             PLHAVG(1),PLHAVG(2),PLHAVG(3))
C
      DO IREF=1,2
        IF ( IREF .NE. IREFIN ) THEN
          CALL TOREF(XRVAVG,XYZ(1,IREF),IREFIN, IREF, TRFPAR, EPOCH)
        ELSE
          DO I=1,3
          XYZ(I,IREF)=XRVAVG(I)
          END DO
        END IF
        CALL XYZPL2 (DTM(3),DTM(4),DTM(5),DTM(1),DTM(2),
     &             XYZ(1,IREF),XYZ(2,IREF),XYZ(3,IREF),
     &             PLH(1,IREF),PLH(2,IREF),PLH(3,IREF))
      END DO
C
C
      E2    = DTM(2)*DTM(2)
      SIN_P = DSIN ( PLHAVG(1) )
      COS_P = DCOS ( PLHAVG(1) )
C
      XM            = DTM(1) * ( 1.0D0 - E2 ) /
     &          ( 1.0D0 - E2 * SIN_P * SIN_P ) ** 1.5
      XN            = DTM(1) / SQRT ( 1.0D0 - E2 * SIN_P * SIN_P )
C
      IF(IMODE.NE.1) THEN
       PSIGM(1) = DPSIG(1)*XM
       PSIGM(2) = DPSIG(2)*XN*COS_P
      ELSE
       PSIGM(1) = DPSIG(1)
       PSIGM(2) = DPSIG(2)
      END IF
      PSIGM(3) = DPSIG(3)
c!    WRITE(LPR,1150) '*SIG',DXSIG(1),DXSIG(2),DXSIG(3),
c!   &                       PSIGM(1),PSIGM(2),PSIGM(3)
C
      PRMSM(1) = DPRMS(1)*XM
      PRMSM(2) = DPRMS(2)*XN*COS_P
      PRMSM(3) = DPRMS(3)
C
      IF ( IREFIN .NE. IREFOUT ) THEN
        CALL TOREF(XRVAVG,XRVOUT,IREFIN, IREFOUT, TRFPAR, EPOCH)
      ELSE
        XRVOUT(1)=XRVAVG(1)
        XRVOUT(2)=XRVAVG(2)
        XRVOUT(3)=XRVAVG(3)
      ENDIF
      CALL XYZPL2 (DTM(3),DTM(4),DTM(5),DTM(1),DTM(2),
     &             XRVOUT(1),XRVOUT(2),XRVOUT(3),
     &             PLHOUT(1),PLHOUT(2),PLHOUT(3))
      DO I=1,3
        DXYZ(I) = XRVOUT(I) - XRVINI(I)
        DPLH(I) = PLHOUT(I) - PLHIN(I)
      END DO
C
      DPLH(1) = DPLH(1)*XM
      DPLH(2) = DPLH(2)*XN*COS_P
c!    WRITE(LPR,1150) '*DIF', DXYZ, DPLH
C
C
C------------------------------------------------------------------------
C     WRITE TO SUMMARY AND SESSION FILES
C------------------------------------------------------------------------
C
      WRITE(LSES,1415) 'XYZ',STNA,IYEAR,IMTH,IDAY,
     &                 IFRAME(IREFOUT),IFREAL(IREFOUT),'APR',
     &                 XRVINP(1),XRVINP(2),XRVINP(3), ANTH, MJD
      WRITE(LSES,1420) 'PLH',STNA,IYEAR,IMTH,IDAY,
     &                 IFRAME(IREFOUT),IFREAL(IREFOUT),'APR',
     &                 DMSPIP, DMSLIP, PLHIP(3), ANTH, MJD
C
      WRITE(LSES,1415) 'XYZ',STNA,IYEAR,IMTH,IDAY,
     &                 IFRAME(IREFOUT),IFREAL(IREFOUT),'INI',
     &                 XRVINI(1),XRVINI(2),XRVINI(3), ANTH, MJD
      WRITE(LSES,1420) 'PLH',STNA,IYEAR,IMTH,IDAY,
     &                 IFRAME(IREFOUT),IFREAL(IREFOUT),'INI',
     &                 DMSPIN, DMSLIN, PLHIN(3), ANTH, MJD
C
C     CARTESIAN COORDINATES RECORD
C
      DO IREF=1,2
       WRITE(LSES,1415) 'XYZ',STNA,IYEAR,IMTH,IDAY,
     &                    IFRAME(IREF),IFREAL(IREF),'EST',
     &                    XYZ(1,IREF),XYZ(2,IREF),XYZ(3,IREF),ANTH, 
     &                    MJD
      END DO
C
      IF (LNG .EQ. 1) WRITE(LPR,800)
      IF (LNG .EQ. 2) WRITE(LPR,801)
      IF( INIRESET ) THEN
      IF( LNG.EQ.1 ) WRITE(LPR,850) SRC(IXRVRNX+2)
      IF( LNG.EQ.2 ) WRITE(LPR,851) SRC(IXRVRNX+2)
      ELSE
       IF( POSCOR .GT. 1.D2 ) THEN
        IF( LNG.EQ.1 ) WRITE(LPR,860) SRC(IXRVRNX+2)
        IF( LNG.EQ.2 ) WRITE(LPR,861) SRC(IXRVRNX+2)
       ENDIF
      ENDIF
      WRITE(LPR,1000) XYZHDR(LNG), IFRAME(1), IFREAL(1), 
     &              IFRAME(2), IFREAL(2)
      DO IX=1,3
        DREF(IX)=XYZ(IX,1)-XYZ(IX,2)
      END DO
      WRITE(LPR,2100) XHDR,XYZ(1,1),XYZ(1,2), DXSIG(1), DREF(1)
      WRITE(LPR,2100) YHDR,XYZ(2,1),XYZ(2,2), DXSIG(2), DREF(2)
      WRITE(LPR,2100) ZHDR,XYZ(3,1),XYZ(3,2), DXSIG(3), DREF(3)
      IF( IMODE .NE. 2 ) THEN
       WRITE(LPR,2150)
       WRITE(LPR,2151) DSQRT(VX(1,1)),VX(1,2)/DSQRT(VX(1,1)*VX(2,2))
     &                               ,VX(1,3)/DSQRT(VX(1,1)*VX(3,3))
       WRITE(LPR,2152) DSQRT(VX(2,2)),VX(2,3)/DSQRT(VX(2,2)*VX(3,3))
       WRITE(LPR,2153) DSQRT(VX(3,3))
      END IF
C
C     ELLIPSOIDAL COORDINATES RECORD
C
      DO IREF=1,2
         CALL RADMS ( PLH(1,IREF), IDMSP(1,IREF), IDMSP(2,IREF), SECP )
         write(CHDEG,'(I4)') IDMSP(1,IREF)
         if(IDMSP(1,IREF).eq.0 .and. PLH(1,IREF).lt.0.0) CHDEG=NEG_ZERO
         IDMSP(3,IREF)=INT(SECP) 
         IDMSP(4,IREF)=INT((SECP-INT(SECP))*10000)
         WRITE(DMSP(IREF),2000) 
     &    CHDEG,IDMSP(2,IREF),IDMSP(3,IREF),IDMSP(4,IREF)
         CALL RADMS ( PLH(2,IREF), IDMSL(1,IREF), IDMSL(2,IREF), SECL )
         write(CHDEG,'(I4)') IDMSL(1,IREF)
         if(IDMSL(1,IREF).eq.0 .and. PLH(2,IREF).lt.0.0) CHDEG=NEG_ZERO
         IDMSL(3,IREF)=INT(SECL) 
         IDMSL(4,IREF)=INT((SECL-INT(SECL))*10000)
         WRITE(DMSL(IREF),2000) 
     &    CHDEG,IDMSL(2,IREF),IDMSL(3,IREF),IDMSL(4,IREF)
         WRITE(LSES,1420) 'PLH',STNA,IYEAR,IMTH,IDAY,
     &                    IFRAME(IREF),IFREAL(IREF),'EST',
     &                    DMSP(IREF), DMSL(IREF), PLH(3,IREF), ANTH, 
     &                    MJD
      END DO
      WRITE(LPR,1010) PLHHDR(LNG)
      WRITE(LPR,2200) PHDR,DMSP(1),DMSP(2),PSIGM(1),
     &       (PLH(1,1)-PLH(1,2))*XM
      WRITE(LPR,2200) LHDR,DMSL(1),DMSL(2),PSIGM(2),
     &       (PLH(2,1)-PLH(2,2))*XN*COS_P
      WRITE(LPR,2100) HHDR,PLH(3,1),PLH(3,2),PSIGM(3),
     &       (PLH(3,1)-PLH(3,2))
      IF( IMODE .NE. 2 ) THEN
       WRITE(LPR,2250)
       WRITE(LPR,2251) DSQRT(VP(1,1)),VP(1,2)/DSQRT(VP(1,1)*VP(2,2))
     &                               ,VP(1,3)/DSQRT(VP(1,1)*VP(3,3))
       WRITE(LPR,2252) DSQRT(VP(2,2)),VP(2,3)/DSQRT(VP(2,2)*VP(3,3))
       WRITE(LPR,2253) DSQRT(VP(3,3))
      END IF
C
C     COORDINATES DIFFERENCE RECORD
C
      WRITE(LSES,1430) 'DIF',STNA,IYEAR,IMTH,IDAY,NFIX,
     &      DXYZ(1),DXYZ(2),DXYZ(3),DPLH(1),DPLH(2),DPLH(3),MJD
C
      IF (LNG .EQ. 1) WRITE(LPR,900) IFRAME(IREFOUT), IFREAL(IREFOUT)
      IF (LNG .EQ. 2) WRITE(LPR,901) IFRAME(IREFOUT), IFREAL(IREFOUT)
      WRITE(LPR,1005) XYZHDR(LNG), ESTHDR(LNG), APRHDR(LNG)
      WRITE(LPR,2100) XHDR,XYZ(1,IREFOUT),XRVINI(1), DXYZ(1), DXRMS(1)
      WRITE(LPR,2100) YHDR,XYZ(2,IREFOUT),XRVINI(2), DXYZ(2), DXRMS(2)
      WRITE(LPR,2100) ZHDR,XYZ(3,IREFOUT),XRVINI(3), DXYZ(3), DXRMS(3)
      WRITE(LPR,1010) PLHHDR(LNG)
      WRITE(LPR,2200) PHDR,DMSP(IREFOUT),DMSPIN,DPLH(1),PRMSM(1)
      WRITE(LPR,2200) LHDR,DMSL(IREFOUT),DMSLIN,DPLH(2),PRMSM(2)
      WRITE(LPR,2100) HHDR,PLH(3,IREFOUT),PLHIN(3),DPLH(3),PRMSM(3)
C
C     COORDINATES PRECISION RECORD
C
      WRITE(LSES,1430) 'SIG',STNA,IYEAR,IMTH,IDAY,NFIX,
     &      DXSIG(1),DXSIG(2),DXSIG(3),PSIGM(1),PSIGM(2),PSIGM(3),MJD
C
C     COORDINATES COVARIANCES RECORDS
C
      IF( IMODE .NE. 2 ) THEN
       WRITE(LSES,1440) 'COV',STNA,IYEAR,IMTH,IDAY,NFIX
     &                 ,DSQRT(VX(1,1)),VX(1,2)/DSQRT(VX(1,1)*VX(2,2))
     &                                ,VX(1,3)/DSQRT(VX(1,1)*VX(3,3))
     &                 ,DSQRT(VP(1,1)),VP(1,2)/DSQRT(VP(1,1)*VP(2,2))
     &                                ,VP(1,3)/DSQRT(VP(1,1)*VP(3,3))
       WRITE(LSES,1441) 'COV',STNA,IYEAR,IMTH,IDAY,NFIX
     &                 ,DSQRT(VX(2,2)),VX(2,3)/DSQRT(VX(2,2)*VX(3,3))
     &                 ,DSQRT(VP(2,2)),VP(2,3)/DSQRT(VP(2,2)*VP(3,3))
       WRITE(LSES,1442) 'COV',STNA,IYEAR,IMTH,IDAY,NFIX
     &                 ,DSQRT(VX(3,3))
     &                 ,DSQRT(VP(3,3))
      END IF
C
C------------------------------------------------------------------------
C     FORMAT STATEMENTS
C------------------------------------------------------------------------
C
  800 FORMAT( /,1X,'3.3 Coordinate estimates',/)
  801 FORMAT( /,1X,"3.3 Coordonnees estimees",/)
  850 FORMAT( 1X,'WARNING: Initial coordinates from ',A4,
     &           ' updated with initial pseudorange solution.',/)
  851 FORMAT( 1X,'AVERTISSEMENT: Coordonnees initiales de ',A4,
     &  ' mises-a-jour avec solution pseudodistance initiale.',/)
  860 FORMAT( 1X,'WARNING: Initial pseudorange solution differ from ',
     &        A4,' by ',D7.1,' meters.',/)
  861 FORMAT( 1X,'AVERTISSEMENT: Solution pseudodistance initiale ',
     &        'differe de ',A4,' de ',D7.1,' metres.',/)
  900 FORMAT( /,1X,'3.4 Coordinate differences',
     &          1X,A5,'(',A5,')',/)
  901 FORMAT( /,1X,"3.4 Difference de coordonnees",
     &          1X,A5,'(',A5,')',/)
 1000 FORMAT( 1X, A15,1X, 2(4X,A5,'(',A5,')',1X),
     &        '  Sigma(m) NAD-ITR(m)')
 1005 FORMAT( 1X, A15,6X, 2(2X,A12,2X), 'Delta(m)     RMS(m)')
 1010 FORMAT( /,1X, A15 )
 1100 FORMAT( A4,   3F13.3,2(   I4,I3,F7.3),F9.3 )
 1150 FORMAT( A4,   3F13.3, 2F14.3, F9.3 )
 1415 FORMAT ( A3,1X,A4,1X,I4,'/',I2.2,'/',I2.2,
     &         1X,A5,'(',A5,')',
     &         1X,A3,3(1X,F13.4),1X,F7.3,1X,I10 )
 1420 FORMAT ( A3,1X,A4,1X,I4,'/',I2.2,'/',I2.2,
     &         1X,A5,'(',A5,')',
     &         1X,A3,2A16,1X,F9.3,1X,F7.3,1X,I10 )
 1425 FORMAT ( A3,1X,A4,1X,I4,'/',I2.2,'/',I2.2,
     &         1X,I6,1X,6(2X,F6.3),1X,I10 )
 1430 FORMAT ( A3,1X,A4,1X,I4,'/',I2.2,'/',I2.2,
     &         1X,I6,1X,6(1X,F8.4),1X,I10 )
 1440 FORMAT ( A3,1X,A4,1X,I4,'/',I2.2,'/',I2.2,
     &         1X,I6,1X,2(3(1X,F8.4)),1X,I10 )
 1441 FORMAT ( A3,1X,A4,1X,I4,'/',I2.2,'/',I2.2,
     &         1X,I6,1X,2(9X,2(1X,F8.4)),1X,I10 )
 1442 FORMAT ( A3,1X,A4,1X,I4,'/',I2.2,'/',I2.2,
     &         1X,I6,1X,2(18X,(1X,F8.4)),1X,I10 )
 2000 FORMAT (1X,A4,1X,I2.2,1X,I2.2,'.',I4.4)
 2100 FORMAT (1X,A15,2(1X,F16.4),2(1X,F10.4))
 2150 FORMAT ( /,1X,
     &    'SIGMA/CORRELATIONS',/,20X,'     X(m)     Y(m)     Z(m)')
 2151 FORMAT (10X,'X(m)',6X,3(1X,F8.4))
 2152 FORMAT (10X,'Y(m)',6X,9X,2(1X,F8.4))
 2153 FORMAT (10X,'Z(m)',6X,18X,1(1X,F8.4))
 2200 FORMAT (1X,A15,2(1X,A16),2(1X,F10.4))
 2250 FORMAT ( /,1X,
     &    'SIGMA/CORRELATIONS',/,20X,'   Lat(m)   Lon(m)     H(m)')
 2251 FORMAT (8X,'Lat(m)',6X,3(1X,F8.4))
 2252 FORMAT (8X,'Lon(m)',6X,9X,2(1X,F8.4))
 2253 FORMAT (10X,'H(m)',6X,18X,1(1X,F8.4))
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** SUMRES
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SUMRES ( LPR, IOBTYP, NSVARC, RESARC,
     &                IACTION,
     &                    NRESREJ, RESREJ, LNG )
C
C     PURPOSE:   SUMMARIZE SATELLITE ARC RESIDUALS
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     LPR               LOGICAL UNIT OF PRINTER
C
C***********************************************************************
C
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      CHARACTER*80   RESREJ(*)
      CHARACTER*90   RESARC(2,*)
      INTEGER*4 LPR, NSVARC, NRESREJ, LNG
C
      INTEGER*4 I
     &         ,IOBTYP
     &         ,IACTION
C
      IF (LNG .EQ. 1) WRITE(LPR,800)
      IF (LNG .EQ. 2) WRITE(LPR,801)
C
      IF( IOBTYP.EQ.2) THEN
       IF( IACTION.EQ.0 ) THEN
        WRITE(LPR,1000) 'RES'
       ELSE
        WRITE(LPR,1000) 'DWT'
       ENDIF
      ELSE
       IF( IACTION.EQ.0 ) THEN
        WRITE(LPR,1001) 'RES'
       ELSE
        WRITE(LPR,1001) 'DWT'
       ENDIF
      ENDIF
      DO I=1,NSVARC
      WRITE(LPR,'(A82)') RESARC(1,I)
      IF( IOBTYP .EQ. 2 )
     &    WRITE(LPR,'(A82)') RESARC(2,I)
      END DO
      IF (LNG .EQ. 1) WRITE(LPR,900)
      IF (LNG .EQ. 2) WRITE(LPR,901)
C
      WRITE(LPR,1100)
      DO I=1,NRESREJ
      IF ( I .LE. MAXRES ) WRITE(LPR,'(A78)') RESREJ(I)
      END DO
C
C------------------------------------------------------------------------
C     FORMAT STATEMENTS
C------------------------------------------------------------------------
C
  800 FORMAT( /,1X,'3.6 Observation rejection table',/)
  801 FORMAT( /,1X,"3.6 Tableau des observations rejetees",/)
 1000 FORMAT( 34X,'#REJ/SLIP',20X,' CODE       PHASE', /,
     &        ' PRN AC #ARC #AM  #OBS',2X,
     &        'TRK  SLP  CLK  EPH  IGP  ',A3,'  ELV',3X,
     &        ' AVG   RMS    AVG  RMS ',/,12X,'%FIX  %FIX',
     &        2X,'               TIM  NRL  WDL  DCM',
     &        4X,'(m)   (m)   (cm) (cm)',/)
 1001 FORMAT( 34X,'   #REJ  ',20X,' CODE       PHASE', /,
     &        ' PRN AC #ARC #AM  #OBS',2X,
     &        'TRK  SLP  CLK  EPH  IGP  ',A3,'  ELV',3X,
     &        ' AVG   RMS    AVG  RMS ',/,
     &        61X,'(m)   (m)   (cm) (cm)',/)
 1100 FORMAT( 33X,'CODE               PHASE',/,
     &        28X,'RES       MAX       RES       MAX DIR',/,
     &        'PRN   HH:MM:SS.SSS',10X,'(m)       (m)   ',
     &        '   (cm)      (cm)')
  900 FORMAT( /,1X,'3.7 List of observation outliers',/)
  901 FORMAT( /,1X,"3.7 Liste des observations aberrantes",/)
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** SUNXYZ
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SUNXYZ (DMJ ,SIDT, XSUN, YSUN, ZSUN)
C                                                   Jan 20 2012
C FUNCTION: SUNXYZ CALCULATES SUN COORDINATES
C
C INPUT: DMJ   = MODIFIED JULIAN DATE
C        SIDT = SIDERAL TIME
C
C OUTPUT: XSUN   = X COORDINATE OF SUN
C         YSUN   = Y COORDINATE OF SUN
C         ZSUN   = Z COORDINATE OF SUN
C
C REFERENCE: Meeus, J. Astronomical algorithmus, Willman-Bell, 1st
C          English edition, 1991, ISBN 0-943396-35-2
C ERRORS: (2000+-50y) within Right Ascension +-3" Declination +-17"
C
      IMPLICIT NONE
C
      REAL*8 DMJ ,SIDT, XSUN, YSUN, ZSUN
C
      REAL*8 D,DMJD,B2,C1,C2,P0,C7,SUNR
      REAL*8 RSUN, OBSS,  OBCS, RASS, RACS
C
      D=0.0174532925D0
C  DAYS SINCE J2000 (51544.5)
      DMJD=DMJ -51544.5D0
      B2=DMJD/36525.D0
C
      C1=(357.528D0+0.9856003D0*DMJD)*D
      C2=(280.461D0+0.9856474D0*DMJD)
C PO r- OBLIQUITY
      P0=(23.43929111D0-(46.815D0+(0.00059D0-0.001813D0*B2)*B2)*B2
     & /3600.D0)*D
C
C C7 - ECLIPTIC LONGITUDE OF SUN
      C7=(C2 + 1.915D0*SIN(C1)+ 0.02D0*SIN(2.D0*C1))*D
C
      SUNR=1.00014D0-0.01671D0*DCOS(C1 )-0.00014D0*DCOS(2.D0*C1)
C
C  COMPUTE RECT COORDINATES OF SUN USING AU (M)     C
C
      RSUN=       1.49597870700D11*SUNR
C               
      OBSS= SIN(P0)
      OBCS= COS(P0)
      RASS= SIN(C7)
      RACS= COS(C7)
      ZSUN =  RSUN* RASS   *OBSS   
C ITRF
      XSUN = RSUN* RACS   *COS(SIDT) +RSUN* RASS   *OBCS   *SIN(SIDT)
      YSUN =-RSUN* RACS   *SIN(SIDT) +RSUN* RASS   *OBCS   *COS(SIDT)
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** SVTIME
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE SVTIME ( IDIR, IPRN, NARC, UTTAG, STIME, ETIME )
C     NAME              SVTIME
C
C     PURPOSE         SAVE SATELLITE ARC START AND END TIMES
C
C     PARAMETERS        DESCRIPTION
C
C          IDIR         DIRECTION OF PROCESSING (1=FWD, -1=BWD)
C          IPRN         SATELLITE PRN NUMBER
C          NARC         NUMBER OF OBSERVED SATELLITE ARCS 
C          UTTAG        UNAMBIGUOUS TIME TAG OF CURRENT OBSERVATION
C                       (GPSWK*604800.D0+SECOW) 
C          STIME        ARC START TIME 
C          ETIME        ARC END TIME OF WEEK 
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4 IDIR, IPRN, NARC
      REAL*8    UTTAG, DTIME
      REAL*8    STIME(MAXSAT,MAXARC)
      REAL*8    ETIME(MAXSAT,MAXARC)
C
      IF ( NARC .EQ. 0 ) THEN
       NARC = NARC + 1
       STIME(IPRN,NARC) = UTTAG
       ETIME(IPRN,NARC) = UTTAG
      END IF
C
      DTIME = UTTAG - ETIME(IPRN,NARC)
      IF(IDIR.EQ.-1) DTIME =  STIME(IPRN,NARC) - UTTAG
      IF ( DTIME .GT. 3600.D0 .AND. NARC .LT. MAXARC ) THEN
       NARC = NARC + 1
       STIME(IPRN,NARC) = UTTAG
       ETIME(IPRN,NARC) = UTTAG
      END IF
C
C  FWD RUN
      IF ( IDIR .EQ. 1 ) ETIME(IPRN,NARC) = UTTAG
C
C  BWD RUN
      IF ( IDIR .EQ.-1 ) STIME(IPRN,NARC) = UTTAG
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** TOMAG
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
       SUBROUTINE TOMAG ( IYEAR, JDAY, TTAG, GEOLAT, GEOLON, GMAGLAT,
     &                   GMAGLON, GMAGHR, ICD )
C
C     NAME              TOMAG
C
C     PURPOSE   CONVERT GEOGRAPHIC COORDINATES TO
C                       GEOMAGNETIC COORDINATES
C
C     PARAMETERS        DESCRIPTION
C
C         IYEAR         YEAR OF OBSERVATION
C         JDAY          DAY OF YEAR
C         TTAG          TIME OF DAY (SECONDS)
C         GEOLAT        GEOGRAPHIC LATITUDE
C         GEOLON        GEOGRAPHIC LONGITUDE
C         GMAGLAT       GEOMAGNETIC LATITUDE
C         GMAGLON       GEOMAGNETIC LONGITUDE
C         GMAGHR        GEOMAGNETIC HOUR
C         ICD           DIPOLE OPTION (1=CENTERED,2=EXCENTRIC)
C
C         NOTE:         XMAG= R2(PHI)*R3(LAM)*XGEO
C                  
C                WHERE: R2 = | COS(PHI)      0     -SIN(PHI) |
C                            |    0          1         0     |
C                            | SIN(PHI)      0      COS(PHI) |  
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4 IYEAR,JDAY,ICD 
      REAL*8    TTAG,GEOLAT,GEOLON,GMAGLAT,GMAGLON,GMAGHR
C
      REAL*8    PI,XEDB,YEDB,ZEDB,C0,C1,C2,APLAT,APLON,BPLAT
      REAL*8    BPLON,DX,DY,DZ,DCA,D2,KB,KA,DCL1,DCL2,DCL3
      REAL*8    DCM1,DCM2,DCM3,DCN1,DCN2,DCN3,XGEO,YGEO,ZGEO
      REAL*8    XMAG,YMAG,ZMAG,BETA,EPS,SUNDC,TODHR,ASUNTM
      REAL*8    YSUN,XSUN,SUNLON
       PI = 3.1416D0
       XEDB = 0.D0
       YEDB = 0.D0
       ZEDB = 0.D0
C
C-----------------------------------------------------------------------  
C      DEFINE CONSTANTS USED IN DETERMINATION OF
C      GEOGRAPHIC COORDINATES OF AUSTRAL AND BOREAL 
C      MAGNETIC POLES
C-----------------------------------------------------------------------  
C
      C0 = -68.042D0 + 0.0192160D0*IYEAR
      C1 = -21.474D0 + 0.0098558D0*IYEAR
      C2 =  23.845D0 - 0.0092273D0*IYEAR
C
C-----------------------------------------------------------------------  
C     COMPUTE LATITUDE AND LONGITUDE OF AUSTRAL AND BOREAL POLES
C-----------------------------------------------------------------------  
C
      APLAT = DATAN2( DSQRT(C1**2+C2**2), C0 )
      APLON = DATAN2( C2,C1 )
      BPLAT = DATAN2( DSQRT(C1**2+C2**2),-C0 )
      BPLON = DATAN2( -C2,-C1 )
c!    WRITE(*,*) 'TST-PLABP',APLAT,APLON,BPLAT,BPLON
C
C-----------------------------------------------------------------------  
C     COMPUTE TRANSLATION COMPONENTS OF 
C     BOREAL EXCENTRIC DIPOLE CENTER
C-----------------------------------------------------------------------  
C
      IF ( ICD .EQ. 2 ) THEN
        DX =  0.22916D0 - 0.00014630D0*IYEAR
        DY = -0.56093D0 + 0.00030303D0*IYEAR
        DZ = -0.65932D0 + 0.00034630D0*IYEAR
        DCA = DX*DSIN(BPLAT)*DCOS(BPLON) + DY*DSIN(BPLAT)*DSIN(BPLON)
     &        + DZ*DCOS(BPLAT)
        D2 =  DX**2+DY**2+DZ**2
        KB =  -DCA + DSQRT(DCA**2 + 1 - D2)
        KA =  -DCA - DSQRT(DCA**2 + 1 - D2)
C
        XEDB =  DX + KB*DSIN(BPLAT)*DCOS(BPLON)
        YEDB =  DY + KB*DSIN(BPLAT)*DSIN(BPLON)
        ZEDB =  DZ + KB*DCOS(BPLON)
      END IF
C
C-----------------------------------------------------------------------  
C     CONVERT FROM GEOGRAPHIC TO GEOMAGNETIC COORDINATES
C     USING EITHER CENTERED (ICD=1) OR ECCENTRIC (ICD=2) DIPOLE
C
C     COMPUTE DIRECTION COSINES USING BOREAL POLE CO-LATITUDE (BPLAT)
C     AND LONGITUDE (BPLON)
C-----------------------------------------------------------------------  
C
      DCL1 =  DCOS(BPLAT)*DCOS(BPLON)
      DCL2 = -DSIN(BPLON)
      DCL3 =  DSIN(BPLAT)*DCOS(BPLON)
      DCM1 =  DCOS(BPLAT)*DSIN(BPLON)
      DCM2 =  DCOS(BPLON)
      DCM3 =  DSIN(BPLAT)*DSIN(BPLON)
      DCN1 = -DSIN(BPLAT)
      DCN2 =  0.D0
      DCN3 =  DCOS(BPLAT)
C
C-----------------------------------------------------------------------  
C     CONVERT GEOGRAPHIC COORDINATES TO CARTESIAN AND
C     APPLY ECCENTRIC DIPOLE TRANSLATION COMPONENTS       
C-----------------------------------------------------------------------  
C
      XGEO = DCOS(GEOLAT)*DCOS(GEOLON) - XEDB
      YGEO = DCOS(GEOLAT)*DSIN(GEOLON) - YEDB
      ZGEO = DSIN(GEOLAT)
c!    WRITE(*,*) 'TST-XYZGEO',XGEO,YGEO,ZGEO
C
C-----------------------------------------------------------------------  
C     USING DIRECTION COSINES, APPLY ROTATION
C     TO GEOGRAPHIC COORDINATES TO CONVERT TO GEOMAGNETIC
C-----------------------------------------------------------------------  
C
      XMAG = DCL1*XGEO + DCM1*YGEO + DCN1*ZGEO
      YMAG = DCL2*XGEO + DCM2*YGEO + DCN2*ZGEO
      ZMAG = DCL3*XGEO + DCM3*YGEO + DCN3*ZGEO
c!    WRITE(*,*) 'TST-XYZMAG',XMAG,YMAG,ZMAG
C
      GMAGLON = DATAN2(YMAG,XMAG)
      GMAGLAT = DATAN2(ZMAG,DSQRT(XMAG**2+YMAG**2))
C
C-----------------------------------------------------------------------  
C     COMPUTE LOCAL APPARENT MAGNETIC HOUR ANGLE
C-----------------------------------------------------------------------  
C     
      BETA = (JDAY-1)*360.D0/365.D0*PI/180.D0
      EPS = 0.00429718D0 + 0.107029D0*DCOS(BETA) - 1.83788D0*DSIN(BETA)
     &         - 0.837378D0*DCOS(2.D0*BETA) -2.34048D0*DSIN(2.D0*BETA)
      SUNDC  = 0.39637D0 - 22.913D0*DCOS(BETA) - 4.0254D0*DSIN(BETA)
     &         - 0.38720D0*DCOS(2.D0*BETA) + 0.05197D0*DSIN(2.D0*BETA)
      SUNDC = SUNDC*PI/180.D0
c!    WRITE(*,*) 'TST-EPSDC',EPS,SUNDC
      TODHR = DMOD(TTAG,86400.D0)/3600.D0
      ASUNTM = (180.D0 - 15.D0*(DMOD(TTAG,86400.D0)/3600.D0) - EPS)
     &         *PI/180.D0
      YSUN = DCOS(SUNDC)*DSIN(ASUNTM - BPLON)
      XSUN = DCOS(SUNDC)*DCOS(BPLAT)*DCOS(ASUNTM-BPLON)
     &       - DSIN(BPLAT)*DSIN(SUNDC)
      SUNLON = DATAN2(YSUN,XSUN)
      GMAGHR = 12.D0 + (GMAGLON - SUNLON)*180.D0/PI/15.D0
      IF ( GMAGHR .LT. 0.D0 ) GMAGHR=GMAGHR+24.D0
      IF ( GMAGHR .GT. 24.D0 ) GMAGHR=GMAGHR-24.D0      
c!     write(*,'(4f10.3)') todhr,gmaglon,sunlon,gmaghr
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** TOREF
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
       SUBROUTINE TOREF(XRVIN, XRVOUT, IREFIN, IREFOUT, TRFPAR, EPOCH) 
C
C
C     PURPOSE   TRANSFORMS COORDINATES FROM INPUT TO 
C                       OUTPUT REFERENCE FRAME
C
C     PARAMETERS        DESCRIPTION
C     
C     XRVIN             CARTESIAN COORDINATES IN INPUT REFERENCE FRAME
C     XRVOUT            CARTESIAN COORDINATES IN OUTPUT REFERENCE FRAME
C     IREFIN            INPUT REFERENCE FRAME (1=NAD83, 2=ITRF)
C     IREFOUT           OUTPUT REFERENCE FRAME (1=NAD83, 2=ITRF)
C     TRFPAR            REFERENCE FRAME TRANSFORMATION PARAMETERS
C     EPOCH             REFERENCE FRAME EPOCH
C
      IMPLICIT NONE
C
      INTEGER*4 IREFIN, IREFOUT
      REAL*8    XRVIN(*), XRVOUT(*), TRFPAR(*), EPOCH
C
      INTEGER*4 IDIR
      REAL*8    TRYEAR,TRTIME,T1,T2,T3,D,R1,R2,R3
      REAL*8    T1D,T2D,T3D,DD,R1D,R2D,R3D,SCALE
      REAL*8    T1T,T2T,T3T,DT,R1T,R2T,R3T
C
      IDIR=1
C
C     DIRECTION OF TRANSORMATION   IDIR= 1  ITRF=> NAD83
C                                  IDIR=-1  NAD83=> ITRF
      IF( IREFOUT .NE. 1 ) IDIR=-1
C
C     SET TRANS PARAMETRS USINF IERS NOTATINS & FORMULAS
C
      TRYEAR= TRFPAR(1)
      TRTIME= TRFPAR(2)
      T1    = TRFPAR(3)
      T2    = TRFPAR(4) 
      T3    = TRFPAR(5) 
      D     = TRFPAR(6)
      R1    = TRFPAR(7) 
      R2    = TRFPAR(8) 
      R3    = TRFPAR(9) 
C
C     RATE OF CHANGE ./Y
C
      T1D   = TRFPAR(10) 
      T2D   = TRFPAR(11) 
      T3D   = TRFPAR(12) 
      DD    = TRFPAR(13) 
      R1D   = TRFPAR(14) 
      R2D   = TRFPAR(15) 
      R3D   = TRFPAR(16) 
C
C     X,Y,Z IN  M
C
      SCALE= 1.0D-2
C
      T1T= IDIR*(T1+T1D*(EPOCH-TRTIME))*SCALE 
      T2T= IDIR*(T2+T2D*(EPOCH-TRTIME))*SCALE 
      T3T= IDIR*(T3+T3D*(EPOCH-TRTIME))*SCALE 
      DT = IDIR*(D + DD*(EPOCH-TRTIME))*1.0D-9
      R1T= IDIR*(R1+R1D*(EPOCH-TRTIME))*4.848137D-09
      R2T= IDIR*(R2+R2D*(EPOCH-TRTIME))*4.848137D-09
      R3T= IDIR*(R3+R3D*(EPOCH-TRTIME))*4.848137D-09
C
C     TRANSFORM SV XYZ TO A NEW REFERENCE FRAME (DATUM)
C
      XRVOUT(1)= XRVIN(1)*(1.0D0+DT)+T1T-R3T*XRVIN(2)+R2T*XRVIN(3)
      XRVOUT(2)= XRVIN(2)*(1.0D0+DT)+T2T+R3T*XRVIN(1)-R1T*XRVIN(3)
      XRVOUT(3)= XRVIN(3)*(1.0D0+DT)+T3T-R2T*XRVIN(1)+R1T*XRVIN(2)
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** TOWHMS
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE TOWHMS( IWKDAY, TOW, IHR, IMIN, SEC, IWAY )
C
C     NAME              TOWHMS
C
C     PURPOSE   CONVERT TIME OF WEEK (TOW)
C               TO HOURS, MINUTES AND SECONDS OF DAY
C
C     PARAMETERS        DESCRIPTION
C
C        IWKDAY DAY OF WEEK
C        TOW            TIME OF WEEK (SECONDS)
C        IHR            HOUR OF DAY
C        IMIN   MINUTES
C        SEC            SECONDS
C        IWAY   0: TIME OF WEEK -> IWKDAY,HR,MIN,SEC
C               1: IWKDAY,HR,MIN,SEC OF DAY --> TIME OF WEEK
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INTEGER*4 IWKDAY, IHR, IMIN, IWAY
      REAL*8    TOW, SEC
C
      INTEGER*4 ISECOD
      REAL*8    SECOD
C
      IF ( IWAY .EQ. 0 ) THEN
      IWKDAY= IDINT(TOW/86400.D0) + 1
      SECOD = DMOD(TOW,86400.D0)
        ISECOD = INT(SECOD)
      IHR   = ISECOD/3600
      IMIN  = MOD(ISECOD,3600) / 60
      SEC   = SECOD - IHR*3600 - IMIN*60
      ENDIF
C
      IF ( IWAY .EQ. 1 ) THEN
      TOW = (IWKDAY-1)*86400.D0 + IHR*3600.D0 + IMIN*60.D0 + SEC
      ENDIF
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C***************************************************************** TPOL
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE TPOL(X,POL,NP1)
C
C     PURPOSE:   COMPUTE TSCHEBICHEV POLYNOMIALS
C
      IMPLICIT NONE
C
      INCLUDE  'MAXDIM'
C
      INTEGER*4 NP1
      REAL*8    X,POL(MAXORD)
C
      INTEGER*4 N
C
      POL(1) = 1.D0
      POL(2) = X
C
      DO 100 N=3,NP1
      POL(N) = 2.D0*X*POL(N-1) - POL(N-2)
  100 CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C***************************************************************** TROPO
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE TROPO ( MODEL, TEMP, PRES, RH, ELRAD, DRYZEN, WETZEN,
     &                   DRYMAP, WETMAP, TROCOR, GEO, XRV)
C
C     PURPOSE:   COMPUTES THE TROPOSPHERIC CORRECTION
C
C     PARAMETER SPECIFICATIONS:
C
C        MODEL    1 = DAVIS/HOPFIELD
C               4 = CHAO
C        TEMP     TEMPERATURE (DEG C)
C        PRES     PRESSURE (MBAR)
C        RH         RELATIVE HUMIDITY (%)
C        ELRAD    SATELLITE ELEVATION ANGLE (RADIANS)
C          DRYZEN   DRY ZENITH DELAY (M)
C          WETZEN   WET ZENITH DELAY (M)
C          DRYMAP   DRY MAPPING FUNCTION
C          WETMAP   WET MAPPING FUNCTION
C          TROCOR - TROPOSHERIC CORRECTION (M)
C
      IMPLICIT NONE
C
      INTEGER*4 MODEL
      REAL*8 ELRAD  , TEMP , PRES , RH
      REAL*8 DRYZEN , WETZEN, DRYMAP, WETMAP
      REAL*8 TROCOR , PI , TEMPY
C     GEO(3)- A PRIORI LAT, LON (rad) and H (m)
      REAL*8 GEO(3)
      REAL*8 HGT
      REAL*8 XRV(3)
C
C     WVP  - WATER VAPOUR PRESSURE
C     DRYELE - DRY ELEVATION
C     WETELE - WET ELEVATION
C     DRYOBL - DRY OBLIQUE
C     WETOBL - WET OBLIQUE
C     ARG    - A TEMP ARGUMENT
C
      REAL*8 LOWE
      REAL*8 WVP  
      REAL*8 DRYELE  ,  WETELE , DRYOBL , WETOBL
      REAL*8 ARG , E0, ELDEG
C
      HGT=GEO(3)
      IF( GEO(3) .LT. -30.D0 ) GEO(3)=-30.D0
      PI = (DATAN(1.D0)) * 4.D0
      ELDEG = ELRAD*180.D0/PI
      TEMPY = TEMP + 273.0D0
C
      IF( MODEL .EQ. 0 ) THEN
        CALL HOPF(TEMP,PRES,RH,ELDEG,
     &            DRYZEN,WETZEN,DRYMAP,WETMAP,TROCOR,XRV)
C   DAVIS/HOPFIELDS MODEL
      ELSE IF(MODEL .NE. 4 )  THEN
C DAVIS ET AL 1985
          DRYZEN = 2.2768D-3*PRES/
     &    (1.D0 - 2.66D-3*DCOS(2.D0*GEO(1))-.28D-6*GEO(3))
C
          ARG=  62.00D0*(TEMPY-88.259D0)
          WVP=  LOWE (TEMPY) * (RH/100.D0)
          WETZEN = 7.46512D-02*WVP/TEMPY**2* ARG
C
          IF( MODEL .LT. 2 ) 
     &    DRYZEN = 155.2D-7 * (40136.D0 + 148.72D0 * (TEMPY-273.13D0))*
     &                  PRES / TEMPY
          DRYELE = DSQRT( ELDEG**2 + 6.25D0 ) *PI/180.0D0
          WETELE = DSQRT( ELDEG**2 +2.25D0 ) *PI/180.0D0
          DRYMAP = 1.D0/DSIN(DRYELE)
          WETMAP = 1.D0/DSIN(WETELE)
          TROCOR = DRYZEN*DRYMAP+WETZEN*WETMAP
      ELSEIF ( MODEL .EQ. 4) THEN
C   CHAOS MODEL
          ARG = -37.2465D0 + .213166D0 * TEMPY - .256908D-3 * TEMPY**2
          WVP = ( RH / 100.D0 ) * DEXP ( ARG )
          E0 = WVP * 35.65D0 * 10.0D0**(7.617D0-2285.0D0/TEMPY)
          DRYZEN = 2.276D0 * .001D0 * PRES
          WETZEN = 470.0D0 * E0**1.23D0 / TEMPY**2 + 10230.0D0 *
     &            E0**1.46D0 /TEMPY**3
          WETOBL = 1.0D0/(DSIN(ELRAD)+.00035D0/(.0170D0+TAN(ELRAD)))
          DRYOBL = 1.0D0/(DSIN(ELRAD)+.00143D0/(.0445D0+TAN(ELRAD)))
          DRYMAP = 1.0D0/DRYOBL
          WETMAP = 1.0D0/WETOBL
          TROCOR = DRYZEN/DRYMAP + WETZEN/WETMAP
      ENDIF
      GEO(3)=HGT
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** UNITV3
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE UNITV3( V,UV )
C
C FUNCTION: UNITV3 COMPUTE UNIT VECTORS
C
C INPUT:    V   = VECTOR V
C           UV  = UNIT VECTOR UV
C
C
      IMPLICIT NONE
C
      REAL*8     V(*), UV(*)
C
      INTEGER*4 I
      REAL*8 VMAG
C
       VMAG=0.D0
       DO I=1,3
         VMAG= VMAG+V(I)*V(I)
       END DO
       VMAG=DSQRT(VMAG)
C
       DO I=1,3
         UV(I)= V(I)/VMAG
       END DO
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** UPDPX
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE UPDPX ( NPAR, ICLKCOR, ITRPCOR, N, PX )
C
C     NAME              UPDPX
C
C     PURPOSE         UPDATE WEIGHTS OF PARAMETERS
C
C     PARAMETERS        DESCRIPTION
C
C          NPAR         NUMBER OF PARAMETERS
C          MAXPAR       MAXIMUM NUMBER OF PARAMETERS
C          ISD          SOLVE POSITION FLAG
C          ICLKCOR      SOLVE RECEIVER CLOCK FLAG
C          ITRPCOR      SOLVE TROPOSPHERIC SCALE FLAG
C          N            CURRENT PARAMETER NORMALS 
C          PX           PARAMETER WEIGHT MATRIX
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4  NPAR
      INTEGER*4  ICLKCOR,  ITRPCOR
      REAL*8     PX(MAXPAR2,MAXPAR2)
      REAL*8     N(MAXPAR2,MAXPAR2)
C
      INTEGER*4  I,J
C
C     UPDATE PARAMETER WEIGHTS
C
          DO 310 I= 1,NPAR
            DO 300 J= 1,NPAR
            PX(I,J)     = N(I,J)
300         CONTINUE
310       CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** UPDSUW
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE UPDSUW ( IPRN, IOBPR, IOBCP, IDX, EL, IPEPACC, PRDC, 
     &             SDCP, SUWCP, SUWPR, C, PI) 
C
C     NAME              UPDPL
C
C     PURPOSE         UPDATE WEIGHTS ON OBSERVATIONS
C               CONSIDERING SATELLITE ELEVATION
C                       AND ORBIT/CLOCK QUALITY CODES
C
C     PARAMETERS        DESCRIPTION
C
C          IPRN         SATELLITE PRN NUMBER 
C          IOBPR        INDEX OF EPOCH PSEUDORANGE OBSERVATION
C          IOBCP        INDEX OF EPOCH CARRIER PHASE OBSERVATION
C          IDX          INDEX OF SATELLITE 
C          EL           SATELLITE ELEVATION ARRAY
C          IPEPACC      PRECISE EPHEMERIS ACCURACY CODES
C          PRDC         PRECISE CLOCK SIGMAS
C          SDPR         APRIORI PSEUDORANGE SIGMA
C          SDCP         APRIORI CARRIER PHASE SIGMA
C
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C      
      INTEGER*4 IPRN, IOBPR, IOBCP
      INTEGER*4 IDX(*)
      INTEGER*4 IPEPACC(*)
C
      REAL*8    EL(*)
      REAL*8    PRDC(10,*)
      REAL*8    SUWPR, SUWCP
      REAL*8    PI, C
C      
      REAL*8    DTR, ELRAD, SINEL
      REAL*8    PCFACT
      REAL*8    CLKSIG, CLKSIG2
      REAL*8    ORBSIG, ORBSIG2
      REAL*8    W37
      REAL*8    SDCP
C
C     SATELLITE ELEVATION, ORBIT AND CLOCK WEIGHTING
C     CLKSIG: TO BE INPUT FROM PRECISE CLOCK OR SP3 FILE (DEFAULT=3 cm)
C
C    PCFACT - PHASE NOISE FACTOR FOR ORB & SOL. SIGMAS
      PCFACT= .2D0
C
C     SET SATELLITE CLOCK PRECISION (DEFAULT 3 CM)
C
      CLKSIG=0.01D0
      IF(PRDC(2,IDX(IPRN)).GT.0.D0) CLKSIG = PRDC(2,IDX(IPRN))*C
C
C
C     SET SATELLITE ORBIT PRECISION
C
      ORBSIG=IPEPACC(IPRN)/1.D3
C
C     SCALE ORBIT AND CLOCK PRECISION
C
      CLKSIG2=(CLKSIG*PCFACT)**2
      ORBSIG2=(ORBSIG*PCFACT)**2
C
C     NORMALIZE WEIGHTING TO AVERAGE EL OF 37 DEG (1.7 = 1/SIN(37))
C     WCP- PHASE WEIGHT; WPR- PSEUDORANGE WEIGHT
C
      DTR=PI/180.D0
      ELRAD = EL(IDX(IPRN))*DTR
C
C LIMIT ELEVATION TO 5DEG AND ABOVE
C
      IF( EL(IDX(IPRN)) .LE. 5.D0 ) ELRAD = 5.D0*DTR
      SINEL = DSIN(ELRAD)
        W37 = 1.7D0
        SUWCP = SDCP*SQRT(1.D0/(CLKSIG2+ORBSIG2+(SDCP/W37/SINEL)**2))
        SUWPR = W37*SINEL
         IF(IPRN.GT.32.AND.IPRN.LE.64) SUWPR= SUWPR/2.d0
C start (GNSS SPECIFIC PR WEIGHTING)                            
C  GAL PR SIGMAs = 1/2 GPS ONES?
C  BEI PR SIGMAS = 2 GPS ONES (LIKE GLN)
         IF(IPRN.GT.100.AND.IPRN.LE.136) SUWPR= SUWPR/2.d0
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C***************************************************************** UPEPH
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE UPEPH (IGPSWK,TTAG,NOBS,SAT,EPHSAT,NEPSV,IEPSV,
     &                  IEPTIM,NEPTIM,EPHTIM,EPHTBL,ISRCH)
C
C     PURPOSE:   TO UPDATE EPHEMERIS INFO
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C       IGPSWK          CURRENT GPS WEEK OF MEASUREMENT EPOCH
C     TTAG              MEASUREMENT EPOCH
C     NOBS              NUMBER OF SATELLITES OBSERVED
C     SAT               PRN'S OF SATELLITES OBSERVED
C     EPHSAT            EPHEMERIS CURRENTLY USED
C     NEPSV             NUMBER OF SATELLITES WITH EPHEMERIS
C     IEPSV             PRN'S OF SATELLITES WITH EPHEMERIS
C     IEPTIM            POSITION OF EPHEMERIS STORED IN EPHSAT
C     NEPTIM            NUMBER OF EPHEMERIS DOWNLOADED PER SATELLITE
C       EPHTIM          EPHEMERIS SORTING TIMES
C     EPHTBL            TABLE OF EPHEMERIDES
C       ISRCH           SEARCH OPTION: 0) LARGEST EPHTIM <= TTAG
C                                      1) CLOSEST EPHTIM TO TTAG
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4      IGPSWK
      INTEGER*4      NOBS
      INTEGER*4      SAT(*)
      INTEGER*4      NEPSV
      INTEGER*4      IEPSV(MAXSAT), NEPTIM(MAXSAT)
      INTEGER*4      IEPTIM(MAXSAT)
      INTEGER*4      ISRCH
      REAL*8         TTAG(*)
      REAL*8         EPHSAT(MAXKEP,MAXSAT)
      REAL*8         EPHTIM(MAXSAT,MAXEPH)
      REAL*8         EPHTBL(MAXKEP,MAXSAT,MAXEPH)
C
      INTEGER*4      IO, IEP, IE, OLDTM, NEWTM, IP
      REAL*8         OLDDT, NEWDT, TIME
C
C     SELECT EPHEMERIS FOR EACH SATELLITE OBSERVED
C     AT THIS EPOCH
C
      DO 400 IEP = 1, NEPSV
        DO IO=1,NOBS
        IF ( SAT(IO) .EQ. IEPSV(IEP) ) GOTO 200
        END DO
        GOTO 400
  200 CONTINUE
        TIME = IGPSWK*604800.D0 + TTAG(IO)
        OLDTM = IEPTIM(IEP)
        NEWTM = OLDTM
        OLDDT = TIME - EPHTIM(IEP,OLDTM)
        DO IE = 1,NEPTIM(IEP)
         NEWDT = TIME - EPHTIM(IEP,IE)
c!       WRITE(*,*) 'NEWDT,OLDDT',IE,NEWDT,OLDDT,EPHTIM(IEP,IE)
         IF( ( ISRCH .EQ. 0 .AND.
     &           NEWDT .GE. 0.D0 .AND.
     &           ( OLDDT .LT. 0.D0 .OR.NEWDT .LT. OLDDT ) ) .OR.
     &         ( ISRCH .EQ. 1 .AND.
     &           DABS(NEWDT) .LT. DABS(OLDDT) ) ) THEN
            NEWTM = IE
            OLDDT= NEWDT
         ENDIF
        END DO
        IF ( OLDTM .NE. NEWTM ) THEN
         DO IP=1,MAXKEP
            EPHSAT(IP,SAT(IO)) = EPHTBL(IP,IEP,NEWTM)
         END DO
         IEPTIM(IEP)=NEWTM
c!       WRITE(*,*) 'UPEPH',SAT(IO),TTAG(IO),
c!   &                DMOD(EPHTIM(IEP,NEWTM),604800.D0),
c!   &                EPHSAT(20,SAT(IO)),EPHSAT(7,SAT(IO))
        ENDIF
        IF ( DABS(TIME-EPHSAT(2,SAT(IO))*604800.D0-EPHSAT(20,SAT(IO)))
     &                     .GT. EPHSAT(21,SAT(IO))*1800.D0 ) 
     &     EPHSAT(5,SAT(IO)) = -1
  400 CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C****************************************************************** UPTBL
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE UPTBL(ISV,TTAG,EPH,NEPSV,IEPSV,NEPTIM,EPHTIM,
     &                 EPHTBL,ISRCH)
C
C     PURPOSE:   TO UPDATE EPHEMERIS INFO
C
C     PARAMETERS        DESCRIPTION
C     ----------        -----------
C
C     ISV               CURRENT SATELLITE I.D. NUMBER
C       TTAG            TIME TAG FOR SORTING EPHEMERIS
C     EPH               CURRENT SATELLITE EPHEMERIS PARAMETERS
C     NEPSV             NUMBER OF SATELLITES WITH EPHEMERIS
C     IEPSV             LIST OF SATELLITE ID'S
C     NEPTIM            NUMBER OF EPHEMERIS DOWNLOADED PER SATELLITE
C     EPHTIM            ARRAY OF EPHEMERIS REFERENCE TIMES
C     EPHTBL            TABLE OF EPHEMERIDES
C       ISRCH           SORT OPTION: 0) TIME TAG
C                                    1) EPHEMERIS REFERENCE TIME
C
C***********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4      ISV, NEPSV, ISRCH
      INTEGER*4      IEPSV(MAXSAT), NEPTIM(MAXSAT)
      REAL*8         TTAG
      REAL*8         EPH(MAXKEP), EPHTIM(MAXSAT,MAXEPH)
      REAL*8         EPHTBL(MAXKEP,MAXSAT,MAXEPH)
C
      INTEGER*4 IS, IP, ITIM, IT, ITS
      REAL*8  TIME
C
C      WRITE(*,*) 'ISV,EPH(20),TTAG'
C      WRITE(*,*) ISV,EPH(20),TTAG
      DO 200, IS =1,NEPSV
       IF ( ISV .EQ. IEPSV(IS) ) GO TO 300
  200 CONTINUE
C
C     SATELLITE NOT IN LIST, INCLUDE IT
C
      NEPSV = NEPSV + 1
      IEPSV(NEPSV) = ISV
      NEPTIM(NEPSV) = 0
      IS = NEPSV
C
C     SATELLITE IN LIST, IF NEW EPHEMERIS,
C     UPDATE TIME COUNTER AND ARRAY
C
  300 CONTINUE
C
      IF (ISRCH .EQ.0 ) THEN
         IF ( TTAG .LT. 604800.D0 ) GO TO 500
         TIME=TTAG
      ELSE
         TIME=EPH(20)+EPH(2)*604800.D0
      END IF
C
      DO 400 ITIM=1,NEPTIM(IS)
c!    WRITE(*,*) IEPSV(IS), ITIM, EPH(20), EPHTIM(IS,ITIM)
        IF ( EPH(20)+EPH(2)*604800.D0 .EQ.
     &       EPHTBL(20,IS,ITIM)+EPHTBL(2,IS,ITIM)*604800.D0 ) THEN
           IF ( EPH(7) .NE. EPHTBL(7,IS,ITIM) ) GOTO 500
         IF ( TIME .GT. EPHTIM(IS,ITIM) ) GO TO 500
         GO TO 445
      END IF
  400 CONTINUE
  410 CONTINUE
      NEPTIM(IS) = NEPTIM(IS) + 1
      ITIM = NEPTIM(IS)
C
      IF ( ITIM .GT. MAXEPH ) THEN
      NEPTIM(IS) = NEPTIM(IS) - 1
      GO TO 500
      END IF
      IF ( NEPTIM(IS) .EQ. 1 ) GO TO 445
C
C     STORE EPHEMERIS IN SORTED ORDER
C     ACCORDING TO TIME
C
      DO 440 IT=1,ITIM
C
C       MAKE ROOM IN TABLE FOR CURRENT EPHEMERIS
C
c!    WRITE(LPR,*) 'I,ITIM,IT,EPHTIM(I,ITIM),EPHTIM(I,IT)'
c!    WRITE(LPR,*) I,ITIM,IT,EPHTIM(I,ITIM),EPHTIM(I,IT)
      IF ( TIME .LT. EPHTIM(IS,IT) ) THEN
         DO 430 ITS=ITIM,IT+1,-1
            DO 420 IP=1,MAXKEP
            EPHTBL(IP,IS,ITS) = EPHTBL(IP,IS,ITS-1)
c!          WRITE(*,'(3i10,f20.10)') IP,IS,ITS,EPHTBL(IP,I,ITS)
  420       CONTINUE
            EPHTIM(IS,ITS) = EPHTIM(IS,ITS-1)
  430     CONTINUE
          ITIM = IT
          GO TO 445
      END IF
  440 CONTINUE
C
C     STORE CURRENT EPHEMERIS
C
  445 CONTINUE
      EPHTIM(IS,ITIM) = TIME
      DO 450 IP=1,MAXKEP
      EPHTBL(IP,IS,ITIM) = EPH(IP)
  450 CONTINUE
C
  500 CONTINUE
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** VMFINTRP
C
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
      subroutine vmfintrp(dmjd,dlat,ht,el,cmf,
     &                    vmf1h,vmf1w, drytrop, strop)
C
C     input data
C     ----------
C     dmjd: modified julian date
C     dlat: latitude in radians
C     el:   elevation in degrees
C
C     output data
C     -----------
C     vmf1h: hydrostatic mapping function
C     vmf1w: wet mapping function
C
C
      implicit none
C Argument declaration
      real*8 dmjd,dlat,ht,el,cmf(5,6),vmf1h,vmf1w,drytrop,strop
C Local declaration
      integer*4 i
      real*8 zd,ah,aw
      zd = (90.d0-el)*dacos(-1.d0)/180.d0
      i= int((dmjd-cmf(1,1))/.25d0)+1
      ah = cmf(1,2)
      aw = cmf(1,3)
      drytrop = cmf(1,4)
      if(i.ge.1.and.i.le.4) then
         ah = cmf(i,2)+(dmjd-cmf(i,1))*(cmf(i+1,2)-cmf(i,2))/.25d0
         aw = cmf(i,3)+(dmjd-cmf(i,1))*(cmf(i+1,3)-cmf(i,3))/.25d0
         drytrop = cmf(i,4)+(dmjd-cmf(i,1))*(cmf(i+1,4)-cmf(i,4))/.25d0
      endif
      if(i.gt.4) then
         ah = cmf(5,2)
         aw = cmf(5,3)
         drytrop = cmf(5,4)
      endif
      if(cmf(1,6).le.0.d0) then
         CALL VMF1_HT( ah, aw, dmjd, dlat, ht, zd, vmf1h, vmf1w )
      else
         CALL VMF1( ah, aw, dmjd, dlat, zd, vmf1h, vmf1w )
      endif
      if (drytrop.eq.0.d0) drytrop= cmf(1,4)
      strop = drytrop*vmf1h+ cmf(1,5)*vmf1w
      end subroutine
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** VPCREJ
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE VPCREJ ( LPR, NSVR, ISVR, NSV, ISV, TTAG, PR1, PR2, 
     &                     P1, P2, FPR, PRDC, DORBC, IODC, FCP,
     &                     ICSLIP, 
     &                     ISPR1, ISPR2,
     &                     MSOFF, MSJMP, NRJCT, IARC,
     &                     IPRINT, IREASON, MAXSAT, MAXARC )
C
C     NAME              VPCREJ
C
C     PURPOSE   REJECT VECTOR OF OBSERVATIONS,
C                       COMPRESS ARRAYS AND ADJUST COUNTERS
C
C     PARAMETERS        DESCRIPTION
C
C          NSVR         NUMBER OF SATELLITES TO REJECT
C          ISVR         PRN'S OF SATELLITES TO REJECT
C        NSV            NUMBER OF SATELLITES IN RECORD
C        ISV            PRN'S OF SATELLITES IN RECORD
C        TTAG   OBSERVATION TIME TAG
C        PR1            PSEUDO-RANGE ON L1
C        PR2            PSEUDO-RANGE ON L2
C        P1             CARRIER PHASE ON L1
C        P2             CARRIER PHASE ON L2
C          FPR          FILTERED PSEUDO-RANGE
C          PRDC         PSEUDO-RANGE DIFFERENTIAL CORRECTION
C          NRJCT        NUMBER OF REJECTIONS
C          NSVOB        NUMBER OF OBSERVATIONS
C          IARC         ARC COUNTER
C          IREASON       REASON FOR REJECTION
C
      IMPLICIT NONE
C
      LOGICAL*4    ISPR1(*), ISPR2(*)
      INTEGER*4    MAXSAT,    MAXARC
      INTEGER*4    LPR,         NSVR,        ISVR(*)
      INTEGER*4    ICSLIP(*),   MSOFF(*),    MSJMP(*)
      INTEGER*4    NSV,         ISV(*)
      INTEGER*4    NRJCT(MAXSAT,MAXARC,*)
      INTEGER*4    IARC(*)
      INTEGER*4    IPRINT,        IREASON
      REAL*8       TTAG(*)
      REAL*8       PR1(*),      PR2(*)
      REAL*8       P1(*),       P2(*)
      REAL*8       FPR(*),     PRDC(10,*)
      REAL*8       FCP(*)
      INTEGER*4    IODC(*)
      REAL*8       DORBC(12,*)
C
      INTEGER*4    IR, IS, IPRN
C
      INTEGER*4 JREASON
      JREASON=IREASON
      IREASON=MOD(IREASON,10)
      DO IR = 1,NSVR
        DO IS = 1,NSV
        IF ( ISVR(IR) .EQ. ISV(IS) ) THEN
          IPRN = ISV(IS)
        IF( IREASON .EQ. 1 .AND. ICSLIP(IS) .EQ. 1 ) THEN
         IREASON = 2
         JREASON = 2+(JREASON/10)*10
        ENDIF
          CALL OPCREJ ( LPR, IS, NSV, ISV, TTAG, PR1, PR2, P1, P2,
     &                  FPR, PRDC, DORBC, IODC, FCP, ICSLIP,
     &                  ISPR1, ISPR2, MSOFF,
     &                  MSJMP, NRJCT,
     &                  IARC(IPRN), IPRINT, JREASON )
        END IF
        END DO
      IF( IREASON .NE. 6 .OR. JREASON.EQ.IREASON ) ISVR(IR)=0
      END DO        
c!
c!     write(*,*) NSV,(ISV(IS),IS=1,NSV)
c!
      IREASON=JREASON
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** VX2VP
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE VX2VP ( DTM, PLH, VX, VP, SDXYZ, SDPLH )
C
C     NAME              VX2VP
C
C     PURPOSE   CONVERT VARIANCE-COVARIANCE FROM CARTESIAN 
C                       TO ELLIPSOIDAL
C
C     PARAMETERS        DESCRIPTION
C
C          DTM          DATUM PARAMETERS
C          PLH          ELLIPSOIDAL COORDINATES OF STATION
C          VX           VARIANCE-COVARIANCE IN CARTESIAN COORDINATES
C          VP           VARIANCE-COVARIANCE IN ELLIPSOIDAL COORDINATES
C          SDXYZ        STANDARD DEVIATIONS IN X,Y,Z
C          SDPLH        STANDARD DEVIATIONS IN P,L,H
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4  I
      REAL*8    DTM(*),     PLH(*)
      REAL*8    SDPLH(*),   SDXYZ(*)
      REAL*8    VX(MAXPAR2,*)
      REAL*8    VP(MAXPAR2,*)
C
      REAL*8    E2,SIN_P,COS_P,RM,RN,XJC(3,3),XJCN(3,3)
C
      E2    = DTM(2)*DTM(2)
      SIN_P = DSIN ( PLH(1) )
      COS_P = DCOS ( PLH(1) )
C
      RM            = DTM(1) * ( 1.0D0 - E2 ) /
     &          ( 1.0D0 - E2 * SIN_P * SIN_P ) ** 1.5
      RN            = DTM(1) / SQRT ( 1.0D0 - E2 * SIN_P * SIN_P )
C
      CALL JACONV (DTM(1), DTM(2), PLH(1), PLH(2), PLH(3), RM, RN, XJC )
C
C     MULTIPLY XJC * VXYZ -> XJCN  
C
      CALL MATMPY (XJC, VX, XJCN, 3, 3, 3, 3, MAXPAR2, 3, 1)
C
C     MULTIPLY XJCN * XJCT -> VP
C
      CALL MATMPY (XJCN, XJC, VP, 3, 3, 3, 3, 3, MAXPAR2 , 3)    
C
      SDXYZ(1)= DSQRT(VX(1,1))
      SDXYZ(2)= DSQRT(VX(2,2))
      SDXYZ(3)= DSQRT(VX(3,3))
C
      SDPLH(1)= DSQRT(VP(1,1))*RM
      SDPLH(2)= DSQRT(VP(2,2))*RN*COS_P
      SDPLH(3)= DSQRT(VP(3,3))
      DO I=1,3
       VP(1,I) = VP(1,I) * RM
       VP(I,1) = VP(I,1) * RM
       VP(2,I) = VP(2,I) * RN * COS_P
       VP(I,2) = VP(I,2) * RN * COS_P
      END DO
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** WNDUP
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE WNDUP( IPRN, TTAG, DTM, XRV, XSV, USVX,PI,XRVVEL,TPWUP,
     &                  PWUP, WUP )
C
C FUNCTION: WNDUP: COMPUTES PHASE WINDUP CORRECTION
C
C INPUT:    XRV   = RECEIVER COORDINATES
C           XSV   = SATELLITE COORDINATES
C           USVX  = UNIT X Vector of SATELL LOCAL FRAME(FROM SANTX)
C
C OUTPUT:   WNDUP = PHASE WINDUP CORRECTION (IN CYCLES!)
C
      IMPLICIT NONE
C
      INTEGER*4 IPRN
      REAL*8    TTAG,DTM(*),XRV(*),XSV(*),USVX(*),PI,TPWUP,PWUP,WUP
C               XRVVEL- Rx velocity in m/s (for static PPP =  0m/s)
     &        , XRVVEL(*)
C
      INTEGER*4 I
      REAL*8    TWOPI,DTWUP,DPRV,WUPSGN,DPSV
      REAL*8    USVY(3),USVZ(3)
      REAL*8    URVX(3),URVY(3),URVZ(3)
      REAL*8    XSVRV(3),USVRV(3)
      REAL*8    XPRV(3),XPSV(3)
      REAL*8    EDPRV(3),EDPSV(3)
      REAL*8    UEDPRV(3),UEDPSV(3)
      REAL*8    WUPDIR(3)
      REAL*8    DPROD3
C
C     INITIALIZE PREVIOUS WIND-UP TIME AND VALUE
C
      TWOPI=2.D0*PI
      IF ( TPWUP .LT. 0 ) THEN
        TPWUP=TTAG
      PWUP=0.D0
      END IF
C
      DTWUP=DABS(TTAG-TPWUP)
      IF ( DTWUP .GT. 14400.D0 ) THEN
        TPWUP=TTAG
      PWUP=0.D0
      END IF
C      
      DO I=1,3
        XSVRV(I)=XRV(I)-XSV(I)
      END DO
      CALL UNITV3(XSVRV,USVRV)
c!    WRITE(*,'(A5,I2.2,3F10.3)') 'WNDUP',IPRN,
C    &                             USVRV(1),USVRV(2),USVRV(3)
      CALL SATUV( XSV, USVX, USVY, USVZ )
c!    WRITE(*,*) 'BEFORE RCVUV',xrv(1),xrv(2),xrv(3)
      CALL RCVUV( XRV, DTM, URVX, URVY, URVZ )
C
C For kin PPP  when XRVVEL > 1 m/s, URVX (ANT REF DIRECTION)
C POINTS ALONG THE Rx VELOXITY, RATHER THAN TO NORTH
       IF(SQRT(XRVVEL(1)**2+XRVVEL(2)**2+XRVVEL(3)**2).GT.1.0d0) THEN
          CALL UNITV3(XRVVEL,URVX)
          CALL XPROD3(URVX, URVZ, URVY)
          DO I=1,3
           URVY(I)= -URVY(I)
          ENDDO
       ENDIF
C
C     COMPUTE DOT AND CROSS PRODUCTS AT RECEIVER AND SPACE VEHICLE 
C
      DPRV = DPROD3(USVRV,URVX)
      DPSV = DPROD3(USVRV,USVX)
c!    WRITE(*,'(A5,I2.2,2F10.3)') 'WNDUP',IPRN,DPRV,DPSV
      CALL XPROD3(USVRV,URVY, XPRV)   
      CALL XPROD3(USVRV,USVY, XPSV) 
c!    WRITE(*,'(A5,I2.2,2F10.3)') 'WNDUP',IPRN,XPRV,XPSV
C
C     COMPUTE EFFECTIVE DIPOLES
C
      DO I = 1,3
         EDPRV(I) = URVX(I) - USVRV(I)*DPRV + XPRV(I)    
         EDPSV(I) = USVX(I) - USVRV(I)*DPSV - XPSV(I)
      END DO
      CALL UNITV3(EDPRV,UEDPRV)
      CALL UNITV3(EDPSV,UEDPSV)
c!    WRITE(*,'(A5,I2.2,3F10.3)') 'WNDUP',IPRN,UEDPRV
c!    WRITE(*,'(A5,I2.2,3F10.3)') 'WNDUP',IPRN,UEDPSV
C
      WUP = (DACOS( MAX(-1.D0,MIN(1.D0,DPROD3(UEDPSV,UEDPRV))) ))/TWOPI
      CALL XPROD3(UEDPSV,UEDPRV,WUPDIR)
      WUPSGN=DPROD3(WUPDIR,USVRV)
      IF ( WUPSGN .LE. 0.D0 ) WUP = -WUP
c!    write(*,'(A10,I2.2,F12.1,4F10.3)')
c!   &'WNDUP ',IPRN,TTAG,PWUP,WUP,DNINT(PWUP - WUP),
c!   &DNINT(PWUP - WUP)+WUP
      WUP = DNINT(PWUP - WUP) + WUP
c!    WRITE(*,'(A12,I2.2,2F10.1,3F10.3)') 
c!   &         'AFTER  WNDUP',IPRN,TTAG,TPWUP,PWUP,WUP,WUPSGN
      PWUP = WUP
      TPWUP = TTAG
C
       RETURN
       END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** WRTCOR
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE WRTCOR( LUO, IYEAR, IMTH, IDAY, IHR, IMIN, SEC,
     &                   NSVO, ISVO, IDX, AZ, EL, TROCOR, IONCOR,
     &                   PCVCOR,TIDCOR,WUPCOR,ION2COR,
     &                   SRELCOR, SAGCOR )
C
C     NAME              WRTCOR
C
C     PURPOSE   WRITE CORRECTION RECORD 
C
C     PARAMETERS        DESCRIPTION
C
C          LUO          LOGICAL UNIT OF OUTPUT
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4 LUO,IYEAR,IMTH,IDAY,IHR,IMIN,NSVO,IDX(*),ISVO(*)
      REAL*8    SEC
      REAL*8    AZ(*),EL(*),TROCOR(*),IONCOR(*),SRELCOR(*),SAGCOR(*)
     &         ,PCVCOR(*),TIDCOR(*),WUPCOR(*),ION2COR(*)
C
      INTEGER*4 IO
     +         ,I
C
      DO I=0,(NSVO-1)/10
      WRITE(LUO,900) IYEAR,IMTH,IDAY,IHR,IMIN,SEC,(ISVO(IO),
     &                       IO=I*10+1,MIN(I*10+10,NSVO))
      WRITE(LUO,1100) ( AZ(IDX(ISVO(IO))), 
     &                       IO=I*10+1,MIN(I*10+10,NSVO))
      WRITE(LUO,1110) ( EL(IDX(ISVO(IO))), 
     &                       IO=I*10+1,MIN(I*10+10,NSVO))
      WRITE(LUO,1120) ( TROCOR(IDX(ISVO(IO))), 
     &                       IO=I*10+1,MIN(I*10+10,NSVO))
      WRITE(LUO,1130) ( IONCOR(IDX(ISVO(IO))), 
     &                       IO=I*10+1,MIN(I*10+10,NSVO))
      WRITE(LUO,1132) ( SRELCOR(IDX(ISVO(IO))), 
     &                       IO=I*10+1,MIN(I*10+10,NSVO))
      WRITE(LUO,1133) ( SAGCOR(IDX(ISVO(IO))), 
     &                       IO=I*10+1,MIN(I*10+10,NSVO))
      WRITE(LUO,1134) ( 1.D2*TIDCOR(IDX(ISVO(IO))), 
     &                       IO=I*10+1,MIN(I*10+10,NSVO))
      WRITE(LUO,1135) ( 1.D2*WUPCOR(IDX(ISVO(IO))), 
     &                       IO=I*10+1,MIN(I*10+10,NSVO))
      WRITE(LUO,1136) ( 1.D2*ION2COR(IDX(ISVO(IO))), 
     &                       IO=I*10+1,MIN(I*10+10,NSVO))
      WRITE(LUO,1137) ( 1.D2*PCVCOR(IDX(ISVO(IO))), 
     &                       IO=I*10+1,MIN(I*10+10,NSVO))
      END DO
C
  900 FORMAT( /,1X,I4,2('/',I2), 1X,2(I2,':'), F4.1 ,1X,'PRNS # ',20I6)
 1100 FORMAT( ' AZIMUTH          (deg.) ',7X,10F6.1 )
 1110 FORMAT( ' ELEVATION        (deg.) ',7X,10F6.1 )
 1120 FORMAT( ' TROPOSPHERIC DELAY (m.) ',7X,10F6.1 )
 1130 FORMAT( ' IONOSPHERIC DELAY  (m.) ',7X,10F6.1 )
 1132 FORMAT( ' RELATIVITY EFFECT  (m.) ',7X,10F6.1 )
 1133 FORMAT( ' SAGNAC DELAY       (m.) ',7X,10F6.1 )
 1134 FORMAT( ' EARTH TIDE DELAY  (cm.) ',7X,10F6.1 )     
 1135 FORMAT( ' WIND-UP DELAY     (cm.) ',7X,10F6.1 )     
 1136 FORMAT( ' 2ND ORD ION DELAY (cm.) ',7X,10F6.1 )
 1137 FORMAT( ' SAT PCV DELAY     (cm.) ',7X,10F6.1 )     
C      
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** WRTDIF
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE WRTDIF( LUO, IHR, IMIN, SEC, GDOP, DRYEPO, XRVEPO, 
     &                   XRVMRK, VX, C )
C
C     NAME              WRTPAR
C
C     PURPOSE   WRITE DIFFERENCES BETWEEN EPOCH ESTIMATES 
C                       AND INITIAL PARAMETERS 
C
C     PARAMETERS        DESCRIPTION
C
C          LUO          LOGICAL UNIT OF OUTPUT
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4 LUO, IHR, IMIN
      REAL*8    SEC, GDOP, DRYEPO,C
      REAL*8    XRVEPO(*), XRVMRK(*), VX(MAXPAR2,*)
C
      INTEGER*4 I
C
      WRITE(LUO,1000) 'GDOP      ',IHR,IMIN,SEC,GDOP     
      WRITE(LUO,1100)
     &         'UPD-   XRV',IHR,IMIN,SEC,(XRVEPO(I)-XRVMRK(I),I=1,3),
     &          XRVEPO(4)*C, DRYEPO, XRVEPO(5)
     &          ,XRVEPO(8)*C, XRVEPO(9)*C, XRVEPO(10)*C
      WRITE(LUO,1100)
     &         'SIG-   XRV',IHR,IMIN,SEC,(DSQRT(VX(I,I)),I=1,3),
     &          DSQRT(VX(4,4))*.299792458,  DSQRT(VX(5,5)) 
     &          ,DSQRT(VX(8,8))*(C*1.D-9),DSQRT(VX(9,9))*(C*1.D-9)
     &          ,DSQRT(VX(10,10))*(C*1.D-9)
 1000 FORMAT(A10,3X,2(I2.2,":"),F4.1,F15.3)
 1100 FORMAT(A10,3X,2(I2.2,":"),F4.1,5X,9F15.3)
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** WRTPAR
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE WRTPAR( LUO, ITER, ISVO, IHR, IMIN, SEC, NPAR, X, VX,
     &                   XRVEPO, CPAMB, SCPAMB, NFPAR )
C
C     NAME              WRTPAR
C
C     PURPOSE   WRITE EPOCH ESTIMATED PARAMETERS 
C
C     PARAMETERS        DESCRIPTION
C
C          LUO          LOGICAL UNIT OF OUTPUT
C
C *********************************************************************
C
      IMPLICIT NONE
C
      INCLUDE 'MAXDIM'
C
      INTEGER*4 LUO,ITER,IHR,IMIN,NPAR,ISVO(*)
      REAL*8    SEC,XRVEPO(*),CPAMB(*),SCPAMB(*)
      REAL*8    X(MAXPAR2,*),VX(MAXPAR2,*)      
C
C
      INTEGER*4 I, NFPAR
      WRITE(LUO,1100) 'DX ',ITER,IHR,IMIN,SEC,
     &                      (X(I,1),I=1,NPAR)       
      WRITE(LUO,1100) 'SX ',ITER,IHR,IMIN,SEC,
     &                      (DSQRT(VX(I,I)),I=1,NPAR)
      WRITE(LUO,1200) 'XRV-DX',IHR,IMIN,SEC,
     &                      (XRVEPO(I),I=1,3)
      WRITE(LUO,1300) 'BIASES',IHR,IMIN,SEC,
     &                      (CPAMB(ISVO(I)),I=1,NPAR-NFPAR)
      WRITE(LUO,1300) 'SIGMAS',IHR,IMIN,SEC,
     &                      (SCPAMB(ISVO(I)),I=1,NPAR-NFPAR)
C
 1100 FORMAT(A5,I2,1X,2(I2,':'),F4.1,(30F10.2))
 1200 FORMAT(A10,3X,2(I2.2,":"),F4.1,5X,3F15.3)
 1300 FORMAT(A8,3X,2(I2,':'),F4.1,5X,(20D7.1))
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C*************************************************************** XPROD3
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE XPROD3( A, B, C )
C
C FUNCTION: XPROD3 COMPUTES CROS PRODUCT OF 3D VECTORS
C
C INPUT:    A   = VECTOR A
C           B   = VECTOR B
C           C   = A x B
C
C
      IMPLICIT NONE
C
      REAL*8     A(*),B(*),C(*)
C
      C(1)=A(2)*B(3)-A(3)*B(2)
      C(2)=A(3)*B(1)-A(1)*B(3)
      C(3)=A(1)*B(2)-A(2)*B(1)
C
      RETURN
      END
C2345678901234567890123456789012345678901234567890123456789012345678901234567890
C
C**************************************************************** XYZPL2
C
C Copyright (c) 2018 Government of Canada. Under MIT License terms
C Droit d'auteur (c) Gouvernement du Canada, 2018. Sous termes de Licence MIT
C
C
      SUBROUTINE XYZPL2(X0,Y0,Z0,A,E,X,Y,Z,PLAT,PLON,PHGT)
C
C       PURPOSE         CONVERT CARTESIAN TO ELLIPSOIDAL COORDINATES
C
C      IN:  X0, Y0, Z0, A, E : DATUM PARAMETERS
C         X,Y,Z      : CARTESIAN COORDINATES
C     OUT:  PLAT,PLON,PHGT   : PHI, LAMBDA, H
C
      IMPLICIT NONE
      INTEGER*4 ITER
      REAL*8 DELTAH,DELTAPHI
C
      REAL*8 X0,Y0,Z0,A,E,X,Y,Z,PLAT,PLON,PHGT
C
      REAL*8 E2,XP,YP,ZP,S,RLAM,ZPS,H,PHI,XN,HP,PHIP
C
      DATA PHIP, HP / 0.D0, 0.D0 /
      ITER=0
      E2   = E*E
      XP   = X - X0
      YP   = Y - Y0
      ZP   = Z - Z0
      IF( XP .NE. 0.D0 .OR. YP .NE. 0.D0 ) THEN
       S    = DSQRT(XP**2 + YP**2)
       RLAM = DATAN2(YP,XP)
       ZPS  = ZP / S
       H    = DSQRT(XP**2 + YP**2 + ZP**2) - A
       PHI  = DATAN(ZPS/(1.D0 - E2*A/(A+H)))
      ELSE
       PLON = 0.D0
       PHGT = DSQRT(XP**2 + YP**2 + ZP**2) - A*(1.D0-E2)
       PLAT = DSIGN(DACOS(0.D0),Z)
       RETURN
      ENDIF
   10 CONTINUE
      ITER=ITER+1
      DELTAPHI=PHIP-PHI
      DELTAH=HP-H
      XN   = A/DSQRT(1.D0 - E2*DSIN(PHI)**2)
      HP   = H
      PHIP = PHI
      H    = S/DCOS(PHI) - XN
      PHI  = DATAN(ZPS/(1.D0 - E2*XN/(XN+H)))
      IF( ITER .LE. 10 .AND. 
     &   (DABS(PHIP - PHI).GT.1.D-11.OR.DABS(HP - H).GT.1.D-5)) GOTO 10
      IF(ITER .EQ. 11 .AND.
     &   ( DABS(PHIP - PHI + DELTAPHI)  .GT. 1.D-11 .OR.
     &     DABS(HP - H + DELTAH) .GT. 1.D-5 ) )
     & WRITE (*,*) 'XYZPL2 - CONVERGENCE PROBLEM'
C
      PLAT = PHI
      PLON = RLAM
      PHGT = H
C
      RETURN
      END
